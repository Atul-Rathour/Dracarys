function es(r) {
    if (r === void 0)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return r
}
function mT(r, e) {
    r.prototype = Object.create(e.prototype),
    r.prototype.constructor = r,
    r.__proto__ = e
}
/*!
 * GSAP 3.12.5
 * https://gsap.com
 *
 * @license Copyright 2008-2024, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license or for
 * Club GSAP members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/
var zi = {
    autoSleep: 120,
    force3D: "auto",
    nullTargetWarn: 1,
    units: {
        lineHeight: ""
    }
}, Ja = {
    duration: .5,
    overwrite: !1,
    delay: 0
}, u_, ri, sn, $i = 1e8, Kt = 1 / $i, ym = Math.PI * 2, NC = ym / 4, FC = 0, _T = Math.sqrt, BC = Math.cos, kC = Math.sin, Gn = function(e) {
    return typeof e == "string"
}, pn = function(e) {
    return typeof e == "function"
}, ss = function(e) {
    return typeof e == "number"
}, h_ = function(e) {
    return typeof e > "u"
}, Or = function(e) {
    return typeof e == "object"
}, yi = function(e) {
    return e !== !1
}, f_ = function() {
    return typeof window < "u"
}, Lu = function(e) {
    return pn(e) || Gn(e)
}, gT = typeof ArrayBuffer == "function" && ArrayBuffer.isView || function() {}
, si = Array.isArray, xm = /(?:-?\.?\d|\.)+/gi, vT = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g, Ba = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g, tp = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi, yT = /[+-]=-?[.\d]+/, xT = /[^,'"\[\]\s]+/gi, zC = /^[+\-=e\s\d]*\d+[.\d]*([a-z]*|%)\s*$/i, ln, Er, Tm, d_, Vi = {}, Bh = {}, TT, bT = function(e) {
    return (Bh = Io(e, Vi)) && Mi
}, p_ = function(e, t) {
    return console.warn("Invalid property", e, "set to", t, "Missing plugin? gsap.registerPlugin()")
}, Ec = function(e, t) {
    return !t && console.warn(e)
}, ST = function(e, t) {
    return e && (Vi[e] = t) && Bh && (Bh[e] = t) || Vi
}, Ac = function() {
    return 0
}, HC = {
    suppressEvents: !0,
    isStart: !0,
    kill: !1
}, Rh = {
    suppressEvents: !0,
    kill: !1
}, VC = {
    suppressEvents: !0
}, m_ = {}, Os = [], bm = {}, MT, Oi = {}, np = {}, Qv = 30, Ch = [], __ = "", g_ = function(e) {
    var t = e[0], n, i;
    if (Or(t) || pn(t) || (e = [e]),
    !(n = (t._gsap || {}).harness)) {
        for (i = Ch.length; i-- && !Ch[i].targetTest(t); )
            ;
        n = Ch[i]
    }
    for (i = e.length; i--; )
        e[i] && (e[i]._gsap || (e[i]._gsap = new KT(e[i],n))) || e.splice(i, 1);
    return e
}, wo = function(e) {
    return e._gsap || g_(Zi(e))[0]._gsap
}, wT = function(e, t, n) {
    return (n = e[t]) && pn(n) ? e[t]() : h_(n) && e.getAttribute && e.getAttribute(t) || n
}, xi = function(e, t) {
    return (e = e.split(",")).forEach(t) || e
}, _n = function(e) {
    return Math.round(e * 1e5) / 1e5 || 0
}, zn = function(e) {
    return Math.round(e * 1e7) / 1e7 || 0
}, Wa = function(e, t) {
    var n = t.charAt(0)
      , i = parseFloat(t.substr(2));
    return e = parseFloat(e),
    n === "+" ? e + i : n === "-" ? e - i : n === "*" ? e * i : e / i
}, GC = function(e, t) {
    for (var n = t.length, i = 0; e.indexOf(t[i]) < 0 && ++i < n; )
        ;
    return i < n
}, kh = function() {
    var e = Os.length, t = Os.slice(0), n, i;
    for (bm = {},
    Os.length = 0,
    n = 0; n < e; n++)
        i = t[n],
        i && i._lazy && (i.render(i._lazy[0], i._lazy[1], !0)._lazy = 0)
}, ET = function(e, t, n, i) {
    Os.length && !ri && kh(),
    e.render(t, n, i || ri && t < 0 && (e._initted || e._startAt)),
    Os.length && !ri && kh()
}, AT = function(e) {
    var t = parseFloat(e);
    return (t || t === 0) && (e + "").match(xT).length < 2 ? t : Gn(e) ? e.trim() : e
}, PT = function(e) {
    return e
}, ir = function(e, t) {
    for (var n in t)
        n in e || (e[n] = t[n]);
    return e
}, WC = function(e) {
    return function(t, n) {
        for (var i in n)
            i in t || i === "duration" && e || i === "ease" || (t[i] = n[i])
    }
}, Io = function(e, t) {
    for (var n in t)
        e[n] = t[n];
    return e
}, e0 = function r(e, t) {
    for (var n in t)
        n !== "__proto__" && n !== "constructor" && n !== "prototype" && (e[n] = Or(t[n]) ? r(e[n] || (e[n] = {}), t[n]) : t[n]);
    return e
}, zh = function(e, t) {
    var n = {}, i;
    for (i in e)
        i in t || (n[i] = e[i]);
    return n
}, mc = function(e) {
    var t = e.parent || ln
      , n = e.keyframes ? WC(si(e.keyframes)) : ir;
    if (yi(e.inherit))
        for (; t; )
            n(e, t.vars.defaults),
            t = t.parent || t._dp;
    return e
}, jC = function(e, t) {
    for (var n = e.length, i = n === t.length; i && n-- && e[n] === t[n]; )
        ;
    return n < 0
}, RT = function(e, t, n, i, s) {
    n === void 0 && (n = "_first"),
    i === void 0 && (i = "_last");
    var o = e[i], a;
    if (s)
        for (a = t[s]; o && o[s] > a; )
            o = o._prev;
    return o ? (t._next = o._next,
    o._next = t) : (t._next = e[n],
    e[n] = t),
    t._next ? t._next._prev = t : e[i] = t,
    t._prev = o,
    t.parent = t._dp = e,
    t
}, cf = function(e, t, n, i) {
    n === void 0 && (n = "_first"),
    i === void 0 && (i = "_last");
    var s = t._prev
      , o = t._next;
    s ? s._next = o : e[n] === t && (e[n] = o),
    o ? o._prev = s : e[i] === t && (e[i] = s),
    t._next = t._prev = t.parent = null
}, Bs = function(e, t) {
    e.parent && (!t || e.parent.autoRemoveChildren) && e.parent.remove && e.parent.remove(e),
    e._act = 0
}, Eo = function(e, t) {
    if (e && (!t || t._end > e._dur || t._start < 0))
        for (var n = e; n; )
            n._dirty = 1,
            n = n.parent;
    return e
}, XC = function(e) {
    for (var t = e.parent; t && t.parent; )
        t._dirty = 1,
        t.totalDuration(),
        t = t.parent;
    return e
}, Sm = function(e, t, n, i) {
    return e._startAt && (ri ? e._startAt.revert(Rh) : e.vars.immediateRender && !e.vars.autoRevert || e._startAt.render(t, !0, i))
}, qC = function r(e) {
    return !e || e._ts && r(e.parent)
}, t0 = function(e) {
    return e._repeat ? Qa(e._tTime, e = e.duration() + e._rDelay) * e : 0
}, Qa = function(e, t) {
    var n = Math.floor(e /= t);
    return e && n === e ? n - 1 : n
}, Hh = function(e, t) {
    return (e - t._start) * t._ts + (t._ts >= 0 ? 0 : t._dirty ? t.totalDuration() : t._tDur)
}, uf = function(e) {
    return e._end = zn(e._start + (e._tDur / Math.abs(e._ts || e._rts || Kt) || 0))
}, hf = function(e, t) {
    var n = e._dp;
    return n && n.smoothChildTiming && e._ts && (e._start = zn(n._time - (e._ts > 0 ? t / e._ts : ((e._dirty ? e.totalDuration() : e._tDur) - t) / -e._ts)),
    uf(e),
    n._dirty || Eo(n, e)),
    e
}, CT = function(e, t) {
    var n;
    if ((t._time || !t._dur && t._initted || t._start < e._time && (t._dur || !t.add)) && (n = Hh(e.rawTime(), t),
    (!t._dur || Nc(0, t.totalDuration(), n) - t._tTime > Kt) && t.render(n, !0)),
    Eo(e, t)._dp && e._initted && e._time >= e._dur && e._ts) {
        if (e._dur < e.duration())
            for (n = e; n._dp; )
                n.rawTime() >= 0 && n.totalTime(n._tTime),
                n = n._dp;
        e._zTime = -Kt
    }
}, Pr = function(e, t, n, i) {
    return t.parent && Bs(t),
    t._start = zn((ss(n) ? n : n || e !== ln ? qi(e, n, t) : e._time) + t._delay),
    t._end = zn(t._start + (t.totalDuration() / Math.abs(t.timeScale()) || 0)),
    RT(e, t, "_first", "_last", e._sort ? "_start" : 0),
    Mm(t) || (e._recent = t),
    i || CT(e, t),
    e._ts < 0 && hf(e, e._tTime),
    e
}, IT = function(e, t) {
    return (Vi.ScrollTrigger || p_("scrollTrigger", t)) && Vi.ScrollTrigger.create(t, e)
}, LT = function(e, t, n, i, s) {
    if (y_(e, t, s),
    !e._initted)
        return 1;
    if (!n && e._pt && !ri && (e._dur && e.vars.lazy !== !1 || !e._dur && e.vars.lazy) && MT !== Ui.frame)
        return Os.push(e),
        e._lazy = [s, i],
        1
}, KC = function r(e) {
    var t = e.parent;
    return t && t._ts && t._initted && !t._lock && (t.rawTime() < 0 || r(t))
}, Mm = function(e) {
    var t = e.data;
    return t === "isFromStart" || t === "isStart"
}, YC = function(e, t, n, i) {
    var s = e.ratio, o = t < 0 || !t && (!e._start && KC(e) && !(!e._initted && Mm(e)) || (e._ts < 0 || e._dp._ts < 0) && !Mm(e)) ? 0 : 1, a = e._rDelay, c = 0, h, d, l;
    if (a && e._repeat && (c = Nc(0, e._tDur, t),
    d = Qa(c, a),
    e._yoyo && d & 1 && (o = 1 - o),
    d !== Qa(e._tTime, a) && (s = 1 - o,
    e.vars.repeatRefresh && e._initted && e.invalidate())),
    o !== s || ri || i || e._zTime === Kt || !t && e._zTime) {
        if (!e._initted && LT(e, t, i, n, c))
            return;
        for (l = e._zTime,
        e._zTime = t || (n ? Kt : 0),
        n || (n = t && !l),
        e.ratio = o,
        e._from && (o = 1 - o),
        e._time = 0,
        e._tTime = c,
        h = e._pt; h; )
            h.r(o, h.d),
            h = h._next;
        t < 0 && Sm(e, t, n, !0),
        e._onUpdate && !n && Bi(e, "onUpdate"),
        c && e._repeat && !n && e.parent && Bi(e, "onRepeat"),
        (t >= e._tDur || t < 0) && e.ratio === o && (o && Bs(e, 1),
        !n && !ri && (Bi(e, o ? "onComplete" : "onReverseComplete", !0),
        e._prom && e._prom()))
    } else
        e._zTime || (e._zTime = t)
}, $C = function(e, t, n) {
    var i;
    if (n > t)
        for (i = e._first; i && i._start <= n; ) {
            if (i.data === "isPause" && i._start > t)
                return i;
            i = i._next
        }
    else
        for (i = e._last; i && i._start >= n; ) {
            if (i.data === "isPause" && i._start < t)
                return i;
            i = i._prev
        }
}, el = function(e, t, n, i) {
    var s = e._repeat
      , o = zn(t) || 0
      , a = e._tTime / e._tDur;
    return a && !i && (e._time *= o / e._dur),
    e._dur = o,
    e._tDur = s ? s < 0 ? 1e10 : zn(o * (s + 1) + e._rDelay * s) : o,
    a > 0 && !i && hf(e, e._tTime = e._tDur * a),
    e.parent && uf(e),
    n || Eo(e.parent, e),
    e
}, n0 = function(e) {
    return e instanceof ui ? Eo(e) : el(e, e._dur)
}, ZC = {
    _start: 0,
    endTime: Ac,
    totalDuration: Ac
}, qi = function r(e, t, n) {
    var i = e.labels, s = e._recent || ZC, o = e.duration() >= $i ? s.endTime(!1) : e._dur, a, c, h;
    return Gn(t) && (isNaN(t) || t in i) ? (c = t.charAt(0),
    h = t.substr(-1) === "%",
    a = t.indexOf("="),
    c === "<" || c === ">" ? (a >= 0 && (t = t.replace(/=/, "")),
    (c === "<" ? s._start : s.endTime(s._repeat >= 0)) + (parseFloat(t.substr(1)) || 0) * (h ? (a < 0 ? s : n).totalDuration() / 100 : 1)) : a < 0 ? (t in i || (i[t] = o),
    i[t]) : (c = parseFloat(t.charAt(a - 1) + t.substr(a + 1)),
    h && n && (c = c / 100 * (si(n) ? n[0] : n).totalDuration()),
    a > 1 ? r(e, t.substr(0, a - 1), n) + c : o + c)) : t == null ? o : +t
}, _c = function(e, t, n) {
    var i = ss(t[1]), s = (i ? 2 : 1) + (e < 2 ? 0 : 1), o = t[s], a, c;
    if (i && (o.duration = t[1]),
    o.parent = n,
    e) {
        for (a = o,
        c = n; c && !("immediateRender"in a); )
            a = c.vars.defaults || {},
            c = yi(c.vars.inherit) && c.parent;
        o.immediateRender = yi(a.immediateRender),
        e < 2 ? o.runBackwards = 1 : o.startAt = t[s - 1]
    }
    return new Mn(t[0],o,t[s + 1])
}, Hs = function(e, t) {
    return e || e === 0 ? t(e) : t
}, Nc = function(e, t, n) {
    return n < e ? e : n > t ? t : n
}, ni = function(e, t) {
    return !Gn(e) || !(t = zC.exec(e)) ? "" : t[1]
}, JC = function(e, t, n) {
    return Hs(n, function(i) {
        return Nc(e, t, i)
    })
}, wm = [].slice, DT = function(e, t) {
    return e && Or(e) && "length"in e && (!t && !e.length || e.length - 1 in e && Or(e[0])) && !e.nodeType && e !== Er
}, QC = function(e, t, n) {
    return n === void 0 && (n = []),
    e.forEach(function(i) {
        var s;
        return Gn(i) && !t || DT(i, 1) ? (s = n).push.apply(s, Zi(i)) : n.push(i)
    }) || n
}, Zi = function(e, t, n) {
    return sn && !t && sn.selector ? sn.selector(e) : Gn(e) && !n && (Tm || !tl()) ? wm.call((t || d_).querySelectorAll(e), 0) : si(e) ? QC(e, n) : DT(e) ? wm.call(e, 0) : e ? [e] : []
}, Em = function(e) {
    return e = Zi(e)[0] || Ec("Invalid scope") || {},
    function(t) {
        var n = e.current || e.nativeElement || e;
        return Zi(t, n.querySelectorAll ? n : n === e ? Ec("Invalid scope") || d_.createElement("div") : e)
    }
}, OT = function(e) {
    return e.sort(function() {
        return .5 - Math.random()
    })
}, UT = function(e) {
    if (pn(e))
        return e;
    var t = Or(e) ? e : {
        each: e
    }
      , n = Ao(t.ease)
      , i = t.from || 0
      , s = parseFloat(t.base) || 0
      , o = {}
      , a = i > 0 && i < 1
      , c = isNaN(i) || a
      , h = t.axis
      , d = i
      , l = i;
    return Gn(i) ? d = l = {
        center: .5,
        edges: .5,
        end: 1
    }[i] || 0 : !a && c && (d = i[0],
    l = i[1]),
    function(f, p, g) {
        var y = (g || t).length, v = o[y], _, b, T, S, E, P, R, O, w;
        if (!v) {
            if (w = t.grid === "auto" ? 0 : (t.grid || [1, $i])[1],
            !w) {
                for (R = -$i; R < (R = g[w++].getBoundingClientRect().left) && w < y; )
                    ;
                w < y && w--
            }
            for (v = o[y] = [],
            _ = c ? Math.min(w, y) * d - .5 : i % w,
            b = w === $i ? 0 : c ? y * l / w - .5 : i / w | 0,
            R = 0,
            O = $i,
            P = 0; P < y; P++)
                T = P % w - _,
                S = b - (P / w | 0),
                v[P] = E = h ? Math.abs(h === "y" ? S : T) : _T(T * T + S * S),
                E > R && (R = E),
                E < O && (O = E);
            i === "random" && OT(v),
            v.max = R - O,
            v.min = O,
            v.v = y = (parseFloat(t.amount) || parseFloat(t.each) * (w > y ? y - 1 : h ? h === "y" ? y / w : w : Math.max(w, y / w)) || 0) * (i === "edges" ? -1 : 1),
            v.b = y < 0 ? s - y : s,
            v.u = ni(t.amount || t.each) || 0,
            n = n && y < 0 ? jT(n) : n
        }
        return y = (v[f] - v.min) / v.max || 0,
        zn(v.b + (n ? n(y) : y) * v.v) + v.u
    }
}, Am = function(e) {
    var t = Math.pow(10, ((e + "").split(".")[1] || "").length);
    return function(n) {
        var i = zn(Math.round(parseFloat(n) / e) * e * t);
        return (i - i % 1) / t + (ss(n) ? 0 : ni(n))
    }
}, NT = function(e, t) {
    var n = si(e), i, s;
    return !n && Or(e) && (i = n = e.radius || $i,
    e.values ? (e = Zi(e.values),
    (s = !ss(e[0])) && (i *= i)) : e = Am(e.increment)),
    Hs(t, n ? pn(e) ? function(o) {
        return s = e(o),
        Math.abs(s - o) <= i ? s : o
    }
    : function(o) {
        for (var a = parseFloat(s ? o.x : o), c = parseFloat(s ? o.y : 0), h = $i, d = 0, l = e.length, f, p; l--; )
            s ? (f = e[l].x - a,
            p = e[l].y - c,
            f = f * f + p * p) : f = Math.abs(e[l] - a),
            f < h && (h = f,
            d = l);
        return d = !i || h <= i ? e[d] : o,
        s || d === o || ss(o) ? d : d + ni(o)
    }
    : Am(e))
}, FT = function(e, t, n, i) {
    return Hs(si(e) ? !t : n === !0 ? !!(n = 0) : !i, function() {
        return si(e) ? e[~~(Math.random() * e.length)] : (n = n || 1e-5) && (i = n < 1 ? Math.pow(10, (n + "").length - 2) : 1) && Math.floor(Math.round((e - n / 2 + Math.random() * (t - e + n * .99)) / n) * n * i) / i
    })
}, eI = function() {
    for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
        t[n] = arguments[n];
    return function(i) {
        return t.reduce(function(s, o) {
            return o(s)
        }, i)
    }
}, tI = function(e, t) {
    return function(n) {
        return e(parseFloat(n)) + (t || ni(n))
    }
}, nI = function(e, t, n) {
    return kT(e, t, 0, 1, n)
}, BT = function(e, t, n) {
    return Hs(n, function(i) {
        return e[~~t(i)]
    })
}, iI = function r(e, t, n) {
    var i = t - e;
    return si(e) ? BT(e, r(0, e.length), t) : Hs(n, function(s) {
        return (i + (s - e) % i) % i + e
    })
}, rI = function r(e, t, n) {
    var i = t - e
      , s = i * 2;
    return si(e) ? BT(e, r(0, e.length - 1), t) : Hs(n, function(o) {
        return o = (s + (o - e) % s) % s || 0,
        e + (o > i ? s - o : o)
    })
}, Pc = function(e) {
    for (var t = 0, n = "", i, s, o, a; ~(i = e.indexOf("random(", t)); )
        o = e.indexOf(")", i),
        a = e.charAt(i + 7) === "[",
        s = e.substr(i + 7, o - i - 7).match(a ? xT : xm),
        n += e.substr(t, i - t) + FT(a ? s : +s[0], a ? 0 : +s[1], +s[2] || 1e-5),
        t = o + 1;
    return n + e.substr(t, e.length - t)
}, kT = function(e, t, n, i, s) {
    var o = t - e
      , a = i - n;
    return Hs(s, function(c) {
        return n + ((c - e) / o * a || 0)
    })
}, sI = function r(e, t, n, i) {
    var s = isNaN(e + t) ? 0 : function(p) {
        return (1 - p) * e + p * t
    }
    ;
    if (!s) {
        var o = Gn(e), a = {}, c, h, d, l, f;
        if (n === !0 && (i = 1) && (n = null),
        o)
            e = {
                p: e
            },
            t = {
                p: t
            };
        else if (si(e) && !si(t)) {
            for (d = [],
            l = e.length,
            f = l - 2,
            h = 1; h < l; h++)
                d.push(r(e[h - 1], e[h]));
            l--,
            s = function(g) {
                g *= l;
                var y = Math.min(f, ~~g);
                return d[y](g - y)
            }
            ,
            n = t
        } else
            i || (e = Io(si(e) ? [] : {}, e));
        if (!d) {
            for (c in t)
                v_.call(a, e, c, "get", t[c]);
            s = function(g) {
                return b_(g, a) || (o ? e.p : e)
            }
        }
    }
    return Hs(n, s)
}, i0 = function(e, t, n) {
    var i = e.labels, s = $i, o, a, c;
    for (o in i)
        a = i[o] - t,
        a < 0 == !!n && a && s > (a = Math.abs(a)) && (c = o,
        s = a);
    return c
}, Bi = function(e, t, n) {
    var i = e.vars, s = i[t], o = sn, a = e._ctx, c, h, d;
    if (s)
        return c = i[t + "Params"],
        h = i.callbackScope || e,
        n && Os.length && kh(),
        a && (sn = a),
        d = c ? s.apply(h, c) : s.call(h),
        sn = o,
        d
}, uc = function(e) {
    return Bs(e),
    e.scrollTrigger && e.scrollTrigger.kill(!!ri),
    e.progress() < 1 && Bi(e, "onInterrupt"),
    e
}, ka, zT = [], HT = function(e) {
    if (e)
        if (e = !e.name && e.default || e,
        f_() || e.headless) {
            var t = e.name
              , n = pn(e)
              , i = t && !n && e.init ? function() {
                this._props = []
            }
            : e
              , s = {
                init: Ac,
                render: b_,
                add: v_,
                kill: TI,
                modifier: xI,
                rawVars: 0
            }
              , o = {
                targetTest: 0,
                get: 0,
                getSetter: T_,
                aliases: {},
                register: 0
            };
            if (tl(),
            e !== i) {
                if (Oi[t])
                    return;
                ir(i, ir(zh(e, s), o)),
                Io(i.prototype, Io(s, zh(e, o))),
                Oi[i.prop = t] = i,
                e.targetTest && (Ch.push(i),
                m_[t] = 1),
                t = (t === "css" ? "CSS" : t.charAt(0).toUpperCase() + t.substr(1)) + "Plugin"
            }
            ST(t, i),
            e.register && e.register(Mi, i, Ti)
        } else
            zT.push(e)
}, zt = 255, hc = {
    aqua: [0, zt, zt],
    lime: [0, zt, 0],
    silver: [192, 192, 192],
    black: [0, 0, 0],
    maroon: [128, 0, 0],
    teal: [0, 128, 128],
    blue: [0, 0, zt],
    navy: [0, 0, 128],
    white: [zt, zt, zt],
    olive: [128, 128, 0],
    yellow: [zt, zt, 0],
    orange: [zt, 165, 0],
    gray: [128, 128, 128],
    purple: [128, 0, 128],
    green: [0, 128, 0],
    red: [zt, 0, 0],
    pink: [zt, 192, 203],
    cyan: [0, zt, zt],
    transparent: [zt, zt, zt, 0]
}, ip = function(e, t, n) {
    return e += e < 0 ? 1 : e > 1 ? -1 : 0,
    (e * 6 < 1 ? t + (n - t) * e * 6 : e < .5 ? n : e * 3 < 2 ? t + (n - t) * (2 / 3 - e) * 6 : t) * zt + .5 | 0
}, VT = function(e, t, n) {
    var i = e ? ss(e) ? [e >> 16, e >> 8 & zt, e & zt] : 0 : hc.black, s, o, a, c, h, d, l, f, p, g;
    if (!i) {
        if (e.substr(-1) === "," && (e = e.substr(0, e.length - 1)),
        hc[e])
            i = hc[e];
        else if (e.charAt(0) === "#") {
            if (e.length < 6 && (s = e.charAt(1),
            o = e.charAt(2),
            a = e.charAt(3),
            e = "#" + s + s + o + o + a + a + (e.length === 5 ? e.charAt(4) + e.charAt(4) : "")),
            e.length === 9)
                return i = parseInt(e.substr(1, 6), 16),
                [i >> 16, i >> 8 & zt, i & zt, parseInt(e.substr(7), 16) / 255];
            e = parseInt(e.substr(1), 16),
            i = [e >> 16, e >> 8 & zt, e & zt]
        } else if (e.substr(0, 3) === "hsl") {
            if (i = g = e.match(xm),
            !t)
                c = +i[0] % 360 / 360,
                h = +i[1] / 100,
                d = +i[2] / 100,
                o = d <= .5 ? d * (h + 1) : d + h - d * h,
                s = d * 2 - o,
                i.length > 3 && (i[3] *= 1),
                i[0] = ip(c + 1 / 3, s, o),
                i[1] = ip(c, s, o),
                i[2] = ip(c - 1 / 3, s, o);
            else if (~e.indexOf("="))
                return i = e.match(vT),
                n && i.length < 4 && (i[3] = 1),
                i
        } else
            i = e.match(xm) || hc.transparent;
        i = i.map(Number)
    }
    return t && !g && (s = i[0] / zt,
    o = i[1] / zt,
    a = i[2] / zt,
    l = Math.max(s, o, a),
    f = Math.min(s, o, a),
    d = (l + f) / 2,
    l === f ? c = h = 0 : (p = l - f,
    h = d > .5 ? p / (2 - l - f) : p / (l + f),
    c = l === s ? (o - a) / p + (o < a ? 6 : 0) : l === o ? (a - s) / p + 2 : (s - o) / p + 4,
    c *= 60),
    i[0] = ~~(c + .5),
    i[1] = ~~(h * 100 + .5),
    i[2] = ~~(d * 100 + .5)),
    n && i.length < 4 && (i[3] = 1),
    i
}, GT = function(e) {
    var t = []
      , n = []
      , i = -1;
    return e.split(Us).forEach(function(s) {
        var o = s.match(Ba) || [];
        t.push.apply(t, o),
        n.push(i += o.length + 1)
    }),
    t.c = n,
    t
}, r0 = function(e, t, n) {
    var i = "", s = (e + i).match(Us), o = t ? "hsla(" : "rgba(", a = 0, c, h, d, l;
    if (!s)
        return e;
    if (s = s.map(function(f) {
        return (f = VT(f, t, 1)) && o + (t ? f[0] + "," + f[1] + "%," + f[2] + "%," + f[3] : f.join(",")) + ")"
    }),
    n && (d = GT(e),
    c = n.c,
    c.join(i) !== d.c.join(i)))
        for (h = e.replace(Us, "1").split(Ba),
        l = h.length - 1; a < l; a++)
            i += h[a] + (~c.indexOf(a) ? s.shift() || o + "0,0,0,0)" : (d.length ? d : s.length ? s : n).shift());
    if (!h)
        for (h = e.split(Us),
        l = h.length - 1; a < l; a++)
            i += h[a] + s[a];
    return i + h[l]
}, Us = function() {
    var r = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b", e;
    for (e in hc)
        r += "|" + e + "\\b";
    return new RegExp(r + ")","gi")
}(), oI = /hsl[a]?\(/, WT = function(e) {
    var t = e.join(" "), n;
    if (Us.lastIndex = 0,
    Us.test(t))
        return n = oI.test(t),
        e[1] = r0(e[1], n),
        e[0] = r0(e[0], n, GT(e[1])),
        !0
}, Rc, Ui = function() {
    var r = Date.now, e = 500, t = 33, n = r(), i = n, s = 1e3 / 240, o = s, a = [], c, h, d, l, f, p, g = function y(v) {
        var _ = r() - i, b = v === !0, T, S, E, P;
        if ((_ > e || _ < 0) && (n += _ - t),
        i += _,
        E = i - n,
        T = E - o,
        (T > 0 || b) && (P = ++l.frame,
        f = E - l.time * 1e3,
        l.time = E = E / 1e3,
        o += T + (T >= s ? 4 : s - T),
        S = 1),
        b || (c = h(y)),
        S)
            for (p = 0; p < a.length; p++)
                a[p](E, f, P, v)
    };
    return l = {
        time: 0,
        frame: 0,
        tick: function() {
            g(!0)
        },
        deltaRatio: function(v) {
            return f / (1e3 / (v || 60))
        },
        wake: function() {
            TT && (!Tm && f_() && (Er = Tm = window,
            d_ = Er.document || {},
            Vi.gsap = Mi,
            (Er.gsapVersions || (Er.gsapVersions = [])).push(Mi.version),
            bT(Bh || Er.GreenSockGlobals || !Er.gsap && Er || {}),
            zT.forEach(HT)),
            d = typeof requestAnimationFrame < "u" && requestAnimationFrame,
            c && l.sleep(),
            h = d || function(v) {
                return setTimeout(v, o - l.time * 1e3 + 1 | 0)
            }
            ,
            Rc = 1,
            g(2))
        },
        sleep: function() {
            (d ? cancelAnimationFrame : clearTimeout)(c),
            Rc = 0,
            h = Ac
        },
        lagSmoothing: function(v, _) {
            e = v || 1 / 0,
            t = Math.min(_ || 33, e)
        },
        fps: function(v) {
            s = 1e3 / (v || 240),
            o = l.time * 1e3 + s
        },
        add: function(v, _, b) {
            var T = _ ? function(S, E, P, R) {
                v(S, E, P, R),
                l.remove(T)
            }
            : v;
            return l.remove(v),
            a[b ? "unshift" : "push"](T),
            tl(),
            T
        },
        remove: function(v, _) {
            ~(_ = a.indexOf(v)) && a.splice(_, 1) && p >= _ && p--
        },
        _listeners: a
    },
    l
}(), tl = function() {
    return !Rc && Ui.wake()
}, Tt = {}, aI = /^[\d.\-M][\d.\-,\s]/, lI = /["']/g, cI = function(e) {
    for (var t = {}, n = e.substr(1, e.length - 3).split(":"), i = n[0], s = 1, o = n.length, a, c, h; s < o; s++)
        c = n[s],
        a = s !== o - 1 ? c.lastIndexOf(",") : c.length,
        h = c.substr(0, a),
        t[i] = isNaN(h) ? h.replace(lI, "").trim() : +h,
        i = c.substr(a + 1).trim();
    return t
}, uI = function(e) {
    var t = e.indexOf("(") + 1
      , n = e.indexOf(")")
      , i = e.indexOf("(", t);
    return e.substring(t, ~i && i < n ? e.indexOf(")", n + 1) : n)
}, hI = function(e) {
    var t = (e + "").split("(")
      , n = Tt[t[0]];
    return n && t.length > 1 && n.config ? n.config.apply(null, ~e.indexOf("{") ? [cI(t[1])] : uI(e).split(",").map(AT)) : Tt._CE && aI.test(e) ? Tt._CE("", e) : n
}, jT = function(e) {
    return function(t) {
        return 1 - e(1 - t)
    }
}, XT = function r(e, t) {
    for (var n = e._first, i; n; )
        n instanceof ui ? r(n, t) : n.vars.yoyoEase && (!n._yoyo || !n._repeat) && n._yoyo !== t && (n.timeline ? r(n.timeline, t) : (i = n._ease,
        n._ease = n._yEase,
        n._yEase = i,
        n._yoyo = t)),
        n = n._next
}, Ao = function(e, t) {
    return e && (pn(e) ? e : Tt[e] || hI(e)) || t
}, Fo = function(e, t, n, i) {
    n === void 0 && (n = function(c) {
        return 1 - t(1 - c)
    }
    ),
    i === void 0 && (i = function(c) {
        return c < .5 ? t(c * 2) / 2 : 1 - t((1 - c) * 2) / 2
    }
    );
    var s = {
        easeIn: t,
        easeOut: n,
        easeInOut: i
    }, o;
    return xi(e, function(a) {
        Tt[a] = Vi[a] = s,
        Tt[o = a.toLowerCase()] = n;
        for (var c in s)
            Tt[o + (c === "easeIn" ? ".in" : c === "easeOut" ? ".out" : ".inOut")] = Tt[a + "." + c] = s[c]
    }),
    s
}, qT = function(e) {
    return function(t) {
        return t < .5 ? (1 - e(1 - t * 2)) / 2 : .5 + e((t - .5) * 2) / 2
    }
}, rp = function r(e, t, n) {
    var i = t >= 1 ? t : 1
      , s = (n || (e ? .3 : .45)) / (t < 1 ? t : 1)
      , o = s / ym * (Math.asin(1 / i) || 0)
      , a = function(d) {
        return d === 1 ? 1 : i * Math.pow(2, -10 * d) * kC((d - o) * s) + 1
    }
      , c = e === "out" ? a : e === "in" ? function(h) {
        return 1 - a(1 - h)
    }
    : qT(a);
    return s = ym / s,
    c.config = function(h, d) {
        return r(e, h, d)
    }
    ,
    c
}, sp = function r(e, t) {
    t === void 0 && (t = 1.70158);
    var n = function(o) {
        return o ? --o * o * ((t + 1) * o + t) + 1 : 0
    }
      , i = e === "out" ? n : e === "in" ? function(s) {
        return 1 - n(1 - s)
    }
    : qT(n);
    return i.config = function(s) {
        return r(e, s)
    }
    ,
    i
};
xi("Linear,Quad,Cubic,Quart,Quint,Strong", function(r, e) {
    var t = e < 5 ? e + 1 : e;
    Fo(r + ",Power" + (t - 1), e ? function(n) {
        return Math.pow(n, t)
    }
    : function(n) {
        return n
    }
    , function(n) {
        return 1 - Math.pow(1 - n, t)
    }, function(n) {
        return n < .5 ? Math.pow(n * 2, t) / 2 : 1 - Math.pow((1 - n) * 2, t) / 2
    })
});
Tt.Linear.easeNone = Tt.none = Tt.Linear.easeIn;
Fo("Elastic", rp("in"), rp("out"), rp());
(function(r, e) {
    var t = 1 / e
      , n = 2 * t
      , i = 2.5 * t
      , s = function(a) {
        return a < t ? r * a * a : a < n ? r * Math.pow(a - 1.5 / e, 2) + .75 : a < i ? r * (a -= 2.25 / e) * a + .9375 : r * Math.pow(a - 2.625 / e, 2) + .984375
    };
    Fo("Bounce", function(o) {
        return 1 - s(1 - o)
    }, s)
}
)(7.5625, 2.75);
Fo("Expo", function(r) {
    return r ? Math.pow(2, 10 * (r - 1)) : 0
});
Fo("Circ", function(r) {
    return -(_T(1 - r * r) - 1)
});
Fo("Sine", function(r) {
    return r === 1 ? 1 : -BC(r * NC) + 1
});
Fo("Back", sp("in"), sp("out"), sp());
Tt.SteppedEase = Tt.steps = Vi.SteppedEase = {
    config: function(e, t) {
        e === void 0 && (e = 1);
        var n = 1 / e
          , i = e + (t ? 0 : 1)
          , s = t ? 1 : 0
          , o = 1 - Kt;
        return function(a) {
            return ((i * Nc(0, o, a) | 0) + s) * n
        }
    }
};
Ja.ease = Tt["quad.out"];
xi("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt", function(r) {
    return __ += r + "," + r + "Params,"
});
var KT = function(e, t) {
    this.id = FC++,
    e._gsap = this,
    this.target = e,
    this.harness = t,
    this.get = t ? t.get : wT,
    this.set = t ? t.getSetter : T_
}
  , Cc = function() {
    function r(t) {
        this.vars = t,
        this._delay = +t.delay || 0,
        (this._repeat = t.repeat === 1 / 0 ? -2 : t.repeat || 0) && (this._rDelay = t.repeatDelay || 0,
        this._yoyo = !!t.yoyo || !!t.yoyoEase),
        this._ts = 1,
        el(this, +t.duration, 1, 1),
        this.data = t.data,
        sn && (this._ctx = sn,
        sn.data.push(this)),
        Rc || Ui.wake()
    }
    var e = r.prototype;
    return e.delay = function(n) {
        return n || n === 0 ? (this.parent && this.parent.smoothChildTiming && this.startTime(this._start + n - this._delay),
        this._delay = n,
        this) : this._delay
    }
    ,
    e.duration = function(n) {
        return arguments.length ? this.totalDuration(this._repeat > 0 ? n + (n + this._rDelay) * this._repeat : n) : this.totalDuration() && this._dur
    }
    ,
    e.totalDuration = function(n) {
        return arguments.length ? (this._dirty = 0,
        el(this, this._repeat < 0 ? n : (n - this._repeat * this._rDelay) / (this._repeat + 1))) : this._tDur
    }
    ,
    e.totalTime = function(n, i) {
        if (tl(),
        !arguments.length)
            return this._tTime;
        var s = this._dp;
        if (s && s.smoothChildTiming && this._ts) {
            for (hf(this, n),
            !s._dp || s.parent || CT(s, this); s && s.parent; )
                s.parent._time !== s._start + (s._ts >= 0 ? s._tTime / s._ts : (s.totalDuration() - s._tTime) / -s._ts) && s.totalTime(s._tTime, !0),
                s = s.parent;
            !this.parent && this._dp.autoRemoveChildren && (this._ts > 0 && n < this._tDur || this._ts < 0 && n > 0 || !this._tDur && !n) && Pr(this._dp, this, this._start - this._delay)
        }
        return (this._tTime !== n || !this._dur && !i || this._initted && Math.abs(this._zTime) === Kt || !n && !this._initted && (this.add || this._ptLookup)) && (this._ts || (this._pTime = n),
        ET(this, n, i)),
        this
    }
    ,
    e.time = function(n, i) {
        return arguments.length ? this.totalTime(Math.min(this.totalDuration(), n + t0(this)) % (this._dur + this._rDelay) || (n ? this._dur : 0), i) : this._time
    }
    ,
    e.totalProgress = function(n, i) {
        return arguments.length ? this.totalTime(this.totalDuration() * n, i) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.rawTime() > 0 ? 1 : 0
    }
    ,
    e.progress = function(n, i) {
        return arguments.length ? this.totalTime(this.duration() * (this._yoyo && !(this.iteration() & 1) ? 1 - n : n) + t0(this), i) : this.duration() ? Math.min(1, this._time / this._dur) : this.rawTime() > 0 ? 1 : 0
    }
    ,
    e.iteration = function(n, i) {
        var s = this.duration() + this._rDelay;
        return arguments.length ? this.totalTime(this._time + (n - 1) * s, i) : this._repeat ? Qa(this._tTime, s) + 1 : 1
    }
    ,
    e.timeScale = function(n, i) {
        if (!arguments.length)
            return this._rts === -Kt ? 0 : this._rts;
        if (this._rts === n)
            return this;
        var s = this.parent && this._ts ? Hh(this.parent._time, this) : this._tTime;
        return this._rts = +n || 0,
        this._ts = this._ps || n === -Kt ? 0 : this._rts,
        this.totalTime(Nc(-Math.abs(this._delay), this._tDur, s), i !== !1),
        uf(this),
        XC(this)
    }
    ,
    e.paused = function(n) {
        return arguments.length ? (this._ps !== n && (this._ps = n,
        n ? (this._pTime = this._tTime || Math.max(-this._delay, this.rawTime()),
        this._ts = this._act = 0) : (tl(),
        this._ts = this._rts,
        this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, this.progress() === 1 && Math.abs(this._zTime) !== Kt && (this._tTime -= Kt)))),
        this) : this._ps
    }
    ,
    e.startTime = function(n) {
        if (arguments.length) {
            this._start = n;
            var i = this.parent || this._dp;
            return i && (i._sort || !this.parent) && Pr(i, this, n - this._delay),
            this
        }
        return this._start
    }
    ,
    e.endTime = function(n) {
        return this._start + (yi(n) ? this.totalDuration() : this.duration()) / Math.abs(this._ts || 1)
    }
    ,
    e.rawTime = function(n) {
        var i = this.parent || this._dp;
        return i ? n && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : this._ts ? Hh(i.rawTime(n), this) : this._tTime : this._tTime
    }
    ,
    e.revert = function(n) {
        n === void 0 && (n = VC);
        var i = ri;
        return ri = n,
        (this._initted || this._startAt) && (this.timeline && this.timeline.revert(n),
        this.totalTime(-.01, n.suppressEvents)),
        this.data !== "nested" && n.kill !== !1 && this.kill(),
        ri = i,
        this
    }
    ,
    e.globalTime = function(n) {
        for (var i = this, s = arguments.length ? n : i.rawTime(); i; )
            s = i._start + s / (Math.abs(i._ts) || 1),
            i = i._dp;
        return !this.parent && this._sat ? this._sat.globalTime(n) : s
    }
    ,
    e.repeat = function(n) {
        return arguments.length ? (this._repeat = n === 1 / 0 ? -2 : n,
        n0(this)) : this._repeat === -2 ? 1 / 0 : this._repeat
    }
    ,
    e.repeatDelay = function(n) {
        if (arguments.length) {
            var i = this._time;
            return this._rDelay = n,
            n0(this),
            i ? this.time(i) : this
        }
        return this._rDelay
    }
    ,
    e.yoyo = function(n) {
        return arguments.length ? (this._yoyo = n,
        this) : this._yoyo
    }
    ,
    e.seek = function(n, i) {
        return this.totalTime(qi(this, n), yi(i))
    }
    ,
    e.restart = function(n, i) {
        return this.play().totalTime(n ? -this._delay : 0, yi(i))
    }
    ,
    e.play = function(n, i) {
        return n != null && this.seek(n, i),
        this.reversed(!1).paused(!1)
    }
    ,
    e.reverse = function(n, i) {
        return n != null && this.seek(n || this.totalDuration(), i),
        this.reversed(!0).paused(!1)
    }
    ,
    e.pause = function(n, i) {
        return n != null && this.seek(n, i),
        this.paused(!0)
    }
    ,
    e.resume = function() {
        return this.paused(!1)
    }
    ,
    e.reversed = function(n) {
        return arguments.length ? (!!n !== this.reversed() && this.timeScale(-this._rts || (n ? -Kt : 0)),
        this) : this._rts < 0
    }
    ,
    e.invalidate = function() {
        return this._initted = this._act = 0,
        this._zTime = -Kt,
        this
    }
    ,
    e.isActive = function() {
        var n = this.parent || this._dp, i = this._start, s;
        return !!(!n || this._ts && this._initted && n.isActive() && (s = n.rawTime(!0)) >= i && s < this.endTime(!0) - Kt)
    }
    ,
    e.eventCallback = function(n, i, s) {
        var o = this.vars;
        return arguments.length > 1 ? (i ? (o[n] = i,
        s && (o[n + "Params"] = s),
        n === "onUpdate" && (this._onUpdate = i)) : delete o[n],
        this) : o[n]
    }
    ,
    e.then = function(n) {
        var i = this;
        return new Promise(function(s) {
            var o = pn(n) ? n : PT
              , a = function() {
                var h = i.then;
                i.then = null,
                pn(o) && (o = o(i)) && (o.then || o === i) && (i.then = h),
                s(o),
                i.then = h
            };
            i._initted && i.totalProgress() === 1 && i._ts >= 0 || !i._tTime && i._ts < 0 ? a() : i._prom = a
        }
        )
    }
    ,
    e.kill = function() {
        uc(this)
    }
    ,
    r
}();
ir(Cc.prototype, {
    _time: 0,
    _start: 0,
    _end: 0,
    _tTime: 0,
    _tDur: 0,
    _dirty: 0,
    _repeat: 0,
    _yoyo: !1,
    parent: null,
    _initted: !1,
    _rDelay: 0,
    _ts: 1,
    _dp: 0,
    ratio: 0,
    _zTime: -Kt,
    _prom: 0,
    _ps: !1,
    _rts: 1
});
var ui = function(r) {
    mT(e, r);
    function e(n, i) {
        var s;
        return n === void 0 && (n = {}),
        s = r.call(this, n) || this,
        s.labels = {},
        s.smoothChildTiming = !!n.smoothChildTiming,
        s.autoRemoveChildren = !!n.autoRemoveChildren,
        s._sort = yi(n.sortChildren),
        ln && Pr(n.parent || ln, es(s), i),
        n.reversed && s.reverse(),
        n.paused && s.paused(!0),
        n.scrollTrigger && IT(es(s), n.scrollTrigger),
        s
    }
    var t = e.prototype;
    return t.to = function(i, s, o) {
        return _c(0, arguments, this),
        this
    }
    ,
    t.from = function(i, s, o) {
        return _c(1, arguments, this),
        this
    }
    ,
    t.fromTo = function(i, s, o, a) {
        return _c(2, arguments, this),
        this
    }
    ,
    t.set = function(i, s, o) {
        return s.duration = 0,
        s.parent = this,
        mc(s).repeatDelay || (s.repeat = 0),
        s.immediateRender = !!s.immediateRender,
        new Mn(i,s,qi(this, o),1),
        this
    }
    ,
    t.call = function(i, s, o) {
        return Pr(this, Mn.delayedCall(0, i, s), o)
    }
    ,
    t.staggerTo = function(i, s, o, a, c, h, d) {
        return o.duration = s,
        o.stagger = o.stagger || a,
        o.onComplete = h,
        o.onCompleteParams = d,
        o.parent = this,
        new Mn(i,o,qi(this, c)),
        this
    }
    ,
    t.staggerFrom = function(i, s, o, a, c, h, d) {
        return o.runBackwards = 1,
        mc(o).immediateRender = yi(o.immediateRender),
        this.staggerTo(i, s, o, a, c, h, d)
    }
    ,
    t.staggerFromTo = function(i, s, o, a, c, h, d, l) {
        return a.startAt = o,
        mc(a).immediateRender = yi(a.immediateRender),
        this.staggerTo(i, s, a, c, h, d, l)
    }
    ,
    t.render = function(i, s, o) {
        var a = this._time, c = this._dirty ? this.totalDuration() : this._tDur, h = this._dur, d = i <= 0 ? 0 : zn(i), l = this._zTime < 0 != i < 0 && (this._initted || !h), f, p, g, y, v, _, b, T, S, E, P, R;
        if (this !== ln && d > c && i >= 0 && (d = c),
        d !== this._tTime || o || l) {
            if (a !== this._time && h && (d += this._time - a,
            i += this._time - a),
            f = d,
            S = this._start,
            T = this._ts,
            _ = !T,
            l && (h || (a = this._zTime),
            (i || !s) && (this._zTime = i)),
            this._repeat) {
                if (P = this._yoyo,
                v = h + this._rDelay,
                this._repeat < -1 && i < 0)
                    return this.totalTime(v * 100 + i, s, o);
                if (f = zn(d % v),
                d === c ? (y = this._repeat,
                f = h) : (y = ~~(d / v),
                y && y === d / v && (f = h,
                y--),
                f > h && (f = h)),
                E = Qa(this._tTime, v),
                !a && this._tTime && E !== y && this._tTime - E * v - this._dur <= 0 && (E = y),
                P && y & 1 && (f = h - f,
                R = 1),
                y !== E && !this._lock) {
                    var O = P && E & 1
                      , w = O === (P && y & 1);
                    if (y < E && (O = !O),
                    a = O ? 0 : d % h ? h : d,
                    this._lock = 1,
                    this.render(a || (R ? 0 : zn(y * v)), s, !h)._lock = 0,
                    this._tTime = d,
                    !s && this.parent && Bi(this, "onRepeat"),
                    this.vars.repeatRefresh && !R && (this.invalidate()._lock = 1),
                    a && a !== this._time || _ !== !this._ts || this.vars.onRepeat && !this.parent && !this._act)
                        return this;
                    if (h = this._dur,
                    c = this._tDur,
                    w && (this._lock = 2,
                    a = O ? h : -1e-4,
                    this.render(a, !0),
                    this.vars.repeatRefresh && !R && this.invalidate()),
                    this._lock = 0,
                    !this._ts && !_)
                        return this;
                    XT(this, R)
                }
            }
            if (this._hasPause && !this._forcing && this._lock < 2 && (b = $C(this, zn(a), zn(f)),
            b && (d -= f - (f = b._start))),
            this._tTime = d,
            this._time = f,
            this._act = !T,
            this._initted || (this._onUpdate = this.vars.onUpdate,
            this._initted = 1,
            this._zTime = i,
            a = 0),
            !a && f && !s && !y && (Bi(this, "onStart"),
            this._tTime !== d))
                return this;
            if (f >= a && i >= 0)
                for (p = this._first; p; ) {
                    if (g = p._next,
                    (p._act || f >= p._start) && p._ts && b !== p) {
                        if (p.parent !== this)
                            return this.render(i, s, o);
                        if (p.render(p._ts > 0 ? (f - p._start) * p._ts : (p._dirty ? p.totalDuration() : p._tDur) + (f - p._start) * p._ts, s, o),
                        f !== this._time || !this._ts && !_) {
                            b = 0,
                            g && (d += this._zTime = -Kt);
                            break
                        }
                    }
                    p = g
                }
            else {
                p = this._last;
                for (var I = i < 0 ? i : f; p; ) {
                    if (g = p._prev,
                    (p._act || I <= p._end) && p._ts && b !== p) {
                        if (p.parent !== this)
                            return this.render(i, s, o);
                        if (p.render(p._ts > 0 ? (I - p._start) * p._ts : (p._dirty ? p.totalDuration() : p._tDur) + (I - p._start) * p._ts, s, o || ri && (p._initted || p._startAt)),
                        f !== this._time || !this._ts && !_) {
                            b = 0,
                            g && (d += this._zTime = I ? -Kt : Kt);
                            break
                        }
                    }
                    p = g
                }
            }
            if (b && !s && (this.pause(),
            b.render(f >= a ? 0 : -Kt)._zTime = f >= a ? 1 : -1,
            this._ts))
                return this._start = S,
                uf(this),
                this.render(i, s, o);
            this._onUpdate && !s && Bi(this, "onUpdate", !0),
            (d === c && this._tTime >= this.totalDuration() || !d && a) && (S === this._start || Math.abs(T) !== Math.abs(this._ts)) && (this._lock || ((i || !h) && (d === c && this._ts > 0 || !d && this._ts < 0) && Bs(this, 1),
            !s && !(i < 0 && !a) && (d || a || !c) && (Bi(this, d === c && i >= 0 ? "onComplete" : "onReverseComplete", !0),
            this._prom && !(d < c && this.timeScale() > 0) && this._prom())))
        }
        return this
    }
    ,
    t.add = function(i, s) {
        var o = this;
        if (ss(s) || (s = qi(this, s, i)),
        !(i instanceof Cc)) {
            if (si(i))
                return i.forEach(function(a) {
                    return o.add(a, s)
                }),
                this;
            if (Gn(i))
                return this.addLabel(i, s);
            if (pn(i))
                i = Mn.delayedCall(0, i);
            else
                return this
        }
        return this !== i ? Pr(this, i, s) : this
    }
    ,
    t.getChildren = function(i, s, o, a) {
        i === void 0 && (i = !0),
        s === void 0 && (s = !0),
        o === void 0 && (o = !0),
        a === void 0 && (a = -$i);
        for (var c = [], h = this._first; h; )
            h._start >= a && (h instanceof Mn ? s && c.push(h) : (o && c.push(h),
            i && c.push.apply(c, h.getChildren(!0, s, o)))),
            h = h._next;
        return c
    }
    ,
    t.getById = function(i) {
        for (var s = this.getChildren(1, 1, 1), o = s.length; o--; )
            if (s[o].vars.id === i)
                return s[o]
    }
    ,
    t.remove = function(i) {
        return Gn(i) ? this.removeLabel(i) : pn(i) ? this.killTweensOf(i) : (cf(this, i),
        i === this._recent && (this._recent = this._last),
        Eo(this))
    }
    ,
    t.totalTime = function(i, s) {
        return arguments.length ? (this._forcing = 1,
        !this._dp && this._ts && (this._start = zn(Ui.time - (this._ts > 0 ? i / this._ts : (this.totalDuration() - i) / -this._ts))),
        r.prototype.totalTime.call(this, i, s),
        this._forcing = 0,
        this) : this._tTime
    }
    ,
    t.addLabel = function(i, s) {
        return this.labels[i] = qi(this, s),
        this
    }
    ,
    t.removeLabel = function(i) {
        return delete this.labels[i],
        this
    }
    ,
    t.addPause = function(i, s, o) {
        var a = Mn.delayedCall(0, s || Ac, o);
        return a.data = "isPause",
        this._hasPause = 1,
        Pr(this, a, qi(this, i))
    }
    ,
    t.removePause = function(i) {
        var s = this._first;
        for (i = qi(this, i); s; )
            s._start === i && s.data === "isPause" && Bs(s),
            s = s._next
    }
    ,
    t.killTweensOf = function(i, s, o) {
        for (var a = this.getTweensOf(i, o), c = a.length; c--; )
            Cs !== a[c] && a[c].kill(i, s);
        return this
    }
    ,
    t.getTweensOf = function(i, s) {
        for (var o = [], a = Zi(i), c = this._first, h = ss(s), d; c; )
            c instanceof Mn ? GC(c._targets, a) && (h ? (!Cs || c._initted && c._ts) && c.globalTime(0) <= s && c.globalTime(c.totalDuration()) > s : !s || c.isActive()) && o.push(c) : (d = c.getTweensOf(a, s)).length && o.push.apply(o, d),
            c = c._next;
        return o
    }
    ,
    t.tweenTo = function(i, s) {
        s = s || {};
        var o = this, a = qi(o, i), c = s, h = c.startAt, d = c.onStart, l = c.onStartParams, f = c.immediateRender, p, g = Mn.to(o, ir({
            ease: s.ease || "none",
            lazy: !1,
            immediateRender: !1,
            time: a,
            overwrite: "auto",
            duration: s.duration || Math.abs((a - (h && "time"in h ? h.time : o._time)) / o.timeScale()) || Kt,
            onStart: function() {
                if (o.pause(),
                !p) {
                    var v = s.duration || Math.abs((a - (h && "time"in h ? h.time : o._time)) / o.timeScale());
                    g._dur !== v && el(g, v, 0, 1).render(g._time, !0, !0),
                    p = 1
                }
                d && d.apply(g, l || [])
            }
        }, s));
        return f ? g.render(0) : g
    }
    ,
    t.tweenFromTo = function(i, s, o) {
        return this.tweenTo(s, ir({
            startAt: {
                time: qi(this, i)
            }
        }, o))
    }
    ,
    t.recent = function() {
        return this._recent
    }
    ,
    t.nextLabel = function(i) {
        return i === void 0 && (i = this._time),
        i0(this, qi(this, i))
    }
    ,
    t.previousLabel = function(i) {
        return i === void 0 && (i = this._time),
        i0(this, qi(this, i), 1)
    }
    ,
    t.currentLabel = function(i) {
        return arguments.length ? this.seek(i, !0) : this.previousLabel(this._time + Kt)
    }
    ,
    t.shiftChildren = function(i, s, o) {
        o === void 0 && (o = 0);
        for (var a = this._first, c = this.labels, h; a; )
            a._start >= o && (a._start += i,
            a._end += i),
            a = a._next;
        if (s)
            for (h in c)
                c[h] >= o && (c[h] += i);
        return Eo(this)
    }
    ,
    t.invalidate = function(i) {
        var s = this._first;
        for (this._lock = 0; s; )
            s.invalidate(i),
            s = s._next;
        return r.prototype.invalidate.call(this, i)
    }
    ,
    t.clear = function(i) {
        i === void 0 && (i = !0);
        for (var s = this._first, o; s; )
            o = s._next,
            this.remove(s),
            s = o;
        return this._dp && (this._time = this._tTime = this._pTime = 0),
        i && (this.labels = {}),
        Eo(this)
    }
    ,
    t.totalDuration = function(i) {
        var s = 0, o = this, a = o._last, c = $i, h, d, l;
        if (arguments.length)
            return o.timeScale((o._repeat < 0 ? o.duration() : o.totalDuration()) / (o.reversed() ? -i : i));
        if (o._dirty) {
            for (l = o.parent; a; )
                h = a._prev,
                a._dirty && a.totalDuration(),
                d = a._start,
                d > c && o._sort && a._ts && !o._lock ? (o._lock = 1,
                Pr(o, a, d - a._delay, 1)._lock = 0) : c = d,
                d < 0 && a._ts && (s -= d,
                (!l && !o._dp || l && l.smoothChildTiming) && (o._start += d / o._ts,
                o._time -= d,
                o._tTime -= d),
                o.shiftChildren(-d, !1, -1 / 0),
                c = 0),
                a._end > s && a._ts && (s = a._end),
                a = h;
            el(o, o === ln && o._time > s ? o._time : s, 1, 1),
            o._dirty = 0
        }
        return o._tDur
    }
    ,
    e.updateRoot = function(i) {
        if (ln._ts && (ET(ln, Hh(i, ln)),
        MT = Ui.frame),
        Ui.frame >= Qv) {
            Qv += zi.autoSleep || 120;
            var s = ln._first;
            if ((!s || !s._ts) && zi.autoSleep && Ui._listeners.length < 2) {
                for (; s && !s._ts; )
                    s = s._next;
                s || Ui.sleep()
            }
        }
    }
    ,
    e
}(Cc);
ir(ui.prototype, {
    _lock: 0,
    _hasPause: 0,
    _forcing: 0
});
var fI = function(e, t, n, i, s, o, a) {
    var c = new Ti(this._pt,e,t,0,1,eb,null,s), h = 0, d = 0, l, f, p, g, y, v, _, b;
    for (c.b = n,
    c.e = i,
    n += "",
    i += "",
    (_ = ~i.indexOf("random(")) && (i = Pc(i)),
    o && (b = [n, i],
    o(b, e, t),
    n = b[0],
    i = b[1]),
    f = n.match(tp) || []; l = tp.exec(i); )
        g = l[0],
        y = i.substring(h, l.index),
        p ? p = (p + 1) % 5 : y.substr(-5) === "rgba(" && (p = 1),
        g !== f[d++] && (v = parseFloat(f[d - 1]) || 0,
        c._pt = {
            _next: c._pt,
            p: y || d === 1 ? y : ",",
            s: v,
            c: g.charAt(1) === "=" ? Wa(v, g) - v : parseFloat(g) - v,
            m: p && p < 4 ? Math.round : 0
        },
        h = tp.lastIndex);
    return c.c = h < i.length ? i.substring(h, i.length) : "",
    c.fp = a,
    (yT.test(i) || _) && (c.e = 0),
    this._pt = c,
    c
}, v_ = function(e, t, n, i, s, o, a, c, h, d) {
    pn(i) && (i = i(s || 0, e, o));
    var l = e[t], f = n !== "get" ? n : pn(l) ? h ? e[t.indexOf("set") || !pn(e["get" + t.substr(3)]) ? t : "get" + t.substr(3)](h) : e[t]() : l, p = pn(l) ? h ? gI : JT : x_, g;
    if (Gn(i) && (~i.indexOf("random(") && (i = Pc(i)),
    i.charAt(1) === "=" && (g = Wa(f, i) + (ni(f) || 0),
    (g || g === 0) && (i = g))),
    !d || f !== i || Pm)
        return !isNaN(f * i) && i !== "" ? (g = new Ti(this._pt,e,t,+f || 0,i - (f || 0),typeof l == "boolean" ? yI : QT,0,p),
        h && (g.fp = h),
        a && g.modifier(a, this, e),
        this._pt = g) : (!l && !(t in e) && p_(t, i),
        fI.call(this, e, t, f, i, p, c || zi.stringFilter, h))
}, dI = function(e, t, n, i, s) {
    if (pn(e) && (e = gc(e, s, t, n, i)),
    !Or(e) || e.style && e.nodeType || si(e) || gT(e))
        return Gn(e) ? gc(e, s, t, n, i) : e;
    var o = {}, a;
    for (a in e)
        o[a] = gc(e[a], s, t, n, i);
    return o
}, YT = function(e, t, n, i, s, o) {
    var a, c, h, d;
    if (Oi[e] && (a = new Oi[e]).init(s, a.rawVars ? t[e] : dI(t[e], i, s, o, n), n, i, o) !== !1 && (n._pt = c = new Ti(n._pt,s,e,0,1,a.render,a,0,a.priority),
    n !== ka))
        for (h = n._ptLookup[n._targets.indexOf(s)],
        d = a._props.length; d--; )
            h[a._props[d]] = c;
    return a
}, Cs, Pm, y_ = function r(e, t, n) {
    var i = e.vars, s = i.ease, o = i.startAt, a = i.immediateRender, c = i.lazy, h = i.onUpdate, d = i.runBackwards, l = i.yoyoEase, f = i.keyframes, p = i.autoRevert, g = e._dur, y = e._startAt, v = e._targets, _ = e.parent, b = _ && _.data === "nested" ? _.vars.targets : v, T = e._overwrite === "auto" && !u_, S = e.timeline, E, P, R, O, w, I, V, z, q, F, j, K, J;
    if (S && (!f || !s) && (s = "none"),
    e._ease = Ao(s, Ja.ease),
    e._yEase = l ? jT(Ao(l === !0 ? s : l, Ja.ease)) : 0,
    l && e._yoyo && !e._repeat && (l = e._yEase,
    e._yEase = e._ease,
    e._ease = l),
    e._from = !S && !!i.runBackwards,
    !S || f && !i.stagger) {
        if (z = v[0] ? wo(v[0]).harness : 0,
        K = z && i[z.prop],
        E = zh(i, m_),
        y && (y._zTime < 0 && y.progress(1),
        t < 0 && d && a && !p ? y.render(-1, !0) : y.revert(d && g ? Rh : HC),
        y._lazy = 0),
        o) {
            if (Bs(e._startAt = Mn.set(v, ir({
                data: "isStart",
                overwrite: !1,
                parent: _,
                immediateRender: !0,
                lazy: !y && yi(c),
                startAt: null,
                delay: 0,
                onUpdate: h && function() {
                    return Bi(e, "onUpdate")
                }
                ,
                stagger: 0
            }, o))),
            e._startAt._dp = 0,
            e._startAt._sat = e,
            t < 0 && (ri || !a && !p) && e._startAt.revert(Rh),
            a && g && t <= 0 && n <= 0) {
                t && (e._zTime = t);
                return
            }
        } else if (d && g && !y) {
            if (t && (a = !1),
            R = ir({
                overwrite: !1,
                data: "isFromStart",
                lazy: a && !y && yi(c),
                immediateRender: a,
                stagger: 0,
                parent: _
            }, E),
            K && (R[z.prop] = K),
            Bs(e._startAt = Mn.set(v, R)),
            e._startAt._dp = 0,
            e._startAt._sat = e,
            t < 0 && (ri ? e._startAt.revert(Rh) : e._startAt.render(-1, !0)),
            e._zTime = t,
            !a)
                r(e._startAt, Kt, Kt);
            else if (!t)
                return
        }
        for (e._pt = e._ptCache = 0,
        c = g && yi(c) || c && !g,
        P = 0; P < v.length; P++) {
            if (w = v[P],
            V = w._gsap || g_(v)[P]._gsap,
            e._ptLookup[P] = F = {},
            bm[V.id] && Os.length && kh(),
            j = b === v ? P : b.indexOf(w),
            z && (q = new z).init(w, K || E, e, j, b) !== !1 && (e._pt = O = new Ti(e._pt,w,q.name,0,1,q.render,q,0,q.priority),
            q._props.forEach(function(de) {
                F[de] = O
            }),
            q.priority && (I = 1)),
            !z || K)
                for (R in E)
                    Oi[R] && (q = YT(R, E, e, j, w, b)) ? q.priority && (I = 1) : F[R] = O = v_.call(e, w, R, "get", E[R], j, b, 0, i.stringFilter);
            e._op && e._op[P] && e.kill(w, e._op[P]),
            T && e._pt && (Cs = e,
            ln.killTweensOf(w, F, e.globalTime(t)),
            J = !e.parent,
            Cs = 0),
            e._pt && c && (bm[V.id] = 1)
        }
        I && tb(e),
        e._onInit && e._onInit(e)
    }
    e._onUpdate = h,
    e._initted = (!e._op || e._pt) && !J,
    f && t <= 0 && S.render($i, !0, !0)
}, pI = function(e, t, n, i, s, o, a, c) {
    var h = (e._pt && e._ptCache || (e._ptCache = {}))[t], d, l, f, p;
    if (!h)
        for (h = e._ptCache[t] = [],
        f = e._ptLookup,
        p = e._targets.length; p--; ) {
            if (d = f[p][t],
            d && d.d && d.d._pt)
                for (d = d.d._pt; d && d.p !== t && d.fp !== t; )
                    d = d._next;
            if (!d)
                return Pm = 1,
                e.vars[t] = "+=0",
                y_(e, a),
                Pm = 0,
                c ? Ec(t + " not eligible for reset") : 1;
            h.push(d)
        }
    for (p = h.length; p--; )
        l = h[p],
        d = l._pt || l,
        d.s = (i || i === 0) && !s ? i : d.s + (i || 0) + o * d.c,
        d.c = n - d.s,
        l.e && (l.e = _n(n) + ni(l.e)),
        l.b && (l.b = d.s + ni(l.b))
}, mI = function(e, t) {
    var n = e[0] ? wo(e[0]).harness : 0, i = n && n.aliases, s, o, a, c;
    if (!i)
        return t;
    s = Io({}, t);
    for (o in i)
        if (o in s)
            for (c = i[o].split(","),
            a = c.length; a--; )
                s[c[a]] = s[o];
    return s
}, _I = function(e, t, n, i) {
    var s = t.ease || i || "power1.inOut", o, a;
    if (si(t))
        a = n[e] || (n[e] = []),
        t.forEach(function(c, h) {
            return a.push({
                t: h / (t.length - 1) * 100,
                v: c,
                e: s
            })
        });
    else
        for (o in t)
            a = n[o] || (n[o] = []),
            o === "ease" || a.push({
                t: parseFloat(e),
                v: t[o],
                e: s
            })
}, gc = function(e, t, n, i, s) {
    return pn(e) ? e.call(t, n, i, s) : Gn(e) && ~e.indexOf("random(") ? Pc(e) : e
}, $T = __ + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase,autoRevert", ZT = {};
xi($T + ",id,stagger,delay,duration,paused,scrollTrigger", function(r) {
    return ZT[r] = 1
});
var Mn = function(r) {
    mT(e, r);
    function e(n, i, s, o) {
        var a;
        typeof i == "number" && (s.duration = i,
        i = s,
        s = null),
        a = r.call(this, o ? i : mc(i)) || this;
        var c = a.vars, h = c.duration, d = c.delay, l = c.immediateRender, f = c.stagger, p = c.overwrite, g = c.keyframes, y = c.defaults, v = c.scrollTrigger, _ = c.yoyoEase, b = i.parent || ln, T = (si(n) || gT(n) ? ss(n[0]) : "length"in i) ? [n] : Zi(n), S, E, P, R, O, w, I, V;
        if (a._targets = T.length ? g_(T) : Ec("GSAP target " + n + " not found. https://gsap.com", !zi.nullTargetWarn) || [],
        a._ptLookup = [],
        a._overwrite = p,
        g || f || Lu(h) || Lu(d)) {
            if (i = a.vars,
            S = a.timeline = new ui({
                data: "nested",
                defaults: y || {},
                targets: b && b.data === "nested" ? b.vars.targets : T
            }),
            S.kill(),
            S.parent = S._dp = es(a),
            S._start = 0,
            f || Lu(h) || Lu(d)) {
                if (R = T.length,
                I = f && UT(f),
                Or(f))
                    for (O in f)
                        ~$T.indexOf(O) && (V || (V = {}),
                        V[O] = f[O]);
                for (E = 0; E < R; E++)
                    P = zh(i, ZT),
                    P.stagger = 0,
                    _ && (P.yoyoEase = _),
                    V && Io(P, V),
                    w = T[E],
                    P.duration = +gc(h, es(a), E, w, T),
                    P.delay = (+gc(d, es(a), E, w, T) || 0) - a._delay,
                    !f && R === 1 && P.delay && (a._delay = d = P.delay,
                    a._start += d,
                    P.delay = 0),
                    S.to(w, P, I ? I(E, w, T) : 0),
                    S._ease = Tt.none;
                S.duration() ? h = d = 0 : a.timeline = 0
            } else if (g) {
                mc(ir(S.vars.defaults, {
                    ease: "none"
                })),
                S._ease = Ao(g.ease || i.ease || "none");
                var z = 0, q, F, j;
                if (si(g))
                    g.forEach(function(K) {
                        return S.to(T, K, ">")
                    }),
                    S.duration();
                else {
                    P = {};
                    for (O in g)
                        O === "ease" || O === "easeEach" || _I(O, g[O], P, g.easeEach);
                    for (O in P)
                        for (q = P[O].sort(function(K, J) {
                            return K.t - J.t
                        }),
                        z = 0,
                        E = 0; E < q.length; E++)
                            F = q[E],
                            j = {
                                ease: F.e,
                                duration: (F.t - (E ? q[E - 1].t : 0)) / 100 * h
                            },
                            j[O] = F.v,
                            S.to(T, j, z),
                            z += j.duration;
                    S.duration() < h && S.to({}, {
                        duration: h - S.duration()
                    })
                }
            }
            h || a.duration(h = S.duration())
        } else
            a.timeline = 0;
        return p === !0 && !u_ && (Cs = es(a),
        ln.killTweensOf(T),
        Cs = 0),
        Pr(b, es(a), s),
        i.reversed && a.reverse(),
        i.paused && a.paused(!0),
        (l || !h && !g && a._start === zn(b._time) && yi(l) && qC(es(a)) && b.data !== "nested") && (a._tTime = -Kt,
        a.render(Math.max(0, -d) || 0)),
        v && IT(es(a), v),
        a
    }
    var t = e.prototype;
    return t.render = function(i, s, o) {
        var a = this._time, c = this._tDur, h = this._dur, d = i < 0, l = i > c - Kt && !d ? c : i < Kt ? 0 : i, f, p, g, y, v, _, b, T, S;
        if (!h)
            YC(this, i, s, o);
        else if (l !== this._tTime || !i || o || !this._initted && this._tTime || this._startAt && this._zTime < 0 !== d) {
            if (f = l,
            T = this.timeline,
            this._repeat) {
                if (y = h + this._rDelay,
                this._repeat < -1 && d)
                    return this.totalTime(y * 100 + i, s, o);
                if (f = zn(l % y),
                l === c ? (g = this._repeat,
                f = h) : (g = ~~(l / y),
                g && g === zn(l / y) && (f = h,
                g--),
                f > h && (f = h)),
                _ = this._yoyo && g & 1,
                _ && (S = this._yEase,
                f = h - f),
                v = Qa(this._tTime, y),
                f === a && !o && this._initted && g === v)
                    return this._tTime = l,
                    this;
                g !== v && (T && this._yEase && XT(T, _),
                this.vars.repeatRefresh && !_ && !this._lock && this._time !== y && this._initted && (this._lock = o = 1,
                this.render(zn(y * g), !0).invalidate()._lock = 0))
            }
            if (!this._initted) {
                if (LT(this, d ? i : f, o, s, l))
                    return this._tTime = 0,
                    this;
                if (a !== this._time && !(o && this.vars.repeatRefresh && g !== v))
                    return this;
                if (h !== this._dur)
                    return this.render(i, s, o)
            }
            if (this._tTime = l,
            this._time = f,
            !this._act && this._ts && (this._act = 1,
            this._lazy = 0),
            this.ratio = b = (S || this._ease)(f / h),
            this._from && (this.ratio = b = 1 - b),
            f && !a && !s && !g && (Bi(this, "onStart"),
            this._tTime !== l))
                return this;
            for (p = this._pt; p; )
                p.r(b, p.d),
                p = p._next;
            T && T.render(i < 0 ? i : T._dur * T._ease(f / this._dur), s, o) || this._startAt && (this._zTime = i),
            this._onUpdate && !s && (d && Sm(this, i, s, o),
            Bi(this, "onUpdate")),
            this._repeat && g !== v && this.vars.onRepeat && !s && this.parent && Bi(this, "onRepeat"),
            (l === this._tDur || !l) && this._tTime === l && (d && !this._onUpdate && Sm(this, i, !0, !0),
            (i || !h) && (l === this._tDur && this._ts > 0 || !l && this._ts < 0) && Bs(this, 1),
            !s && !(d && !a) && (l || a || _) && (Bi(this, l === c ? "onComplete" : "onReverseComplete", !0),
            this._prom && !(l < c && this.timeScale() > 0) && this._prom()))
        }
        return this
    }
    ,
    t.targets = function() {
        return this._targets
    }
    ,
    t.invalidate = function(i) {
        return (!i || !this.vars.runBackwards) && (this._startAt = 0),
        this._pt = this._op = this._onUpdate = this._lazy = this.ratio = 0,
        this._ptLookup = [],
        this.timeline && this.timeline.invalidate(i),
        r.prototype.invalidate.call(this, i)
    }
    ,
    t.resetTo = function(i, s, o, a, c) {
        Rc || Ui.wake(),
        this._ts || this.play();
        var h = Math.min(this._dur, (this._dp._time - this._start) * this._ts), d;
        return this._initted || y_(this, h),
        d = this._ease(h / this._dur),
        pI(this, i, s, o, a, d, h, c) ? this.resetTo(i, s, o, a, 1) : (hf(this, 0),
        this.parent || RT(this._dp, this, "_first", "_last", this._dp._sort ? "_start" : 0),
        this.render(0))
    }
    ,
    t.kill = function(i, s) {
        if (s === void 0 && (s = "all"),
        !i && (!s || s === "all"))
            return this._lazy = this._pt = 0,
            this.parent ? uc(this) : this;
        if (this.timeline) {
            var o = this.timeline.totalDuration();
            return this.timeline.killTweensOf(i, s, Cs && Cs.vars.overwrite !== !0)._first || uc(this),
            this.parent && o !== this.timeline.totalDuration() && el(this, this._dur * this.timeline._tDur / o, 0, 1),
            this
        }
        var a = this._targets, c = i ? Zi(i) : a, h = this._ptLookup, d = this._pt, l, f, p, g, y, v, _;
        if ((!s || s === "all") && jC(a, c))
            return s === "all" && (this._pt = 0),
            uc(this);
        for (l = this._op = this._op || [],
        s !== "all" && (Gn(s) && (y = {},
        xi(s, function(b) {
            return y[b] = 1
        }),
        s = y),
        s = mI(a, s)),
        _ = a.length; _--; )
            if (~c.indexOf(a[_])) {
                f = h[_],
                s === "all" ? (l[_] = s,
                g = f,
                p = {}) : (p = l[_] = l[_] || {},
                g = s);
                for (y in g)
                    v = f && f[y],
                    v && ((!("kill"in v.d) || v.d.kill(y) === !0) && cf(this, v, "_pt"),
                    delete f[y]),
                    p !== "all" && (p[y] = 1)
            }
        return this._initted && !this._pt && d && uc(this),
        this
    }
    ,
    e.to = function(i, s) {
        return new e(i,s,arguments[2])
    }
    ,
    e.from = function(i, s) {
        return _c(1, arguments)
    }
    ,
    e.delayedCall = function(i, s, o, a) {
        return new e(s,0,{
            immediateRender: !1,
            lazy: !1,
            overwrite: !1,
            delay: i,
            onComplete: s,
            onReverseComplete: s,
            onCompleteParams: o,
            onReverseCompleteParams: o,
            callbackScope: a
        })
    }
    ,
    e.fromTo = function(i, s, o) {
        return _c(2, arguments)
    }
    ,
    e.set = function(i, s) {
        return s.duration = 0,
        s.repeatDelay || (s.repeat = 0),
        new e(i,s)
    }
    ,
    e.killTweensOf = function(i, s, o) {
        return ln.killTweensOf(i, s, o)
    }
    ,
    e
}(Cc);
ir(Mn.prototype, {
    _targets: [],
    _lazy: 0,
    _startAt: 0,
    _op: 0,
    _onInit: 0
});
xi("staggerTo,staggerFrom,staggerFromTo", function(r) {
    Mn[r] = function() {
        var e = new ui
          , t = wm.call(arguments, 0);
        return t.splice(r === "staggerFromTo" ? 5 : 4, 0, 0),
        e[r].apply(e, t)
    }
});
var x_ = function(e, t, n) {
    return e[t] = n
}
  , JT = function(e, t, n) {
    return e[t](n)
}
  , gI = function(e, t, n, i) {
    return e[t](i.fp, n)
}
  , vI = function(e, t, n) {
    return e.setAttribute(t, n)
}
  , T_ = function(e, t) {
    return pn(e[t]) ? JT : h_(e[t]) && e.setAttribute ? vI : x_
}
  , QT = function(e, t) {
    return t.set(t.t, t.p, Math.round((t.s + t.c * e) * 1e6) / 1e6, t)
}
  , yI = function(e, t) {
    return t.set(t.t, t.p, !!(t.s + t.c * e), t)
}
  , eb = function(e, t) {
    var n = t._pt
      , i = "";
    if (!e && t.b)
        i = t.b;
    else if (e === 1 && t.e)
        i = t.e;
    else {
        for (; n; )
            i = n.p + (n.m ? n.m(n.s + n.c * e) : Math.round((n.s + n.c * e) * 1e4) / 1e4) + i,
            n = n._next;
        i += t.c
    }
    t.set(t.t, t.p, i, t)
}
  , b_ = function(e, t) {
    for (var n = t._pt; n; )
        n.r(e, n.d),
        n = n._next
}
  , xI = function(e, t, n, i) {
    for (var s = this._pt, o; s; )
        o = s._next,
        s.p === i && s.modifier(e, t, n),
        s = o
}
  , TI = function(e) {
    for (var t = this._pt, n, i; t; )
        i = t._next,
        t.p === e && !t.op || t.op === e ? cf(this, t, "_pt") : t.dep || (n = 1),
        t = i;
    return !n
}
  , bI = function(e, t, n, i) {
    i.mSet(e, t, i.m.call(i.tween, n, i.mt), i)
}
  , tb = function(e) {
    for (var t = e._pt, n, i, s, o; t; ) {
        for (n = t._next,
        i = s; i && i.pr > t.pr; )
            i = i._next;
        (t._prev = i ? i._prev : o) ? t._prev._next = t : s = t,
        (t._next = i) ? i._prev = t : o = t,
        t = n
    }
    e._pt = s
}
  , Ti = function() {
    function r(t, n, i, s, o, a, c, h, d) {
        this.t = n,
        this.s = s,
        this.c = o,
        this.p = i,
        this.r = a || QT,
        this.d = c || this,
        this.set = h || x_,
        this.pr = d || 0,
        this._next = t,
        t && (t._prev = this)
    }
    var e = r.prototype;
    return e.modifier = function(n, i, s) {
        this.mSet = this.mSet || this.set,
        this.set = bI,
        this.m = n,
        this.mt = s,
        this.tween = i
    }
    ,
    r
}();
xi(__ + "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger", function(r) {
    return m_[r] = 1
});
Vi.TweenMax = Vi.TweenLite = Mn;
Vi.TimelineLite = Vi.TimelineMax = ui;
ln = new ui({
    sortChildren: !1,
    defaults: Ja,
    autoRemoveChildren: !0,
    id: "root",
    smoothChildTiming: !0
});
zi.stringFilter = WT;
var Po = []
  , Ih = {}
  , SI = []
  , s0 = 0
  , MI = 0
  , op = function(e) {
    return (Ih[e] || SI).map(function(t) {
        return t()
    })
}
  , Rm = function() {
    var e = Date.now()
      , t = [];
    e - s0 > 2 && (op("matchMediaInit"),
    Po.forEach(function(n) {
        var i = n.queries, s = n.conditions, o, a, c, h;
        for (a in i)
            o = Er.matchMedia(i[a]).matches,
            o && (c = 1),
            o !== s[a] && (s[a] = o,
            h = 1);
        h && (n.revert(),
        c && t.push(n))
    }),
    op("matchMediaRevert"),
    t.forEach(function(n) {
        return n.onMatch(n, function(i) {
            return n.add(null, i)
        })
    }),
    s0 = e,
    op("matchMedia"))
}
  , nb = function() {
    function r(t, n) {
        this.selector = n && Em(n),
        this.data = [],
        this._r = [],
        this.isReverted = !1,
        this.id = MI++,
        t && this.add(t)
    }
    var e = r.prototype;
    return e.add = function(n, i, s) {
        pn(n) && (s = i,
        i = n,
        n = pn);
        var o = this
          , a = function() {
            var h = sn, d = o.selector, l;
            return h && h !== o && h.data.push(o),
            s && (o.selector = Em(s)),
            sn = o,
            l = i.apply(o, arguments),
            pn(l) && o._r.push(l),
            sn = h,
            o.selector = d,
            o.isReverted = !1,
            l
        };
        return o.last = a,
        n === pn ? a(o, function(c) {
            return o.add(null, c)
        }) : n ? o[n] = a : a
    }
    ,
    e.ignore = function(n) {
        var i = sn;
        sn = null,
        n(this),
        sn = i
    }
    ,
    e.getTweens = function() {
        var n = [];
        return this.data.forEach(function(i) {
            return i instanceof r ? n.push.apply(n, i.getTweens()) : i instanceof Mn && !(i.parent && i.parent.data === "nested") && n.push(i)
        }),
        n
    }
    ,
    e.clear = function() {
        this._r.length = this.data.length = 0
    }
    ,
    e.kill = function(n, i) {
        var s = this;
        if (n ? function() {
            for (var a = s.getTweens(), c = s.data.length, h; c--; )
                h = s.data[c],
                h.data === "isFlip" && (h.revert(),
                h.getChildren(!0, !0, !1).forEach(function(d) {
                    return a.splice(a.indexOf(d), 1)
                }));
            for (a.map(function(d) {
                return {
                    g: d._dur || d._delay || d._sat && !d._sat.vars.immediateRender ? d.globalTime(0) : -1 / 0,
                    t: d
                }
            }).sort(function(d, l) {
                return l.g - d.g || -1 / 0
            }).forEach(function(d) {
                return d.t.revert(n)
            }),
            c = s.data.length; c--; )
                h = s.data[c],
                h instanceof ui ? h.data !== "nested" && (h.scrollTrigger && h.scrollTrigger.revert(),
                h.kill()) : !(h instanceof Mn) && h.revert && h.revert(n);
            s._r.forEach(function(d) {
                return d(n, s)
            }),
            s.isReverted = !0
        }() : this.data.forEach(function(a) {
            return a.kill && a.kill()
        }),
        this.clear(),
        i)
            for (var o = Po.length; o--; )
                Po[o].id === this.id && Po.splice(o, 1)
    }
    ,
    e.revert = function(n) {
        this.kill(n || {})
    }
    ,
    r
}()
  , wI = function() {
    function r(t) {
        this.contexts = [],
        this.scope = t,
        sn && sn.data.push(this)
    }
    var e = r.prototype;
    return e.add = function(n, i, s) {
        Or(n) || (n = {
            matches: n
        });
        var o = new nb(0,s || this.scope), a = o.conditions = {}, c, h, d;
        sn && !o.selector && (o.selector = sn.selector),
        this.contexts.push(o),
        i = o.add("onMatch", i),
        o.queries = n;
        for (h in n)
            h === "all" ? d = 1 : (c = Er.matchMedia(n[h]),
            c && (Po.indexOf(o) < 0 && Po.push(o),
            (a[h] = c.matches) && (d = 1),
            c.addListener ? c.addListener(Rm) : c.addEventListener("change", Rm)));
        return d && i(o, function(l) {
            return o.add(null, l)
        }),
        this
    }
    ,
    e.revert = function(n) {
        this.kill(n || {})
    }
    ,
    e.kill = function(n) {
        this.contexts.forEach(function(i) {
            return i.kill(n, !0)
        })
    }
    ,
    r
}()
  , Vh = {
    registerPlugin: function() {
        for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
            t[n] = arguments[n];
        t.forEach(function(i) {
            return HT(i)
        })
    },
    timeline: function(e) {
        return new ui(e)
    },
    getTweensOf: function(e, t) {
        return ln.getTweensOf(e, t)
    },
    getProperty: function(e, t, n, i) {
        Gn(e) && (e = Zi(e)[0]);
        var s = wo(e || {}).get
          , o = n ? PT : AT;
        return n === "native" && (n = ""),
        e && (t ? o((Oi[t] && Oi[t].get || s)(e, t, n, i)) : function(a, c, h) {
            return o((Oi[a] && Oi[a].get || s)(e, a, c, h))
        }
        )
    },
    quickSetter: function(e, t, n) {
        if (e = Zi(e),
        e.length > 1) {
            var i = e.map(function(d) {
                return Mi.quickSetter(d, t, n)
            })
              , s = i.length;
            return function(d) {
                for (var l = s; l--; )
                    i[l](d)
            }
        }
        e = e[0] || {};
        var o = Oi[t]
          , a = wo(e)
          , c = a.harness && (a.harness.aliases || {})[t] || t
          , h = o ? function(d) {
            var l = new o;
            ka._pt = 0,
            l.init(e, n ? d + n : d, ka, 0, [e]),
            l.render(1, l),
            ka._pt && b_(1, ka)
        }
        : a.set(e, c);
        return o ? h : function(d) {
            return h(e, c, n ? d + n : d, a, 1)
        }
    },
    quickTo: function(e, t, n) {
        var i, s = Mi.to(e, Io((i = {},
        i[t] = "+=0.1",
        i.paused = !0,
        i), n || {})), o = function(c, h, d) {
            return s.resetTo(t, c, h, d)
        };
        return o.tween = s,
        o
    },
    isTweening: function(e) {
        return ln.getTweensOf(e, !0).length > 0
    },
    defaults: function(e) {
        return e && e.ease && (e.ease = Ao(e.ease, Ja.ease)),
        e0(Ja, e || {})
    },
    config: function(e) {
        return e0(zi, e || {})
    },
    registerEffect: function(e) {
        var t = e.name
          , n = e.effect
          , i = e.plugins
          , s = e.defaults
          , o = e.extendTimeline;
        (i || "").split(",").forEach(function(a) {
            return a && !Oi[a] && !Vi[a] && Ec(t + " effect requires " + a + " plugin.")
        }),
        np[t] = function(a, c, h) {
            return n(Zi(a), ir(c || {}, s), h)
        }
        ,
        o && (ui.prototype[t] = function(a, c, h) {
            return this.add(np[t](a, Or(c) ? c : (h = c) && {}, this), h)
        }
        )
    },
    registerEase: function(e, t) {
        Tt[e] = Ao(t)
    },
    parseEase: function(e, t) {
        return arguments.length ? Ao(e, t) : Tt
    },
    getById: function(e) {
        return ln.getById(e)
    },
    exportRoot: function(e, t) {
        e === void 0 && (e = {});
        var n = new ui(e), i, s;
        for (n.smoothChildTiming = yi(e.smoothChildTiming),
        ln.remove(n),
        n._dp = 0,
        n._time = n._tTime = ln._time,
        i = ln._first; i; )
            s = i._next,
            (t || !(!i._dur && i instanceof Mn && i.vars.onComplete === i._targets[0])) && Pr(n, i, i._start - i._delay),
            i = s;
        return Pr(ln, n, 0),
        n
    },
    context: function(e, t) {
        return e ? new nb(e,t) : sn
    },
    matchMedia: function(e) {
        return new wI(e)
    },
    matchMediaRefresh: function() {
        return Po.forEach(function(e) {
            var t = e.conditions, n, i;
            for (i in t)
                t[i] && (t[i] = !1,
                n = 1);
            n && e.revert()
        }) || Rm()
    },
    addEventListener: function(e, t) {
        var n = Ih[e] || (Ih[e] = []);
        ~n.indexOf(t) || n.push(t)
    },
    removeEventListener: function(e, t) {
        var n = Ih[e]
          , i = n && n.indexOf(t);
        i >= 0 && n.splice(i, 1)
    },
    utils: {
        wrap: iI,
        wrapYoyo: rI,
        distribute: UT,
        random: FT,
        snap: NT,
        normalize: nI,
        getUnit: ni,
        clamp: JC,
        splitColor: VT,
        toArray: Zi,
        selector: Em,
        mapRange: kT,
        pipe: eI,
        unitize: tI,
        interpolate: sI,
        shuffle: OT
    },
    install: bT,
    effects: np,
    ticker: Ui,
    updateRoot: ui.updateRoot,
    plugins: Oi,
    globalTimeline: ln,
    core: {
        PropTween: Ti,
        globals: ST,
        Tween: Mn,
        Timeline: ui,
        Animation: Cc,
        getCache: wo,
        _removeLinkedListItem: cf,
        reverting: function() {
            return ri
        },
        context: function(e) {
            return e && sn && (sn.data.push(e),
            e._ctx = sn),
            sn
        },
        suppressOverwrites: function(e) {
            return u_ = e
        }
    }
};
xi("to,from,fromTo,delayedCall,set,killTweensOf", function(r) {
    return Vh[r] = Mn[r]
});
Ui.add(ui.updateRoot);
ka = Vh.to({}, {
    duration: 0
});
var EI = function(e, t) {
    for (var n = e._pt; n && n.p !== t && n.op !== t && n.fp !== t; )
        n = n._next;
    return n
}
  , AI = function(e, t) {
    var n = e._targets, i, s, o;
    for (i in t)
        for (s = n.length; s--; )
            o = e._ptLookup[s][i],
            o && (o = o.d) && (o._pt && (o = EI(o, i)),
            o && o.modifier && o.modifier(t[i], e, n[s], i))
}
  , ap = function(e, t) {
    return {
        name: e,
        rawVars: 1,
        init: function(i, s, o) {
            o._onInit = function(a) {
                var c, h;
                if (Gn(s) && (c = {},
                xi(s, function(d) {
                    return c[d] = 1
                }),
                s = c),
                t) {
                    c = {};
                    for (h in s)
                        c[h] = t(s[h]);
                    s = c
                }
                AI(a, s)
            }
        }
    }
}
  , Mi = Vh.registerPlugin({
    name: "attr",
    init: function(e, t, n, i, s) {
        var o, a, c;
        this.tween = n;
        for (o in t)
            c = e.getAttribute(o) || "",
            a = this.add(e, "setAttribute", (c || 0) + "", t[o], i, s, 0, 0, o),
            a.op = o,
            a.b = c,
            this._props.push(o)
    },
    render: function(e, t) {
        for (var n = t._pt; n; )
            ri ? n.set(n.t, n.p, n.b, n) : n.r(e, n.d),
            n = n._next
    }
}, {
    name: "endArray",
    init: function(e, t) {
        for (var n = t.length; n--; )
            this.add(e, n, e[n] || 0, t[n], 0, 0, 0, 0, 0, 1)
    }
}, ap("roundProps", Am), ap("modifiers"), ap("snap", NT)) || Vh;
Mn.version = ui.version = Mi.version = "3.12.5";
TT = 1;
f_() && tl();
Tt.Power0;
Tt.Power1;
Tt.Power2;
Tt.Power3;
Tt.Power4;
Tt.Linear;
Tt.Quad;
Tt.Cubic;
Tt.Quart;
Tt.Quint;
Tt.Strong;
Tt.Elastic;
Tt.Back;
Tt.SteppedEase;
Tt.Bounce;
Tt.Sine;
Tt.Expo;
Tt.Circ;
/*!
 * CSSPlugin 3.12.5
 * https://gsap.com
 *
 * Copyright 2008-2024, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license or for
 * Club GSAP members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/
var o0, Is, ja, S_, Mo, a0, M_, PI = function() {
    return typeof window < "u"
}, os = {}, xo = 180 / Math.PI, Xa = Math.PI / 180, na = Math.atan2, l0 = 1e8, w_ = /([A-Z])/g, RI = /(left|right|width|margin|padding|x)/i, CI = /[\s,\(]\S/, Cr = {
    autoAlpha: "opacity,visibility",
    scale: "scaleX,scaleY",
    alpha: "opacity"
}, Cm = function(e, t) {
    return t.set(t.t, t.p, Math.round((t.s + t.c * e) * 1e4) / 1e4 + t.u, t)
}, II = function(e, t) {
    return t.set(t.t, t.p, e === 1 ? t.e : Math.round((t.s + t.c * e) * 1e4) / 1e4 + t.u, t)
}, LI = function(e, t) {
    return t.set(t.t, t.p, e ? Math.round((t.s + t.c * e) * 1e4) / 1e4 + t.u : t.b, t)
}, DI = function(e, t) {
    var n = t.s + t.c * e;
    t.set(t.t, t.p, ~~(n + (n < 0 ? -.5 : .5)) + t.u, t)
}, ib = function(e, t) {
    return t.set(t.t, t.p, e ? t.e : t.b, t)
}, rb = function(e, t) {
    return t.set(t.t, t.p, e !== 1 ? t.b : t.e, t)
}, OI = function(e, t, n) {
    return e.style[t] = n
}, UI = function(e, t, n) {
    return e.style.setProperty(t, n)
}, NI = function(e, t, n) {
    return e._gsap[t] = n
}, FI = function(e, t, n) {
    return e._gsap.scaleX = e._gsap.scaleY = n
}, BI = function(e, t, n, i, s) {
    var o = e._gsap;
    o.scaleX = o.scaleY = n,
    o.renderTransform(s, o)
}, kI = function(e, t, n, i, s) {
    var o = e._gsap;
    o[t] = n,
    o.renderTransform(s, o)
}, cn = "transform", bi = cn + "Origin", zI = function r(e, t) {
    var n = this
      , i = this.target
      , s = i.style
      , o = i._gsap;
    if (e in os && s) {
        if (this.tfm = this.tfm || {},
        e !== "transform")
            e = Cr[e] || e,
            ~e.indexOf(",") ? e.split(",").forEach(function(a) {
                return n.tfm[a] = ts(i, a)
            }) : this.tfm[e] = o.x ? o[e] : ts(i, e),
            e === bi && (this.tfm.zOrigin = o.zOrigin);
        else
            return Cr.transform.split(",").forEach(function(a) {
                return r.call(n, a, t)
            });
        if (this.props.indexOf(cn) >= 0)
            return;
        o.svg && (this.svgo = i.getAttribute("data-svg-origin"),
        this.props.push(bi, t, "")),
        e = cn
    }
    (s || t) && this.props.push(e, t, s[e])
}, sb = function(e) {
    e.translate && (e.removeProperty("translate"),
    e.removeProperty("scale"),
    e.removeProperty("rotate"))
}, HI = function() {
    var e = this.props, t = this.target, n = t.style, i = t._gsap, s, o;
    for (s = 0; s < e.length; s += 3)
        e[s + 1] ? t[e[s]] = e[s + 2] : e[s + 2] ? n[e[s]] = e[s + 2] : n.removeProperty(e[s].substr(0, 2) === "--" ? e[s] : e[s].replace(w_, "-$1").toLowerCase());
    if (this.tfm) {
        for (o in this.tfm)
            i[o] = this.tfm[o];
        i.svg && (i.renderTransform(),
        t.setAttribute("data-svg-origin", this.svgo || "")),
        s = M_(),
        (!s || !s.isStart) && !n[cn] && (sb(n),
        i.zOrigin && n[bi] && (n[bi] += " " + i.zOrigin + "px",
        i.zOrigin = 0,
        i.renderTransform()),
        i.uncache = 1)
    }
}, ob = function(e, t) {
    var n = {
        target: e,
        props: [],
        revert: HI,
        save: zI
    };
    return e._gsap || Mi.core.getCache(e),
    t && t.split(",").forEach(function(i) {
        return n.save(i)
    }),
    n
}, ab, Im = function(e, t) {
    var n = Is.createElementNS ? Is.createElementNS((t || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), e) : Is.createElement(e);
    return n && n.style ? n : Is.createElement(e)
}, Lr = function r(e, t, n) {
    var i = getComputedStyle(e);
    return i[t] || i.getPropertyValue(t.replace(w_, "-$1").toLowerCase()) || i.getPropertyValue(t) || !n && r(e, nl(t) || t, 1) || ""
}, c0 = "O,Moz,ms,Ms,Webkit".split(","), nl = function(e, t, n) {
    var i = t || Mo
      , s = i.style
      , o = 5;
    if (e in s && !n)
        return e;
    for (e = e.charAt(0).toUpperCase() + e.substr(1); o-- && !(c0[o] + e in s); )
        ;
    return o < 0 ? null : (o === 3 ? "ms" : o >= 0 ? c0[o] : "") + e
}, Lm = function() {
    PI() && window.document && (o0 = window,
    Is = o0.document,
    ja = Is.documentElement,
    Mo = Im("div") || {
        style: {}
    },
    Im("div"),
    cn = nl(cn),
    bi = cn + "Origin",
    Mo.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0",
    ab = !!nl("perspective"),
    M_ = Mi.core.reverting,
    S_ = 1)
}, lp = function r(e) {
    var t = Im("svg", this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns") || "http://www.w3.org/2000/svg"), n = this.parentNode, i = this.nextSibling, s = this.style.cssText, o;
    if (ja.appendChild(t),
    t.appendChild(this),
    this.style.display = "block",
    e)
        try {
            o = this.getBBox(),
            this._gsapBBox = this.getBBox,
            this.getBBox = r
        } catch {}
    else
        this._gsapBBox && (o = this._gsapBBox());
    return n && (i ? n.insertBefore(this, i) : n.appendChild(this)),
    ja.removeChild(t),
    this.style.cssText = s,
    o
}, u0 = function(e, t) {
    for (var n = t.length; n--; )
        if (e.hasAttribute(t[n]))
            return e.getAttribute(t[n])
}, lb = function(e) {
    var t;
    try {
        t = e.getBBox()
    } catch {
        t = lp.call(e, !0)
    }
    return t && (t.width || t.height) || e.getBBox === lp || (t = lp.call(e, !0)),
    t && !t.width && !t.x && !t.y ? {
        x: +u0(e, ["x", "cx", "x1"]) || 0,
        y: +u0(e, ["y", "cy", "y1"]) || 0,
        width: 0,
        height: 0
    } : t
}, cb = function(e) {
    return !!(e.getCTM && (!e.parentNode || e.ownerSVGElement) && lb(e))
}, Lo = function(e, t) {
    if (t) {
        var n = e.style, i;
        t in os && t !== bi && (t = cn),
        n.removeProperty ? (i = t.substr(0, 2),
        (i === "ms" || t.substr(0, 6) === "webkit") && (t = "-" + t),
        n.removeProperty(i === "--" ? t : t.replace(w_, "-$1").toLowerCase())) : n.removeAttribute(t)
    }
}, Ls = function(e, t, n, i, s, o) {
    var a = new Ti(e._pt,t,n,0,1,o ? rb : ib);
    return e._pt = a,
    a.b = i,
    a.e = s,
    e._props.push(n),
    a
}, h0 = {
    deg: 1,
    rad: 1,
    turn: 1
}, VI = {
    grid: 1,
    flex: 1
}, ks = function r(e, t, n, i) {
    var s = parseFloat(n) || 0, o = (n + "").trim().substr((s + "").length) || "px", a = Mo.style, c = RI.test(t), h = e.tagName.toLowerCase() === "svg", d = (h ? "client" : "offset") + (c ? "Width" : "Height"), l = 100, f = i === "px", p = i === "%", g, y, v, _;
    if (i === o || !s || h0[i] || h0[o])
        return s;
    if (o !== "px" && !f && (s = r(e, t, n, "px")),
    _ = e.getCTM && cb(e),
    (p || o === "%") && (os[t] || ~t.indexOf("adius")))
        return g = _ ? e.getBBox()[c ? "width" : "height"] : e[d],
        _n(p ? s / g * l : s / 100 * g);
    if (a[c ? "width" : "height"] = l + (f ? o : i),
    y = ~t.indexOf("adius") || i === "em" && e.appendChild && !h ? e : e.parentNode,
    _ && (y = (e.ownerSVGElement || {}).parentNode),
    (!y || y === Is || !y.appendChild) && (y = Is.body),
    v = y._gsap,
    v && p && v.width && c && v.time === Ui.time && !v.uncache)
        return _n(s / v.width * l);
    if (p && (t === "height" || t === "width")) {
        var b = e.style[t];
        e.style[t] = l + i,
        g = e[d],
        b ? e.style[t] = b : Lo(e, t)
    } else
        (p || o === "%") && !VI[Lr(y, "display")] && (a.position = Lr(e, "position")),
        y === e && (a.position = "static"),
        y.appendChild(Mo),
        g = Mo[d],
        y.removeChild(Mo),
        a.position = "absolute";
    return c && p && (v = wo(y),
    v.time = Ui.time,
    v.width = y[d]),
    _n(f ? g * s / l : g && s ? l / g * s : 0)
}, ts = function(e, t, n, i) {
    var s;
    return S_ || Lm(),
    t in Cr && t !== "transform" && (t = Cr[t],
    ~t.indexOf(",") && (t = t.split(",")[0])),
    os[t] && t !== "transform" ? (s = Lc(e, i),
    s = t !== "transformOrigin" ? s[t] : s.svg ? s.origin : Wh(Lr(e, bi)) + " " + s.zOrigin + "px") : (s = e.style[t],
    (!s || s === "auto" || i || ~(s + "").indexOf("calc(")) && (s = Gh[t] && Gh[t](e, t, n) || Lr(e, t) || wT(e, t) || (t === "opacity" ? 1 : 0))),
    n && !~(s + "").trim().indexOf(" ") ? ks(e, t, s, n) + n : s
}, GI = function(e, t, n, i) {
    if (!n || n === "none") {
        var s = nl(t, e, 1)
          , o = s && Lr(e, s, 1);
        o && o !== n ? (t = s,
        n = o) : t === "borderColor" && (n = Lr(e, "borderTopColor"))
    }
    var a = new Ti(this._pt,e.style,t,0,1,eb), c = 0, h = 0, d, l, f, p, g, y, v, _, b, T, S, E;
    if (a.b = n,
    a.e = i,
    n += "",
    i += "",
    i === "auto" && (y = e.style[t],
    e.style[t] = i,
    i = Lr(e, t) || i,
    y ? e.style[t] = y : Lo(e, t)),
    d = [n, i],
    WT(d),
    n = d[0],
    i = d[1],
    f = n.match(Ba) || [],
    E = i.match(Ba) || [],
    E.length) {
        for (; l = Ba.exec(i); )
            v = l[0],
            b = i.substring(c, l.index),
            g ? g = (g + 1) % 5 : (b.substr(-5) === "rgba(" || b.substr(-5) === "hsla(") && (g = 1),
            v !== (y = f[h++] || "") && (p = parseFloat(y) || 0,
            S = y.substr((p + "").length),
            v.charAt(1) === "=" && (v = Wa(p, v) + S),
            _ = parseFloat(v),
            T = v.substr((_ + "").length),
            c = Ba.lastIndex - T.length,
            T || (T = T || zi.units[t] || S,
            c === i.length && (i += T,
            a.e += T)),
            S !== T && (p = ks(e, t, y, T) || 0),
            a._pt = {
                _next: a._pt,
                p: b || h === 1 ? b : ",",
                s: p,
                c: _ - p,
                m: g && g < 4 || t === "zIndex" ? Math.round : 0
            });
        a.c = c < i.length ? i.substring(c, i.length) : ""
    } else
        a.r = t === "display" && i === "none" ? rb : ib;
    return yT.test(i) && (a.e = 0),
    this._pt = a,
    a
}, f0 = {
    top: "0%",
    bottom: "100%",
    left: "0%",
    right: "100%",
    center: "50%"
}, WI = function(e) {
    var t = e.split(" ")
      , n = t[0]
      , i = t[1] || "50%";
    return (n === "top" || n === "bottom" || i === "left" || i === "right") && (e = n,
    n = i,
    i = e),
    t[0] = f0[n] || n,
    t[1] = f0[i] || i,
    t.join(" ")
}, jI = function(e, t) {
    if (t.tween && t.tween._time === t.tween._dur) {
        var n = t.t, i = n.style, s = t.u, o = n._gsap, a, c, h;
        if (s === "all" || s === !0)
            i.cssText = "",
            c = 1;
        else
            for (s = s.split(","),
            h = s.length; --h > -1; )
                a = s[h],
                os[a] && (c = 1,
                a = a === "transformOrigin" ? bi : cn),
                Lo(n, a);
        c && (Lo(n, cn),
        o && (o.svg && n.removeAttribute("transform"),
        Lc(n, 1),
        o.uncache = 1,
        sb(i)))
    }
}, Gh = {
    clearProps: function(e, t, n, i, s) {
        if (s.data !== "isFromStart") {
            var o = e._pt = new Ti(e._pt,t,n,0,0,jI);
            return o.u = i,
            o.pr = -10,
            o.tween = s,
            e._props.push(n),
            1
        }
    }
}, Ic = [1, 0, 0, 1, 0, 0], ub = {}, hb = function(e) {
    return e === "matrix(1, 0, 0, 1, 0, 0)" || e === "none" || !e
}, d0 = function(e) {
    var t = Lr(e, cn);
    return hb(t) ? Ic : t.substr(7).match(vT).map(_n)
}, E_ = function(e, t) {
    var n = e._gsap || wo(e), i = e.style, s = d0(e), o, a, c, h;
    return n.svg && e.getAttribute("transform") ? (c = e.transform.baseVal.consolidate().matrix,
    s = [c.a, c.b, c.c, c.d, c.e, c.f],
    s.join(",") === "1,0,0,1,0,0" ? Ic : s) : (s === Ic && !e.offsetParent && e !== ja && !n.svg && (c = i.display,
    i.display = "block",
    o = e.parentNode,
    (!o || !e.offsetParent) && (h = 1,
    a = e.nextElementSibling,
    ja.appendChild(e)),
    s = d0(e),
    c ? i.display = c : Lo(e, "display"),
    h && (a ? o.insertBefore(e, a) : o ? o.appendChild(e) : ja.removeChild(e))),
    t && s.length > 6 ? [s[0], s[1], s[4], s[5], s[12], s[13]] : s)
}, Dm = function(e, t, n, i, s, o) {
    var a = e._gsap, c = s || E_(e, !0), h = a.xOrigin || 0, d = a.yOrigin || 0, l = a.xOffset || 0, f = a.yOffset || 0, p = c[0], g = c[1], y = c[2], v = c[3], _ = c[4], b = c[5], T = t.split(" "), S = parseFloat(T[0]) || 0, E = parseFloat(T[1]) || 0, P, R, O, w;
    n ? c !== Ic && (R = p * v - g * y) && (O = S * (v / R) + E * (-y / R) + (y * b - v * _) / R,
    w = S * (-g / R) + E * (p / R) - (p * b - g * _) / R,
    S = O,
    E = w) : (P = lb(e),
    S = P.x + (~T[0].indexOf("%") ? S / 100 * P.width : S),
    E = P.y + (~(T[1] || T[0]).indexOf("%") ? E / 100 * P.height : E)),
    i || i !== !1 && a.smooth ? (_ = S - h,
    b = E - d,
    a.xOffset = l + (_ * p + b * y) - _,
    a.yOffset = f + (_ * g + b * v) - b) : a.xOffset = a.yOffset = 0,
    a.xOrigin = S,
    a.yOrigin = E,
    a.smooth = !!i,
    a.origin = t,
    a.originIsAbsolute = !!n,
    e.style[bi] = "0px 0px",
    o && (Ls(o, a, "xOrigin", h, S),
    Ls(o, a, "yOrigin", d, E),
    Ls(o, a, "xOffset", l, a.xOffset),
    Ls(o, a, "yOffset", f, a.yOffset)),
    e.setAttribute("data-svg-origin", S + " " + E)
}, Lc = function(e, t) {
    var n = e._gsap || new KT(e);
    if ("x"in n && !t && !n.uncache)
        return n;
    var i = e.style, s = n.scaleX < 0, o = "px", a = "deg", c = getComputedStyle(e), h = Lr(e, bi) || "0", d, l, f, p, g, y, v, _, b, T, S, E, P, R, O, w, I, V, z, q, F, j, K, J, de, ae, ue, ge, Ee, oe, he, xe;
    return d = l = f = y = v = _ = b = T = S = 0,
    p = g = 1,
    n.svg = !!(e.getCTM && cb(e)),
    c.translate && ((c.translate !== "none" || c.scale !== "none" || c.rotate !== "none") && (i[cn] = (c.translate !== "none" ? "translate3d(" + (c.translate + " 0 0").split(" ").slice(0, 3).join(", ") + ") " : "") + (c.rotate !== "none" ? "rotate(" + c.rotate + ") " : "") + (c.scale !== "none" ? "scale(" + c.scale.split(" ").join(",") + ") " : "") + (c[cn] !== "none" ? c[cn] : "")),
    i.scale = i.rotate = i.translate = "none"),
    R = E_(e, n.svg),
    n.svg && (n.uncache ? (de = e.getBBox(),
    h = n.xOrigin - de.x + "px " + (n.yOrigin - de.y) + "px",
    J = "") : J = !t && e.getAttribute("data-svg-origin"),
    Dm(e, J || h, !!J || n.originIsAbsolute, n.smooth !== !1, R)),
    E = n.xOrigin || 0,
    P = n.yOrigin || 0,
    R !== Ic && (V = R[0],
    z = R[1],
    q = R[2],
    F = R[3],
    d = j = R[4],
    l = K = R[5],
    R.length === 6 ? (p = Math.sqrt(V * V + z * z),
    g = Math.sqrt(F * F + q * q),
    y = V || z ? na(z, V) * xo : 0,
    b = q || F ? na(q, F) * xo + y : 0,
    b && (g *= Math.abs(Math.cos(b * Xa))),
    n.svg && (d -= E - (E * V + P * q),
    l -= P - (E * z + P * F))) : (xe = R[6],
    oe = R[7],
    ue = R[8],
    ge = R[9],
    Ee = R[10],
    he = R[11],
    d = R[12],
    l = R[13],
    f = R[14],
    O = na(xe, Ee),
    v = O * xo,
    O && (w = Math.cos(-O),
    I = Math.sin(-O),
    J = j * w + ue * I,
    de = K * w + ge * I,
    ae = xe * w + Ee * I,
    ue = j * -I + ue * w,
    ge = K * -I + ge * w,
    Ee = xe * -I + Ee * w,
    he = oe * -I + he * w,
    j = J,
    K = de,
    xe = ae),
    O = na(-q, Ee),
    _ = O * xo,
    O && (w = Math.cos(-O),
    I = Math.sin(-O),
    J = V * w - ue * I,
    de = z * w - ge * I,
    ae = q * w - Ee * I,
    he = F * I + he * w,
    V = J,
    z = de,
    q = ae),
    O = na(z, V),
    y = O * xo,
    O && (w = Math.cos(O),
    I = Math.sin(O),
    J = V * w + z * I,
    de = j * w + K * I,
    z = z * w - V * I,
    K = K * w - j * I,
    V = J,
    j = de),
    v && Math.abs(v) + Math.abs(y) > 359.9 && (v = y = 0,
    _ = 180 - _),
    p = _n(Math.sqrt(V * V + z * z + q * q)),
    g = _n(Math.sqrt(K * K + xe * xe)),
    O = na(j, K),
    b = Math.abs(O) > 2e-4 ? O * xo : 0,
    S = he ? 1 / (he < 0 ? -he : he) : 0),
    n.svg && (J = e.getAttribute("transform"),
    n.forceCSS = e.setAttribute("transform", "") || !hb(Lr(e, cn)),
    J && e.setAttribute("transform", J))),
    Math.abs(b) > 90 && Math.abs(b) < 270 && (s ? (p *= -1,
    b += y <= 0 ? 180 : -180,
    y += y <= 0 ? 180 : -180) : (g *= -1,
    b += b <= 0 ? 180 : -180)),
    t = t || n.uncache,
    n.x = d - ((n.xPercent = d && (!t && n.xPercent || (Math.round(e.offsetWidth / 2) === Math.round(-d) ? -50 : 0))) ? e.offsetWidth * n.xPercent / 100 : 0) + o,
    n.y = l - ((n.yPercent = l && (!t && n.yPercent || (Math.round(e.offsetHeight / 2) === Math.round(-l) ? -50 : 0))) ? e.offsetHeight * n.yPercent / 100 : 0) + o,
    n.z = f + o,
    n.scaleX = _n(p),
    n.scaleY = _n(g),
    n.rotation = _n(y) + a,
    n.rotationX = _n(v) + a,
    n.rotationY = _n(_) + a,
    n.skewX = b + a,
    n.skewY = T + a,
    n.transformPerspective = S + o,
    (n.zOrigin = parseFloat(h.split(" ")[2]) || !t && n.zOrigin || 0) && (i[bi] = Wh(h)),
    n.xOffset = n.yOffset = 0,
    n.force3D = zi.force3D,
    n.renderTransform = n.svg ? qI : ab ? fb : XI,
    n.uncache = 0,
    n
}, Wh = function(e) {
    return (e = e.split(" "))[0] + " " + e[1]
}, cp = function(e, t, n) {
    var i = ni(t);
    return _n(parseFloat(t) + parseFloat(ks(e, "x", n + "px", i))) + i
}, XI = function(e, t) {
    t.z = "0px",
    t.rotationY = t.rotationX = "0deg",
    t.force3D = 0,
    fb(e, t)
}, fo = "0deg", ql = "0px", po = ") ", fb = function(e, t) {
    var n = t || this
      , i = n.xPercent
      , s = n.yPercent
      , o = n.x
      , a = n.y
      , c = n.z
      , h = n.rotation
      , d = n.rotationY
      , l = n.rotationX
      , f = n.skewX
      , p = n.skewY
      , g = n.scaleX
      , y = n.scaleY
      , v = n.transformPerspective
      , _ = n.force3D
      , b = n.target
      , T = n.zOrigin
      , S = ""
      , E = _ === "auto" && e && e !== 1 || _ === !0;
    if (T && (l !== fo || d !== fo)) {
        var P = parseFloat(d) * Xa, R = Math.sin(P), O = Math.cos(P), w;
        P = parseFloat(l) * Xa,
        w = Math.cos(P),
        o = cp(b, o, R * w * -T),
        a = cp(b, a, -Math.sin(P) * -T),
        c = cp(b, c, O * w * -T + T)
    }
    v !== ql && (S += "perspective(" + v + po),
    (i || s) && (S += "translate(" + i + "%, " + s + "%) "),
    (E || o !== ql || a !== ql || c !== ql) && (S += c !== ql || E ? "translate3d(" + o + ", " + a + ", " + c + ") " : "translate(" + o + ", " + a + po),
    h !== fo && (S += "rotate(" + h + po),
    d !== fo && (S += "rotateY(" + d + po),
    l !== fo && (S += "rotateX(" + l + po),
    (f !== fo || p !== fo) && (S += "skew(" + f + ", " + p + po),
    (g !== 1 || y !== 1) && (S += "scale(" + g + ", " + y + po),
    b.style[cn] = S || "translate(0, 0)"
}, qI = function(e, t) {
    var n = t || this, i = n.xPercent, s = n.yPercent, o = n.x, a = n.y, c = n.rotation, h = n.skewX, d = n.skewY, l = n.scaleX, f = n.scaleY, p = n.target, g = n.xOrigin, y = n.yOrigin, v = n.xOffset, _ = n.yOffset, b = n.forceCSS, T = parseFloat(o), S = parseFloat(a), E, P, R, O, w;
    c = parseFloat(c),
    h = parseFloat(h),
    d = parseFloat(d),
    d && (d = parseFloat(d),
    h += d,
    c += d),
    c || h ? (c *= Xa,
    h *= Xa,
    E = Math.cos(c) * l,
    P = Math.sin(c) * l,
    R = Math.sin(c - h) * -f,
    O = Math.cos(c - h) * f,
    h && (d *= Xa,
    w = Math.tan(h - d),
    w = Math.sqrt(1 + w * w),
    R *= w,
    O *= w,
    d && (w = Math.tan(d),
    w = Math.sqrt(1 + w * w),
    E *= w,
    P *= w)),
    E = _n(E),
    P = _n(P),
    R = _n(R),
    O = _n(O)) : (E = l,
    O = f,
    P = R = 0),
    (T && !~(o + "").indexOf("px") || S && !~(a + "").indexOf("px")) && (T = ks(p, "x", o, "px"),
    S = ks(p, "y", a, "px")),
    (g || y || v || _) && (T = _n(T + g - (g * E + y * R) + v),
    S = _n(S + y - (g * P + y * O) + _)),
    (i || s) && (w = p.getBBox(),
    T = _n(T + i / 100 * w.width),
    S = _n(S + s / 100 * w.height)),
    w = "matrix(" + E + "," + P + "," + R + "," + O + "," + T + "," + S + ")",
    p.setAttribute("transform", w),
    b && (p.style[cn] = w)
}, KI = function(e, t, n, i, s) {
    var o = 360, a = Gn(s), c = parseFloat(s) * (a && ~s.indexOf("rad") ? xo : 1), h = c - i, d = i + h + "deg", l, f;
    return a && (l = s.split("_")[1],
    l === "short" && (h %= o,
    h !== h % (o / 2) && (h += h < 0 ? o : -o)),
    l === "cw" && h < 0 ? h = (h + o * l0) % o - ~~(h / o) * o : l === "ccw" && h > 0 && (h = (h - o * l0) % o - ~~(h / o) * o)),
    e._pt = f = new Ti(e._pt,t,n,i,h,II),
    f.e = d,
    f.u = "deg",
    e._props.push(n),
    f
}, p0 = function(e, t) {
    for (var n in t)
        e[n] = t[n];
    return e
}, YI = function(e, t, n) {
    var i = p0({}, n._gsap), s = "perspective,force3D,transformOrigin,svgOrigin", o = n.style, a, c, h, d, l, f, p, g;
    i.svg ? (h = n.getAttribute("transform"),
    n.setAttribute("transform", ""),
    o[cn] = t,
    a = Lc(n, 1),
    Lo(n, cn),
    n.setAttribute("transform", h)) : (h = getComputedStyle(n)[cn],
    o[cn] = t,
    a = Lc(n, 1),
    o[cn] = h);
    for (c in os)
        h = i[c],
        d = a[c],
        h !== d && s.indexOf(c) < 0 && (p = ni(h),
        g = ni(d),
        l = p !== g ? ks(n, c, h, g) : parseFloat(h),
        f = parseFloat(d),
        e._pt = new Ti(e._pt,a,c,l,f - l,Cm),
        e._pt.u = g || 0,
        e._props.push(c));
    p0(a, i)
};
xi("padding,margin,Width,Radius", function(r, e) {
    var t = "Top"
      , n = "Right"
      , i = "Bottom"
      , s = "Left"
      , o = (e < 3 ? [t, n, i, s] : [t + s, t + n, i + n, i + s]).map(function(a) {
        return e < 2 ? r + a : "border" + a + r
    });
    Gh[e > 1 ? "border" + r : r] = function(a, c, h, d, l) {
        var f, p;
        if (arguments.length < 4)
            return f = o.map(function(g) {
                return ts(a, g, h)
            }),
            p = f.join(" "),
            p.split(f[0]).length === 5 ? f[0] : p;
        f = (d + "").split(" "),
        p = {},
        o.forEach(function(g, y) {
            return p[g] = f[y] = f[y] || f[(y - 1) / 2 | 0]
        }),
        a.init(c, p, l)
    }
});
var db = {
    name: "css",
    register: Lm,
    targetTest: function(e) {
        return e.style && e.nodeType
    },
    init: function(e, t, n, i, s) {
        var o = this._props, a = e.style, c = n.vars.startAt, h, d, l, f, p, g, y, v, _, b, T, S, E, P, R, O;
        S_ || Lm(),
        this.styles = this.styles || ob(e),
        O = this.styles.props,
        this.tween = n;
        for (y in t)
            if (y !== "autoRound" && (d = t[y],
            !(Oi[y] && YT(y, t, n, i, e, s)))) {
                if (p = typeof d,
                g = Gh[y],
                p === "function" && (d = d.call(n, i, e, s),
                p = typeof d),
                p === "string" && ~d.indexOf("random(") && (d = Pc(d)),
                g)
                    g(this, e, y, d, n) && (R = 1);
                else if (y.substr(0, 2) === "--")
                    h = (getComputedStyle(e).getPropertyValue(y) + "").trim(),
                    d += "",
                    Us.lastIndex = 0,
                    Us.test(h) || (v = ni(h),
                    _ = ni(d)),
                    _ ? v !== _ && (h = ks(e, y, h, _) + _) : v && (d += v),
                    this.add(a, "setProperty", h, d, i, s, 0, 0, y),
                    o.push(y),
                    O.push(y, 0, a[y]);
                else if (p !== "undefined") {
                    if (c && y in c ? (h = typeof c[y] == "function" ? c[y].call(n, i, e, s) : c[y],
                    Gn(h) && ~h.indexOf("random(") && (h = Pc(h)),
                    ni(h + "") || h === "auto" || (h += zi.units[y] || ni(ts(e, y)) || ""),
                    (h + "").charAt(1) === "=" && (h = ts(e, y))) : h = ts(e, y),
                    f = parseFloat(h),
                    b = p === "string" && d.charAt(1) === "=" && d.substr(0, 2),
                    b && (d = d.substr(2)),
                    l = parseFloat(d),
                    y in Cr && (y === "autoAlpha" && (f === 1 && ts(e, "visibility") === "hidden" && l && (f = 0),
                    O.push("visibility", 0, a.visibility),
                    Ls(this, a, "visibility", f ? "inherit" : "hidden", l ? "inherit" : "hidden", !l)),
                    y !== "scale" && y !== "transform" && (y = Cr[y],
                    ~y.indexOf(",") && (y = y.split(",")[0]))),
                    T = y in os,
                    T) {
                        if (this.styles.save(y),
                        S || (E = e._gsap,
                        E.renderTransform && !t.parseTransform || Lc(e, t.parseTransform),
                        P = t.smoothOrigin !== !1 && E.smooth,
                        S = this._pt = new Ti(this._pt,a,cn,0,1,E.renderTransform,E,0,-1),
                        S.dep = 1),
                        y === "scale")
                            this._pt = new Ti(this._pt,E,"scaleY",E.scaleY,(b ? Wa(E.scaleY, b + l) : l) - E.scaleY || 0,Cm),
                            this._pt.u = 0,
                            o.push("scaleY", y),
                            y += "X";
                        else if (y === "transformOrigin") {
                            O.push(bi, 0, a[bi]),
                            d = WI(d),
                            E.svg ? Dm(e, d, 0, P, 0, this) : (_ = parseFloat(d.split(" ")[2]) || 0,
                            _ !== E.zOrigin && Ls(this, E, "zOrigin", E.zOrigin, _),
                            Ls(this, a, y, Wh(h), Wh(d)));
                            continue
                        } else if (y === "svgOrigin") {
                            Dm(e, d, 1, P, 0, this);
                            continue
                        } else if (y in ub) {
                            KI(this, E, y, f, b ? Wa(f, b + d) : d);
                            continue
                        } else if (y === "smoothOrigin") {
                            Ls(this, E, "smooth", E.smooth, d);
                            continue
                        } else if (y === "force3D") {
                            E[y] = d;
                            continue
                        } else if (y === "transform") {
                            YI(this, d, e);
                            continue
                        }
                    } else
                        y in a || (y = nl(y) || y);
                    if (T || (l || l === 0) && (f || f === 0) && !CI.test(d) && y in a)
                        v = (h + "").substr((f + "").length),
                        l || (l = 0),
                        _ = ni(d) || (y in zi.units ? zi.units[y] : v),
                        v !== _ && (f = ks(e, y, h, _)),
                        this._pt = new Ti(this._pt,T ? E : a,y,f,(b ? Wa(f, b + l) : l) - f,!T && (_ === "px" || y === "zIndex") && t.autoRound !== !1 ? DI : Cm),
                        this._pt.u = _ || 0,
                        v !== _ && _ !== "%" && (this._pt.b = h,
                        this._pt.r = LI);
                    else if (y in a)
                        GI.call(this, e, y, h, b ? b + d : d);
                    else if (y in e)
                        this.add(e, y, h || e[y], b ? b + d : d, i, s);
                    else if (y !== "parseTransform") {
                        p_(y, d);
                        continue
                    }
                    T || (y in a ? O.push(y, 0, a[y]) : O.push(y, 1, h || e[y])),
                    o.push(y)
                }
            }
        R && tb(this)
    },
    render: function(e, t) {
        if (t.tween._time || !M_())
            for (var n = t._pt; n; )
                n.r(e, n.d),
                n = n._next;
        else
            t.styles.revert()
    },
    get: ts,
    aliases: Cr,
    getSetter: function(e, t, n) {
        var i = Cr[t];
        return i && i.indexOf(",") < 0 && (t = i),
        t in os && t !== bi && (e._gsap.x || ts(e, "x")) ? n && a0 === n ? t === "scale" ? FI : NI : (a0 = n || {}) && (t === "scale" ? BI : kI) : e.style && !h_(e.style[t]) ? OI : ~t.indexOf("-") ? UI : T_(e, t)
    },
    core: {
        _removeProperty: Lo,
        _getMatrix: E_
    }
};
Mi.utils.checkPrefix = nl;
Mi.core.getStyleSaver = ob;
(function(r, e, t, n) {
    var i = xi(r + "," + e + "," + t, function(s) {
        os[s] = 1
    });
    xi(e, function(s) {
        zi.units[s] = "deg",
        ub[s] = 1
    }),
    Cr[i[13]] = r + "," + e,
    xi(n, function(s) {
        var o = s.split(":");
        Cr[o[1]] = i[o[0]]
    })
}
)("x,y,z,scale,scaleX,scaleY,xPercent,yPercent", "rotation,rotationX,rotationY,skewX,skewY", "transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", "0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY");
xi("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective", function(r) {
    zi.units[r] = "px"
});
Mi.registerPlugin(db);
var Qt = Mi.registerPlugin(db) || Mi;
Qt.core.Tween;
class $I {
    constructor() {
        this.events = {}
    }
    emit(e, ...t) {
        const n = this.events[e] || [];
        for (let i = 0, {length: s} = n; i < s; i++)
            n[i].cb(...t)
    }
    on(e, t, n=0) {
        const i = {
            cb: t,
            priority: n
        };
        return this.events[e]?.push(i) || (this.events[e] = [i]),
        this.events[e].sort((s,o)=>s.priority - o.priority),
        ()=>{
            this.events[e] = this.events[e]?.filter(s=>t !== s.cb)
        }
    }
    off(e, t) {
        this.events[e] = this.events[e]?.filter(({cb: n})=>t !== n)
    }
    once(e, t, n=0) {
        const i = (...s)=>{
            t(...s),
            this.off(e, i)
        }
        ;
        return this.on(e, i, n),
        ()=>{
            this.off(e, t)
        }
    }
    destroy() {
        this.events = {}
    }
}
const yt = new $I
  , xt = {
    MOUSE_MOVE: "MOUSE:MOVE",
    RESIZE: "APP:RESIZE",
    TICK: "TICK",
    ROAR: "WEBGL:ROAR",
    RENDER_REFLECTOR: "WEBGL:RENDER_REFLECTOR",
    TIMESCALE_CHANGE: "APP:TIMESCALE_CHANGE",
    LOADED: "APP:LOADED",
    INTRO_ENTERING: "APP:INTRO:ENTERING",
    INTRO_ENTERED: "APP:INTRO:ENTERED",
    KONAMI: "APP:KONAMI"
};
yt.on(xt.LOADED, ()=>{
    const r = document.querySelector("#canvas");
    yt.emit(xt.INTRO_ENTERING),
    Qt.to(r, {
        duration: .05,
        opacity: 1,
        delay: .1
    })
}
);
const ZI = "modulepreload"
  , JI = function(r) {
    return "/" + r
}
  , m0 = {}
  , _0 = function(e, t, n) {
    let i = Promise.resolve();
    if (t && t.length > 0) {
        const s = document.getElementsByTagName("link");
        i = Promise.all(t.map(o=>{
            if (o = JI(o),
            o in m0)
                return;
            m0[o] = !0;
            const a = o.endsWith(".css")
              , c = a ? '[rel="stylesheet"]' : "";
            if (!!n)
                for (let l = s.length - 1; l >= 0; l--) {
                    const f = s[l];
                    if (f.href === o && (!a || f.rel === "stylesheet"))
                        return
                }
            else if (document.querySelector(`link[href="${o}"]${c}`))
                return;
            const d = document.createElement("link");
            if (d.rel = a ? "stylesheet" : ZI,
            a || (d.as = "script",
            d.crossOrigin = ""),
            d.href = o,
            document.head.appendChild(d),
            a)
                return new Promise((l,f)=>{
                    d.addEventListener("load", l),
                    d.addEventListener("error", ()=>f(new Error(`Unable to preload CSS for ${o}`)))
                }
                )
        }
        ))
    }
    return i.then(()=>e()).catch(s=>{
        const o = new Event("vite:preloadError",{
            cancelable: !0
        });
        if (o.payload = s,
        window.dispatchEvent(o),
        !o.defaultPrevented)
            throw s
    }
    )
};
/**
 * @license
 * Copyright 2010-2023 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
const gl = "159"
  , ia = {
    LEFT: 0,
    MIDDLE: 1,
    RIGHT: 2,
    ROTATE: 0,
    DOLLY: 1,
    PAN: 2
}
  , ra = {
    ROTATE: 0,
    PAN: 1,
    DOLLY_PAN: 2,
    DOLLY_ROTATE: 3
}
  , QI = 0
  , g0 = 1
  , eL = 2
  , pb = 1
  , tL = 2
  , Jr = 3
  , xr = 0
  , fi = 1
  , mr = 2
  , Si = 0
  , qa = 1
  , Dc = 2
  , v0 = 3
  , y0 = 4
  , nL = 5
  , bo = 100
  , iL = 101
  , rL = 102
  , x0 = 103
  , T0 = 104
  , sL = 200
  , oL = 201
  , aL = 202
  , lL = 203
  , Om = 204
  , Um = 205
  , cL = 206
  , uL = 207
  , hL = 208
  , fL = 209
  , dL = 210
  , pL = 211
  , mL = 212
  , _L = 213
  , gL = 214
  , vL = 0
  , yL = 1
  , xL = 2
  , jh = 3
  , TL = 4
  , bL = 5
  , SL = 6
  , ML = 7
  , mb = 0
  , wL = 1
  , EL = 2
  , Ns = 0
  , AL = 1
  , PL = 2
  , RL = 3
  , CL = 4
  , IL = 5
  , b0 = "attached"
  , LL = "detached"
  , _b = 300
  , il = 301
  , rl = 302
  , Nm = 303
  , Fm = 304
  , ff = 306
  , ii = 1e3
  , hi = 1001
  , sl = 1002
  , Jt = 1003
  , Bm = 1004
  , Lh = 1005
  , Ot = 1006
  , gb = 1007
  , Do = 1008
  , S0 = 1008
  , Vn = 1009
  , DL = 1010
  , OL = 1011
  , A_ = 1012
  , vb = 1013
  , ns = 1014
  , wn = 1015
  , Ur = 1016
  , yb = 1017
  , xb = 1018
  , Fs = 1020
  , UL = 1021
  , Kn = 1023
  , NL = 1024
  , FL = 1025
  , Ro = 1026
  , Oo = 1027
  , BL = 1028
  , Tb = 1029
  , kL = 1030
  , bb = 1031
  , Sb = 1033
  , up = 33776
  , hp = 33777
  , fp = 33778
  , dp = 33779
  , M0 = 35840
  , w0 = 35841
  , E0 = 35842
  , A0 = 35843
  , Mb = 36196
  , P0 = 37492
  , R0 = 37496
  , C0 = 37808
  , I0 = 37809
  , L0 = 37810
  , D0 = 37811
  , O0 = 37812
  , U0 = 37813
  , N0 = 37814
  , F0 = 37815
  , B0 = 37816
  , k0 = 37817
  , z0 = 37818
  , H0 = 37819
  , V0 = 37820
  , G0 = 37821
  , pp = 36492
  , W0 = 36494
  , j0 = 36495
  , zL = 36283
  , X0 = 36284
  , q0 = 36285
  , K0 = 36286
  , HL = 2200
  , VL = 2201
  , GL = 2202
  , Oc = 2300
  , ol = 2301
  , mp = 2302
  , za = 2400
  , Ha = 2401
  , Xh = 2402
  , P_ = 2500
  , WL = 2501
  , jL = 0
  , wb = 1
  , km = 2
  , df = 3e3
  , Dr = 3001
  , Fc = 3200
  , R_ = 3201
  , Eb = 0
  , XL = 1
  , Ni = ""
  , Ft = "srgb"
  , gn = "srgb-linear"
  , C_ = "display-p3"
  , pf = "display-p3-linear"
  , qh = "linear"
  , Zt = "srgb"
  , Kh = "rec709"
  , Yh = "p3"
  , sa = 7680
  , Y0 = 519
  , qL = 512
  , KL = 513
  , YL = 514
  , Ab = 515
  , $L = 516
  , ZL = 517
  , JL = 518
  , QL = 519
  , zm = 35044
  , Dh = 35048
  , $0 = "300 es"
  , Hm = 1035
  , is = 2e3
  , $h = 2001;
class Sr {
    addEventListener(e, t) {
        this._listeners === void 0 && (this._listeners = {});
        const n = this._listeners;
        n[e] === void 0 && (n[e] = []),
        n[e].indexOf(t) === -1 && n[e].push(t)
    }
    hasEventListener(e, t) {
        if (this._listeners === void 0)
            return !1;
        const n = this._listeners;
        return n[e] !== void 0 && n[e].indexOf(t) !== -1
    }
    removeEventListener(e, t) {
        if (this._listeners === void 0)
            return;
        const i = this._listeners[e];
        if (i !== void 0) {
            const s = i.indexOf(t);
            s !== -1 && i.splice(s, 1)
        }
    }
    dispatchEvent(e) {
        if (this._listeners === void 0)
            return;
        const n = this._listeners[e.type];
        if (n !== void 0) {
            e.target = this;
            const i = n.slice(0);
            for (let s = 0, o = i.length; s < o; s++)
                i[s].call(this, e);
            e.target = null
        }
    }
}
const Qn = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
let Z0 = 1234567;
const vc = Math.PI / 180
  , al = 180 / Math.PI;
function vr() {
    const r = Math.random() * 4294967295 | 0
      , e = Math.random() * 4294967295 | 0
      , t = Math.random() * 4294967295 | 0
      , n = Math.random() * 4294967295 | 0;
    return (Qn[r & 255] + Qn[r >> 8 & 255] + Qn[r >> 16 & 255] + Qn[r >> 24 & 255] + "-" + Qn[e & 255] + Qn[e >> 8 & 255] + "-" + Qn[e >> 16 & 15 | 64] + Qn[e >> 24 & 255] + "-" + Qn[t & 63 | 128] + Qn[t >> 8 & 255] + "-" + Qn[t >> 16 & 255] + Qn[t >> 24 & 255] + Qn[n & 255] + Qn[n >> 8 & 255] + Qn[n >> 16 & 255] + Qn[n >> 24 & 255]).toLowerCase()
}
function Hn(r, e, t) {
    return Math.max(e, Math.min(t, r))
}
function I_(r, e) {
    return (r % e + e) % e
}
function eD(r, e, t, n, i) {
    return n + (r - e) * (i - n) / (t - e)
}
function tD(r, e, t) {
    return r !== e ? (t - r) / (e - r) : 0
}
function yc(r, e, t) {
    return (1 - t) * r + t * e
}
function nD(r, e, t, n) {
    return yc(r, e, 1 - Math.exp(-t * n))
}
function iD(r, e=1) {
    return e - Math.abs(I_(r, e * 2) - e)
}
function rD(r, e, t) {
    return r <= e ? 0 : r >= t ? 1 : (r = (r - e) / (t - e),
    r * r * (3 - 2 * r))
}
function sD(r, e, t) {
    return r <= e ? 0 : r >= t ? 1 : (r = (r - e) / (t - e),
    r * r * r * (r * (r * 6 - 15) + 10))
}
function oD(r, e) {
    return r + Math.floor(Math.random() * (e - r + 1))
}
function aD(r, e) {
    return r + Math.random() * (e - r)
}
function lD(r) {
    return r * (.5 - Math.random())
}
function cD(r) {
    r !== void 0 && (Z0 = r);
    let e = Z0 += 1831565813;
    return e = Math.imul(e ^ e >>> 15, e | 1),
    e ^= e + Math.imul(e ^ e >>> 7, e | 61),
    ((e ^ e >>> 14) >>> 0) / 4294967296
}
function uD(r) {
    return r * vc
}
function hD(r) {
    return r * al
}
function Vm(r) {
    return (r & r - 1) === 0 && r !== 0
}
function fD(r) {
    return Math.pow(2, Math.ceil(Math.log(r) / Math.LN2))
}
function Zh(r) {
    return Math.pow(2, Math.floor(Math.log(r) / Math.LN2))
}
function dD(r, e, t, n, i) {
    const s = Math.cos
      , o = Math.sin
      , a = s(t / 2)
      , c = o(t / 2)
      , h = s((e + n) / 2)
      , d = o((e + n) / 2)
      , l = s((e - n) / 2)
      , f = o((e - n) / 2)
      , p = s((n - e) / 2)
      , g = o((n - e) / 2);
    switch (i) {
    case "XYX":
        r.set(a * d, c * l, c * f, a * h);
        break;
    case "YZY":
        r.set(c * f, a * d, c * l, a * h);
        break;
    case "ZXZ":
        r.set(c * l, c * f, a * d, a * h);
        break;
    case "XZX":
        r.set(a * d, c * g, c * p, a * h);
        break;
    case "YXY":
        r.set(c * p, a * d, c * g, a * h);
        break;
    case "ZYZ":
        r.set(c * g, c * p, a * d, a * h);
        break;
    default:
        console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + i)
    }
}
function Rr(r, e) {
    switch (e.constructor) {
    case Float32Array:
        return r;
    case Uint32Array:
        return r / 4294967295;
    case Uint16Array:
        return r / 65535;
    case Uint8Array:
        return r / 255;
    case Int32Array:
        return Math.max(r / 2147483647, -1);
    case Int16Array:
        return Math.max(r / 32767, -1);
    case Int8Array:
        return Math.max(r / 127, -1);
    default:
        throw new Error("Invalid component type.")
    }
}
function Nt(r, e) {
    switch (e.constructor) {
    case Float32Array:
        return r;
    case Uint32Array:
        return Math.round(r * 4294967295);
    case Uint16Array:
        return Math.round(r * 65535);
    case Uint8Array:
        return Math.round(r * 255);
    case Int32Array:
        return Math.round(r * 2147483647);
    case Int16Array:
        return Math.round(r * 32767);
    case Int8Array:
        return Math.round(r * 127);
    default:
        throw new Error("Invalid component type.")
    }
}
const Dn = {
    DEG2RAD: vc,
    RAD2DEG: al,
    generateUUID: vr,
    clamp: Hn,
    euclideanModulo: I_,
    mapLinear: eD,
    inverseLerp: tD,
    lerp: yc,
    damp: nD,
    pingpong: iD,
    smoothstep: rD,
    smootherstep: sD,
    randInt: oD,
    randFloat: aD,
    randFloatSpread: lD,
    seededRandom: cD,
    degToRad: uD,
    radToDeg: hD,
    isPowerOfTwo: Vm,
    ceilPowerOfTwo: fD,
    floorPowerOfTwo: Zh,
    setQuaternionFromProperEuler: dD,
    normalize: Nt,
    denormalize: Rr
};
class Ce {
    constructor(e=0, t=0) {
        Ce.prototype.isVector2 = !0,
        this.x = e,
        this.y = t
    }
    get width() {
        return this.x
    }
    set width(e) {
        this.x = e
    }
    get height() {
        return this.y
    }
    set height(e) {
        this.y = e
    }
    set(e, t) {
        return this.x = e,
        this.y = t,
        this
    }
    setScalar(e) {
        return this.x = e,
        this.y = e,
        this
    }
    setX(e) {
        return this.x = e,
        this
    }
    setY(e) {
        return this.y = e,
        this
    }
    setComponent(e, t) {
        switch (e) {
        case 0:
            this.x = t;
            break;
        case 1:
            this.y = t;
            break;
        default:
            throw new Error("index is out of range: " + e)
        }
        return this
    }
    getComponent(e) {
        switch (e) {
        case 0:
            return this.x;
        case 1:
            return this.y;
        default:
            throw new Error("index is out of range: " + e)
        }
    }
    clone() {
        return new this.constructor(this.x,this.y)
    }
    copy(e) {
        return this.x = e.x,
        this.y = e.y,
        this
    }
    add(e) {
        return this.x += e.x,
        this.y += e.y,
        this
    }
    addScalar(e) {
        return this.x += e,
        this.y += e,
        this
    }
    addVectors(e, t) {
        return this.x = e.x + t.x,
        this.y = e.y + t.y,
        this
    }
    addScaledVector(e, t) {
        return this.x += e.x * t,
        this.y += e.y * t,
        this
    }
    sub(e) {
        return this.x -= e.x,
        this.y -= e.y,
        this
    }
    subScalar(e) {
        return this.x -= e,
        this.y -= e,
        this
    }
    subVectors(e, t) {
        return this.x = e.x - t.x,
        this.y = e.y - t.y,
        this
    }
    multiply(e) {
        return this.x *= e.x,
        this.y *= e.y,
        this
    }
    multiplyScalar(e) {
        return this.x *= e,
        this.y *= e,
        this
    }
    divide(e) {
        return this.x /= e.x,
        this.y /= e.y,
        this
    }
    divideScalar(e) {
        return this.multiplyScalar(1 / e)
    }
    applyMatrix3(e) {
        const t = this.x
          , n = this.y
          , i = e.elements;
        return this.x = i[0] * t + i[3] * n + i[6],
        this.y = i[1] * t + i[4] * n + i[7],
        this
    }
    min(e) {
        return this.x = Math.min(this.x, e.x),
        this.y = Math.min(this.y, e.y),
        this
    }
    max(e) {
        return this.x = Math.max(this.x, e.x),
        this.y = Math.max(this.y, e.y),
        this
    }
    clamp(e, t) {
        return this.x = Math.max(e.x, Math.min(t.x, this.x)),
        this.y = Math.max(e.y, Math.min(t.y, this.y)),
        this
    }
    clampScalar(e, t) {
        return this.x = Math.max(e, Math.min(t, this.x)),
        this.y = Math.max(e, Math.min(t, this.y)),
        this
    }
    clampLength(e, t) {
        const n = this.length();
        return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)))
    }
    floor() {
        return this.x = Math.floor(this.x),
        this.y = Math.floor(this.y),
        this
    }
    ceil() {
        return this.x = Math.ceil(this.x),
        this.y = Math.ceil(this.y),
        this
    }
    round() {
        return this.x = Math.round(this.x),
        this.y = Math.round(this.y),
        this
    }
    roundToZero() {
        return this.x = Math.trunc(this.x),
        this.y = Math.trunc(this.y),
        this
    }
    negate() {
        return this.x = -this.x,
        this.y = -this.y,
        this
    }
    dot(e) {
        return this.x * e.x + this.y * e.y
    }
    cross(e) {
        return this.x * e.y - this.y * e.x
    }
    lengthSq() {
        return this.x * this.x + this.y * this.y
    }
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y)
    }
    manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y)
    }
    normalize() {
        return this.divideScalar(this.length() || 1)
    }
    angle() {
        return Math.atan2(-this.y, -this.x) + Math.PI
    }
    angleTo(e) {
        const t = Math.sqrt(this.lengthSq() * e.lengthSq());
        if (t === 0)
            return Math.PI / 2;
        const n = this.dot(e) / t;
        return Math.acos(Hn(n, -1, 1))
    }
    distanceTo(e) {
        return Math.sqrt(this.distanceToSquared(e))
    }
    distanceToSquared(e) {
        const t = this.x - e.x
          , n = this.y - e.y;
        return t * t + n * n
    }
    manhattanDistanceTo(e) {
        return Math.abs(this.x - e.x) + Math.abs(this.y - e.y)
    }
    setLength(e) {
        return this.normalize().multiplyScalar(e)
    }
    lerp(e, t) {
        return this.x += (e.x - this.x) * t,
        this.y += (e.y - this.y) * t,
        this
    }
    lerpVectors(e, t, n) {
        return this.x = e.x + (t.x - e.x) * n,
        this.y = e.y + (t.y - e.y) * n,
        this
    }
    equals(e) {
        return e.x === this.x && e.y === this.y
    }
    fromArray(e, t=0) {
        return this.x = e[t],
        this.y = e[t + 1],
        this
    }
    toArray(e=[], t=0) {
        return e[t] = this.x,
        e[t + 1] = this.y,
        e
    }
    fromBufferAttribute(e, t) {
        return this.x = e.getX(t),
        this.y = e.getY(t),
        this
    }
    rotateAround(e, t) {
        const n = Math.cos(t)
          , i = Math.sin(t)
          , s = this.x - e.x
          , o = this.y - e.y;
        return this.x = s * n - o * i + e.x,
        this.y = s * i + o * n + e.y,
        this
    }
    random() {
        return this.x = Math.random(),
        this.y = Math.random(),
        this
    }
    *[Symbol.iterator]() {
        yield this.x,
        yield this.y
    }
}
class _t {
    constructor(e, t, n, i, s, o, a, c, h) {
        _t.prototype.isMatrix3 = !0,
        this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1],
        e !== void 0 && this.set(e, t, n, i, s, o, a, c, h)
    }
    set(e, t, n, i, s, o, a, c, h) {
        const d = this.elements;
        return d[0] = e,
        d[1] = i,
        d[2] = a,
        d[3] = t,
        d[4] = s,
        d[5] = c,
        d[6] = n,
        d[7] = o,
        d[8] = h,
        this
    }
    identity() {
        return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1),
        this
    }
    copy(e) {
        const t = this.elements
          , n = e.elements;
        return t[0] = n[0],
        t[1] = n[1],
        t[2] = n[2],
        t[3] = n[3],
        t[4] = n[4],
        t[5] = n[5],
        t[6] = n[6],
        t[7] = n[7],
        t[8] = n[8],
        this
    }
    extractBasis(e, t, n) {
        return e.setFromMatrix3Column(this, 0),
        t.setFromMatrix3Column(this, 1),
        n.setFromMatrix3Column(this, 2),
        this
    }
    setFromMatrix4(e) {
        const t = e.elements;
        return this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]),
        this
    }
    multiply(e) {
        return this.multiplyMatrices(this, e)
    }
    premultiply(e) {
        return this.multiplyMatrices(e, this)
    }
    multiplyMatrices(e, t) {
        const n = e.elements
          , i = t.elements
          , s = this.elements
          , o = n[0]
          , a = n[3]
          , c = n[6]
          , h = n[1]
          , d = n[4]
          , l = n[7]
          , f = n[2]
          , p = n[5]
          , g = n[8]
          , y = i[0]
          , v = i[3]
          , _ = i[6]
          , b = i[1]
          , T = i[4]
          , S = i[7]
          , E = i[2]
          , P = i[5]
          , R = i[8];
        return s[0] = o * y + a * b + c * E,
        s[3] = o * v + a * T + c * P,
        s[6] = o * _ + a * S + c * R,
        s[1] = h * y + d * b + l * E,
        s[4] = h * v + d * T + l * P,
        s[7] = h * _ + d * S + l * R,
        s[2] = f * y + p * b + g * E,
        s[5] = f * v + p * T + g * P,
        s[8] = f * _ + p * S + g * R,
        this
    }
    multiplyScalar(e) {
        const t = this.elements;
        return t[0] *= e,
        t[3] *= e,
        t[6] *= e,
        t[1] *= e,
        t[4] *= e,
        t[7] *= e,
        t[2] *= e,
        t[5] *= e,
        t[8] *= e,
        this
    }
    determinant() {
        const e = this.elements
          , t = e[0]
          , n = e[1]
          , i = e[2]
          , s = e[3]
          , o = e[4]
          , a = e[5]
          , c = e[6]
          , h = e[7]
          , d = e[8];
        return t * o * d - t * a * h - n * s * d + n * a * c + i * s * h - i * o * c
    }
    invert() {
        const e = this.elements
          , t = e[0]
          , n = e[1]
          , i = e[2]
          , s = e[3]
          , o = e[4]
          , a = e[5]
          , c = e[6]
          , h = e[7]
          , d = e[8]
          , l = d * o - a * h
          , f = a * c - d * s
          , p = h * s - o * c
          , g = t * l + n * f + i * p;
        if (g === 0)
            return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
        const y = 1 / g;
        return e[0] = l * y,
        e[1] = (i * h - d * n) * y,
        e[2] = (a * n - i * o) * y,
        e[3] = f * y,
        e[4] = (d * t - i * c) * y,
        e[5] = (i * s - a * t) * y,
        e[6] = p * y,
        e[7] = (n * c - h * t) * y,
        e[8] = (o * t - n * s) * y,
        this
    }
    transpose() {
        let e;
        const t = this.elements;
        return e = t[1],
        t[1] = t[3],
        t[3] = e,
        e = t[2],
        t[2] = t[6],
        t[6] = e,
        e = t[5],
        t[5] = t[7],
        t[7] = e,
        this
    }
    getNormalMatrix(e) {
        return this.setFromMatrix4(e).invert().transpose()
    }
    transposeIntoArray(e) {
        const t = this.elements;
        return e[0] = t[0],
        e[1] = t[3],
        e[2] = t[6],
        e[3] = t[1],
        e[4] = t[4],
        e[5] = t[7],
        e[6] = t[2],
        e[7] = t[5],
        e[8] = t[8],
        this
    }
    setUvTransform(e, t, n, i, s, o, a) {
        const c = Math.cos(s)
          , h = Math.sin(s);
        return this.set(n * c, n * h, -n * (c * o + h * a) + o + e, -i * h, i * c, -i * (-h * o + c * a) + a + t, 0, 0, 1),
        this
    }
    scale(e, t) {
        return this.premultiply(_p.makeScale(e, t)),
        this
    }
    rotate(e) {
        return this.premultiply(_p.makeRotation(-e)),
        this
    }
    translate(e, t) {
        return this.premultiply(_p.makeTranslation(e, t)),
        this
    }
    makeTranslation(e, t) {
        return e.isVector2 ? this.set(1, 0, e.x, 0, 1, e.y, 0, 0, 1) : this.set(1, 0, e, 0, 1, t, 0, 0, 1),
        this
    }
    makeRotation(e) {
        const t = Math.cos(e)
          , n = Math.sin(e);
        return this.set(t, -n, 0, n, t, 0, 0, 0, 1),
        this
    }
    makeScale(e, t) {
        return this.set(e, 0, 0, 0, t, 0, 0, 0, 1),
        this
    }
    equals(e) {
        const t = this.elements
          , n = e.elements;
        for (let i = 0; i < 9; i++)
            if (t[i] !== n[i])
                return !1;
        return !0
    }
    fromArray(e, t=0) {
        for (let n = 0; n < 9; n++)
            this.elements[n] = e[n + t];
        return this
    }
    toArray(e=[], t=0) {
        const n = this.elements;
        return e[t] = n[0],
        e[t + 1] = n[1],
        e[t + 2] = n[2],
        e[t + 3] = n[3],
        e[t + 4] = n[4],
        e[t + 5] = n[5],
        e[t + 6] = n[6],
        e[t + 7] = n[7],
        e[t + 8] = n[8],
        e
    }
    clone() {
        return new this.constructor().fromArray(this.elements)
    }
}
const _p = new _t;
function Pb(r) {
    for (let e = r.length - 1; e >= 0; --e)
        if (r[e] >= 65535)
            return !0;
    return !1
}
function Uc(r) {
    return document.createElementNS("http://www.w3.org/1999/xhtml", r)
}
function pD() {
    const r = Uc("canvas");
    return r.style.display = "block",
    r
}
const J0 = {};
function xc(r) {
    r in J0 || (J0[r] = !0,
    console.warn(r))
}
const Q0 = new _t().set(.8224621, .177538, 0, .0331941, .9668058, 0, .0170827, .0723974, .9105199)
  , ey = new _t().set(1.2249401, -.2249404, 0, -.0420569, 1.0420571, 0, -.0196376, -.0786361, 1.0982735)
  , Du = {
    [gn]: {
        transfer: qh,
        primaries: Kh,
        toReference: r=>r,
        fromReference: r=>r
    },
    [Ft]: {
        transfer: Zt,
        primaries: Kh,
        toReference: r=>r.convertSRGBToLinear(),
        fromReference: r=>r.convertLinearToSRGB()
    },
    [pf]: {
        transfer: qh,
        primaries: Yh,
        toReference: r=>r.applyMatrix3(ey),
        fromReference: r=>r.applyMatrix3(Q0)
    },
    [C_]: {
        transfer: Zt,
        primaries: Yh,
        toReference: r=>r.convertSRGBToLinear().applyMatrix3(ey),
        fromReference: r=>r.applyMatrix3(Q0).convertLinearToSRGB()
    }
}
  , mD = new Set([gn, pf])
  , Rt = {
    enabled: !0,
    _workingColorSpace: gn,
    get legacyMode() {
        return console.warn("THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150."),
        !this.enabled
    },
    set legacyMode(r) {
        console.warn("THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150."),
        this.enabled = !r
    },
    get workingColorSpace() {
        return this._workingColorSpace
    },
    set workingColorSpace(r) {
        if (!mD.has(r))
            throw new Error(`Unsupported working color space, "${r}".`);
        this._workingColorSpace = r
    },
    convert: function(r, e, t) {
        if (this.enabled === !1 || e === t || !e || !t)
            return r;
        const n = Du[e].toReference
          , i = Du[t].fromReference;
        return i(n(r))
    },
    fromWorkingColorSpace: function(r, e) {
        return this.convert(r, this._workingColorSpace, e)
    },
    toWorkingColorSpace: function(r, e) {
        return this.convert(r, e, this._workingColorSpace)
    },
    getPrimaries: function(r) {
        return Du[r].primaries
    },
    getTransfer: function(r) {
        return r === Ni ? qh : Du[r].transfer
    }
};
function Ka(r) {
    return r < .04045 ? r * .0773993808 : Math.pow(r * .9478672986 + .0521327014, 2.4)
}
function gp(r) {
    return r < .0031308 ? r * 12.92 : 1.055 * Math.pow(r, .41666) - .055
}
let oa;
class Rb {
    static getDataURL(e) {
        if (/^data:/i.test(e.src) || typeof HTMLCanvasElement > "u")
            return e.src;
        let t;
        if (e instanceof HTMLCanvasElement)
            t = e;
        else {
            oa === void 0 && (oa = Uc("canvas")),
            oa.width = e.width,
            oa.height = e.height;
            const n = oa.getContext("2d");
            e instanceof ImageData ? n.putImageData(e, 0, 0) : n.drawImage(e, 0, 0, e.width, e.height),
            t = oa
        }
        return t.width > 2048 || t.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", e),
        t.toDataURL("image/jpeg", .6)) : t.toDataURL("image/png")
    }
    static sRGBToLinear(e) {
        if (typeof HTMLImageElement < "u" && e instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && e instanceof ImageBitmap) {
            const t = Uc("canvas");
            t.width = e.width,
            t.height = e.height;
            const n = t.getContext("2d");
            n.drawImage(e, 0, 0, e.width, e.height);
            const i = n.getImageData(0, 0, e.width, e.height)
              , s = i.data;
            for (let o = 0; o < s.length; o++)
                s[o] = Ka(s[o] / 255) * 255;
            return n.putImageData(i, 0, 0),
            t
        } else if (e.data) {
            const t = e.data.slice(0);
            for (let n = 0; n < t.length; n++)
                t instanceof Uint8Array || t instanceof Uint8ClampedArray ? t[n] = Math.floor(Ka(t[n] / 255) * 255) : t[n] = Ka(t[n]);
            return {
                data: t,
                width: e.width,
                height: e.height
            }
        } else
            return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."),
            e
    }
}
let _D = 0;
class Cb {
    constructor(e=null) {
        this.isSource = !0,
        Object.defineProperty(this, "id", {
            value: _D++
        }),
        this.uuid = vr(),
        this.data = e,
        this.version = 0
    }
    set needsUpdate(e) {
        e === !0 && this.version++
    }
    toJSON(e) {
        const t = e === void 0 || typeof e == "string";
        if (!t && e.images[this.uuid] !== void 0)
            return e.images[this.uuid];
        const n = {
            uuid: this.uuid,
            url: ""
        }
          , i = this.data;
        if (i !== null) {
            let s;
            if (Array.isArray(i)) {
                s = [];
                for (let o = 0, a = i.length; o < a; o++)
                    i[o].isDataTexture ? s.push(vp(i[o].image)) : s.push(vp(i[o]))
            } else
                s = vp(i);
            n.url = s
        }
        return t || (e.images[this.uuid] = n),
        n
    }
}
function vp(r) {
    return typeof HTMLImageElement < "u" && r instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && r instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && r instanceof ImageBitmap ? Rb.getDataURL(r) : r.data ? {
        data: Array.from(r.data),
        width: r.width,
        height: r.height,
        type: r.data.constructor.name
    } : (console.warn("THREE.Texture: Unable to serialize Texture."),
    {})
}
let gD = 0;
class Pn extends Sr {
    constructor(e=Pn.DEFAULT_IMAGE, t=Pn.DEFAULT_MAPPING, n=hi, i=hi, s=Ot, o=Do, a=Kn, c=Vn, h=Pn.DEFAULT_ANISOTROPY, d=Ni) {
        super(),
        this.isTexture = !0,
        Object.defineProperty(this, "id", {
            value: gD++
        }),
        this.uuid = vr(),
        this.name = "",
        this.source = new Cb(e),
        this.mipmaps = [],
        this.mapping = t,
        this.channel = 0,
        this.wrapS = n,
        this.wrapT = i,
        this.magFilter = s,
        this.minFilter = o,
        this.anisotropy = h,
        this.format = a,
        this.internalFormat = null,
        this.type = c,
        this.offset = new Ce(0,0),
        this.repeat = new Ce(1,1),
        this.center = new Ce(0,0),
        this.rotation = 0,
        this.matrixAutoUpdate = !0,
        this.matrix = new _t,
        this.generateMipmaps = !0,
        this.premultiplyAlpha = !1,
        this.flipY = !0,
        this.unpackAlignment = 4,
        typeof d == "string" ? this.colorSpace = d : (xc("THREE.Texture: Property .encoding has been replaced by .colorSpace."),
        this.colorSpace = d === Dr ? Ft : Ni),
        this.userData = {},
        this.version = 0,
        this.onUpdate = null,
        this.isRenderTargetTexture = !1,
        this.needsPMREMUpdate = !1
    }
    get image() {
        return this.source.data
    }
    set image(e=null) {
        this.source.data = e
    }
    updateMatrix() {
        this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        return this.name = e.name,
        this.source = e.source,
        this.mipmaps = e.mipmaps.slice(0),
        this.mapping = e.mapping,
        this.channel = e.channel,
        this.wrapS = e.wrapS,
        this.wrapT = e.wrapT,
        this.magFilter = e.magFilter,
        this.minFilter = e.minFilter,
        this.anisotropy = e.anisotropy,
        this.format = e.format,
        this.internalFormat = e.internalFormat,
        this.type = e.type,
        this.offset.copy(e.offset),
        this.repeat.copy(e.repeat),
        this.center.copy(e.center),
        this.rotation = e.rotation,
        this.matrixAutoUpdate = e.matrixAutoUpdate,
        this.matrix.copy(e.matrix),
        this.generateMipmaps = e.generateMipmaps,
        this.premultiplyAlpha = e.premultiplyAlpha,
        this.flipY = e.flipY,
        this.unpackAlignment = e.unpackAlignment,
        this.colorSpace = e.colorSpace,
        this.userData = JSON.parse(JSON.stringify(e.userData)),
        this.needsUpdate = !0,
        this
    }
    toJSON(e) {
        const t = e === void 0 || typeof e == "string";
        if (!t && e.textures[this.uuid] !== void 0)
            return e.textures[this.uuid];
        const n = {
            metadata: {
                version: 4.6,
                type: "Texture",
                generator: "Texture.toJSON"
            },
            uuid: this.uuid,
            name: this.name,
            image: this.source.toJSON(e).uuid,
            mapping: this.mapping,
            channel: this.channel,
            repeat: [this.repeat.x, this.repeat.y],
            offset: [this.offset.x, this.offset.y],
            center: [this.center.x, this.center.y],
            rotation: this.rotation,
            wrap: [this.wrapS, this.wrapT],
            format: this.format,
            internalFormat: this.internalFormat,
            type: this.type,
            colorSpace: this.colorSpace,
            minFilter: this.minFilter,
            magFilter: this.magFilter,
            anisotropy: this.anisotropy,
            flipY: this.flipY,
            generateMipmaps: this.generateMipmaps,
            premultiplyAlpha: this.premultiplyAlpha,
            unpackAlignment: this.unpackAlignment
        };
        return Object.keys(this.userData).length > 0 && (n.userData = this.userData),
        t || (e.textures[this.uuid] = n),
        n
    }
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
    transformUv(e) {
        if (this.mapping !== _b)
            return e;
        if (e.applyMatrix3(this.matrix),
        e.x < 0 || e.x > 1)
            switch (this.wrapS) {
            case ii:
                e.x = e.x - Math.floor(e.x);
                break;
            case hi:
                e.x = e.x < 0 ? 0 : 1;
                break;
            case sl:
                Math.abs(Math.floor(e.x) % 2) === 1 ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x);
                break
            }
        if (e.y < 0 || e.y > 1)
            switch (this.wrapT) {
            case ii:
                e.y = e.y - Math.floor(e.y);
                break;
            case hi:
                e.y = e.y < 0 ? 0 : 1;
                break;
            case sl:
                Math.abs(Math.floor(e.y) % 2) === 1 ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y);
                break
            }
        return this.flipY && (e.y = 1 - e.y),
        e
    }
    set needsUpdate(e) {
        e === !0 && (this.version++,
        this.source.needsUpdate = !0)
    }
    get encoding() {
        return xc("THREE.Texture: Property .encoding has been replaced by .colorSpace."),
        this.colorSpace === Ft ? Dr : df
    }
    set encoding(e) {
        xc("THREE.Texture: Property .encoding has been replaced by .colorSpace."),
        this.colorSpace = e === Dr ? Ft : Ni
    }
}
Pn.DEFAULT_IMAGE = null;
Pn.DEFAULT_MAPPING = _b;
Pn.DEFAULT_ANISOTROPY = 1;
class Ct {
    constructor(e=0, t=0, n=0, i=1) {
        Ct.prototype.isVector4 = !0,
        this.x = e,
        this.y = t,
        this.z = n,
        this.w = i
    }
    get width() {
        return this.z
    }
    set width(e) {
        this.z = e
    }
    get height() {
        return this.w
    }
    set height(e) {
        this.w = e
    }
    set(e, t, n, i) {
        return this.x = e,
        this.y = t,
        this.z = n,
        this.w = i,
        this
    }
    setScalar(e) {
        return this.x = e,
        this.y = e,
        this.z = e,
        this.w = e,
        this
    }
    setX(e) {
        return this.x = e,
        this
    }
    setY(e) {
        return this.y = e,
        this
    }
    setZ(e) {
        return this.z = e,
        this
    }
    setW(e) {
        return this.w = e,
        this
    }
    setComponent(e, t) {
        switch (e) {
        case 0:
            this.x = t;
            break;
        case 1:
            this.y = t;
            break;
        case 2:
            this.z = t;
            break;
        case 3:
            this.w = t;
            break;
        default:
            throw new Error("index is out of range: " + e)
        }
        return this
    }
    getComponent(e) {
        switch (e) {
        case 0:
            return this.x;
        case 1:
            return this.y;
        case 2:
            return this.z;
        case 3:
            return this.w;
        default:
            throw new Error("index is out of range: " + e)
        }
    }
    clone() {
        return new this.constructor(this.x,this.y,this.z,this.w)
    }
    copy(e) {
        return this.x = e.x,
        this.y = e.y,
        this.z = e.z,
        this.w = e.w !== void 0 ? e.w : 1,
        this
    }
    add(e) {
        return this.x += e.x,
        this.y += e.y,
        this.z += e.z,
        this.w += e.w,
        this
    }
    addScalar(e) {
        return this.x += e,
        this.y += e,
        this.z += e,
        this.w += e,
        this
    }
    addVectors(e, t) {
        return this.x = e.x + t.x,
        this.y = e.y + t.y,
        this.z = e.z + t.z,
        this.w = e.w + t.w,
        this
    }
    addScaledVector(e, t) {
        return this.x += e.x * t,
        this.y += e.y * t,
        this.z += e.z * t,
        this.w += e.w * t,
        this
    }
    sub(e) {
        return this.x -= e.x,
        this.y -= e.y,
        this.z -= e.z,
        this.w -= e.w,
        this
    }
    subScalar(e) {
        return this.x -= e,
        this.y -= e,
        this.z -= e,
        this.w -= e,
        this
    }
    subVectors(e, t) {
        return this.x = e.x - t.x,
        this.y = e.y - t.y,
        this.z = e.z - t.z,
        this.w = e.w - t.w,
        this
    }
    multiply(e) {
        return this.x *= e.x,
        this.y *= e.y,
        this.z *= e.z,
        this.w *= e.w,
        this
    }
    multiplyScalar(e) {
        return this.x *= e,
        this.y *= e,
        this.z *= e,
        this.w *= e,
        this
    }
    applyMatrix4(e) {
        const t = this.x
          , n = this.y
          , i = this.z
          , s = this.w
          , o = e.elements;
        return this.x = o[0] * t + o[4] * n + o[8] * i + o[12] * s,
        this.y = o[1] * t + o[5] * n + o[9] * i + o[13] * s,
        this.z = o[2] * t + o[6] * n + o[10] * i + o[14] * s,
        this.w = o[3] * t + o[7] * n + o[11] * i + o[15] * s,
        this
    }
    divideScalar(e) {
        return this.multiplyScalar(1 / e)
    }
    setAxisAngleFromQuaternion(e) {
        this.w = 2 * Math.acos(e.w);
        const t = Math.sqrt(1 - e.w * e.w);
        return t < 1e-4 ? (this.x = 1,
        this.y = 0,
        this.z = 0) : (this.x = e.x / t,
        this.y = e.y / t,
        this.z = e.z / t),
        this
    }
    setAxisAngleFromRotationMatrix(e) {
        let t, n, i, s;
        const c = e.elements
          , h = c[0]
          , d = c[4]
          , l = c[8]
          , f = c[1]
          , p = c[5]
          , g = c[9]
          , y = c[2]
          , v = c[6]
          , _ = c[10];
        if (Math.abs(d - f) < .01 && Math.abs(l - y) < .01 && Math.abs(g - v) < .01) {
            if (Math.abs(d + f) < .1 && Math.abs(l + y) < .1 && Math.abs(g + v) < .1 && Math.abs(h + p + _ - 3) < .1)
                return this.set(1, 0, 0, 0),
                this;
            t = Math.PI;
            const T = (h + 1) / 2
              , S = (p + 1) / 2
              , E = (_ + 1) / 2
              , P = (d + f) / 4
              , R = (l + y) / 4
              , O = (g + v) / 4;
            return T > S && T > E ? T < .01 ? (n = 0,
            i = .707106781,
            s = .707106781) : (n = Math.sqrt(T),
            i = P / n,
            s = R / n) : S > E ? S < .01 ? (n = .707106781,
            i = 0,
            s = .707106781) : (i = Math.sqrt(S),
            n = P / i,
            s = O / i) : E < .01 ? (n = .707106781,
            i = .707106781,
            s = 0) : (s = Math.sqrt(E),
            n = R / s,
            i = O / s),
            this.set(n, i, s, t),
            this
        }
        let b = Math.sqrt((v - g) * (v - g) + (l - y) * (l - y) + (f - d) * (f - d));
        return Math.abs(b) < .001 && (b = 1),
        this.x = (v - g) / b,
        this.y = (l - y) / b,
        this.z = (f - d) / b,
        this.w = Math.acos((h + p + _ - 1) / 2),
        this
    }
    min(e) {
        return this.x = Math.min(this.x, e.x),
        this.y = Math.min(this.y, e.y),
        this.z = Math.min(this.z, e.z),
        this.w = Math.min(this.w, e.w),
        this
    }
    max(e) {
        return this.x = Math.max(this.x, e.x),
        this.y = Math.max(this.y, e.y),
        this.z = Math.max(this.z, e.z),
        this.w = Math.max(this.w, e.w),
        this
    }
    clamp(e, t) {
        return this.x = Math.max(e.x, Math.min(t.x, this.x)),
        this.y = Math.max(e.y, Math.min(t.y, this.y)),
        this.z = Math.max(e.z, Math.min(t.z, this.z)),
        this.w = Math.max(e.w, Math.min(t.w, this.w)),
        this
    }
    clampScalar(e, t) {
        return this.x = Math.max(e, Math.min(t, this.x)),
        this.y = Math.max(e, Math.min(t, this.y)),
        this.z = Math.max(e, Math.min(t, this.z)),
        this.w = Math.max(e, Math.min(t, this.w)),
        this
    }
    clampLength(e, t) {
        const n = this.length();
        return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)))
    }
    floor() {
        return this.x = Math.floor(this.x),
        this.y = Math.floor(this.y),
        this.z = Math.floor(this.z),
        this.w = Math.floor(this.w),
        this
    }
    ceil() {
        return this.x = Math.ceil(this.x),
        this.y = Math.ceil(this.y),
        this.z = Math.ceil(this.z),
        this.w = Math.ceil(this.w),
        this
    }
    round() {
        return this.x = Math.round(this.x),
        this.y = Math.round(this.y),
        this.z = Math.round(this.z),
        this.w = Math.round(this.w),
        this
    }
    roundToZero() {
        return this.x = Math.trunc(this.x),
        this.y = Math.trunc(this.y),
        this.z = Math.trunc(this.z),
        this.w = Math.trunc(this.w),
        this
    }
    negate() {
        return this.x = -this.x,
        this.y = -this.y,
        this.z = -this.z,
        this.w = -this.w,
        this
    }
    dot(e) {
        return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w
    }
    lengthSq() {
        return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
    }
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
    }
    manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
    }
    normalize() {
        return this.divideScalar(this.length() || 1)
    }
    setLength(e) {
        return this.normalize().multiplyScalar(e)
    }
    lerp(e, t) {
        return this.x += (e.x - this.x) * t,
        this.y += (e.y - this.y) * t,
        this.z += (e.z - this.z) * t,
        this.w += (e.w - this.w) * t,
        this
    }
    lerpVectors(e, t, n) {
        return this.x = e.x + (t.x - e.x) * n,
        this.y = e.y + (t.y - e.y) * n,
        this.z = e.z + (t.z - e.z) * n,
        this.w = e.w + (t.w - e.w) * n,
        this
    }
    equals(e) {
        return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w
    }
    fromArray(e, t=0) {
        return this.x = e[t],
        this.y = e[t + 1],
        this.z = e[t + 2],
        this.w = e[t + 3],
        this
    }
    toArray(e=[], t=0) {
        return e[t] = this.x,
        e[t + 1] = this.y,
        e[t + 2] = this.z,
        e[t + 3] = this.w,
        e
    }
    fromBufferAttribute(e, t) {
        return this.x = e.getX(t),
        this.y = e.getY(t),
        this.z = e.getZ(t),
        this.w = e.getW(t),
        this
    }
    random() {
        return this.x = Math.random(),
        this.y = Math.random(),
        this.z = Math.random(),
        this.w = Math.random(),
        this
    }
    *[Symbol.iterator]() {
        yield this.x,
        yield this.y,
        yield this.z,
        yield this.w
    }
}
class vD extends Sr {
    constructor(e=1, t=1, n={}) {
        super(),
        this.isRenderTarget = !0,
        this.width = e,
        this.height = t,
        this.depth = 1,
        this.scissor = new Ct(0,0,e,t),
        this.scissorTest = !1,
        this.viewport = new Ct(0,0,e,t);
        const i = {
            width: e,
            height: t,
            depth: 1
        };
        n.encoding !== void 0 && (xc("THREE.WebGLRenderTarget: option.encoding has been replaced by option.colorSpace."),
        n.colorSpace = n.encoding === Dr ? Ft : Ni),
        n = Object.assign({
            generateMipmaps: !1,
            internalFormat: null,
            minFilter: Ot,
            depthBuffer: !0,
            stencilBuffer: !1,
            depthTexture: null,
            samples: 0
        }, n),
        this.texture = new Pn(i,n.mapping,n.wrapS,n.wrapT,n.magFilter,n.minFilter,n.format,n.type,n.anisotropy,n.colorSpace),
        this.texture.isRenderTargetTexture = !0,
        this.texture.flipY = !1,
        this.texture.generateMipmaps = n.generateMipmaps,
        this.texture.internalFormat = n.internalFormat,
        this.depthBuffer = n.depthBuffer,
        this.stencilBuffer = n.stencilBuffer,
        this.depthTexture = n.depthTexture,
        this.samples = n.samples
    }
    setSize(e, t, n=1) {
        (this.width !== e || this.height !== t || this.depth !== n) && (this.width = e,
        this.height = t,
        this.depth = n,
        this.texture.image.width = e,
        this.texture.image.height = t,
        this.texture.image.depth = n,
        this.dispose()),
        this.viewport.set(0, 0, e, t),
        this.scissor.set(0, 0, e, t)
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        this.width = e.width,
        this.height = e.height,
        this.depth = e.depth,
        this.scissor.copy(e.scissor),
        this.scissorTest = e.scissorTest,
        this.viewport.copy(e.viewport),
        this.texture = e.texture.clone(),
        this.texture.isRenderTargetTexture = !0;
        const t = Object.assign({}, e.texture.image);
        return this.texture.source = new Cb(t),
        this.depthBuffer = e.depthBuffer,
        this.stencilBuffer = e.stencilBuffer,
        e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()),
        this.samples = e.samples,
        this
    }
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
}
class vn extends vD {
    constructor(e=1, t=1, n={}) {
        super(e, t, n),
        this.isWebGLRenderTarget = !0
    }
}
class Ib extends Pn {
    constructor(e=null, t=1, n=1, i=1) {
        super(null),
        this.isDataArrayTexture = !0,
        this.image = {
            data: e,
            width: t,
            height: n,
            depth: i
        },
        this.magFilter = Jt,
        this.minFilter = Jt,
        this.wrapR = hi,
        this.generateMipmaps = !1,
        this.flipY = !1,
        this.unpackAlignment = 1
    }
}
class Tc extends Pn {
    constructor(e=null, t=1, n=1, i=1) {
        super(null),
        this.isData3DTexture = !0,
        this.image = {
            data: e,
            width: t,
            height: n,
            depth: i
        },
        this.magFilter = Jt,
        this.minFilter = Jt,
        this.wrapR = hi,
        this.generateMipmaps = !1,
        this.flipY = !1,
        this.unpackAlignment = 1
    }
}
class Hi {
    constructor(e=0, t=0, n=0, i=1) {
        this.isQuaternion = !0,
        this._x = e,
        this._y = t,
        this._z = n,
        this._w = i
    }
    static slerpFlat(e, t, n, i, s, o, a) {
        let c = n[i + 0]
          , h = n[i + 1]
          , d = n[i + 2]
          , l = n[i + 3];
        const f = s[o + 0]
          , p = s[o + 1]
          , g = s[o + 2]
          , y = s[o + 3];
        if (a === 0) {
            e[t + 0] = c,
            e[t + 1] = h,
            e[t + 2] = d,
            e[t + 3] = l;
            return
        }
        if (a === 1) {
            e[t + 0] = f,
            e[t + 1] = p,
            e[t + 2] = g,
            e[t + 3] = y;
            return
        }
        if (l !== y || c !== f || h !== p || d !== g) {
            let v = 1 - a;
            const _ = c * f + h * p + d * g + l * y
              , b = _ >= 0 ? 1 : -1
              , T = 1 - _ * _;
            if (T > Number.EPSILON) {
                const E = Math.sqrt(T)
                  , P = Math.atan2(E, _ * b);
                v = Math.sin(v * P) / E,
                a = Math.sin(a * P) / E
            }
            const S = a * b;
            if (c = c * v + f * S,
            h = h * v + p * S,
            d = d * v + g * S,
            l = l * v + y * S,
            v === 1 - a) {
                const E = 1 / Math.sqrt(c * c + h * h + d * d + l * l);
                c *= E,
                h *= E,
                d *= E,
                l *= E
            }
        }
        e[t] = c,
        e[t + 1] = h,
        e[t + 2] = d,
        e[t + 3] = l
    }
    static multiplyQuaternionsFlat(e, t, n, i, s, o) {
        const a = n[i]
          , c = n[i + 1]
          , h = n[i + 2]
          , d = n[i + 3]
          , l = s[o]
          , f = s[o + 1]
          , p = s[o + 2]
          , g = s[o + 3];
        return e[t] = a * g + d * l + c * p - h * f,
        e[t + 1] = c * g + d * f + h * l - a * p,
        e[t + 2] = h * g + d * p + a * f - c * l,
        e[t + 3] = d * g - a * l - c * f - h * p,
        e
    }
    get x() {
        return this._x
    }
    set x(e) {
        this._x = e,
        this._onChangeCallback()
    }
    get y() {
        return this._y
    }
    set y(e) {
        this._y = e,
        this._onChangeCallback()
    }
    get z() {
        return this._z
    }
    set z(e) {
        this._z = e,
        this._onChangeCallback()
    }
    get w() {
        return this._w
    }
    set w(e) {
        this._w = e,
        this._onChangeCallback()
    }
    set(e, t, n, i) {
        return this._x = e,
        this._y = t,
        this._z = n,
        this._w = i,
        this._onChangeCallback(),
        this
    }
    clone() {
        return new this.constructor(this._x,this._y,this._z,this._w)
    }
    copy(e) {
        return this._x = e.x,
        this._y = e.y,
        this._z = e.z,
        this._w = e.w,
        this._onChangeCallback(),
        this
    }
    setFromEuler(e, t) {
        const n = e._x
          , i = e._y
          , s = e._z
          , o = e._order
          , a = Math.cos
          , c = Math.sin
          , h = a(n / 2)
          , d = a(i / 2)
          , l = a(s / 2)
          , f = c(n / 2)
          , p = c(i / 2)
          , g = c(s / 2);
        switch (o) {
        case "XYZ":
            this._x = f * d * l + h * p * g,
            this._y = h * p * l - f * d * g,
            this._z = h * d * g + f * p * l,
            this._w = h * d * l - f * p * g;
            break;
        case "YXZ":
            this._x = f * d * l + h * p * g,
            this._y = h * p * l - f * d * g,
            this._z = h * d * g - f * p * l,
            this._w = h * d * l + f * p * g;
            break;
        case "ZXY":
            this._x = f * d * l - h * p * g,
            this._y = h * p * l + f * d * g,
            this._z = h * d * g + f * p * l,
            this._w = h * d * l - f * p * g;
            break;
        case "ZYX":
            this._x = f * d * l - h * p * g,
            this._y = h * p * l + f * d * g,
            this._z = h * d * g - f * p * l,
            this._w = h * d * l + f * p * g;
            break;
        case "YZX":
            this._x = f * d * l + h * p * g,
            this._y = h * p * l + f * d * g,
            this._z = h * d * g - f * p * l,
            this._w = h * d * l - f * p * g;
            break;
        case "XZY":
            this._x = f * d * l - h * p * g,
            this._y = h * p * l - f * d * g,
            this._z = h * d * g + f * p * l,
            this._w = h * d * l + f * p * g;
            break;
        default:
            console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + o)
        }
        return t !== !1 && this._onChangeCallback(),
        this
    }
    setFromAxisAngle(e, t) {
        const n = t / 2
          , i = Math.sin(n);
        return this._x = e.x * i,
        this._y = e.y * i,
        this._z = e.z * i,
        this._w = Math.cos(n),
        this._onChangeCallback(),
        this
    }
    setFromRotationMatrix(e) {
        const t = e.elements
          , n = t[0]
          , i = t[4]
          , s = t[8]
          , o = t[1]
          , a = t[5]
          , c = t[9]
          , h = t[2]
          , d = t[6]
          , l = t[10]
          , f = n + a + l;
        if (f > 0) {
            const p = .5 / Math.sqrt(f + 1);
            this._w = .25 / p,
            this._x = (d - c) * p,
            this._y = (s - h) * p,
            this._z = (o - i) * p
        } else if (n > a && n > l) {
            const p = 2 * Math.sqrt(1 + n - a - l);
            this._w = (d - c) / p,
            this._x = .25 * p,
            this._y = (i + o) / p,
            this._z = (s + h) / p
        } else if (a > l) {
            const p = 2 * Math.sqrt(1 + a - n - l);
            this._w = (s - h) / p,
            this._x = (i + o) / p,
            this._y = .25 * p,
            this._z = (c + d) / p
        } else {
            const p = 2 * Math.sqrt(1 + l - n - a);
            this._w = (o - i) / p,
            this._x = (s + h) / p,
            this._y = (c + d) / p,
            this._z = .25 * p
        }
        return this._onChangeCallback(),
        this
    }
    setFromUnitVectors(e, t) {
        let n = e.dot(t) + 1;
        return n < Number.EPSILON ? (n = 0,
        Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y,
        this._y = e.x,
        this._z = 0,
        this._w = n) : (this._x = 0,
        this._y = -e.z,
        this._z = e.y,
        this._w = n)) : (this._x = e.y * t.z - e.z * t.y,
        this._y = e.z * t.x - e.x * t.z,
        this._z = e.x * t.y - e.y * t.x,
        this._w = n),
        this.normalize()
    }
    angleTo(e) {
        return 2 * Math.acos(Math.abs(Hn(this.dot(e), -1, 1)))
    }
    rotateTowards(e, t) {
        const n = this.angleTo(e);
        if (n === 0)
            return this;
        const i = Math.min(1, t / n);
        return this.slerp(e, i),
        this
    }
    identity() {
        return this.set(0, 0, 0, 1)
    }
    invert() {
        return this.conjugate()
    }
    conjugate() {
        return this._x *= -1,
        this._y *= -1,
        this._z *= -1,
        this._onChangeCallback(),
        this
    }
    dot(e) {
        return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w
    }
    lengthSq() {
        return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
    }
    length() {
        return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
    }
    normalize() {
        let e = this.length();
        return e === 0 ? (this._x = 0,
        this._y = 0,
        this._z = 0,
        this._w = 1) : (e = 1 / e,
        this._x = this._x * e,
        this._y = this._y * e,
        this._z = this._z * e,
        this._w = this._w * e),
        this._onChangeCallback(),
        this
    }
    multiply(e) {
        return this.multiplyQuaternions(this, e)
    }
    premultiply(e) {
        return this.multiplyQuaternions(e, this)
    }
    multiplyQuaternions(e, t) {
        const n = e._x
          , i = e._y
          , s = e._z
          , o = e._w
          , a = t._x
          , c = t._y
          , h = t._z
          , d = t._w;
        return this._x = n * d + o * a + i * h - s * c,
        this._y = i * d + o * c + s * a - n * h,
        this._z = s * d + o * h + n * c - i * a,
        this._w = o * d - n * a - i * c - s * h,
        this._onChangeCallback(),
        this
    }
    slerp(e, t) {
        if (t === 0)
            return this;
        if (t === 1)
            return this.copy(e);
        const n = this._x
          , i = this._y
          , s = this._z
          , o = this._w;
        let a = o * e._w + n * e._x + i * e._y + s * e._z;
        if (a < 0 ? (this._w = -e._w,
        this._x = -e._x,
        this._y = -e._y,
        this._z = -e._z,
        a = -a) : this.copy(e),
        a >= 1)
            return this._w = o,
            this._x = n,
            this._y = i,
            this._z = s,
            this;
        const c = 1 - a * a;
        if (c <= Number.EPSILON) {
            const p = 1 - t;
            return this._w = p * o + t * this._w,
            this._x = p * n + t * this._x,
            this._y = p * i + t * this._y,
            this._z = p * s + t * this._z,
            this.normalize(),
            this._onChangeCallback(),
            this
        }
        const h = Math.sqrt(c)
          , d = Math.atan2(h, a)
          , l = Math.sin((1 - t) * d) / h
          , f = Math.sin(t * d) / h;
        return this._w = o * l + this._w * f,
        this._x = n * l + this._x * f,
        this._y = i * l + this._y * f,
        this._z = s * l + this._z * f,
        this._onChangeCallback(),
        this
    }
    slerpQuaternions(e, t, n) {
        return this.copy(e).slerp(t, n)
    }
    random() {
        const e = Math.random()
          , t = Math.sqrt(1 - e)
          , n = Math.sqrt(e)
          , i = 2 * Math.PI * Math.random()
          , s = 2 * Math.PI * Math.random();
        return this.set(t * Math.cos(i), n * Math.sin(s), n * Math.cos(s), t * Math.sin(i))
    }
    equals(e) {
        return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w
    }
    fromArray(e, t=0) {
        return this._x = e[t],
        this._y = e[t + 1],
        this._z = e[t + 2],
        this._w = e[t + 3],
        this._onChangeCallback(),
        this
    }
    toArray(e=[], t=0) {
        return e[t] = this._x,
        e[t + 1] = this._y,
        e[t + 2] = this._z,
        e[t + 3] = this._w,
        e
    }
    fromBufferAttribute(e, t) {
        return this._x = e.getX(t),
        this._y = e.getY(t),
        this._z = e.getZ(t),
        this._w = e.getW(t),
        this
    }
    toJSON() {
        return this.toArray()
    }
    _onChange(e) {
        return this._onChangeCallback = e,
        this
    }
    _onChangeCallback() {}
    *[Symbol.iterator]() {
        yield this._x,
        yield this._y,
        yield this._z,
        yield this._w
    }
}
class k {
    constructor(e=0, t=0, n=0) {
        k.prototype.isVector3 = !0,
        this.x = e,
        this.y = t,
        this.z = n
    }
    set(e, t, n) {
        return n === void 0 && (n = this.z),
        this.x = e,
        this.y = t,
        this.z = n,
        this
    }
    setScalar(e) {
        return this.x = e,
        this.y = e,
        this.z = e,
        this
    }
    setX(e) {
        return this.x = e,
        this
    }
    setY(e) {
        return this.y = e,
        this
    }
    setZ(e) {
        return this.z = e,
        this
    }
    setComponent(e, t) {
        switch (e) {
        case 0:
            this.x = t;
            break;
        case 1:
            this.y = t;
            break;
        case 2:
            this.z = t;
            break;
        default:
            throw new Error("index is out of range: " + e)
        }
        return this
    }
    getComponent(e) {
        switch (e) {
        case 0:
            return this.x;
        case 1:
            return this.y;
        case 2:
            return this.z;
        default:
            throw new Error("index is out of range: " + e)
        }
    }
    clone() {
        return new this.constructor(this.x,this.y,this.z)
    }
    copy(e) {
        return this.x = e.x,
        this.y = e.y,
        this.z = e.z,
        this
    }
    add(e) {
        return this.x += e.x,
        this.y += e.y,
        this.z += e.z,
        this
    }
    addScalar(e) {
        return this.x += e,
        this.y += e,
        this.z += e,
        this
    }
    addVectors(e, t) {
        return this.x = e.x + t.x,
        this.y = e.y + t.y,
        this.z = e.z + t.z,
        this
    }
    addScaledVector(e, t) {
        return this.x += e.x * t,
        this.y += e.y * t,
        this.z += e.z * t,
        this
    }
    sub(e) {
        return this.x -= e.x,
        this.y -= e.y,
        this.z -= e.z,
        this
    }
    subScalar(e) {
        return this.x -= e,
        this.y -= e,
        this.z -= e,
        this
    }
    subVectors(e, t) {
        return this.x = e.x - t.x,
        this.y = e.y - t.y,
        this.z = e.z - t.z,
        this
    }
    multiply(e) {
        return this.x *= e.x,
        this.y *= e.y,
        this.z *= e.z,
        this
    }
    multiplyScalar(e) {
        return this.x *= e,
        this.y *= e,
        this.z *= e,
        this
    }
    multiplyVectors(e, t) {
        return this.x = e.x * t.x,
        this.y = e.y * t.y,
        this.z = e.z * t.z,
        this
    }
    applyEuler(e) {
        return this.applyQuaternion(ty.setFromEuler(e))
    }
    applyAxisAngle(e, t) {
        return this.applyQuaternion(ty.setFromAxisAngle(e, t))
    }
    applyMatrix3(e) {
        const t = this.x
          , n = this.y
          , i = this.z
          , s = e.elements;
        return this.x = s[0] * t + s[3] * n + s[6] * i,
        this.y = s[1] * t + s[4] * n + s[7] * i,
        this.z = s[2] * t + s[5] * n + s[8] * i,
        this
    }
    applyNormalMatrix(e) {
        return this.applyMatrix3(e).normalize()
    }
    applyMatrix4(e) {
        const t = this.x
          , n = this.y
          , i = this.z
          , s = e.elements
          , o = 1 / (s[3] * t + s[7] * n + s[11] * i + s[15]);
        return this.x = (s[0] * t + s[4] * n + s[8] * i + s[12]) * o,
        this.y = (s[1] * t + s[5] * n + s[9] * i + s[13]) * o,
        this.z = (s[2] * t + s[6] * n + s[10] * i + s[14]) * o,
        this
    }
    applyQuaternion(e) {
        const t = this.x
          , n = this.y
          , i = this.z
          , s = e.x
          , o = e.y
          , a = e.z
          , c = e.w
          , h = 2 * (o * i - a * n)
          , d = 2 * (a * t - s * i)
          , l = 2 * (s * n - o * t);
        return this.x = t + c * h + o * l - a * d,
        this.y = n + c * d + a * h - s * l,
        this.z = i + c * l + s * d - o * h,
        this
    }
    project(e) {
        return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)
    }
    unproject(e) {
        return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld)
    }
    transformDirection(e) {
        const t = this.x
          , n = this.y
          , i = this.z
          , s = e.elements;
        return this.x = s[0] * t + s[4] * n + s[8] * i,
        this.y = s[1] * t + s[5] * n + s[9] * i,
        this.z = s[2] * t + s[6] * n + s[10] * i,
        this.normalize()
    }
    divide(e) {
        return this.x /= e.x,
        this.y /= e.y,
        this.z /= e.z,
        this
    }
    divideScalar(e) {
        return this.multiplyScalar(1 / e)
    }
    min(e) {
        return this.x = Math.min(this.x, e.x),
        this.y = Math.min(this.y, e.y),
        this.z = Math.min(this.z, e.z),
        this
    }
    max(e) {
        return this.x = Math.max(this.x, e.x),
        this.y = Math.max(this.y, e.y),
        this.z = Math.max(this.z, e.z),
        this
    }
    clamp(e, t) {
        return this.x = Math.max(e.x, Math.min(t.x, this.x)),
        this.y = Math.max(e.y, Math.min(t.y, this.y)),
        this.z = Math.max(e.z, Math.min(t.z, this.z)),
        this
    }
    clampScalar(e, t) {
        return this.x = Math.max(e, Math.min(t, this.x)),
        this.y = Math.max(e, Math.min(t, this.y)),
        this.z = Math.max(e, Math.min(t, this.z)),
        this
    }
    clampLength(e, t) {
        const n = this.length();
        return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)))
    }
    floor() {
        return this.x = Math.floor(this.x),
        this.y = Math.floor(this.y),
        this.z = Math.floor(this.z),
        this
    }
    ceil() {
        return this.x = Math.ceil(this.x),
        this.y = Math.ceil(this.y),
        this.z = Math.ceil(this.z),
        this
    }
    round() {
        return this.x = Math.round(this.x),
        this.y = Math.round(this.y),
        this.z = Math.round(this.z),
        this
    }
    roundToZero() {
        return this.x = Math.trunc(this.x),
        this.y = Math.trunc(this.y),
        this.z = Math.trunc(this.z),
        this
    }
    negate() {
        return this.x = -this.x,
        this.y = -this.y,
        this.z = -this.z,
        this
    }
    dot(e) {
        return this.x * e.x + this.y * e.y + this.z * e.z
    }
    lengthSq() {
        return this.x * this.x + this.y * this.y + this.z * this.z
    }
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
    }
    manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
    }
    normalize() {
        return this.divideScalar(this.length() || 1)
    }
    setLength(e) {
        return this.normalize().multiplyScalar(e)
    }
    lerp(e, t) {
        return this.x += (e.x - this.x) * t,
        this.y += (e.y - this.y) * t,
        this.z += (e.z - this.z) * t,
        this
    }
    lerpVectors(e, t, n) {
        return this.x = e.x + (t.x - e.x) * n,
        this.y = e.y + (t.y - e.y) * n,
        this.z = e.z + (t.z - e.z) * n,
        this
    }
    cross(e) {
        return this.crossVectors(this, e)
    }
    crossVectors(e, t) {
        const n = e.x
          , i = e.y
          , s = e.z
          , o = t.x
          , a = t.y
          , c = t.z;
        return this.x = i * c - s * a,
        this.y = s * o - n * c,
        this.z = n * a - i * o,
        this
    }
    projectOnVector(e) {
        const t = e.lengthSq();
        if (t === 0)
            return this.set(0, 0, 0);
        const n = e.dot(this) / t;
        return this.copy(e).multiplyScalar(n)
    }
    projectOnPlane(e) {
        return yp.copy(this).projectOnVector(e),
        this.sub(yp)
    }
    reflect(e) {
        return this.sub(yp.copy(e).multiplyScalar(2 * this.dot(e)))
    }
    angleTo(e) {
        const t = Math.sqrt(this.lengthSq() * e.lengthSq());
        if (t === 0)
            return Math.PI / 2;
        const n = this.dot(e) / t;
        return Math.acos(Hn(n, -1, 1))
    }
    distanceTo(e) {
        return Math.sqrt(this.distanceToSquared(e))
    }
    distanceToSquared(e) {
        const t = this.x - e.x
          , n = this.y - e.y
          , i = this.z - e.z;
        return t * t + n * n + i * i
    }
    manhattanDistanceTo(e) {
        return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z)
    }
    setFromSpherical(e) {
        return this.setFromSphericalCoords(e.radius, e.phi, e.theta)
    }
    setFromSphericalCoords(e, t, n) {
        const i = Math.sin(t) * e;
        return this.x = i * Math.sin(n),
        this.y = Math.cos(t) * e,
        this.z = i * Math.cos(n),
        this
    }
    setFromCylindrical(e) {
        return this.setFromCylindricalCoords(e.radius, e.theta, e.y)
    }
    setFromCylindricalCoords(e, t, n) {
        return this.x = e * Math.sin(t),
        this.y = n,
        this.z = e * Math.cos(t),
        this
    }
    setFromMatrixPosition(e) {
        const t = e.elements;
        return this.x = t[12],
        this.y = t[13],
        this.z = t[14],
        this
    }
    setFromMatrixScale(e) {
        const t = this.setFromMatrixColumn(e, 0).length()
          , n = this.setFromMatrixColumn(e, 1).length()
          , i = this.setFromMatrixColumn(e, 2).length();
        return this.x = t,
        this.y = n,
        this.z = i,
        this
    }
    setFromMatrixColumn(e, t) {
        return this.fromArray(e.elements, t * 4)
    }
    setFromMatrix3Column(e, t) {
        return this.fromArray(e.elements, t * 3)
    }
    setFromEuler(e) {
        return this.x = e._x,
        this.y = e._y,
        this.z = e._z,
        this
    }
    setFromColor(e) {
        return this.x = e.r,
        this.y = e.g,
        this.z = e.b,
        this
    }
    equals(e) {
        return e.x === this.x && e.y === this.y && e.z === this.z
    }
    fromArray(e, t=0) {
        return this.x = e[t],
        this.y = e[t + 1],
        this.z = e[t + 2],
        this
    }
    toArray(e=[], t=0) {
        return e[t] = this.x,
        e[t + 1] = this.y,
        e[t + 2] = this.z,
        e
    }
    fromBufferAttribute(e, t) {
        return this.x = e.getX(t),
        this.y = e.getY(t),
        this.z = e.getZ(t),
        this
    }
    random() {
        return this.x = Math.random(),
        this.y = Math.random(),
        this.z = Math.random(),
        this
    }
    randomDirection() {
        const e = (Math.random() - .5) * 2
          , t = Math.random() * Math.PI * 2
          , n = Math.sqrt(1 - e ** 2);
        return this.x = n * Math.cos(t),
        this.y = n * Math.sin(t),
        this.z = e,
        this
    }
    *[Symbol.iterator]() {
        yield this.x,
        yield this.y,
        yield this.z
    }
}
const yp = new k
  , ty = new Hi;
class yn {
    constructor(e=new k(1 / 0,1 / 0,1 / 0), t=new k(-1 / 0,-1 / 0,-1 / 0)) {
        this.isBox3 = !0,
        this.min = e,
        this.max = t
    }
    set(e, t) {
        return this.min.copy(e),
        this.max.copy(t),
        this
    }
    setFromArray(e) {
        this.makeEmpty();
        for (let t = 0, n = e.length; t < n; t += 3)
            this.expandByPoint(ur.fromArray(e, t));
        return this
    }
    setFromBufferAttribute(e) {
        this.makeEmpty();
        for (let t = 0, n = e.count; t < n; t++)
            this.expandByPoint(ur.fromBufferAttribute(e, t));
        return this
    }
    setFromPoints(e) {
        this.makeEmpty();
        for (let t = 0, n = e.length; t < n; t++)
            this.expandByPoint(e[t]);
        return this
    }
    setFromCenterAndSize(e, t) {
        const n = ur.copy(t).multiplyScalar(.5);
        return this.min.copy(e).sub(n),
        this.max.copy(e).add(n),
        this
    }
    setFromObject(e, t=!1) {
        return this.makeEmpty(),
        this.expandByObject(e, t)
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        return this.min.copy(e.min),
        this.max.copy(e.max),
        this
    }
    makeEmpty() {
        return this.min.x = this.min.y = this.min.z = 1 / 0,
        this.max.x = this.max.y = this.max.z = -1 / 0,
        this
    }
    isEmpty() {
        return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
    }
    getCenter(e) {
        return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
    }
    getSize(e) {
        return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min)
    }
    expandByPoint(e) {
        return this.min.min(e),
        this.max.max(e),
        this
    }
    expandByVector(e) {
        return this.min.sub(e),
        this.max.add(e),
        this
    }
    expandByScalar(e) {
        return this.min.addScalar(-e),
        this.max.addScalar(e),
        this
    }
    expandByObject(e, t=!1) {
        e.updateWorldMatrix(!1, !1);
        const n = e.geometry;
        if (n !== void 0) {
            const s = n.getAttribute("position");
            if (t === !0 && s !== void 0 && e.isInstancedMesh !== !0)
                for (let o = 0, a = s.count; o < a; o++)
                    e.isMesh === !0 ? e.getVertexPosition(o, ur) : ur.fromBufferAttribute(s, o),
                    ur.applyMatrix4(e.matrixWorld),
                    this.expandByPoint(ur);
            else
                e.boundingBox !== void 0 ? (e.boundingBox === null && e.computeBoundingBox(),
                Ou.copy(e.boundingBox)) : (n.boundingBox === null && n.computeBoundingBox(),
                Ou.copy(n.boundingBox)),
                Ou.applyMatrix4(e.matrixWorld),
                this.union(Ou)
        }
        const i = e.children;
        for (let s = 0, o = i.length; s < o; s++)
            this.expandByObject(i[s], t);
        return this
    }
    containsPoint(e) {
        return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y || e.z < this.min.z || e.z > this.max.z)
    }
    containsBox(e) {
        return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z
    }
    getParameter(e, t) {
        return t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z))
    }
    intersectsBox(e) {
        return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y || e.max.z < this.min.z || e.min.z > this.max.z)
    }
    intersectsSphere(e) {
        return this.clampPoint(e.center, ur),
        ur.distanceToSquared(e.center) <= e.radius * e.radius
    }
    intersectsPlane(e) {
        let t, n;
        return e.normal.x > 0 ? (t = e.normal.x * this.min.x,
        n = e.normal.x * this.max.x) : (t = e.normal.x * this.max.x,
        n = e.normal.x * this.min.x),
        e.normal.y > 0 ? (t += e.normal.y * this.min.y,
        n += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y,
        n += e.normal.y * this.min.y),
        e.normal.z > 0 ? (t += e.normal.z * this.min.z,
        n += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z,
        n += e.normal.z * this.min.z),
        t <= -e.constant && n >= -e.constant
    }
    intersectsTriangle(e) {
        if (this.isEmpty())
            return !1;
        this.getCenter(Kl),
        Uu.subVectors(this.max, Kl),
        aa.subVectors(e.a, Kl),
        la.subVectors(e.b, Kl),
        ca.subVectors(e.c, Kl),
        gs.subVectors(la, aa),
        vs.subVectors(ca, la),
        mo.subVectors(aa, ca);
        let t = [0, -gs.z, gs.y, 0, -vs.z, vs.y, 0, -mo.z, mo.y, gs.z, 0, -gs.x, vs.z, 0, -vs.x, mo.z, 0, -mo.x, -gs.y, gs.x, 0, -vs.y, vs.x, 0, -mo.y, mo.x, 0];
        return !xp(t, aa, la, ca, Uu) || (t = [1, 0, 0, 0, 1, 0, 0, 0, 1],
        !xp(t, aa, la, ca, Uu)) ? !1 : (Nu.crossVectors(gs, vs),
        t = [Nu.x, Nu.y, Nu.z],
        xp(t, aa, la, ca, Uu))
    }
    clampPoint(e, t) {
        return t.copy(e).clamp(this.min, this.max)
    }
    distanceToPoint(e) {
        return this.clampPoint(e, ur).distanceTo(e)
    }
    getBoundingSphere(e) {
        return this.isEmpty() ? e.makeEmpty() : (this.getCenter(e.center),
        e.radius = this.getSize(ur).length() * .5),
        e
    }
    intersect(e) {
        return this.min.max(e.min),
        this.max.min(e.max),
        this.isEmpty() && this.makeEmpty(),
        this
    }
    union(e) {
        return this.min.min(e.min),
        this.max.max(e.max),
        this
    }
    applyMatrix4(e) {
        return this.isEmpty() ? this : (Xr[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e),
        Xr[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e),
        Xr[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e),
        Xr[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e),
        Xr[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e),
        Xr[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e),
        Xr[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e),
        Xr[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e),
        this.setFromPoints(Xr),
        this)
    }
    translate(e) {
        return this.min.add(e),
        this.max.add(e),
        this
    }
    equals(e) {
        return e.min.equals(this.min) && e.max.equals(this.max)
    }
}
const Xr = [new k, new k, new k, new k, new k, new k, new k, new k]
  , ur = new k
  , Ou = new yn
  , aa = new k
  , la = new k
  , ca = new k
  , gs = new k
  , vs = new k
  , mo = new k
  , Kl = new k
  , Uu = new k
  , Nu = new k
  , _o = new k;
function xp(r, e, t, n, i) {
    for (let s = 0, o = r.length - 3; s <= o; s += 3) {
        _o.fromArray(r, s);
        const a = i.x * Math.abs(_o.x) + i.y * Math.abs(_o.y) + i.z * Math.abs(_o.z)
          , c = e.dot(_o)
          , h = t.dot(_o)
          , d = n.dot(_o);
        if (Math.max(-Math.max(c, h, d), Math.min(c, h, d)) > a)
            return !1
    }
    return !0
}
const yD = new yn
  , Yl = new k
  , Tp = new k;
class Mr {
    constructor(e=new k, t=-1) {
        this.center = e,
        this.radius = t
    }
    set(e, t) {
        return this.center.copy(e),
        this.radius = t,
        this
    }
    setFromPoints(e, t) {
        const n = this.center;
        t !== void 0 ? n.copy(t) : yD.setFromPoints(e).getCenter(n);
        let i = 0;
        for (let s = 0, o = e.length; s < o; s++)
            i = Math.max(i, n.distanceToSquared(e[s]));
        return this.radius = Math.sqrt(i),
        this
    }
    copy(e) {
        return this.center.copy(e.center),
        this.radius = e.radius,
        this
    }
    isEmpty() {
        return this.radius < 0
    }
    makeEmpty() {
        return this.center.set(0, 0, 0),
        this.radius = -1,
        this
    }
    containsPoint(e) {
        return e.distanceToSquared(this.center) <= this.radius * this.radius
    }
    distanceToPoint(e) {
        return e.distanceTo(this.center) - this.radius
    }
    intersectsSphere(e) {
        const t = this.radius + e.radius;
        return e.center.distanceToSquared(this.center) <= t * t
    }
    intersectsBox(e) {
        return e.intersectsSphere(this)
    }
    intersectsPlane(e) {
        return Math.abs(e.distanceToPoint(this.center)) <= this.radius
    }
    clampPoint(e, t) {
        const n = this.center.distanceToSquared(e);
        return t.copy(e),
        n > this.radius * this.radius && (t.sub(this.center).normalize(),
        t.multiplyScalar(this.radius).add(this.center)),
        t
    }
    getBoundingBox(e) {
        return this.isEmpty() ? (e.makeEmpty(),
        e) : (e.set(this.center, this.center),
        e.expandByScalar(this.radius),
        e)
    }
    applyMatrix4(e) {
        return this.center.applyMatrix4(e),
        this.radius = this.radius * e.getMaxScaleOnAxis(),
        this
    }
    translate(e) {
        return this.center.add(e),
        this
    }
    expandByPoint(e) {
        if (this.isEmpty())
            return this.center.copy(e),
            this.radius = 0,
            this;
        Yl.subVectors(e, this.center);
        const t = Yl.lengthSq();
        if (t > this.radius * this.radius) {
            const n = Math.sqrt(t)
              , i = (n - this.radius) * .5;
            this.center.addScaledVector(Yl, i / n),
            this.radius += i
        }
        return this
    }
    union(e) {
        return e.isEmpty() ? this : this.isEmpty() ? (this.copy(e),
        this) : (this.center.equals(e.center) === !0 ? this.radius = Math.max(this.radius, e.radius) : (Tp.subVectors(e.center, this.center).setLength(e.radius),
        this.expandByPoint(Yl.copy(e.center).add(Tp)),
        this.expandByPoint(Yl.copy(e.center).sub(Tp))),
        this)
    }
    equals(e) {
        return e.center.equals(this.center) && e.radius === this.radius
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
const qr = new k
  , bp = new k
  , Fu = new k
  , ys = new k
  , Sp = new k
  , Bu = new k
  , Mp = new k;
class Bo {
    constructor(e=new k, t=new k(0,0,-1)) {
        this.origin = e,
        this.direction = t
    }
    set(e, t) {
        return this.origin.copy(e),
        this.direction.copy(t),
        this
    }
    copy(e) {
        return this.origin.copy(e.origin),
        this.direction.copy(e.direction),
        this
    }
    at(e, t) {
        return t.copy(this.origin).addScaledVector(this.direction, e)
    }
    lookAt(e) {
        return this.direction.copy(e).sub(this.origin).normalize(),
        this
    }
    recast(e) {
        return this.origin.copy(this.at(e, qr)),
        this
    }
    closestPointToPoint(e, t) {
        t.subVectors(e, this.origin);
        const n = t.dot(this.direction);
        return n < 0 ? t.copy(this.origin) : t.copy(this.origin).addScaledVector(this.direction, n)
    }
    distanceToPoint(e) {
        return Math.sqrt(this.distanceSqToPoint(e))
    }
    distanceSqToPoint(e) {
        const t = qr.subVectors(e, this.origin).dot(this.direction);
        return t < 0 ? this.origin.distanceToSquared(e) : (qr.copy(this.origin).addScaledVector(this.direction, t),
        qr.distanceToSquared(e))
    }
    distanceSqToSegment(e, t, n, i) {
        bp.copy(e).add(t).multiplyScalar(.5),
        Fu.copy(t).sub(e).normalize(),
        ys.copy(this.origin).sub(bp);
        const s = e.distanceTo(t) * .5
          , o = -this.direction.dot(Fu)
          , a = ys.dot(this.direction)
          , c = -ys.dot(Fu)
          , h = ys.lengthSq()
          , d = Math.abs(1 - o * o);
        let l, f, p, g;
        if (d > 0)
            if (l = o * c - a,
            f = o * a - c,
            g = s * d,
            l >= 0)
                if (f >= -g)
                    if (f <= g) {
                        const y = 1 / d;
                        l *= y,
                        f *= y,
                        p = l * (l + o * f + 2 * a) + f * (o * l + f + 2 * c) + h
                    } else
                        f = s,
                        l = Math.max(0, -(o * f + a)),
                        p = -l * l + f * (f + 2 * c) + h;
                else
                    f = -s,
                    l = Math.max(0, -(o * f + a)),
                    p = -l * l + f * (f + 2 * c) + h;
            else
                f <= -g ? (l = Math.max(0, -(-o * s + a)),
                f = l > 0 ? -s : Math.min(Math.max(-s, -c), s),
                p = -l * l + f * (f + 2 * c) + h) : f <= g ? (l = 0,
                f = Math.min(Math.max(-s, -c), s),
                p = f * (f + 2 * c) + h) : (l = Math.max(0, -(o * s + a)),
                f = l > 0 ? s : Math.min(Math.max(-s, -c), s),
                p = -l * l + f * (f + 2 * c) + h);
        else
            f = o > 0 ? -s : s,
            l = Math.max(0, -(o * f + a)),
            p = -l * l + f * (f + 2 * c) + h;
        return n && n.copy(this.origin).addScaledVector(this.direction, l),
        i && i.copy(bp).addScaledVector(Fu, f),
        p
    }
    intersectSphere(e, t) {
        qr.subVectors(e.center, this.origin);
        const n = qr.dot(this.direction)
          , i = qr.dot(qr) - n * n
          , s = e.radius * e.radius;
        if (i > s)
            return null;
        const o = Math.sqrt(s - i)
          , a = n - o
          , c = n + o;
        return c < 0 ? null : a < 0 ? this.at(c, t) : this.at(a, t)
    }
    intersectsSphere(e) {
        return this.distanceSqToPoint(e.center) <= e.radius * e.radius
    }
    distanceToPlane(e) {
        const t = e.normal.dot(this.direction);
        if (t === 0)
            return e.distanceToPoint(this.origin) === 0 ? 0 : null;
        const n = -(this.origin.dot(e.normal) + e.constant) / t;
        return n >= 0 ? n : null
    }
    intersectPlane(e, t) {
        const n = this.distanceToPlane(e);
        return n === null ? null : this.at(n, t)
    }
    intersectsPlane(e) {
        const t = e.distanceToPoint(this.origin);
        return t === 0 || e.normal.dot(this.direction) * t < 0
    }
    intersectBox(e, t) {
        let n, i, s, o, a, c;
        const h = 1 / this.direction.x
          , d = 1 / this.direction.y
          , l = 1 / this.direction.z
          , f = this.origin;
        return h >= 0 ? (n = (e.min.x - f.x) * h,
        i = (e.max.x - f.x) * h) : (n = (e.max.x - f.x) * h,
        i = (e.min.x - f.x) * h),
        d >= 0 ? (s = (e.min.y - f.y) * d,
        o = (e.max.y - f.y) * d) : (s = (e.max.y - f.y) * d,
        o = (e.min.y - f.y) * d),
        n > o || s > i || ((s > n || isNaN(n)) && (n = s),
        (o < i || isNaN(i)) && (i = o),
        l >= 0 ? (a = (e.min.z - f.z) * l,
        c = (e.max.z - f.z) * l) : (a = (e.max.z - f.z) * l,
        c = (e.min.z - f.z) * l),
        n > c || a > i) || ((a > n || n !== n) && (n = a),
        (c < i || i !== i) && (i = c),
        i < 0) ? null : this.at(n >= 0 ? n : i, t)
    }
    intersectsBox(e) {
        return this.intersectBox(e, qr) !== null
    }
    intersectTriangle(e, t, n, i, s) {
        Sp.subVectors(t, e),
        Bu.subVectors(n, e),
        Mp.crossVectors(Sp, Bu);
        let o = this.direction.dot(Mp), a;
        if (o > 0) {
            if (i)
                return null;
            a = 1
        } else if (o < 0)
            a = -1,
            o = -o;
        else
            return null;
        ys.subVectors(this.origin, e);
        const c = a * this.direction.dot(Bu.crossVectors(ys, Bu));
        if (c < 0)
            return null;
        const h = a * this.direction.dot(Sp.cross(ys));
        if (h < 0 || c + h > o)
            return null;
        const d = -a * ys.dot(Mp);
        return d < 0 ? null : this.at(d / o, s)
    }
    applyMatrix4(e) {
        return this.origin.applyMatrix4(e),
        this.direction.transformDirection(e),
        this
    }
    equals(e) {
        return e.origin.equals(this.origin) && e.direction.equals(this.direction)
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
class it {
    constructor(e, t, n, i, s, o, a, c, h, d, l, f, p, g, y, v) {
        it.prototype.isMatrix4 = !0,
        this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
        e !== void 0 && this.set(e, t, n, i, s, o, a, c, h, d, l, f, p, g, y, v)
    }
    set(e, t, n, i, s, o, a, c, h, d, l, f, p, g, y, v) {
        const _ = this.elements;
        return _[0] = e,
        _[4] = t,
        _[8] = n,
        _[12] = i,
        _[1] = s,
        _[5] = o,
        _[9] = a,
        _[13] = c,
        _[2] = h,
        _[6] = d,
        _[10] = l,
        _[14] = f,
        _[3] = p,
        _[7] = g,
        _[11] = y,
        _[15] = v,
        this
    }
    identity() {
        return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
        this
    }
    clone() {
        return new it().fromArray(this.elements)
    }
    copy(e) {
        const t = this.elements
          , n = e.elements;
        return t[0] = n[0],
        t[1] = n[1],
        t[2] = n[2],
        t[3] = n[3],
        t[4] = n[4],
        t[5] = n[5],
        t[6] = n[6],
        t[7] = n[7],
        t[8] = n[8],
        t[9] = n[9],
        t[10] = n[10],
        t[11] = n[11],
        t[12] = n[12],
        t[13] = n[13],
        t[14] = n[14],
        t[15] = n[15],
        this
    }
    copyPosition(e) {
        const t = this.elements
          , n = e.elements;
        return t[12] = n[12],
        t[13] = n[13],
        t[14] = n[14],
        this
    }
    setFromMatrix3(e) {
        const t = e.elements;
        return this.set(t[0], t[3], t[6], 0, t[1], t[4], t[7], 0, t[2], t[5], t[8], 0, 0, 0, 0, 1),
        this
    }
    extractBasis(e, t, n) {
        return e.setFromMatrixColumn(this, 0),
        t.setFromMatrixColumn(this, 1),
        n.setFromMatrixColumn(this, 2),
        this
    }
    makeBasis(e, t, n) {
        return this.set(e.x, t.x, n.x, 0, e.y, t.y, n.y, 0, e.z, t.z, n.z, 0, 0, 0, 0, 1),
        this
    }
    extractRotation(e) {
        const t = this.elements
          , n = e.elements
          , i = 1 / ua.setFromMatrixColumn(e, 0).length()
          , s = 1 / ua.setFromMatrixColumn(e, 1).length()
          , o = 1 / ua.setFromMatrixColumn(e, 2).length();
        return t[0] = n[0] * i,
        t[1] = n[1] * i,
        t[2] = n[2] * i,
        t[3] = 0,
        t[4] = n[4] * s,
        t[5] = n[5] * s,
        t[6] = n[6] * s,
        t[7] = 0,
        t[8] = n[8] * o,
        t[9] = n[9] * o,
        t[10] = n[10] * o,
        t[11] = 0,
        t[12] = 0,
        t[13] = 0,
        t[14] = 0,
        t[15] = 1,
        this
    }
    makeRotationFromEuler(e) {
        const t = this.elements
          , n = e.x
          , i = e.y
          , s = e.z
          , o = Math.cos(n)
          , a = Math.sin(n)
          , c = Math.cos(i)
          , h = Math.sin(i)
          , d = Math.cos(s)
          , l = Math.sin(s);
        if (e.order === "XYZ") {
            const f = o * d
              , p = o * l
              , g = a * d
              , y = a * l;
            t[0] = c * d,
            t[4] = -c * l,
            t[8] = h,
            t[1] = p + g * h,
            t[5] = f - y * h,
            t[9] = -a * c,
            t[2] = y - f * h,
            t[6] = g + p * h,
            t[10] = o * c
        } else if (e.order === "YXZ") {
            const f = c * d
              , p = c * l
              , g = h * d
              , y = h * l;
            t[0] = f + y * a,
            t[4] = g * a - p,
            t[8] = o * h,
            t[1] = o * l,
            t[5] = o * d,
            t[9] = -a,
            t[2] = p * a - g,
            t[6] = y + f * a,
            t[10] = o * c
        } else if (e.order === "ZXY") {
            const f = c * d
              , p = c * l
              , g = h * d
              , y = h * l;
            t[0] = f - y * a,
            t[4] = -o * l,
            t[8] = g + p * a,
            t[1] = p + g * a,
            t[5] = o * d,
            t[9] = y - f * a,
            t[2] = -o * h,
            t[6] = a,
            t[10] = o * c
        } else if (e.order === "ZYX") {
            const f = o * d
              , p = o * l
              , g = a * d
              , y = a * l;
            t[0] = c * d,
            t[4] = g * h - p,
            t[8] = f * h + y,
            t[1] = c * l,
            t[5] = y * h + f,
            t[9] = p * h - g,
            t[2] = -h,
            t[6] = a * c,
            t[10] = o * c
        } else if (e.order === "YZX") {
            const f = o * c
              , p = o * h
              , g = a * c
              , y = a * h;
            t[0] = c * d,
            t[4] = y - f * l,
            t[8] = g * l + p,
            t[1] = l,
            t[5] = o * d,
            t[9] = -a * d,
            t[2] = -h * d,
            t[6] = p * l + g,
            t[10] = f - y * l
        } else if (e.order === "XZY") {
            const f = o * c
              , p = o * h
              , g = a * c
              , y = a * h;
            t[0] = c * d,
            t[4] = -l,
            t[8] = h * d,
            t[1] = f * l + y,
            t[5] = o * d,
            t[9] = p * l - g,
            t[2] = g * l - p,
            t[6] = a * d,
            t[10] = y * l + f
        }
        return t[3] = 0,
        t[7] = 0,
        t[11] = 0,
        t[12] = 0,
        t[13] = 0,
        t[14] = 0,
        t[15] = 1,
        this
    }
    makeRotationFromQuaternion(e) {
        return this.compose(xD, e, TD)
    }
    lookAt(e, t, n) {
        const i = this.elements;
        return Li.subVectors(e, t),
        Li.lengthSq() === 0 && (Li.z = 1),
        Li.normalize(),
        xs.crossVectors(n, Li),
        xs.lengthSq() === 0 && (Math.abs(n.z) === 1 ? Li.x += 1e-4 : Li.z += 1e-4,
        Li.normalize(),
        xs.crossVectors(n, Li)),
        xs.normalize(),
        ku.crossVectors(Li, xs),
        i[0] = xs.x,
        i[4] = ku.x,
        i[8] = Li.x,
        i[1] = xs.y,
        i[5] = ku.y,
        i[9] = Li.y,
        i[2] = xs.z,
        i[6] = ku.z,
        i[10] = Li.z,
        this
    }
    multiply(e) {
        return this.multiplyMatrices(this, e)
    }
    premultiply(e) {
        return this.multiplyMatrices(e, this)
    }
    multiplyMatrices(e, t) {
        const n = e.elements
          , i = t.elements
          , s = this.elements
          , o = n[0]
          , a = n[4]
          , c = n[8]
          , h = n[12]
          , d = n[1]
          , l = n[5]
          , f = n[9]
          , p = n[13]
          , g = n[2]
          , y = n[6]
          , v = n[10]
          , _ = n[14]
          , b = n[3]
          , T = n[7]
          , S = n[11]
          , E = n[15]
          , P = i[0]
          , R = i[4]
          , O = i[8]
          , w = i[12]
          , I = i[1]
          , V = i[5]
          , z = i[9]
          , q = i[13]
          , F = i[2]
          , j = i[6]
          , K = i[10]
          , J = i[14]
          , de = i[3]
          , ae = i[7]
          , ue = i[11]
          , ge = i[15];
        return s[0] = o * P + a * I + c * F + h * de,
        s[4] = o * R + a * V + c * j + h * ae,
        s[8] = o * O + a * z + c * K + h * ue,
        s[12] = o * w + a * q + c * J + h * ge,
        s[1] = d * P + l * I + f * F + p * de,
        s[5] = d * R + l * V + f * j + p * ae,
        s[9] = d * O + l * z + f * K + p * ue,
        s[13] = d * w + l * q + f * J + p * ge,
        s[2] = g * P + y * I + v * F + _ * de,
        s[6] = g * R + y * V + v * j + _ * ae,
        s[10] = g * O + y * z + v * K + _ * ue,
        s[14] = g * w + y * q + v * J + _ * ge,
        s[3] = b * P + T * I + S * F + E * de,
        s[7] = b * R + T * V + S * j + E * ae,
        s[11] = b * O + T * z + S * K + E * ue,
        s[15] = b * w + T * q + S * J + E * ge,
        this
    }
    multiplyScalar(e) {
        const t = this.elements;
        return t[0] *= e,
        t[4] *= e,
        t[8] *= e,
        t[12] *= e,
        t[1] *= e,
        t[5] *= e,
        t[9] *= e,
        t[13] *= e,
        t[2] *= e,
        t[6] *= e,
        t[10] *= e,
        t[14] *= e,
        t[3] *= e,
        t[7] *= e,
        t[11] *= e,
        t[15] *= e,
        this
    }
    determinant() {
        const e = this.elements
          , t = e[0]
          , n = e[4]
          , i = e[8]
          , s = e[12]
          , o = e[1]
          , a = e[5]
          , c = e[9]
          , h = e[13]
          , d = e[2]
          , l = e[6]
          , f = e[10]
          , p = e[14]
          , g = e[3]
          , y = e[7]
          , v = e[11]
          , _ = e[15];
        return g * (+s * c * l - i * h * l - s * a * f + n * h * f + i * a * p - n * c * p) + y * (+t * c * p - t * h * f + s * o * f - i * o * p + i * h * d - s * c * d) + v * (+t * h * l - t * a * p - s * o * l + n * o * p + s * a * d - n * h * d) + _ * (-i * a * d - t * c * l + t * a * f + i * o * l - n * o * f + n * c * d)
    }
    transpose() {
        const e = this.elements;
        let t;
        return t = e[1],
        e[1] = e[4],
        e[4] = t,
        t = e[2],
        e[2] = e[8],
        e[8] = t,
        t = e[6],
        e[6] = e[9],
        e[9] = t,
        t = e[3],
        e[3] = e[12],
        e[12] = t,
        t = e[7],
        e[7] = e[13],
        e[13] = t,
        t = e[11],
        e[11] = e[14],
        e[14] = t,
        this
    }
    setPosition(e, t, n) {
        const i = this.elements;
        return e.isVector3 ? (i[12] = e.x,
        i[13] = e.y,
        i[14] = e.z) : (i[12] = e,
        i[13] = t,
        i[14] = n),
        this
    }
    invert() {
        const e = this.elements
          , t = e[0]
          , n = e[1]
          , i = e[2]
          , s = e[3]
          , o = e[4]
          , a = e[5]
          , c = e[6]
          , h = e[7]
          , d = e[8]
          , l = e[9]
          , f = e[10]
          , p = e[11]
          , g = e[12]
          , y = e[13]
          , v = e[14]
          , _ = e[15]
          , b = l * v * h - y * f * h + y * c * p - a * v * p - l * c * _ + a * f * _
          , T = g * f * h - d * v * h - g * c * p + o * v * p + d * c * _ - o * f * _
          , S = d * y * h - g * l * h + g * a * p - o * y * p - d * a * _ + o * l * _
          , E = g * l * c - d * y * c - g * a * f + o * y * f + d * a * v - o * l * v
          , P = t * b + n * T + i * S + s * E;
        if (P === 0)
            return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
        const R = 1 / P;
        return e[0] = b * R,
        e[1] = (y * f * s - l * v * s - y * i * p + n * v * p + l * i * _ - n * f * _) * R,
        e[2] = (a * v * s - y * c * s + y * i * h - n * v * h - a * i * _ + n * c * _) * R,
        e[3] = (l * c * s - a * f * s - l * i * h + n * f * h + a * i * p - n * c * p) * R,
        e[4] = T * R,
        e[5] = (d * v * s - g * f * s + g * i * p - t * v * p - d * i * _ + t * f * _) * R,
        e[6] = (g * c * s - o * v * s - g * i * h + t * v * h + o * i * _ - t * c * _) * R,
        e[7] = (o * f * s - d * c * s + d * i * h - t * f * h - o * i * p + t * c * p) * R,
        e[8] = S * R,
        e[9] = (g * l * s - d * y * s - g * n * p + t * y * p + d * n * _ - t * l * _) * R,
        e[10] = (o * y * s - g * a * s + g * n * h - t * y * h - o * n * _ + t * a * _) * R,
        e[11] = (d * a * s - o * l * s - d * n * h + t * l * h + o * n * p - t * a * p) * R,
        e[12] = E * R,
        e[13] = (d * y * i - g * l * i + g * n * f - t * y * f - d * n * v + t * l * v) * R,
        e[14] = (g * a * i - o * y * i - g * n * c + t * y * c + o * n * v - t * a * v) * R,
        e[15] = (o * l * i - d * a * i + d * n * c - t * l * c - o * n * f + t * a * f) * R,
        this
    }
    scale(e) {
        const t = this.elements
          , n = e.x
          , i = e.y
          , s = e.z;
        return t[0] *= n,
        t[4] *= i,
        t[8] *= s,
        t[1] *= n,
        t[5] *= i,
        t[9] *= s,
        t[2] *= n,
        t[6] *= i,
        t[10] *= s,
        t[3] *= n,
        t[7] *= i,
        t[11] *= s,
        this
    }
    getMaxScaleOnAxis() {
        const e = this.elements
          , t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2]
          , n = e[4] * e[4] + e[5] * e[5] + e[6] * e[6]
          , i = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
        return Math.sqrt(Math.max(t, n, i))
    }
    makeTranslation(e, t, n) {
        return e.isVector3 ? this.set(1, 0, 0, e.x, 0, 1, 0, e.y, 0, 0, 1, e.z, 0, 0, 0, 1) : this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, n, 0, 0, 0, 1),
        this
    }
    makeRotationX(e) {
        const t = Math.cos(e)
          , n = Math.sin(e);
        return this.set(1, 0, 0, 0, 0, t, -n, 0, 0, n, t, 0, 0, 0, 0, 1),
        this
    }
    makeRotationY(e) {
        const t = Math.cos(e)
          , n = Math.sin(e);
        return this.set(t, 0, n, 0, 0, 1, 0, 0, -n, 0, t, 0, 0, 0, 0, 1),
        this
    }
    makeRotationZ(e) {
        const t = Math.cos(e)
          , n = Math.sin(e);
        return this.set(t, -n, 0, 0, n, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
        this
    }
    makeRotationAxis(e, t) {
        const n = Math.cos(t)
          , i = Math.sin(t)
          , s = 1 - n
          , o = e.x
          , a = e.y
          , c = e.z
          , h = s * o
          , d = s * a;
        return this.set(h * o + n, h * a - i * c, h * c + i * a, 0, h * a + i * c, d * a + n, d * c - i * o, 0, h * c - i * a, d * c + i * o, s * c * c + n, 0, 0, 0, 0, 1),
        this
    }
    makeScale(e, t, n) {
        return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, n, 0, 0, 0, 0, 1),
        this
    }
    makeShear(e, t, n, i, s, o) {
        return this.set(1, n, s, 0, e, 1, o, 0, t, i, 1, 0, 0, 0, 0, 1),
        this
    }
    compose(e, t, n) {
        const i = this.elements
          , s = t._x
          , o = t._y
          , a = t._z
          , c = t._w
          , h = s + s
          , d = o + o
          , l = a + a
          , f = s * h
          , p = s * d
          , g = s * l
          , y = o * d
          , v = o * l
          , _ = a * l
          , b = c * h
          , T = c * d
          , S = c * l
          , E = n.x
          , P = n.y
          , R = n.z;
        return i[0] = (1 - (y + _)) * E,
        i[1] = (p + S) * E,
        i[2] = (g - T) * E,
        i[3] = 0,
        i[4] = (p - S) * P,
        i[5] = (1 - (f + _)) * P,
        i[6] = (v + b) * P,
        i[7] = 0,
        i[8] = (g + T) * R,
        i[9] = (v - b) * R,
        i[10] = (1 - (f + y)) * R,
        i[11] = 0,
        i[12] = e.x,
        i[13] = e.y,
        i[14] = e.z,
        i[15] = 1,
        this
    }
    decompose(e, t, n) {
        const i = this.elements;
        let s = ua.set(i[0], i[1], i[2]).length();
        const o = ua.set(i[4], i[5], i[6]).length()
          , a = ua.set(i[8], i[9], i[10]).length();
        this.determinant() < 0 && (s = -s),
        e.x = i[12],
        e.y = i[13],
        e.z = i[14],
        hr.copy(this);
        const h = 1 / s
          , d = 1 / o
          , l = 1 / a;
        return hr.elements[0] *= h,
        hr.elements[1] *= h,
        hr.elements[2] *= h,
        hr.elements[4] *= d,
        hr.elements[5] *= d,
        hr.elements[6] *= d,
        hr.elements[8] *= l,
        hr.elements[9] *= l,
        hr.elements[10] *= l,
        t.setFromRotationMatrix(hr),
        n.x = s,
        n.y = o,
        n.z = a,
        this
    }
    makePerspective(e, t, n, i, s, o, a=is) {
        const c = this.elements
          , h = 2 * s / (t - e)
          , d = 2 * s / (n - i)
          , l = (t + e) / (t - e)
          , f = (n + i) / (n - i);
        let p, g;
        if (a === is)
            p = -(o + s) / (o - s),
            g = -2 * o * s / (o - s);
        else if (a === $h)
            p = -o / (o - s),
            g = -o * s / (o - s);
        else
            throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + a);
        return c[0] = h,
        c[4] = 0,
        c[8] = l,
        c[12] = 0,
        c[1] = 0,
        c[5] = d,
        c[9] = f,
        c[13] = 0,
        c[2] = 0,
        c[6] = 0,
        c[10] = p,
        c[14] = g,
        c[3] = 0,
        c[7] = 0,
        c[11] = -1,
        c[15] = 0,
        this
    }
    makeOrthographic(e, t, n, i, s, o, a=is) {
        const c = this.elements
          , h = 1 / (t - e)
          , d = 1 / (n - i)
          , l = 1 / (o - s)
          , f = (t + e) * h
          , p = (n + i) * d;
        let g, y;
        if (a === is)
            g = (o + s) * l,
            y = -2 * l;
        else if (a === $h)
            g = s * l,
            y = -1 * l;
        else
            throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + a);
        return c[0] = 2 * h,
        c[4] = 0,
        c[8] = 0,
        c[12] = -f,
        c[1] = 0,
        c[5] = 2 * d,
        c[9] = 0,
        c[13] = -p,
        c[2] = 0,
        c[6] = 0,
        c[10] = y,
        c[14] = -g,
        c[3] = 0,
        c[7] = 0,
        c[11] = 0,
        c[15] = 1,
        this
    }
    equals(e) {
        const t = this.elements
          , n = e.elements;
        for (let i = 0; i < 16; i++)
            if (t[i] !== n[i])
                return !1;
        return !0
    }
    fromArray(e, t=0) {
        for (let n = 0; n < 16; n++)
            this.elements[n] = e[n + t];
        return this
    }
    toArray(e=[], t=0) {
        const n = this.elements;
        return e[t] = n[0],
        e[t + 1] = n[1],
        e[t + 2] = n[2],
        e[t + 3] = n[3],
        e[t + 4] = n[4],
        e[t + 5] = n[5],
        e[t + 6] = n[6],
        e[t + 7] = n[7],
        e[t + 8] = n[8],
        e[t + 9] = n[9],
        e[t + 10] = n[10],
        e[t + 11] = n[11],
        e[t + 12] = n[12],
        e[t + 13] = n[13],
        e[t + 14] = n[14],
        e[t + 15] = n[15],
        e
    }
}
const ua = new k
  , hr = new it
  , xD = new k(0,0,0)
  , TD = new k(1,1,1)
  , xs = new k
  , ku = new k
  , Li = new k
  , ny = new it
  , iy = new Hi;
class mf {
    constructor(e=0, t=0, n=0, i=mf.DEFAULT_ORDER) {
        this.isEuler = !0,
        this._x = e,
        this._y = t,
        this._z = n,
        this._order = i
    }
    get x() {
        return this._x
    }
    set x(e) {
        this._x = e,
        this._onChangeCallback()
    }
    get y() {
        return this._y
    }
    set y(e) {
        this._y = e,
        this._onChangeCallback()
    }
    get z() {
        return this._z
    }
    set z(e) {
        this._z = e,
        this._onChangeCallback()
    }
    get order() {
        return this._order
    }
    set order(e) {
        this._order = e,
        this._onChangeCallback()
    }
    set(e, t, n, i=this._order) {
        return this._x = e,
        this._y = t,
        this._z = n,
        this._order = i,
        this._onChangeCallback(),
        this
    }
    clone() {
        return new this.constructor(this._x,this._y,this._z,this._order)
    }
    copy(e) {
        return this._x = e._x,
        this._y = e._y,
        this._z = e._z,
        this._order = e._order,
        this._onChangeCallback(),
        this
    }
    setFromRotationMatrix(e, t=this._order, n=!0) {
        const i = e.elements
          , s = i[0]
          , o = i[4]
          , a = i[8]
          , c = i[1]
          , h = i[5]
          , d = i[9]
          , l = i[2]
          , f = i[6]
          , p = i[10];
        switch (t) {
        case "XYZ":
            this._y = Math.asin(Hn(a, -1, 1)),
            Math.abs(a) < .9999999 ? (this._x = Math.atan2(-d, p),
            this._z = Math.atan2(-o, s)) : (this._x = Math.atan2(f, h),
            this._z = 0);
            break;
        case "YXZ":
            this._x = Math.asin(-Hn(d, -1, 1)),
            Math.abs(d) < .9999999 ? (this._y = Math.atan2(a, p),
            this._z = Math.atan2(c, h)) : (this._y = Math.atan2(-l, s),
            this._z = 0);
            break;
        case "ZXY":
            this._x = Math.asin(Hn(f, -1, 1)),
            Math.abs(f) < .9999999 ? (this._y = Math.atan2(-l, p),
            this._z = Math.atan2(-o, h)) : (this._y = 0,
            this._z = Math.atan2(c, s));
            break;
        case "ZYX":
            this._y = Math.asin(-Hn(l, -1, 1)),
            Math.abs(l) < .9999999 ? (this._x = Math.atan2(f, p),
            this._z = Math.atan2(c, s)) : (this._x = 0,
            this._z = Math.atan2(-o, h));
            break;
        case "YZX":
            this._z = Math.asin(Hn(c, -1, 1)),
            Math.abs(c) < .9999999 ? (this._x = Math.atan2(-d, h),
            this._y = Math.atan2(-l, s)) : (this._x = 0,
            this._y = Math.atan2(a, p));
            break;
        case "XZY":
            this._z = Math.asin(-Hn(o, -1, 1)),
            Math.abs(o) < .9999999 ? (this._x = Math.atan2(f, h),
            this._y = Math.atan2(a, s)) : (this._x = Math.atan2(-d, p),
            this._y = 0);
            break;
        default:
            console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + t)
        }
        return this._order = t,
        n === !0 && this._onChangeCallback(),
        this
    }
    setFromQuaternion(e, t, n) {
        return ny.makeRotationFromQuaternion(e),
        this.setFromRotationMatrix(ny, t, n)
    }
    setFromVector3(e, t=this._order) {
        return this.set(e.x, e.y, e.z, t)
    }
    reorder(e) {
        return iy.setFromEuler(this),
        this.setFromQuaternion(iy, e)
    }
    equals(e) {
        return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order
    }
    fromArray(e) {
        return this._x = e[0],
        this._y = e[1],
        this._z = e[2],
        e[3] !== void 0 && (this._order = e[3]),
        this._onChangeCallback(),
        this
    }
    toArray(e=[], t=0) {
        return e[t] = this._x,
        e[t + 1] = this._y,
        e[t + 2] = this._z,
        e[t + 3] = this._order,
        e
    }
    _onChange(e) {
        return this._onChangeCallback = e,
        this
    }
    _onChangeCallback() {}
    *[Symbol.iterator]() {
        yield this._x,
        yield this._y,
        yield this._z,
        yield this._order
    }
}
mf.DEFAULT_ORDER = "XYZ";
class L_ {
    constructor() {
        this.mask = 1
    }
    set(e) {
        this.mask = (1 << e | 0) >>> 0
    }
    enable(e) {
        this.mask |= 1 << e | 0
    }
    enableAll() {
        this.mask = -1
    }
    toggle(e) {
        this.mask ^= 1 << e | 0
    }
    disable(e) {
        this.mask &= ~(1 << e | 0)
    }
    disableAll() {
        this.mask = 0
    }
    test(e) {
        return (this.mask & e.mask) !== 0
    }
    isEnabled(e) {
        return (this.mask & (1 << e | 0)) !== 0
    }
}
let bD = 0;
const ry = new k
  , ha = new Hi
  , Kr = new it
  , zu = new k
  , $l = new k
  , SD = new k
  , MD = new Hi
  , sy = new k(1,0,0)
  , oy = new k(0,1,0)
  , ay = new k(0,0,1)
  , wD = {
    type: "added"
}
  , ED = {
    type: "removed"
};
class Yt extends Sr {
    constructor() {
        super(),
        this.isObject3D = !0,
        Object.defineProperty(this, "id", {
            value: bD++
        }),
        this.uuid = vr(),
        this.name = "",
        this.type = "Object3D",
        this.parent = null,
        this.children = [],
        this.up = Yt.DEFAULT_UP.clone();
        const e = new k
          , t = new mf
          , n = new Hi
          , i = new k(1,1,1);
        function s() {
            n.setFromEuler(t, !1)
        }
        function o() {
            t.setFromQuaternion(n, void 0, !1)
        }
        t._onChange(s),
        n._onChange(o),
        Object.defineProperties(this, {
            position: {
                configurable: !0,
                enumerable: !0,
                value: e
            },
            rotation: {
                configurable: !0,
                enumerable: !0,
                value: t
            },
            quaternion: {
                configurable: !0,
                enumerable: !0,
                value: n
            },
            scale: {
                configurable: !0,
                enumerable: !0,
                value: i
            },
            modelViewMatrix: {
                value: new it
            },
            normalMatrix: {
                value: new _t
            }
        }),
        this.matrix = new it,
        this.matrixWorld = new it,
        this.matrixAutoUpdate = Yt.DEFAULT_MATRIX_AUTO_UPDATE,
        this.matrixWorldAutoUpdate = Yt.DEFAULT_MATRIX_WORLD_AUTO_UPDATE,
        this.matrixWorldNeedsUpdate = !1,
        this.layers = new L_,
        this.visible = !0,
        this.castShadow = !1,
        this.receiveShadow = !1,
        this.frustumCulled = !0,
        this.renderOrder = 0,
        this.animations = [],
        this.userData = {}
    }
    onBeforeShadow() {}
    onAfterShadow() {}
    onBeforeRender() {}
    onAfterRender() {}
    applyMatrix4(e) {
        this.matrixAutoUpdate && this.updateMatrix(),
        this.matrix.premultiply(e),
        this.matrix.decompose(this.position, this.quaternion, this.scale)
    }
    applyQuaternion(e) {
        return this.quaternion.premultiply(e),
        this
    }
    setRotationFromAxisAngle(e, t) {
        this.quaternion.setFromAxisAngle(e, t)
    }
    setRotationFromEuler(e) {
        this.quaternion.setFromEuler(e, !0)
    }
    setRotationFromMatrix(e) {
        this.quaternion.setFromRotationMatrix(e)
    }
    setRotationFromQuaternion(e) {
        this.quaternion.copy(e)
    }
    rotateOnAxis(e, t) {
        return ha.setFromAxisAngle(e, t),
        this.quaternion.multiply(ha),
        this
    }
    rotateOnWorldAxis(e, t) {
        return ha.setFromAxisAngle(e, t),
        this.quaternion.premultiply(ha),
        this
    }
    rotateX(e) {
        return this.rotateOnAxis(sy, e)
    }
    rotateY(e) {
        return this.rotateOnAxis(oy, e)
    }
    rotateZ(e) {
        return this.rotateOnAxis(ay, e)
    }
    translateOnAxis(e, t) {
        return ry.copy(e).applyQuaternion(this.quaternion),
        this.position.add(ry.multiplyScalar(t)),
        this
    }
    translateX(e) {
        return this.translateOnAxis(sy, e)
    }
    translateY(e) {
        return this.translateOnAxis(oy, e)
    }
    translateZ(e) {
        return this.translateOnAxis(ay, e)
    }
    localToWorld(e) {
        return this.updateWorldMatrix(!0, !1),
        e.applyMatrix4(this.matrixWorld)
    }
    worldToLocal(e) {
        return this.updateWorldMatrix(!0, !1),
        e.applyMatrix4(Kr.copy(this.matrixWorld).invert())
    }
    lookAt(e, t, n) {
        e.isVector3 ? zu.copy(e) : zu.set(e, t, n);
        const i = this.parent;
        this.updateWorldMatrix(!0, !1),
        $l.setFromMatrixPosition(this.matrixWorld),
        this.isCamera || this.isLight ? Kr.lookAt($l, zu, this.up) : Kr.lookAt(zu, $l, this.up),
        this.quaternion.setFromRotationMatrix(Kr),
        i && (Kr.extractRotation(i.matrixWorld),
        ha.setFromRotationMatrix(Kr),
        this.quaternion.premultiply(ha.invert()))
    }
    add(e) {
        if (arguments.length > 1) {
            for (let t = 0; t < arguments.length; t++)
                this.add(arguments[t]);
            return this
        }
        return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e),
        this) : (e && e.isObject3D ? (e.parent !== null && e.parent.remove(e),
        e.parent = this,
        this.children.push(e),
        e.dispatchEvent(wD)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e),
        this)
    }
    remove(e) {
        if (arguments.length > 1) {
            for (let n = 0; n < arguments.length; n++)
                this.remove(arguments[n]);
            return this
        }
        const t = this.children.indexOf(e);
        return t !== -1 && (e.parent = null,
        this.children.splice(t, 1),
        e.dispatchEvent(ED)),
        this
    }
    removeFromParent() {
        const e = this.parent;
        return e !== null && e.remove(this),
        this
    }
    clear() {
        return this.remove(...this.children)
    }
    attach(e) {
        return this.updateWorldMatrix(!0, !1),
        Kr.copy(this.matrixWorld).invert(),
        e.parent !== null && (e.parent.updateWorldMatrix(!0, !1),
        Kr.multiply(e.parent.matrixWorld)),
        e.applyMatrix4(Kr),
        this.add(e),
        e.updateWorldMatrix(!1, !0),
        this
    }
    getObjectById(e) {
        return this.getObjectByProperty("id", e)
    }
    getObjectByName(e) {
        return this.getObjectByProperty("name", e)
    }
    getObjectByProperty(e, t) {
        if (this[e] === t)
            return this;
        for (let n = 0, i = this.children.length; n < i; n++) {
            const o = this.children[n].getObjectByProperty(e, t);
            if (o !== void 0)
                return o
        }
    }
    getObjectsByProperty(e, t, n=[]) {
        this[e] === t && n.push(this);
        const i = this.children;
        for (let s = 0, o = i.length; s < o; s++)
            i[s].getObjectsByProperty(e, t, n);
        return n
    }
    getWorldPosition(e) {
        return this.updateWorldMatrix(!0, !1),
        e.setFromMatrixPosition(this.matrixWorld)
    }
    getWorldQuaternion(e) {
        return this.updateWorldMatrix(!0, !1),
        this.matrixWorld.decompose($l, e, SD),
        e
    }
    getWorldScale(e) {
        return this.updateWorldMatrix(!0, !1),
        this.matrixWorld.decompose($l, MD, e),
        e
    }
    getWorldDirection(e) {
        this.updateWorldMatrix(!0, !1);
        const t = this.matrixWorld.elements;
        return e.set(t[8], t[9], t[10]).normalize()
    }
    raycast() {}
    traverse(e) {
        e(this);
        const t = this.children;
        for (let n = 0, i = t.length; n < i; n++)
            t[n].traverse(e)
    }
    traverseVisible(e) {
        if (this.visible === !1)
            return;
        e(this);
        const t = this.children;
        for (let n = 0, i = t.length; n < i; n++)
            t[n].traverseVisible(e)
    }
    traverseAncestors(e) {
        const t = this.parent;
        t !== null && (e(t),
        t.traverseAncestors(e))
    }
    updateMatrix() {
        this.matrix.compose(this.position, this.quaternion, this.scale),
        this.matrixWorldNeedsUpdate = !0
    }
    updateMatrixWorld(e) {
        this.matrixAutoUpdate && this.updateMatrix(),
        (this.matrixWorldNeedsUpdate || e) && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix),
        this.matrixWorldNeedsUpdate = !1,
        e = !0);
        const t = this.children;
        for (let n = 0, i = t.length; n < i; n++) {
            const s = t[n];
            (s.matrixWorldAutoUpdate === !0 || e === !0) && s.updateMatrixWorld(e)
        }
    }
    updateWorldMatrix(e, t) {
        const n = this.parent;
        if (e === !0 && n !== null && n.matrixWorldAutoUpdate === !0 && n.updateWorldMatrix(!0, !1),
        this.matrixAutoUpdate && this.updateMatrix(),
        this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix),
        t === !0) {
            const i = this.children;
            for (let s = 0, o = i.length; s < o; s++) {
                const a = i[s];
                a.matrixWorldAutoUpdate === !0 && a.updateWorldMatrix(!1, !0)
            }
        }
    }
    toJSON(e) {
        const t = e === void 0 || typeof e == "string"
          , n = {};
        t && (e = {
            geometries: {},
            materials: {},
            textures: {},
            images: {},
            shapes: {},
            skeletons: {},
            animations: {},
            nodes: {}
        },
        n.metadata = {
            version: 4.6,
            type: "Object",
            generator: "Object3D.toJSON"
        });
        const i = {};
        i.uuid = this.uuid,
        i.type = this.type,
        this.name !== "" && (i.name = this.name),
        this.castShadow === !0 && (i.castShadow = !0),
        this.receiveShadow === !0 && (i.receiveShadow = !0),
        this.visible === !1 && (i.visible = !1),
        this.frustumCulled === !1 && (i.frustumCulled = !1),
        this.renderOrder !== 0 && (i.renderOrder = this.renderOrder),
        Object.keys(this.userData).length > 0 && (i.userData = this.userData),
        i.layers = this.layers.mask,
        i.matrix = this.matrix.toArray(),
        i.up = this.up.toArray(),
        this.matrixAutoUpdate === !1 && (i.matrixAutoUpdate = !1),
        this.isInstancedMesh && (i.type = "InstancedMesh",
        i.count = this.count,
        i.instanceMatrix = this.instanceMatrix.toJSON(),
        this.instanceColor !== null && (i.instanceColor = this.instanceColor.toJSON())),
        this.isBatchedMesh && (i.type = "BatchedMesh",
        i.perObjectFrustumCulled = this.perObjectFrustumCulled,
        i.sortObjects = this.sortObjects,
        i.drawRanges = this._drawRanges,
        i.reservedRanges = this._reservedRanges,
        i.visibility = this._visibility,
        i.active = this._active,
        i.bounds = this._bounds.map(a=>({
            boxInitialized: a.boxInitialized,
            boxMin: a.box.min.toArray(),
            boxMax: a.box.max.toArray(),
            sphereInitialized: a.sphereInitialized,
            sphereRadius: a.sphere.radius,
            sphereCenter: a.sphere.center.toArray()
        })),
        i.maxGeometryCount = this._maxGeometryCount,
        i.maxVertexCount = this._maxVertexCount,
        i.maxIndexCount = this._maxIndexCount,
        i.geometryInitialized = this._geometryInitialized,
        i.geometryCount = this._geometryCount,
        i.matricesTexture = this._matricesTexture.toJSON(e),
        this.boundingSphere !== null && (i.boundingSphere = {
            center: i.boundingSphere.center.toArray(),
            radius: i.boundingSphere.radius
        }),
        this.boundingBox !== null && (i.boundingBox = {
            min: i.boundingBox.min.toArray(),
            max: i.boundingBox.max.toArray()
        }));
        function s(a, c) {
            return a[c.uuid] === void 0 && (a[c.uuid] = c.toJSON(e)),
            c.uuid
        }
        if (this.isScene)
            this.background && (this.background.isColor ? i.background = this.background.toJSON() : this.background.isTexture && (i.background = this.background.toJSON(e).uuid)),
            this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== !0 && (i.environment = this.environment.toJSON(e).uuid);
        else if (this.isMesh || this.isLine || this.isPoints) {
            i.geometry = s(e.geometries, this.geometry);
            const a = this.geometry.parameters;
            if (a !== void 0 && a.shapes !== void 0) {
                const c = a.shapes;
                if (Array.isArray(c))
                    for (let h = 0, d = c.length; h < d; h++) {
                        const l = c[h];
                        s(e.shapes, l)
                    }
                else
                    s(e.shapes, c)
            }
        }
        if (this.isSkinnedMesh && (i.bindMode = this.bindMode,
        i.bindMatrix = this.bindMatrix.toArray(),
        this.skeleton !== void 0 && (s(e.skeletons, this.skeleton),
        i.skeleton = this.skeleton.uuid)),
        this.material !== void 0)
            if (Array.isArray(this.material)) {
                const a = [];
                for (let c = 0, h = this.material.length; c < h; c++)
                    a.push(s(e.materials, this.material[c]));
                i.material = a
            } else
                i.material = s(e.materials, this.material);
        if (this.children.length > 0) {
            i.children = [];
            for (let a = 0; a < this.children.length; a++)
                i.children.push(this.children[a].toJSON(e).object)
        }
        if (this.animations.length > 0) {
            i.animations = [];
            for (let a = 0; a < this.animations.length; a++) {
                const c = this.animations[a];
                i.animations.push(s(e.animations, c))
            }
        }
        if (t) {
            const a = o(e.geometries)
              , c = o(e.materials)
              , h = o(e.textures)
              , d = o(e.images)
              , l = o(e.shapes)
              , f = o(e.skeletons)
              , p = o(e.animations)
              , g = o(e.nodes);
            a.length > 0 && (n.geometries = a),
            c.length > 0 && (n.materials = c),
            h.length > 0 && (n.textures = h),
            d.length > 0 && (n.images = d),
            l.length > 0 && (n.shapes = l),
            f.length > 0 && (n.skeletons = f),
            p.length > 0 && (n.animations = p),
            g.length > 0 && (n.nodes = g)
        }
        return n.object = i,
        n;
        function o(a) {
            const c = [];
            for (const h in a) {
                const d = a[h];
                delete d.metadata,
                c.push(d)
            }
            return c
        }
    }
    clone(e) {
        return new this.constructor().copy(this, e)
    }
    copy(e, t=!0) {
        if (this.name = e.name,
        this.up.copy(e.up),
        this.position.copy(e.position),
        this.rotation.order = e.rotation.order,
        this.quaternion.copy(e.quaternion),
        this.scale.copy(e.scale),
        this.matrix.copy(e.matrix),
        this.matrixWorld.copy(e.matrixWorld),
        this.matrixAutoUpdate = e.matrixAutoUpdate,
        this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate,
        this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate,
        this.layers.mask = e.layers.mask,
        this.visible = e.visible,
        this.castShadow = e.castShadow,
        this.receiveShadow = e.receiveShadow,
        this.frustumCulled = e.frustumCulled,
        this.renderOrder = e.renderOrder,
        this.animations = e.animations.slice(),
        this.userData = JSON.parse(JSON.stringify(e.userData)),
        t === !0)
            for (let n = 0; n < e.children.length; n++) {
                const i = e.children[n];
                this.add(i.clone())
            }
        return this
    }
}
Yt.DEFAULT_UP = new k(0,1,0);
Yt.DEFAULT_MATRIX_AUTO_UPDATE = !0;
Yt.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
const fr = new k
  , Yr = new k
  , wp = new k
  , $r = new k
  , fa = new k
  , da = new k
  , ly = new k
  , Ep = new k
  , Ap = new k
  , Pp = new k;
let Hu = !1;
class ti {
    constructor(e=new k, t=new k, n=new k) {
        this.a = e,
        this.b = t,
        this.c = n
    }
    static getNormal(e, t, n, i) {
        i.subVectors(n, t),
        fr.subVectors(e, t),
        i.cross(fr);
        const s = i.lengthSq();
        return s > 0 ? i.multiplyScalar(1 / Math.sqrt(s)) : i.set(0, 0, 0)
    }
    static getBarycoord(e, t, n, i, s) {
        fr.subVectors(i, t),
        Yr.subVectors(n, t),
        wp.subVectors(e, t);
        const o = fr.dot(fr)
          , a = fr.dot(Yr)
          , c = fr.dot(wp)
          , h = Yr.dot(Yr)
          , d = Yr.dot(wp)
          , l = o * h - a * a;
        if (l === 0)
            return s.set(-2, -1, -1);
        const f = 1 / l
          , p = (h * c - a * d) * f
          , g = (o * d - a * c) * f;
        return s.set(1 - p - g, g, p)
    }
    static containsPoint(e, t, n, i) {
        return this.getBarycoord(e, t, n, i, $r),
        $r.x >= 0 && $r.y >= 0 && $r.x + $r.y <= 1
    }
    static getUV(e, t, n, i, s, o, a, c) {
        return Hu === !1 && (console.warn("THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."),
        Hu = !0),
        this.getInterpolation(e, t, n, i, s, o, a, c)
    }
    static getInterpolation(e, t, n, i, s, o, a, c) {
        return this.getBarycoord(e, t, n, i, $r),
        c.setScalar(0),
        c.addScaledVector(s, $r.x),
        c.addScaledVector(o, $r.y),
        c.addScaledVector(a, $r.z),
        c
    }
    static isFrontFacing(e, t, n, i) {
        return fr.subVectors(n, t),
        Yr.subVectors(e, t),
        fr.cross(Yr).dot(i) < 0
    }
    set(e, t, n) {
        return this.a.copy(e),
        this.b.copy(t),
        this.c.copy(n),
        this
    }
    setFromPointsAndIndices(e, t, n, i) {
        return this.a.copy(e[t]),
        this.b.copy(e[n]),
        this.c.copy(e[i]),
        this
    }
    setFromAttributeAndIndices(e, t, n, i) {
        return this.a.fromBufferAttribute(e, t),
        this.b.fromBufferAttribute(e, n),
        this.c.fromBufferAttribute(e, i),
        this
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        return this.a.copy(e.a),
        this.b.copy(e.b),
        this.c.copy(e.c),
        this
    }
    getArea() {
        return fr.subVectors(this.c, this.b),
        Yr.subVectors(this.a, this.b),
        fr.cross(Yr).length() * .5
    }
    getMidpoint(e) {
        return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
    }
    getNormal(e) {
        return ti.getNormal(this.a, this.b, this.c, e)
    }
    getPlane(e) {
        return e.setFromCoplanarPoints(this.a, this.b, this.c)
    }
    getBarycoord(e, t) {
        return ti.getBarycoord(e, this.a, this.b, this.c, t)
    }
    getUV(e, t, n, i, s) {
        return Hu === !1 && (console.warn("THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."),
        Hu = !0),
        ti.getInterpolation(e, this.a, this.b, this.c, t, n, i, s)
    }
    getInterpolation(e, t, n, i, s) {
        return ti.getInterpolation(e, this.a, this.b, this.c, t, n, i, s)
    }
    containsPoint(e) {
        return ti.containsPoint(e, this.a, this.b, this.c)
    }
    isFrontFacing(e) {
        return ti.isFrontFacing(this.a, this.b, this.c, e)
    }
    intersectsBox(e) {
        return e.intersectsTriangle(this)
    }
    closestPointToPoint(e, t) {
        const n = this.a
          , i = this.b
          , s = this.c;
        let o, a;
        fa.subVectors(i, n),
        da.subVectors(s, n),
        Ep.subVectors(e, n);
        const c = fa.dot(Ep)
          , h = da.dot(Ep);
        if (c <= 0 && h <= 0)
            return t.copy(n);
        Ap.subVectors(e, i);
        const d = fa.dot(Ap)
          , l = da.dot(Ap);
        if (d >= 0 && l <= d)
            return t.copy(i);
        const f = c * l - d * h;
        if (f <= 0 && c >= 0 && d <= 0)
            return o = c / (c - d),
            t.copy(n).addScaledVector(fa, o);
        Pp.subVectors(e, s);
        const p = fa.dot(Pp)
          , g = da.dot(Pp);
        if (g >= 0 && p <= g)
            return t.copy(s);
        const y = p * h - c * g;
        if (y <= 0 && h >= 0 && g <= 0)
            return a = h / (h - g),
            t.copy(n).addScaledVector(da, a);
        const v = d * g - p * l;
        if (v <= 0 && l - d >= 0 && p - g >= 0)
            return ly.subVectors(s, i),
            a = (l - d) / (l - d + (p - g)),
            t.copy(i).addScaledVector(ly, a);
        const _ = 1 / (v + y + f);
        return o = y * _,
        a = f * _,
        t.copy(n).addScaledVector(fa, o).addScaledVector(da, a)
    }
    equals(e) {
        return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c)
    }
}
const Lb = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074
}
  , Ts = {
    h: 0,
    s: 0,
    l: 0
}
  , Vu = {
    h: 0,
    s: 0,
    l: 0
};
function Rp(r, e, t) {
    return t < 0 && (t += 1),
    t > 1 && (t -= 1),
    t < 1 / 6 ? r + (e - r) * 6 * t : t < 1 / 2 ? e : t < 2 / 3 ? r + (e - r) * 6 * (2 / 3 - t) : r
}
class Ke {
    constructor(e, t, n) {
        return this.isColor = !0,
        this.r = 1,
        this.g = 1,
        this.b = 1,
        this.set(e, t, n)
    }
    set(e, t, n) {
        if (t === void 0 && n === void 0) {
            const i = e;
            i && i.isColor ? this.copy(i) : typeof i == "number" ? this.setHex(i) : typeof i == "string" && this.setStyle(i)
        } else
            this.setRGB(e, t, n);
        return this
    }
    setScalar(e) {
        return this.r = e,
        this.g = e,
        this.b = e,
        this
    }
    setHex(e, t=Ft) {
        return e = Math.floor(e),
        this.r = (e >> 16 & 255) / 255,
        this.g = (e >> 8 & 255) / 255,
        this.b = (e & 255) / 255,
        Rt.toWorkingColorSpace(this, t),
        this
    }
    setRGB(e, t, n, i=Rt.workingColorSpace) {
        return this.r = e,
        this.g = t,
        this.b = n,
        Rt.toWorkingColorSpace(this, i),
        this
    }
    setHSL(e, t, n, i=Rt.workingColorSpace) {
        if (e = I_(e, 1),
        t = Hn(t, 0, 1),
        n = Hn(n, 0, 1),
        t === 0)
            this.r = this.g = this.b = n;
        else {
            const s = n <= .5 ? n * (1 + t) : n + t - n * t
              , o = 2 * n - s;
            this.r = Rp(o, s, e + 1 / 3),
            this.g = Rp(o, s, e),
            this.b = Rp(o, s, e - 1 / 3)
        }
        return Rt.toWorkingColorSpace(this, i),
        this
    }
    setStyle(e, t=Ft) {
        function n(s) {
            s !== void 0 && parseFloat(s) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.")
        }
        let i;
        if (i = /^(\w+)\(([^\)]*)\)/.exec(e)) {
            let s;
            const o = i[1]
              , a = i[2];
            switch (o) {
            case "rgb":
            case "rgba":
                if (s = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))
                    return n(s[4]),
                    this.setRGB(Math.min(255, parseInt(s[1], 10)) / 255, Math.min(255, parseInt(s[2], 10)) / 255, Math.min(255, parseInt(s[3], 10)) / 255, t);
                if (s = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))
                    return n(s[4]),
                    this.setRGB(Math.min(100, parseInt(s[1], 10)) / 100, Math.min(100, parseInt(s[2], 10)) / 100, Math.min(100, parseInt(s[3], 10)) / 100, t);
                break;
            case "hsl":
            case "hsla":
                if (s = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))
                    return n(s[4]),
                    this.setHSL(parseFloat(s[1]) / 360, parseFloat(s[2]) / 100, parseFloat(s[3]) / 100, t);
                break;
            default:
                console.warn("THREE.Color: Unknown color model " + e)
            }
        } else if (i = /^\#([A-Fa-f\d]+)$/.exec(e)) {
            const s = i[1]
              , o = s.length;
            if (o === 3)
                return this.setRGB(parseInt(s.charAt(0), 16) / 15, parseInt(s.charAt(1), 16) / 15, parseInt(s.charAt(2), 16) / 15, t);
            if (o === 6)
                return this.setHex(parseInt(s, 16), t);
            console.warn("THREE.Color: Invalid hex color " + e)
        } else if (e && e.length > 0)
            return this.setColorName(e, t);
        return this
    }
    setColorName(e, t=Ft) {
        const n = Lb[e.toLowerCase()];
        return n !== void 0 ? this.setHex(n, t) : console.warn("THREE.Color: Unknown color " + e),
        this
    }
    clone() {
        return new this.constructor(this.r,this.g,this.b)
    }
    copy(e) {
        return this.r = e.r,
        this.g = e.g,
        this.b = e.b,
        this
    }
    copySRGBToLinear(e) {
        return this.r = Ka(e.r),
        this.g = Ka(e.g),
        this.b = Ka(e.b),
        this
    }
    copyLinearToSRGB(e) {
        return this.r = gp(e.r),
        this.g = gp(e.g),
        this.b = gp(e.b),
        this
    }
    convertSRGBToLinear() {
        return this.copySRGBToLinear(this),
        this
    }
    convertLinearToSRGB() {
        return this.copyLinearToSRGB(this),
        this
    }
    getHex(e=Ft) {
        return Rt.fromWorkingColorSpace(ei.copy(this), e),
        Math.round(Hn(ei.r * 255, 0, 255)) * 65536 + Math.round(Hn(ei.g * 255, 0, 255)) * 256 + Math.round(Hn(ei.b * 255, 0, 255))
    }
    getHexString(e=Ft) {
        return ("000000" + this.getHex(e).toString(16)).slice(-6)
    }
    getHSL(e, t=Rt.workingColorSpace) {
        Rt.fromWorkingColorSpace(ei.copy(this), t);
        const n = ei.r
          , i = ei.g
          , s = ei.b
          , o = Math.max(n, i, s)
          , a = Math.min(n, i, s);
        let c, h;
        const d = (a + o) / 2;
        if (a === o)
            c = 0,
            h = 0;
        else {
            const l = o - a;
            switch (h = d <= .5 ? l / (o + a) : l / (2 - o - a),
            o) {
            case n:
                c = (i - s) / l + (i < s ? 6 : 0);
                break;
            case i:
                c = (s - n) / l + 2;
                break;
            case s:
                c = (n - i) / l + 4;
                break
            }
            c /= 6
        }
        return e.h = c,
        e.s = h,
        e.l = d,
        e
    }
    getRGB(e, t=Rt.workingColorSpace) {
        return Rt.fromWorkingColorSpace(ei.copy(this), t),
        e.r = ei.r,
        e.g = ei.g,
        e.b = ei.b,
        e
    }
    getStyle(e=Ft) {
        Rt.fromWorkingColorSpace(ei.copy(this), e);
        const t = ei.r
          , n = ei.g
          , i = ei.b;
        return e !== Ft ? `color(${e} ${t.toFixed(3)} ${n.toFixed(3)} ${i.toFixed(3)})` : `rgb(${Math.round(t * 255)},${Math.round(n * 255)},${Math.round(i * 255)})`
    }
    offsetHSL(e, t, n) {
        return this.getHSL(Ts),
        this.setHSL(Ts.h + e, Ts.s + t, Ts.l + n)
    }
    add(e) {
        return this.r += e.r,
        this.g += e.g,
        this.b += e.b,
        this
    }
    addColors(e, t) {
        return this.r = e.r + t.r,
        this.g = e.g + t.g,
        this.b = e.b + t.b,
        this
    }
    addScalar(e) {
        return this.r += e,
        this.g += e,
        this.b += e,
        this
    }
    sub(e) {
        return this.r = Math.max(0, this.r - e.r),
        this.g = Math.max(0, this.g - e.g),
        this.b = Math.max(0, this.b - e.b),
        this
    }
    multiply(e) {
        return this.r *= e.r,
        this.g *= e.g,
        this.b *= e.b,
        this
    }
    multiplyScalar(e) {
        return this.r *= e,
        this.g *= e,
        this.b *= e,
        this
    }
    lerp(e, t) {
        return this.r += (e.r - this.r) * t,
        this.g += (e.g - this.g) * t,
        this.b += (e.b - this.b) * t,
        this
    }
    lerpColors(e, t, n) {
        return this.r = e.r + (t.r - e.r) * n,
        this.g = e.g + (t.g - e.g) * n,
        this.b = e.b + (t.b - e.b) * n,
        this
    }
    lerpHSL(e, t) {
        this.getHSL(Ts),
        e.getHSL(Vu);
        const n = yc(Ts.h, Vu.h, t)
          , i = yc(Ts.s, Vu.s, t)
          , s = yc(Ts.l, Vu.l, t);
        return this.setHSL(n, i, s),
        this
    }
    setFromVector3(e) {
        return this.r = e.x,
        this.g = e.y,
        this.b = e.z,
        this
    }
    applyMatrix3(e) {
        const t = this.r
          , n = this.g
          , i = this.b
          , s = e.elements;
        return this.r = s[0] * t + s[3] * n + s[6] * i,
        this.g = s[1] * t + s[4] * n + s[7] * i,
        this.b = s[2] * t + s[5] * n + s[8] * i,
        this
    }
    equals(e) {
        return e.r === this.r && e.g === this.g && e.b === this.b
    }
    fromArray(e, t=0) {
        return this.r = e[t],
        this.g = e[t + 1],
        this.b = e[t + 2],
        this
    }
    toArray(e=[], t=0) {
        return e[t] = this.r,
        e[t + 1] = this.g,
        e[t + 2] = this.b,
        e
    }
    fromBufferAttribute(e, t) {
        return this.r = e.getX(t),
        this.g = e.getY(t),
        this.b = e.getZ(t),
        this
    }
    toJSON() {
        return this.getHex()
    }
    *[Symbol.iterator]() {
        yield this.r,
        yield this.g,
        yield this.b
    }
}
const ei = new Ke;
Ke.NAMES = Lb;
let AD = 0;
class nr extends Sr {
    constructor() {
        super(),
        this.isMaterial = !0,
        Object.defineProperty(this, "id", {
            value: AD++
        }),
        this.uuid = vr(),
        this.name = "",
        this.type = "Material",
        this.blending = qa,
        this.side = xr,
        this.vertexColors = !1,
        this.opacity = 1,
        this.transparent = !1,
        this.alphaHash = !1,
        this.blendSrc = Om,
        this.blendDst = Um,
        this.blendEquation = bo,
        this.blendSrcAlpha = null,
        this.blendDstAlpha = null,
        this.blendEquationAlpha = null,
        this.blendColor = new Ke(0,0,0),
        this.blendAlpha = 0,
        this.depthFunc = jh,
        this.depthTest = !0,
        this.depthWrite = !0,
        this.stencilWriteMask = 255,
        this.stencilFunc = Y0,
        this.stencilRef = 0,
        this.stencilFuncMask = 255,
        this.stencilFail = sa,
        this.stencilZFail = sa,
        this.stencilZPass = sa,
        this.stencilWrite = !1,
        this.clippingPlanes = null,
        this.clipIntersection = !1,
        this.clipShadows = !1,
        this.shadowSide = null,
        this.colorWrite = !0,
        this.precision = null,
        this.polygonOffset = !1,
        this.polygonOffsetFactor = 0,
        this.polygonOffsetUnits = 0,
        this.dithering = !1,
        this.alphaToCoverage = !1,
        this.premultipliedAlpha = !1,
        this.forceSinglePass = !1,
        this.visible = !0,
        this.toneMapped = !0,
        this.userData = {},
        this.version = 0,
        this._alphaTest = 0
    }
    get alphaTest() {
        return this._alphaTest
    }
    set alphaTest(e) {
        this._alphaTest > 0 != e > 0 && this.version++,
        this._alphaTest = e
    }
    onBuild() {}
    onBeforeRender() {}
    onBeforeCompile() {}
    customProgramCacheKey() {
        return this.onBeforeCompile.toString()
    }
    setValues(e) {
        if (e !== void 0)
            for (const t in e) {
                const n = e[t];
                if (n === void 0) {
                    console.warn(`THREE.Material: parameter '${t}' has value of undefined.`);
                    continue
                }
                const i = this[t];
                if (i === void 0) {
                    console.warn(`THREE.Material: '${t}' is not a property of THREE.${this.type}.`);
                    continue
                }
                i && i.isColor ? i.set(n) : i && i.isVector3 && n && n.isVector3 ? i.copy(n) : this[t] = n
            }
    }
    toJSON(e) {
        const t = e === void 0 || typeof e == "string";
        t && (e = {
            textures: {},
            images: {}
        });
        const n = {
            metadata: {
                version: 4.6,
                type: "Material",
                generator: "Material.toJSON"
            }
        };
        n.uuid = this.uuid,
        n.type = this.type,
        this.name !== "" && (n.name = this.name),
        this.color && this.color.isColor && (n.color = this.color.getHex()),
        this.roughness !== void 0 && (n.roughness = this.roughness),
        this.metalness !== void 0 && (n.metalness = this.metalness),
        this.sheen !== void 0 && (n.sheen = this.sheen),
        this.sheenColor && this.sheenColor.isColor && (n.sheenColor = this.sheenColor.getHex()),
        this.sheenRoughness !== void 0 && (n.sheenRoughness = this.sheenRoughness),
        this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()),
        this.emissiveIntensity && this.emissiveIntensity !== 1 && (n.emissiveIntensity = this.emissiveIntensity),
        this.specular && this.specular.isColor && (n.specular = this.specular.getHex()),
        this.specularIntensity !== void 0 && (n.specularIntensity = this.specularIntensity),
        this.specularColor && this.specularColor.isColor && (n.specularColor = this.specularColor.getHex()),
        this.shininess !== void 0 && (n.shininess = this.shininess),
        this.clearcoat !== void 0 && (n.clearcoat = this.clearcoat),
        this.clearcoatRoughness !== void 0 && (n.clearcoatRoughness = this.clearcoatRoughness),
        this.clearcoatMap && this.clearcoatMap.isTexture && (n.clearcoatMap = this.clearcoatMap.toJSON(e).uuid),
        this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid),
        this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid,
        n.clearcoatNormalScale = this.clearcoatNormalScale.toArray()),
        this.iridescence !== void 0 && (n.iridescence = this.iridescence),
        this.iridescenceIOR !== void 0 && (n.iridescenceIOR = this.iridescenceIOR),
        this.iridescenceThicknessRange !== void 0 && (n.iridescenceThicknessRange = this.iridescenceThicknessRange),
        this.iridescenceMap && this.iridescenceMap.isTexture && (n.iridescenceMap = this.iridescenceMap.toJSON(e).uuid),
        this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (n.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(e).uuid),
        this.anisotropy !== void 0 && (n.anisotropy = this.anisotropy),
        this.anisotropyRotation !== void 0 && (n.anisotropyRotation = this.anisotropyRotation),
        this.anisotropyMap && this.anisotropyMap.isTexture && (n.anisotropyMap = this.anisotropyMap.toJSON(e).uuid),
        this.map && this.map.isTexture && (n.map = this.map.toJSON(e).uuid),
        this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(e).uuid),
        this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(e).uuid),
        this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(e).uuid,
        n.lightMapIntensity = this.lightMapIntensity),
        this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(e).uuid,
        n.aoMapIntensity = this.aoMapIntensity),
        this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(e).uuid,
        n.bumpScale = this.bumpScale),
        this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(e).uuid,
        n.normalMapType = this.normalMapType,
        n.normalScale = this.normalScale.toArray()),
        this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(e).uuid,
        n.displacementScale = this.displacementScale,
        n.displacementBias = this.displacementBias),
        this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(e).uuid),
        this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(e).uuid),
        this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(e).uuid),
        this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(e).uuid),
        this.specularIntensityMap && this.specularIntensityMap.isTexture && (n.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid),
        this.specularColorMap && this.specularColorMap.isTexture && (n.specularColorMap = this.specularColorMap.toJSON(e).uuid),
        this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(e).uuid,
        this.combine !== void 0 && (n.combine = this.combine)),
        this.envMapIntensity !== void 0 && (n.envMapIntensity = this.envMapIntensity),
        this.reflectivity !== void 0 && (n.reflectivity = this.reflectivity),
        this.refractionRatio !== void 0 && (n.refractionRatio = this.refractionRatio),
        this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(e).uuid),
        this.transmission !== void 0 && (n.transmission = this.transmission),
        this.transmissionMap && this.transmissionMap.isTexture && (n.transmissionMap = this.transmissionMap.toJSON(e).uuid),
        this.thickness !== void 0 && (n.thickness = this.thickness),
        this.thicknessMap && this.thicknessMap.isTexture && (n.thicknessMap = this.thicknessMap.toJSON(e).uuid),
        this.attenuationDistance !== void 0 && this.attenuationDistance !== 1 / 0 && (n.attenuationDistance = this.attenuationDistance),
        this.attenuationColor !== void 0 && (n.attenuationColor = this.attenuationColor.getHex()),
        this.size !== void 0 && (n.size = this.size),
        this.shadowSide !== null && (n.shadowSide = this.shadowSide),
        this.sizeAttenuation !== void 0 && (n.sizeAttenuation = this.sizeAttenuation),
        this.blending !== qa && (n.blending = this.blending),
        this.side !== xr && (n.side = this.side),
        this.vertexColors === !0 && (n.vertexColors = !0),
        this.opacity < 1 && (n.opacity = this.opacity),
        this.transparent === !0 && (n.transparent = !0),
        this.blendSrc !== Om && (n.blendSrc = this.blendSrc),
        this.blendDst !== Um && (n.blendDst = this.blendDst),
        this.blendEquation !== bo && (n.blendEquation = this.blendEquation),
        this.blendSrcAlpha !== null && (n.blendSrcAlpha = this.blendSrcAlpha),
        this.blendDstAlpha !== null && (n.blendDstAlpha = this.blendDstAlpha),
        this.blendEquationAlpha !== null && (n.blendEquationAlpha = this.blendEquationAlpha),
        this.blendColor && this.blendColor.isColor && (n.blendColor = this.blendColor.getHex()),
        this.blendAlpha !== 0 && (n.blendAlpha = this.blendAlpha),
        this.depthFunc !== jh && (n.depthFunc = this.depthFunc),
        this.depthTest === !1 && (n.depthTest = this.depthTest),
        this.depthWrite === !1 && (n.depthWrite = this.depthWrite),
        this.colorWrite === !1 && (n.colorWrite = this.colorWrite),
        this.stencilWriteMask !== 255 && (n.stencilWriteMask = this.stencilWriteMask),
        this.stencilFunc !== Y0 && (n.stencilFunc = this.stencilFunc),
        this.stencilRef !== 0 && (n.stencilRef = this.stencilRef),
        this.stencilFuncMask !== 255 && (n.stencilFuncMask = this.stencilFuncMask),
        this.stencilFail !== sa && (n.stencilFail = this.stencilFail),
        this.stencilZFail !== sa && (n.stencilZFail = this.stencilZFail),
        this.stencilZPass !== sa && (n.stencilZPass = this.stencilZPass),
        this.stencilWrite === !0 && (n.stencilWrite = this.stencilWrite),
        this.rotation !== void 0 && this.rotation !== 0 && (n.rotation = this.rotation),
        this.polygonOffset === !0 && (n.polygonOffset = !0),
        this.polygonOffsetFactor !== 0 && (n.polygonOffsetFactor = this.polygonOffsetFactor),
        this.polygonOffsetUnits !== 0 && (n.polygonOffsetUnits = this.polygonOffsetUnits),
        this.linewidth !== void 0 && this.linewidth !== 1 && (n.linewidth = this.linewidth),
        this.dashSize !== void 0 && (n.dashSize = this.dashSize),
        this.gapSize !== void 0 && (n.gapSize = this.gapSize),
        this.scale !== void 0 && (n.scale = this.scale),
        this.dithering === !0 && (n.dithering = !0),
        this.alphaTest > 0 && (n.alphaTest = this.alphaTest),
        this.alphaHash === !0 && (n.alphaHash = !0),
        this.alphaToCoverage === !0 && (n.alphaToCoverage = !0),
        this.premultipliedAlpha === !0 && (n.premultipliedAlpha = !0),
        this.forceSinglePass === !0 && (n.forceSinglePass = !0),
        this.wireframe === !0 && (n.wireframe = !0),
        this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth),
        this.wireframeLinecap !== "round" && (n.wireframeLinecap = this.wireframeLinecap),
        this.wireframeLinejoin !== "round" && (n.wireframeLinejoin = this.wireframeLinejoin),
        this.flatShading === !0 && (n.flatShading = !0),
        this.visible === !1 && (n.visible = !1),
        this.toneMapped === !1 && (n.toneMapped = !1),
        this.fog === !1 && (n.fog = !1),
        Object.keys(this.userData).length > 0 && (n.userData = this.userData);
        function i(s) {
            const o = [];
            for (const a in s) {
                const c = s[a];
                delete c.metadata,
                o.push(c)
            }
            return o
        }
        if (t) {
            const s = i(e.textures)
              , o = i(e.images);
            s.length > 0 && (n.textures = s),
            o.length > 0 && (n.images = o)
        }
        return n
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        this.name = e.name,
        this.blending = e.blending,
        this.side = e.side,
        this.vertexColors = e.vertexColors,
        this.opacity = e.opacity,
        this.transparent = e.transparent,
        this.blendSrc = e.blendSrc,
        this.blendDst = e.blendDst,
        this.blendEquation = e.blendEquation,
        this.blendSrcAlpha = e.blendSrcAlpha,
        this.blendDstAlpha = e.blendDstAlpha,
        this.blendEquationAlpha = e.blendEquationAlpha,
        this.blendColor.copy(e.blendColor),
        this.blendAlpha = e.blendAlpha,
        this.depthFunc = e.depthFunc,
        this.depthTest = e.depthTest,
        this.depthWrite = e.depthWrite,
        this.stencilWriteMask = e.stencilWriteMask,
        this.stencilFunc = e.stencilFunc,
        this.stencilRef = e.stencilRef,
        this.stencilFuncMask = e.stencilFuncMask,
        this.stencilFail = e.stencilFail,
        this.stencilZFail = e.stencilZFail,
        this.stencilZPass = e.stencilZPass,
        this.stencilWrite = e.stencilWrite;
        const t = e.clippingPlanes;
        let n = null;
        if (t !== null) {
            const i = t.length;
            n = new Array(i);
            for (let s = 0; s !== i; ++s)
                n[s] = t[s].clone()
        }
        return this.clippingPlanes = n,
        this.clipIntersection = e.clipIntersection,
        this.clipShadows = e.clipShadows,
        this.shadowSide = e.shadowSide,
        this.colorWrite = e.colorWrite,
        this.precision = e.precision,
        this.polygonOffset = e.polygonOffset,
        this.polygonOffsetFactor = e.polygonOffsetFactor,
        this.polygonOffsetUnits = e.polygonOffsetUnits,
        this.dithering = e.dithering,
        this.alphaTest = e.alphaTest,
        this.alphaHash = e.alphaHash,
        this.alphaToCoverage = e.alphaToCoverage,
        this.premultipliedAlpha = e.premultipliedAlpha,
        this.forceSinglePass = e.forceSinglePass,
        this.visible = e.visible,
        this.toneMapped = e.toneMapped,
        this.userData = JSON.parse(JSON.stringify(e.userData)),
        this
    }
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
    set needsUpdate(e) {
        e === !0 && this.version++
    }
}
class _r extends nr {
    constructor(e) {
        super(),
        this.isMeshBasicMaterial = !0,
        this.type = "MeshBasicMaterial",
        this.color = new Ke(16777215),
        this.map = null,
        this.lightMap = null,
        this.lightMapIntensity = 1,
        this.aoMap = null,
        this.aoMapIntensity = 1,
        this.specularMap = null,
        this.alphaMap = null,
        this.envMap = null,
        this.combine = mb,
        this.reflectivity = 1,
        this.refractionRatio = .98,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.wireframeLinecap = "round",
        this.wireframeLinejoin = "round",
        this.fog = !0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.color.copy(e.color),
        this.map = e.map,
        this.lightMap = e.lightMap,
        this.lightMapIntensity = e.lightMapIntensity,
        this.aoMap = e.aoMap,
        this.aoMapIntensity = e.aoMapIntensity,
        this.specularMap = e.specularMap,
        this.alphaMap = e.alphaMap,
        this.envMap = e.envMap,
        this.combine = e.combine,
        this.reflectivity = e.reflectivity,
        this.refractionRatio = e.refractionRatio,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.wireframeLinecap = e.wireframeLinecap,
        this.wireframeLinejoin = e.wireframeLinejoin,
        this.fog = e.fog,
        this
    }
}
const Tn = new k
  , Gu = new Ce;
class pt {
    constructor(e, t, n=!1) {
        if (Array.isArray(e))
            throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
        this.isBufferAttribute = !0,
        this.name = "",
        this.array = e,
        this.itemSize = t,
        this.count = e !== void 0 ? e.length / t : 0,
        this.normalized = n,
        this.usage = zm,
        this._updateRange = {
            offset: 0,
            count: -1
        },
        this.updateRanges = [],
        this.gpuType = wn,
        this.version = 0
    }
    onUploadCallback() {}
    set needsUpdate(e) {
        e === !0 && this.version++
    }
    get updateRange() {
        return console.warn('THREE.BufferAttribute: "updateRange" is deprecated and removed in r169. Use "addUpdateRange()" instead.'),
        this._updateRange
    }
    setUsage(e) {
        return this.usage = e,
        this
    }
    addUpdateRange(e, t) {
        this.updateRanges.push({
            start: e,
            count: t
        })
    }
    clearUpdateRanges() {
        this.updateRanges.length = 0
    }
    copy(e) {
        return this.name = e.name,
        this.array = new e.array.constructor(e.array),
        this.itemSize = e.itemSize,
        this.count = e.count,
        this.normalized = e.normalized,
        this.usage = e.usage,
        this.gpuType = e.gpuType,
        this
    }
    copyAt(e, t, n) {
        e *= this.itemSize,
        n *= t.itemSize;
        for (let i = 0, s = this.itemSize; i < s; i++)
            this.array[e + i] = t.array[n + i];
        return this
    }
    copyArray(e) {
        return this.array.set(e),
        this
    }
    applyMatrix3(e) {
        if (this.itemSize === 2)
            for (let t = 0, n = this.count; t < n; t++)
                Gu.fromBufferAttribute(this, t),
                Gu.applyMatrix3(e),
                this.setXY(t, Gu.x, Gu.y);
        else if (this.itemSize === 3)
            for (let t = 0, n = this.count; t < n; t++)
                Tn.fromBufferAttribute(this, t),
                Tn.applyMatrix3(e),
                this.setXYZ(t, Tn.x, Tn.y, Tn.z);
        return this
    }
    applyMatrix4(e) {
        for (let t = 0, n = this.count; t < n; t++)
            Tn.fromBufferAttribute(this, t),
            Tn.applyMatrix4(e),
            this.setXYZ(t, Tn.x, Tn.y, Tn.z);
        return this
    }
    applyNormalMatrix(e) {
        for (let t = 0, n = this.count; t < n; t++)
            Tn.fromBufferAttribute(this, t),
            Tn.applyNormalMatrix(e),
            this.setXYZ(t, Tn.x, Tn.y, Tn.z);
        return this
    }
    transformDirection(e) {
        for (let t = 0, n = this.count; t < n; t++)
            Tn.fromBufferAttribute(this, t),
            Tn.transformDirection(e),
            this.setXYZ(t, Tn.x, Tn.y, Tn.z);
        return this
    }
    set(e, t=0) {
        return this.array.set(e, t),
        this
    }
    getComponent(e, t) {
        let n = this.array[e * this.itemSize + t];
        return this.normalized && (n = Rr(n, this.array)),
        n
    }
    setComponent(e, t, n) {
        return this.normalized && (n = Nt(n, this.array)),
        this.array[e * this.itemSize + t] = n,
        this
    }
    getX(e) {
        let t = this.array[e * this.itemSize];
        return this.normalized && (t = Rr(t, this.array)),
        t
    }
    setX(e, t) {
        return this.normalized && (t = Nt(t, this.array)),
        this.array[e * this.itemSize] = t,
        this
    }
    getY(e) {
        let t = this.array[e * this.itemSize + 1];
        return this.normalized && (t = Rr(t, this.array)),
        t
    }
    setY(e, t) {
        return this.normalized && (t = Nt(t, this.array)),
        this.array[e * this.itemSize + 1] = t,
        this
    }
    getZ(e) {
        let t = this.array[e * this.itemSize + 2];
        return this.normalized && (t = Rr(t, this.array)),
        t
    }
    setZ(e, t) {
        return this.normalized && (t = Nt(t, this.array)),
        this.array[e * this.itemSize + 2] = t,
        this
    }
    getW(e) {
        let t = this.array[e * this.itemSize + 3];
        return this.normalized && (t = Rr(t, this.array)),
        t
    }
    setW(e, t) {
        return this.normalized && (t = Nt(t, this.array)),
        this.array[e * this.itemSize + 3] = t,
        this
    }
    setXY(e, t, n) {
        return e *= this.itemSize,
        this.normalized && (t = Nt(t, this.array),
        n = Nt(n, this.array)),
        this.array[e + 0] = t,
        this.array[e + 1] = n,
        this
    }
    setXYZ(e, t, n, i) {
        return e *= this.itemSize,
        this.normalized && (t = Nt(t, this.array),
        n = Nt(n, this.array),
        i = Nt(i, this.array)),
        this.array[e + 0] = t,
        this.array[e + 1] = n,
        this.array[e + 2] = i,
        this
    }
    setXYZW(e, t, n, i, s) {
        return e *= this.itemSize,
        this.normalized && (t = Nt(t, this.array),
        n = Nt(n, this.array),
        i = Nt(i, this.array),
        s = Nt(s, this.array)),
        this.array[e + 0] = t,
        this.array[e + 1] = n,
        this.array[e + 2] = i,
        this.array[e + 3] = s,
        this
    }
    onUpload(e) {
        return this.onUploadCallback = e,
        this
    }
    clone() {
        return new this.constructor(this.array,this.itemSize).copy(this)
    }
    toJSON() {
        const e = {
            itemSize: this.itemSize,
            type: this.array.constructor.name,
            array: Array.from(this.array),
            normalized: this.normalized
        };
        return this.name !== "" && (e.name = this.name),
        this.usage !== zm && (e.usage = this.usage),
        e
    }
}
class Db extends pt {
    constructor(e, t, n) {
        super(new Uint16Array(e), t, n)
    }
}
class Ob extends pt {
    constructor(e, t, n) {
        super(new Uint32Array(e), t, n)
    }
}
class di extends pt {
    constructor(e, t, n) {
        super(new Float32Array(e), t, n)
    }
}
let PD = 0;
const ji = new it
  , Cp = new Yt
  , pa = new k
  , Di = new yn
  , Zl = new yn
  , Bn = new k;
class mn extends Sr {
    constructor() {
        super(),
        this.isBufferGeometry = !0,
        Object.defineProperty(this, "id", {
            value: PD++
        }),
        this.uuid = vr(),
        this.name = "",
        this.type = "BufferGeometry",
        this.index = null,
        this.attributes = {},
        this.morphAttributes = {},
        this.morphTargetsRelative = !1,
        this.groups = [],
        this.boundingBox = null,
        this.boundingSphere = null,
        this.drawRange = {
            start: 0,
            count: 1 / 0
        },
        this.userData = {}
    }
    getIndex() {
        return this.index
    }
    setIndex(e) {
        return Array.isArray(e) ? this.index = new (Pb(e) ? Ob : Db)(e,1) : this.index = e,
        this
    }
    getAttribute(e) {
        return this.attributes[e]
    }
    setAttribute(e, t) {
        return this.attributes[e] = t,
        this
    }
    deleteAttribute(e) {
        return delete this.attributes[e],
        this
    }
    hasAttribute(e) {
        return this.attributes[e] !== void 0
    }
    addGroup(e, t, n=0) {
        this.groups.push({
            start: e,
            count: t,
            materialIndex: n
        })
    }
    clearGroups() {
        this.groups = []
    }
    setDrawRange(e, t) {
        this.drawRange.start = e,
        this.drawRange.count = t
    }
    applyMatrix4(e) {
        const t = this.attributes.position;
        t !== void 0 && (t.applyMatrix4(e),
        t.needsUpdate = !0);
        const n = this.attributes.normal;
        if (n !== void 0) {
            const s = new _t().getNormalMatrix(e);
            n.applyNormalMatrix(s),
            n.needsUpdate = !0
        }
        const i = this.attributes.tangent;
        return i !== void 0 && (i.transformDirection(e),
        i.needsUpdate = !0),
        this.boundingBox !== null && this.computeBoundingBox(),
        this.boundingSphere !== null && this.computeBoundingSphere(),
        this
    }
    applyQuaternion(e) {
        return ji.makeRotationFromQuaternion(e),
        this.applyMatrix4(ji),
        this
    }
    rotateX(e) {
        return ji.makeRotationX(e),
        this.applyMatrix4(ji),
        this
    }
    rotateY(e) {
        return ji.makeRotationY(e),
        this.applyMatrix4(ji),
        this
    }
    rotateZ(e) {
        return ji.makeRotationZ(e),
        this.applyMatrix4(ji),
        this
    }
    translate(e, t, n) {
        return ji.makeTranslation(e, t, n),
        this.applyMatrix4(ji),
        this
    }
    scale(e, t, n) {
        return ji.makeScale(e, t, n),
        this.applyMatrix4(ji),
        this
    }
    lookAt(e) {
        return Cp.lookAt(e),
        Cp.updateMatrix(),
        this.applyMatrix4(Cp.matrix),
        this
    }
    center() {
        return this.computeBoundingBox(),
        this.boundingBox.getCenter(pa).negate(),
        this.translate(pa.x, pa.y, pa.z),
        this
    }
    setFromPoints(e) {
        const t = [];
        for (let n = 0, i = e.length; n < i; n++) {
            const s = e[n];
            t.push(s.x, s.y, s.z || 0)
        }
        return this.setAttribute("position", new di(t,3)),
        this
    }
    computeBoundingBox() {
        this.boundingBox === null && (this.boundingBox = new yn);
        const e = this.attributes.position
          , t = this.morphAttributes.position;
        if (e && e.isGLBufferAttribute) {
            console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this),
            this.boundingBox.set(new k(-1 / 0,-1 / 0,-1 / 0), new k(1 / 0,1 / 0,1 / 0));
            return
        }
        if (e !== void 0) {
            if (this.boundingBox.setFromBufferAttribute(e),
            t)
                for (let n = 0, i = t.length; n < i; n++) {
                    const s = t[n];
                    Di.setFromBufferAttribute(s),
                    this.morphTargetsRelative ? (Bn.addVectors(this.boundingBox.min, Di.min),
                    this.boundingBox.expandByPoint(Bn),
                    Bn.addVectors(this.boundingBox.max, Di.max),
                    this.boundingBox.expandByPoint(Bn)) : (this.boundingBox.expandByPoint(Di.min),
                    this.boundingBox.expandByPoint(Di.max))
                }
        } else
            this.boundingBox.makeEmpty();
        (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
    }
    computeBoundingSphere() {
        this.boundingSphere === null && (this.boundingSphere = new Mr);
        const e = this.attributes.position
          , t = this.morphAttributes.position;
        if (e && e.isGLBufferAttribute) {
            console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this),
            this.boundingSphere.set(new k, 1 / 0);
            return
        }
        if (e) {
            const n = this.boundingSphere.center;
            if (Di.setFromBufferAttribute(e),
            t)
                for (let s = 0, o = t.length; s < o; s++) {
                    const a = t[s];
                    Zl.setFromBufferAttribute(a),
                    this.morphTargetsRelative ? (Bn.addVectors(Di.min, Zl.min),
                    Di.expandByPoint(Bn),
                    Bn.addVectors(Di.max, Zl.max),
                    Di.expandByPoint(Bn)) : (Di.expandByPoint(Zl.min),
                    Di.expandByPoint(Zl.max))
                }
            Di.getCenter(n);
            let i = 0;
            for (let s = 0, o = e.count; s < o; s++)
                Bn.fromBufferAttribute(e, s),
                i = Math.max(i, n.distanceToSquared(Bn));
            if (t)
                for (let s = 0, o = t.length; s < o; s++) {
                    const a = t[s]
                      , c = this.morphTargetsRelative;
                    for (let h = 0, d = a.count; h < d; h++)
                        Bn.fromBufferAttribute(a, h),
                        c && (pa.fromBufferAttribute(e, h),
                        Bn.add(pa)),
                        i = Math.max(i, n.distanceToSquared(Bn))
                }
            this.boundingSphere.radius = Math.sqrt(i),
            isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
        }
    }
    computeTangents() {
        const e = this.index
          , t = this.attributes;
        if (e === null || t.position === void 0 || t.normal === void 0 || t.uv === void 0) {
            console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
            return
        }
        const n = e.array
          , i = t.position.array
          , s = t.normal.array
          , o = t.uv.array
          , a = i.length / 3;
        this.hasAttribute("tangent") === !1 && this.setAttribute("tangent", new pt(new Float32Array(4 * a),4));
        const c = this.getAttribute("tangent").array
          , h = []
          , d = [];
        for (let I = 0; I < a; I++)
            h[I] = new k,
            d[I] = new k;
        const l = new k
          , f = new k
          , p = new k
          , g = new Ce
          , y = new Ce
          , v = new Ce
          , _ = new k
          , b = new k;
        function T(I, V, z) {
            l.fromArray(i, I * 3),
            f.fromArray(i, V * 3),
            p.fromArray(i, z * 3),
            g.fromArray(o, I * 2),
            y.fromArray(o, V * 2),
            v.fromArray(o, z * 2),
            f.sub(l),
            p.sub(l),
            y.sub(g),
            v.sub(g);
            const q = 1 / (y.x * v.y - v.x * y.y);
            isFinite(q) && (_.copy(f).multiplyScalar(v.y).addScaledVector(p, -y.y).multiplyScalar(q),
            b.copy(p).multiplyScalar(y.x).addScaledVector(f, -v.x).multiplyScalar(q),
            h[I].add(_),
            h[V].add(_),
            h[z].add(_),
            d[I].add(b),
            d[V].add(b),
            d[z].add(b))
        }
        let S = this.groups;
        S.length === 0 && (S = [{
            start: 0,
            count: n.length
        }]);
        for (let I = 0, V = S.length; I < V; ++I) {
            const z = S[I]
              , q = z.start
              , F = z.count;
            for (let j = q, K = q + F; j < K; j += 3)
                T(n[j + 0], n[j + 1], n[j + 2])
        }
        const E = new k
          , P = new k
          , R = new k
          , O = new k;
        function w(I) {
            R.fromArray(s, I * 3),
            O.copy(R);
            const V = h[I];
            E.copy(V),
            E.sub(R.multiplyScalar(R.dot(V))).normalize(),
            P.crossVectors(O, V);
            const q = P.dot(d[I]) < 0 ? -1 : 1;
            c[I * 4] = E.x,
            c[I * 4 + 1] = E.y,
            c[I * 4 + 2] = E.z,
            c[I * 4 + 3] = q
        }
        for (let I = 0, V = S.length; I < V; ++I) {
            const z = S[I]
              , q = z.start
              , F = z.count;
            for (let j = q, K = q + F; j < K; j += 3)
                w(n[j + 0]),
                w(n[j + 1]),
                w(n[j + 2])
        }
    }
    computeVertexNormals() {
        const e = this.index
          , t = this.getAttribute("position");
        if (t !== void 0) {
            let n = this.getAttribute("normal");
            if (n === void 0)
                n = new pt(new Float32Array(t.count * 3),3),
                this.setAttribute("normal", n);
            else
                for (let f = 0, p = n.count; f < p; f++)
                    n.setXYZ(f, 0, 0, 0);
            const i = new k
              , s = new k
              , o = new k
              , a = new k
              , c = new k
              , h = new k
              , d = new k
              , l = new k;
            if (e)
                for (let f = 0, p = e.count; f < p; f += 3) {
                    const g = e.getX(f + 0)
                      , y = e.getX(f + 1)
                      , v = e.getX(f + 2);
                    i.fromBufferAttribute(t, g),
                    s.fromBufferAttribute(t, y),
                    o.fromBufferAttribute(t, v),
                    d.subVectors(o, s),
                    l.subVectors(i, s),
                    d.cross(l),
                    a.fromBufferAttribute(n, g),
                    c.fromBufferAttribute(n, y),
                    h.fromBufferAttribute(n, v),
                    a.add(d),
                    c.add(d),
                    h.add(d),
                    n.setXYZ(g, a.x, a.y, a.z),
                    n.setXYZ(y, c.x, c.y, c.z),
                    n.setXYZ(v, h.x, h.y, h.z)
                }
            else
                for (let f = 0, p = t.count; f < p; f += 3)
                    i.fromBufferAttribute(t, f + 0),
                    s.fromBufferAttribute(t, f + 1),
                    o.fromBufferAttribute(t, f + 2),
                    d.subVectors(o, s),
                    l.subVectors(i, s),
                    d.cross(l),
                    n.setXYZ(f + 0, d.x, d.y, d.z),
                    n.setXYZ(f + 1, d.x, d.y, d.z),
                    n.setXYZ(f + 2, d.x, d.y, d.z);
            this.normalizeNormals(),
            n.needsUpdate = !0
        }
    }
    normalizeNormals() {
        const e = this.attributes.normal;
        for (let t = 0, n = e.count; t < n; t++)
            Bn.fromBufferAttribute(e, t),
            Bn.normalize(),
            e.setXYZ(t, Bn.x, Bn.y, Bn.z)
    }
    toNonIndexed() {
        function e(a, c) {
            const h = a.array
              , d = a.itemSize
              , l = a.normalized
              , f = new h.constructor(c.length * d);
            let p = 0
              , g = 0;
            for (let y = 0, v = c.length; y < v; y++) {
                a.isInterleavedBufferAttribute ? p = c[y] * a.data.stride + a.offset : p = c[y] * d;
                for (let _ = 0; _ < d; _++)
                    f[g++] = h[p++]
            }
            return new pt(f,d,l)
        }
        if (this.index === null)
            return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),
            this;
        const t = new mn
          , n = this.index.array
          , i = this.attributes;
        for (const a in i) {
            const c = i[a]
              , h = e(c, n);
            t.setAttribute(a, h)
        }
        const s = this.morphAttributes;
        for (const a in s) {
            const c = []
              , h = s[a];
            for (let d = 0, l = h.length; d < l; d++) {
                const f = h[d]
                  , p = e(f, n);
                c.push(p)
            }
            t.morphAttributes[a] = c
        }
        t.morphTargetsRelative = this.morphTargetsRelative;
        const o = this.groups;
        for (let a = 0, c = o.length; a < c; a++) {
            const h = o[a];
            t.addGroup(h.start, h.count, h.materialIndex)
        }
        return t
    }
    toJSON() {
        const e = {
            metadata: {
                version: 4.6,
                type: "BufferGeometry",
                generator: "BufferGeometry.toJSON"
            }
        };
        if (e.uuid = this.uuid,
        e.type = this.type,
        this.name !== "" && (e.name = this.name),
        Object.keys(this.userData).length > 0 && (e.userData = this.userData),
        this.parameters !== void 0) {
            const c = this.parameters;
            for (const h in c)
                c[h] !== void 0 && (e[h] = c[h]);
            return e
        }
        e.data = {
            attributes: {}
        };
        const t = this.index;
        t !== null && (e.data.index = {
            type: t.array.constructor.name,
            array: Array.prototype.slice.call(t.array)
        });
        const n = this.attributes;
        for (const c in n) {
            const h = n[c];
            e.data.attributes[c] = h.toJSON(e.data)
        }
        const i = {};
        let s = !1;
        for (const c in this.morphAttributes) {
            const h = this.morphAttributes[c]
              , d = [];
            for (let l = 0, f = h.length; l < f; l++) {
                const p = h[l];
                d.push(p.toJSON(e.data))
            }
            d.length > 0 && (i[c] = d,
            s = !0)
        }
        s && (e.data.morphAttributes = i,
        e.data.morphTargetsRelative = this.morphTargetsRelative);
        const o = this.groups;
        o.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(o)));
        const a = this.boundingSphere;
        return a !== null && (e.data.boundingSphere = {
            center: a.center.toArray(),
            radius: a.radius
        }),
        e
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        this.index = null,
        this.attributes = {},
        this.morphAttributes = {},
        this.groups = [],
        this.boundingBox = null,
        this.boundingSphere = null;
        const t = {};
        this.name = e.name;
        const n = e.index;
        n !== null && this.setIndex(n.clone(t));
        const i = e.attributes;
        for (const h in i) {
            const d = i[h];
            this.setAttribute(h, d.clone(t))
        }
        const s = e.morphAttributes;
        for (const h in s) {
            const d = []
              , l = s[h];
            for (let f = 0, p = l.length; f < p; f++)
                d.push(l[f].clone(t));
            this.morphAttributes[h] = d
        }
        this.morphTargetsRelative = e.morphTargetsRelative;
        const o = e.groups;
        for (let h = 0, d = o.length; h < d; h++) {
            const l = o[h];
            this.addGroup(l.start, l.count, l.materialIndex)
        }
        const a = e.boundingBox;
        a !== null && (this.boundingBox = a.clone());
        const c = e.boundingSphere;
        return c !== null && (this.boundingSphere = c.clone()),
        this.drawRange.start = e.drawRange.start,
        this.drawRange.count = e.drawRange.count,
        this.userData = e.userData,
        this
    }
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
}
const cy = new it
  , go = new Bo
  , Wu = new Mr
  , uy = new k
  , ma = new k
  , _a = new k
  , ga = new k
  , Ip = new k
  , ju = new k
  , Xu = new Ce
  , qu = new Ce
  , Ku = new Ce
  , hy = new k
  , fy = new k
  , dy = new k
  , Yu = new k
  , $u = new k;
class en extends Yt {
    constructor(e=new mn, t=new _r) {
        super(),
        this.isMesh = !0,
        this.type = "Mesh",
        this.geometry = e,
        this.material = t,
        this.updateMorphTargets()
    }
    copy(e, t) {
        return super.copy(e, t),
        e.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = e.morphTargetInfluences.slice()),
        e.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)),
        this.material = Array.isArray(e.material) ? e.material.slice() : e.material,
        this.geometry = e.geometry,
        this
    }
    updateMorphTargets() {
        const t = this.geometry.morphAttributes
          , n = Object.keys(t);
        if (n.length > 0) {
            const i = t[n[0]];
            if (i !== void 0) {
                this.morphTargetInfluences = [],
                this.morphTargetDictionary = {};
                for (let s = 0, o = i.length; s < o; s++) {
                    const a = i[s].name || String(s);
                    this.morphTargetInfluences.push(0),
                    this.morphTargetDictionary[a] = s
                }
            }
        }
    }
    getVertexPosition(e, t) {
        const n = this.geometry
          , i = n.attributes.position
          , s = n.morphAttributes.position
          , o = n.morphTargetsRelative;
        t.fromBufferAttribute(i, e);
        const a = this.morphTargetInfluences;
        if (s && a) {
            ju.set(0, 0, 0);
            for (let c = 0, h = s.length; c < h; c++) {
                const d = a[c]
                  , l = s[c];
                d !== 0 && (Ip.fromBufferAttribute(l, e),
                o ? ju.addScaledVector(Ip, d) : ju.addScaledVector(Ip.sub(t), d))
            }
            t.add(ju)
        }
        return t
    }
    raycast(e, t) {
        const n = this.geometry
          , i = this.material
          , s = this.matrixWorld;
        i !== void 0 && (n.boundingSphere === null && n.computeBoundingSphere(),
        Wu.copy(n.boundingSphere),
        Wu.applyMatrix4(s),
        go.copy(e.ray).recast(e.near),
        !(Wu.containsPoint(go.origin) === !1 && (go.intersectSphere(Wu, uy) === null || go.origin.distanceToSquared(uy) > (e.far - e.near) ** 2)) && (cy.copy(s).invert(),
        go.copy(e.ray).applyMatrix4(cy),
        !(n.boundingBox !== null && go.intersectsBox(n.boundingBox) === !1) && this._computeIntersections(e, t, go)))
    }
    _computeIntersections(e, t, n) {
        let i;
        const s = this.geometry
          , o = this.material
          , a = s.index
          , c = s.attributes.position
          , h = s.attributes.uv
          , d = s.attributes.uv1
          , l = s.attributes.normal
          , f = s.groups
          , p = s.drawRange;
        if (a !== null)
            if (Array.isArray(o))
                for (let g = 0, y = f.length; g < y; g++) {
                    const v = f[g]
                      , _ = o[v.materialIndex]
                      , b = Math.max(v.start, p.start)
                      , T = Math.min(a.count, Math.min(v.start + v.count, p.start + p.count));
                    for (let S = b, E = T; S < E; S += 3) {
                        const P = a.getX(S)
                          , R = a.getX(S + 1)
                          , O = a.getX(S + 2);
                        i = Zu(this, _, e, n, h, d, l, P, R, O),
                        i && (i.faceIndex = Math.floor(S / 3),
                        i.face.materialIndex = v.materialIndex,
                        t.push(i))
                    }
                }
            else {
                const g = Math.max(0, p.start)
                  , y = Math.min(a.count, p.start + p.count);
                for (let v = g, _ = y; v < _; v += 3) {
                    const b = a.getX(v)
                      , T = a.getX(v + 1)
                      , S = a.getX(v + 2);
                    i = Zu(this, o, e, n, h, d, l, b, T, S),
                    i && (i.faceIndex = Math.floor(v / 3),
                    t.push(i))
                }
            }
        else if (c !== void 0)
            if (Array.isArray(o))
                for (let g = 0, y = f.length; g < y; g++) {
                    const v = f[g]
                      , _ = o[v.materialIndex]
                      , b = Math.max(v.start, p.start)
                      , T = Math.min(c.count, Math.min(v.start + v.count, p.start + p.count));
                    for (let S = b, E = T; S < E; S += 3) {
                        const P = S
                          , R = S + 1
                          , O = S + 2;
                        i = Zu(this, _, e, n, h, d, l, P, R, O),
                        i && (i.faceIndex = Math.floor(S / 3),
                        i.face.materialIndex = v.materialIndex,
                        t.push(i))
                    }
                }
            else {
                const g = Math.max(0, p.start)
                  , y = Math.min(c.count, p.start + p.count);
                for (let v = g, _ = y; v < _; v += 3) {
                    const b = v
                      , T = v + 1
                      , S = v + 2;
                    i = Zu(this, o, e, n, h, d, l, b, T, S),
                    i && (i.faceIndex = Math.floor(v / 3),
                    t.push(i))
                }
            }
    }
}
function RD(r, e, t, n, i, s, o, a) {
    let c;
    if (e.side === fi ? c = n.intersectTriangle(o, s, i, !0, a) : c = n.intersectTriangle(i, s, o, e.side === xr, a),
    c === null)
        return null;
    $u.copy(a),
    $u.applyMatrix4(r.matrixWorld);
    const h = t.ray.origin.distanceTo($u);
    return h < t.near || h > t.far ? null : {
        distance: h,
        point: $u.clone(),
        object: r
    }
}
function Zu(r, e, t, n, i, s, o, a, c, h) {
    r.getVertexPosition(a, ma),
    r.getVertexPosition(c, _a),
    r.getVertexPosition(h, ga);
    const d = RD(r, e, t, n, ma, _a, ga, Yu);
    if (d) {
        i && (Xu.fromBufferAttribute(i, a),
        qu.fromBufferAttribute(i, c),
        Ku.fromBufferAttribute(i, h),
        d.uv = ti.getInterpolation(Yu, ma, _a, ga, Xu, qu, Ku, new Ce)),
        s && (Xu.fromBufferAttribute(s, a),
        qu.fromBufferAttribute(s, c),
        Ku.fromBufferAttribute(s, h),
        d.uv1 = ti.getInterpolation(Yu, ma, _a, ga, Xu, qu, Ku, new Ce),
        d.uv2 = d.uv1),
        o && (hy.fromBufferAttribute(o, a),
        fy.fromBufferAttribute(o, c),
        dy.fromBufferAttribute(o, h),
        d.normal = ti.getInterpolation(Yu, ma, _a, ga, hy, fy, dy, new k),
        d.normal.dot(n.direction) > 0 && d.normal.multiplyScalar(-1));
        const l = {
            a,
            b: c,
            c: h,
            normal: new k,
            materialIndex: 0
        };
        ti.getNormal(ma, _a, ga, l.normal),
        d.face = l
    }
    return d
}
class Bc extends mn {
    constructor(e=1, t=1, n=1, i=1, s=1, o=1) {
        super(),
        this.type = "BoxGeometry",
        this.parameters = {
            width: e,
            height: t,
            depth: n,
            widthSegments: i,
            heightSegments: s,
            depthSegments: o
        };
        const a = this;
        i = Math.floor(i),
        s = Math.floor(s),
        o = Math.floor(o);
        const c = []
          , h = []
          , d = []
          , l = [];
        let f = 0
          , p = 0;
        g("z", "y", "x", -1, -1, n, t, e, o, s, 0),
        g("z", "y", "x", 1, -1, n, t, -e, o, s, 1),
        g("x", "z", "y", 1, 1, e, n, t, i, o, 2),
        g("x", "z", "y", 1, -1, e, n, -t, i, o, 3),
        g("x", "y", "z", 1, -1, e, t, n, i, s, 4),
        g("x", "y", "z", -1, -1, e, t, -n, i, s, 5),
        this.setIndex(c),
        this.setAttribute("position", new di(h,3)),
        this.setAttribute("normal", new di(d,3)),
        this.setAttribute("uv", new di(l,2));
        function g(y, v, _, b, T, S, E, P, R, O, w) {
            const I = S / R
              , V = E / O
              , z = S / 2
              , q = E / 2
              , F = P / 2
              , j = R + 1
              , K = O + 1;
            let J = 0
              , de = 0;
            const ae = new k;
            for (let ue = 0; ue < K; ue++) {
                const ge = ue * V - q;
                for (let Ee = 0; Ee < j; Ee++) {
                    const oe = Ee * I - z;
                    ae[y] = oe * b,
                    ae[v] = ge * T,
                    ae[_] = F,
                    h.push(ae.x, ae.y, ae.z),
                    ae[y] = 0,
                    ae[v] = 0,
                    ae[_] = P > 0 ? 1 : -1,
                    d.push(ae.x, ae.y, ae.z),
                    l.push(Ee / R),
                    l.push(1 - ue / O),
                    J += 1
                }
            }
            for (let ue = 0; ue < O; ue++)
                for (let ge = 0; ge < R; ge++) {
                    const Ee = f + ge + j * ue
                      , oe = f + ge + j * (ue + 1)
                      , he = f + (ge + 1) + j * (ue + 1)
                      , xe = f + (ge + 1) + j * ue;
                    c.push(Ee, oe, xe),
                    c.push(oe, he, xe),
                    de += 6
                }
            a.addGroup(p, de, w),
            p += de,
            f += J
        }
    }
    copy(e) {
        return super.copy(e),
        this.parameters = Object.assign({}, e.parameters),
        this
    }
    static fromJSON(e) {
        return new Bc(e.width,e.height,e.depth,e.widthSegments,e.heightSegments,e.depthSegments)
    }
}
function ll(r) {
    const e = {};
    for (const t in r) {
        e[t] = {};
        for (const n in r[t]) {
            const i = r[t][n];
            i && (i.isColor || i.isMatrix3 || i.isMatrix4 || i.isVector2 || i.isVector3 || i.isVector4 || i.isTexture || i.isQuaternion) ? i.isRenderTargetTexture ? (console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."),
            e[t][n] = null) : e[t][n] = i.clone() : Array.isArray(i) ? e[t][n] = i.slice() : e[t][n] = i
        }
    }
    return e
}
function li(r) {
    const e = {};
    for (let t = 0; t < r.length; t++) {
        const n = ll(r[t]);
        for (const i in n)
            e[i] = n[i]
    }
    return e
}
function CD(r) {
    const e = [];
    for (let t = 0; t < r.length; t++)
        e.push(r[t].clone());
    return e
}
function Ub(r) {
    return r.getRenderTarget() === null ? r.outputColorSpace : Rt.workingColorSpace
}
const ID = {
    clone: ll,
    merge: li
};
var LD = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`
  , DD = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;
class Vt extends nr {
    constructor(e) {
        super(),
        this.isShaderMaterial = !0,
        this.type = "ShaderMaterial",
        this.defines = {},
        this.uniforms = {},
        this.uniformsGroups = [],
        this.vertexShader = LD,
        this.fragmentShader = DD,
        this.linewidth = 1,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.fog = !1,
        this.lights = !1,
        this.clipping = !1,
        this.forceSinglePass = !0,
        this.extensions = {
            derivatives: !1,
            fragDepth: !1,
            drawBuffers: !1,
            shaderTextureLOD: !1
        },
        this.defaultAttributeValues = {
            color: [1, 1, 1],
            uv: [0, 0],
            uv1: [0, 0]
        },
        this.index0AttributeName = void 0,
        this.uniformsNeedUpdate = !1,
        this.glslVersion = null,
        e !== void 0 && this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.fragmentShader = e.fragmentShader,
        this.vertexShader = e.vertexShader,
        this.uniforms = ll(e.uniforms),
        this.uniformsGroups = CD(e.uniformsGroups),
        this.defines = Object.assign({}, e.defines),
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.fog = e.fog,
        this.lights = e.lights,
        this.clipping = e.clipping,
        this.extensions = Object.assign({}, e.extensions),
        this.glslVersion = e.glslVersion,
        this
    }
    toJSON(e) {
        const t = super.toJSON(e);
        t.glslVersion = this.glslVersion,
        t.uniforms = {};
        for (const i in this.uniforms) {
            const o = this.uniforms[i].value;
            o && o.isTexture ? t.uniforms[i] = {
                type: "t",
                value: o.toJSON(e).uuid
            } : o && o.isColor ? t.uniforms[i] = {
                type: "c",
                value: o.getHex()
            } : o && o.isVector2 ? t.uniforms[i] = {
                type: "v2",
                value: o.toArray()
            } : o && o.isVector3 ? t.uniforms[i] = {
                type: "v3",
                value: o.toArray()
            } : o && o.isVector4 ? t.uniforms[i] = {
                type: "v4",
                value: o.toArray()
            } : o && o.isMatrix3 ? t.uniforms[i] = {
                type: "m3",
                value: o.toArray()
            } : o && o.isMatrix4 ? t.uniforms[i] = {
                type: "m4",
                value: o.toArray()
            } : t.uniforms[i] = {
                value: o
            }
        }
        Object.keys(this.defines).length > 0 && (t.defines = this.defines),
        t.vertexShader = this.vertexShader,
        t.fragmentShader = this.fragmentShader,
        t.lights = this.lights,
        t.clipping = this.clipping;
        const n = {};
        for (const i in this.extensions)
            this.extensions[i] === !0 && (n[i] = !0);
        return Object.keys(n).length > 0 && (t.extensions = n),
        t
    }
}
class D_ extends Yt {
    constructor() {
        super(),
        this.isCamera = !0,
        this.type = "Camera",
        this.matrixWorldInverse = new it,
        this.projectionMatrix = new it,
        this.projectionMatrixInverse = new it,
        this.coordinateSystem = is
    }
    copy(e, t) {
        return super.copy(e, t),
        this.matrixWorldInverse.copy(e.matrixWorldInverse),
        this.projectionMatrix.copy(e.projectionMatrix),
        this.projectionMatrixInverse.copy(e.projectionMatrixInverse),
        this.coordinateSystem = e.coordinateSystem,
        this
    }
    getWorldDirection(e) {
        return super.getWorldDirection(e).negate()
    }
    updateMatrixWorld(e) {
        super.updateMatrixWorld(e),
        this.matrixWorldInverse.copy(this.matrixWorld).invert()
    }
    updateWorldMatrix(e, t) {
        super.updateWorldMatrix(e, t),
        this.matrixWorldInverse.copy(this.matrixWorld).invert()
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
class qn extends D_ {
    constructor(e=50, t=1, n=.1, i=2e3) {
        super(),
        this.isPerspectiveCamera = !0,
        this.type = "PerspectiveCamera",
        this.fov = e,
        this.zoom = 1,
        this.near = n,
        this.far = i,
        this.focus = 10,
        this.aspect = t,
        this.view = null,
        this.filmGauge = 35,
        this.filmOffset = 0,
        this.updateProjectionMatrix()
    }
    copy(e, t) {
        return super.copy(e, t),
        this.fov = e.fov,
        this.zoom = e.zoom,
        this.near = e.near,
        this.far = e.far,
        this.focus = e.focus,
        this.aspect = e.aspect,
        this.view = e.view === null ? null : Object.assign({}, e.view),
        this.filmGauge = e.filmGauge,
        this.filmOffset = e.filmOffset,
        this
    }
    setFocalLength(e) {
        const t = .5 * this.getFilmHeight() / e;
        this.fov = al * 2 * Math.atan(t),
        this.updateProjectionMatrix()
    }
    getFocalLength() {
        const e = Math.tan(vc * .5 * this.fov);
        return .5 * this.getFilmHeight() / e
    }
    getEffectiveFOV() {
        return al * 2 * Math.atan(Math.tan(vc * .5 * this.fov) / this.zoom)
    }
    getFilmWidth() {
        return this.filmGauge * Math.min(this.aspect, 1)
    }
    getFilmHeight() {
        return this.filmGauge / Math.max(this.aspect, 1)
    }
    setViewOffset(e, t, n, i, s, o) {
        this.aspect = e / t,
        this.view === null && (this.view = {
            enabled: !0,
            fullWidth: 1,
            fullHeight: 1,
            offsetX: 0,
            offsetY: 0,
            width: 1,
            height: 1
        }),
        this.view.enabled = !0,
        this.view.fullWidth = e,
        this.view.fullHeight = t,
        this.view.offsetX = n,
        this.view.offsetY = i,
        this.view.width = s,
        this.view.height = o,
        this.updateProjectionMatrix()
    }
    clearViewOffset() {
        this.view !== null && (this.view.enabled = !1),
        this.updateProjectionMatrix()
    }
    updateProjectionMatrix() {
        const e = this.near;
        let t = e * Math.tan(vc * .5 * this.fov) / this.zoom
          , n = 2 * t
          , i = this.aspect * n
          , s = -.5 * i;
        const o = this.view;
        if (this.view !== null && this.view.enabled) {
            const c = o.fullWidth
              , h = o.fullHeight;
            s += o.offsetX * i / c,
            t -= o.offsetY * n / h,
            i *= o.width / c,
            n *= o.height / h
        }
        const a = this.filmOffset;
        a !== 0 && (s += e * a / this.getFilmWidth()),
        this.projectionMatrix.makePerspective(s, s + i, t, t - n, e, this.far, this.coordinateSystem),
        this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return t.object.fov = this.fov,
        t.object.zoom = this.zoom,
        t.object.near = this.near,
        t.object.far = this.far,
        t.object.focus = this.focus,
        t.object.aspect = this.aspect,
        this.view !== null && (t.object.view = Object.assign({}, this.view)),
        t.object.filmGauge = this.filmGauge,
        t.object.filmOffset = this.filmOffset,
        t
    }
}
const va = -90
  , ya = 1;
class OD extends Yt {
    constructor(e, t, n) {
        super(),
        this.type = "CubeCamera",
        this.renderTarget = n,
        this.coordinateSystem = null,
        this.activeMipmapLevel = 0;
        const i = new qn(va,ya,e,t);
        i.layers = this.layers,
        this.add(i);
        const s = new qn(va,ya,e,t);
        s.layers = this.layers,
        this.add(s);
        const o = new qn(va,ya,e,t);
        o.layers = this.layers,
        this.add(o);
        const a = new qn(va,ya,e,t);
        a.layers = this.layers,
        this.add(a);
        const c = new qn(va,ya,e,t);
        c.layers = this.layers,
        this.add(c);
        const h = new qn(va,ya,e,t);
        h.layers = this.layers,
        this.add(h)
    }
    updateCoordinateSystem() {
        const e = this.coordinateSystem
          , t = this.children.concat()
          , [n,i,s,o,a,c] = t;
        for (const h of t)
            this.remove(h);
        if (e === is)
            n.up.set(0, 1, 0),
            n.lookAt(1, 0, 0),
            i.up.set(0, 1, 0),
            i.lookAt(-1, 0, 0),
            s.up.set(0, 0, -1),
            s.lookAt(0, 1, 0),
            o.up.set(0, 0, 1),
            o.lookAt(0, -1, 0),
            a.up.set(0, 1, 0),
            a.lookAt(0, 0, 1),
            c.up.set(0, 1, 0),
            c.lookAt(0, 0, -1);
        else if (e === $h)
            n.up.set(0, -1, 0),
            n.lookAt(-1, 0, 0),
            i.up.set(0, -1, 0),
            i.lookAt(1, 0, 0),
            s.up.set(0, 0, 1),
            s.lookAt(0, 1, 0),
            o.up.set(0, 0, -1),
            o.lookAt(0, -1, 0),
            a.up.set(0, -1, 0),
            a.lookAt(0, 0, 1),
            c.up.set(0, -1, 0),
            c.lookAt(0, 0, -1);
        else
            throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " + e);
        for (const h of t)
            this.add(h),
            h.updateMatrixWorld()
    }
    update(e, t) {
        this.parent === null && this.updateMatrixWorld();
        const {renderTarget: n, activeMipmapLevel: i} = this;
        this.coordinateSystem !== e.coordinateSystem && (this.coordinateSystem = e.coordinateSystem,
        this.updateCoordinateSystem());
        const [s,o,a,c,h,d] = this.children
          , l = e.getRenderTarget()
          , f = e.getActiveCubeFace()
          , p = e.getActiveMipmapLevel()
          , g = e.xr.enabled;
        e.xr.enabled = !1;
        const y = n.texture.generateMipmaps;
        n.texture.generateMipmaps = !1,
        e.setRenderTarget(n, 0, i),
        e.render(t, s),
        e.setRenderTarget(n, 1, i),
        e.render(t, o),
        e.setRenderTarget(n, 2, i),
        e.render(t, a),
        e.setRenderTarget(n, 3, i),
        e.render(t, c),
        e.setRenderTarget(n, 4, i),
        e.render(t, h),
        n.texture.generateMipmaps = y,
        e.setRenderTarget(n, 5, i),
        e.render(t, d),
        e.setRenderTarget(l, f, p),
        e.xr.enabled = g,
        n.texture.needsPMREMUpdate = !0
    }
}
class Nb extends Pn {
    constructor(e, t, n, i, s, o, a, c, h, d) {
        e = e !== void 0 ? e : [],
        t = t !== void 0 ? t : il,
        super(e, t, n, i, s, o, a, c, h, d),
        this.isCubeTexture = !0,
        this.flipY = !1
    }
    get images() {
        return this.image
    }
    set images(e) {
        this.image = e
    }
}
class UD extends vn {
    constructor(e=1, t={}) {
        super(e, e, t),
        this.isWebGLCubeRenderTarget = !0;
        const n = {
            width: e,
            height: e,
            depth: 1
        }
          , i = [n, n, n, n, n, n];
        t.encoding !== void 0 && (xc("THREE.WebGLCubeRenderTarget: option.encoding has been replaced by option.colorSpace."),
        t.colorSpace = t.encoding === Dr ? Ft : Ni),
        this.texture = new Nb(i,t.mapping,t.wrapS,t.wrapT,t.magFilter,t.minFilter,t.format,t.type,t.anisotropy,t.colorSpace),
        this.texture.isRenderTargetTexture = !0,
        this.texture.generateMipmaps = t.generateMipmaps !== void 0 ? t.generateMipmaps : !1,
        this.texture.minFilter = t.minFilter !== void 0 ? t.minFilter : Ot
    }
    fromEquirectangularTexture(e, t) {
        this.texture.type = t.type,
        this.texture.colorSpace = t.colorSpace,
        this.texture.generateMipmaps = t.generateMipmaps,
        this.texture.minFilter = t.minFilter,
        this.texture.magFilter = t.magFilter;
        const n = {
            uniforms: {
                tEquirect: {
                    value: null
                }
            },
            vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
            fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
        }
          , i = new Bc(5,5,5)
          , s = new Vt({
            name: "CubemapFromEquirect",
            uniforms: ll(n.uniforms),
            vertexShader: n.vertexShader,
            fragmentShader: n.fragmentShader,
            side: fi,
            blending: Si
        });
        s.uniforms.tEquirect.value = t;
        const o = new en(i,s)
          , a = t.minFilter;
        return t.minFilter === Do && (t.minFilter = Ot),
        new OD(1,10,this).update(e, o),
        t.minFilter = a,
        o.geometry.dispose(),
        o.material.dispose(),
        this
    }
    clear(e, t, n, i) {
        const s = e.getRenderTarget();
        for (let o = 0; o < 6; o++)
            e.setRenderTarget(this, o),
            e.clear(t, n, i);
        e.setRenderTarget(s)
    }
}
const Lp = new k
  , ND = new k
  , FD = new _t;
class pr {
    constructor(e=new k(1,0,0), t=0) {
        this.isPlane = !0,
        this.normal = e,
        this.constant = t
    }
    set(e, t) {
        return this.normal.copy(e),
        this.constant = t,
        this
    }
    setComponents(e, t, n, i) {
        return this.normal.set(e, t, n),
        this.constant = i,
        this
    }
    setFromNormalAndCoplanarPoint(e, t) {
        return this.normal.copy(e),
        this.constant = -t.dot(this.normal),
        this
    }
    setFromCoplanarPoints(e, t, n) {
        const i = Lp.subVectors(n, t).cross(ND.subVectors(e, t)).normalize();
        return this.setFromNormalAndCoplanarPoint(i, e),
        this
    }
    copy(e) {
        return this.normal.copy(e.normal),
        this.constant = e.constant,
        this
    }
    normalize() {
        const e = 1 / this.normal.length();
        return this.normal.multiplyScalar(e),
        this.constant *= e,
        this
    }
    negate() {
        return this.constant *= -1,
        this.normal.negate(),
        this
    }
    distanceToPoint(e) {
        return this.normal.dot(e) + this.constant
    }
    distanceToSphere(e) {
        return this.distanceToPoint(e.center) - e.radius
    }
    projectPoint(e, t) {
        return t.copy(e).addScaledVector(this.normal, -this.distanceToPoint(e))
    }
    intersectLine(e, t) {
        const n = e.delta(Lp)
          , i = this.normal.dot(n);
        if (i === 0)
            return this.distanceToPoint(e.start) === 0 ? t.copy(e.start) : null;
        const s = -(e.start.dot(this.normal) + this.constant) / i;
        return s < 0 || s > 1 ? null : t.copy(e.start).addScaledVector(n, s)
    }
    intersectsLine(e) {
        const t = this.distanceToPoint(e.start)
          , n = this.distanceToPoint(e.end);
        return t < 0 && n > 0 || n < 0 && t > 0
    }
    intersectsBox(e) {
        return e.intersectsPlane(this)
    }
    intersectsSphere(e) {
        return e.intersectsPlane(this)
    }
    coplanarPoint(e) {
        return e.copy(this.normal).multiplyScalar(-this.constant)
    }
    applyMatrix4(e, t) {
        const n = t || FD.getNormalMatrix(e)
          , i = this.coplanarPoint(Lp).applyMatrix4(e)
          , s = this.normal.applyMatrix3(n).normalize();
        return this.constant = -i.dot(s),
        this
    }
    translate(e) {
        return this.constant -= e.dot(this.normal),
        this
    }
    equals(e) {
        return e.normal.equals(this.normal) && e.constant === this.constant
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
const vo = new Mr
  , Ju = new k;
class O_ {
    constructor(e=new pr, t=new pr, n=new pr, i=new pr, s=new pr, o=new pr) {
        this.planes = [e, t, n, i, s, o]
    }
    set(e, t, n, i, s, o) {
        const a = this.planes;
        return a[0].copy(e),
        a[1].copy(t),
        a[2].copy(n),
        a[3].copy(i),
        a[4].copy(s),
        a[5].copy(o),
        this
    }
    copy(e) {
        const t = this.planes;
        for (let n = 0; n < 6; n++)
            t[n].copy(e.planes[n]);
        return this
    }
    setFromProjectionMatrix(e, t=is) {
        const n = this.planes
          , i = e.elements
          , s = i[0]
          , o = i[1]
          , a = i[2]
          , c = i[3]
          , h = i[4]
          , d = i[5]
          , l = i[6]
          , f = i[7]
          , p = i[8]
          , g = i[9]
          , y = i[10]
          , v = i[11]
          , _ = i[12]
          , b = i[13]
          , T = i[14]
          , S = i[15];
        if (n[0].setComponents(c - s, f - h, v - p, S - _).normalize(),
        n[1].setComponents(c + s, f + h, v + p, S + _).normalize(),
        n[2].setComponents(c + o, f + d, v + g, S + b).normalize(),
        n[3].setComponents(c - o, f - d, v - g, S - b).normalize(),
        n[4].setComponents(c - a, f - l, v - y, S - T).normalize(),
        t === is)
            n[5].setComponents(c + a, f + l, v + y, S + T).normalize();
        else if (t === $h)
            n[5].setComponents(a, l, y, T).normalize();
        else
            throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " + t);
        return this
    }
    intersectsObject(e) {
        if (e.boundingSphere !== void 0)
            e.boundingSphere === null && e.computeBoundingSphere(),
            vo.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);
        else {
            const t = e.geometry;
            t.boundingSphere === null && t.computeBoundingSphere(),
            vo.copy(t.boundingSphere).applyMatrix4(e.matrixWorld)
        }
        return this.intersectsSphere(vo)
    }
    intersectsSprite(e) {
        return vo.center.set(0, 0, 0),
        vo.radius = .7071067811865476,
        vo.applyMatrix4(e.matrixWorld),
        this.intersectsSphere(vo)
    }
    intersectsSphere(e) {
        const t = this.planes
          , n = e.center
          , i = -e.radius;
        for (let s = 0; s < 6; s++)
            if (t[s].distanceToPoint(n) < i)
                return !1;
        return !0
    }
    intersectsBox(e) {
        const t = this.planes;
        for (let n = 0; n < 6; n++) {
            const i = t[n];
            if (Ju.x = i.normal.x > 0 ? e.max.x : e.min.x,
            Ju.y = i.normal.y > 0 ? e.max.y : e.min.y,
            Ju.z = i.normal.z > 0 ? e.max.z : e.min.z,
            i.distanceToPoint(Ju) < 0)
                return !1
        }
        return !0
    }
    containsPoint(e) {
        const t = this.planes;
        for (let n = 0; n < 6; n++)
            if (t[n].distanceToPoint(e) < 0)
                return !1;
        return !0
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
function Fb() {
    let r = null
      , e = !1
      , t = null
      , n = null;
    function i(s, o) {
        t(s, o),
        n = r.requestAnimationFrame(i)
    }
    return {
        start: function() {
            e !== !0 && t !== null && (n = r.requestAnimationFrame(i),
            e = !0)
        },
        stop: function() {
            r.cancelAnimationFrame(n),
            e = !1
        },
        setAnimationLoop: function(s) {
            t = s
        },
        setContext: function(s) {
            r = s
        }
    }
}
function BD(r, e) {
    const t = e.isWebGL2
      , n = new WeakMap;
    function i(h, d) {
        const l = h.array
          , f = h.usage
          , p = l.byteLength
          , g = r.createBuffer();
        r.bindBuffer(d, g),
        r.bufferData(d, l, f),
        h.onUploadCallback();
        let y;
        if (l instanceof Float32Array)
            y = r.FLOAT;
        else if (l instanceof Uint16Array)
            if (h.isFloat16BufferAttribute)
                if (t)
                    y = r.HALF_FLOAT;
                else
                    throw new Error("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");
            else
                y = r.UNSIGNED_SHORT;
        else if (l instanceof Int16Array)
            y = r.SHORT;
        else if (l instanceof Uint32Array)
            y = r.UNSIGNED_INT;
        else if (l instanceof Int32Array)
            y = r.INT;
        else if (l instanceof Int8Array)
            y = r.BYTE;
        else if (l instanceof Uint8Array)
            y = r.UNSIGNED_BYTE;
        else if (l instanceof Uint8ClampedArray)
            y = r.UNSIGNED_BYTE;
        else
            throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + l);
        return {
            buffer: g,
            type: y,
            bytesPerElement: l.BYTES_PER_ELEMENT,
            version: h.version,
            size: p
        }
    }
    function s(h, d, l) {
        const f = d.array
          , p = d._updateRange
          , g = d.updateRanges;
        if (r.bindBuffer(l, h),
        p.count === -1 && g.length === 0 && r.bufferSubData(l, 0, f),
        g.length !== 0) {
            for (let y = 0, v = g.length; y < v; y++) {
                const _ = g[y];
                t ? r.bufferSubData(l, _.start * f.BYTES_PER_ELEMENT, f, _.start, _.count) : r.bufferSubData(l, _.start * f.BYTES_PER_ELEMENT, f.subarray(_.start, _.start + _.count))
            }
            d.clearUpdateRanges()
        }
        p.count !== -1 && (t ? r.bufferSubData(l, p.offset * f.BYTES_PER_ELEMENT, f, p.offset, p.count) : r.bufferSubData(l, p.offset * f.BYTES_PER_ELEMENT, f.subarray(p.offset, p.offset + p.count)),
        p.count = -1),
        d.onUploadCallback()
    }
    function o(h) {
        return h.isInterleavedBufferAttribute && (h = h.data),
        n.get(h)
    }
    function a(h) {
        h.isInterleavedBufferAttribute && (h = h.data);
        const d = n.get(h);
        d && (r.deleteBuffer(d.buffer),
        n.delete(h))
    }
    function c(h, d) {
        if (h.isGLBufferAttribute) {
            const f = n.get(h);
            (!f || f.version < h.version) && n.set(h, {
                buffer: h.buffer,
                type: h.type,
                bytesPerElement: h.elementSize,
                version: h.version
            });
            return
        }
        h.isInterleavedBufferAttribute && (h = h.data);
        const l = n.get(h);
        if (l === void 0)
            n.set(h, i(h, d));
        else if (l.version < h.version) {
            if (l.size !== h.array.byteLength)
                throw new Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.");
            s(l.buffer, h, d),
            l.version = h.version
        }
    }
    return {
        get: o,
        remove: a,
        update: c
    }
}
class Tr extends mn {
    constructor(e=1, t=1, n=1, i=1) {
        super(),
        this.type = "PlaneGeometry",
        this.parameters = {
            width: e,
            height: t,
            widthSegments: n,
            heightSegments: i
        };
        const s = e / 2
          , o = t / 2
          , a = Math.floor(n)
          , c = Math.floor(i)
          , h = a + 1
          , d = c + 1
          , l = e / a
          , f = t / c
          , p = []
          , g = []
          , y = []
          , v = [];
        for (let _ = 0; _ < d; _++) {
            const b = _ * f - o;
            for (let T = 0; T < h; T++) {
                const S = T * l - s;
                g.push(S, -b, 0),
                y.push(0, 0, 1),
                v.push(T / a),
                v.push(1 - _ / c)
            }
        }
        for (let _ = 0; _ < c; _++)
            for (let b = 0; b < a; b++) {
                const T = b + h * _
                  , S = b + h * (_ + 1)
                  , E = b + 1 + h * (_ + 1)
                  , P = b + 1 + h * _;
                p.push(T, S, P),
                p.push(S, E, P)
            }
        this.setIndex(p),
        this.setAttribute("position", new di(g,3)),
        this.setAttribute("normal", new di(y,3)),
        this.setAttribute("uv", new di(v,2))
    }
    copy(e) {
        return super.copy(e),
        this.parameters = Object.assign({}, e.parameters),
        this
    }
    static fromJSON(e) {
        return new Tr(e.width,e.height,e.widthSegments,e.heightSegments)
    }
}
var kD = `#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`
  , zD = `#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`
  , HD = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`
  , VD = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`
  , GD = `#ifdef USE_ALPHATEST
	if ( diffuseColor.a < alphaTest ) discard;
#endif`
  , WD = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`
  , jD = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_CLEARCOAT ) 
		clearcoatSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_SHEEN ) 
		sheenSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`
  , XD = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`
  , qD = `#ifdef USE_BATCHING
	attribute float batchId;
	uniform highp sampler2D batchingTexture;
	mat4 getBatchingMatrix( const in float i ) {
		int size = textureSize( batchingTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`
  , KD = `#ifdef USE_BATCHING
	mat4 batchingMatrix = getBatchingMatrix( batchId );
#endif`
  , YD = `vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`
  , $D = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`
  , ZD = `float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`
  , JD = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`
  , QD = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );
		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`
  , e2 = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
	}
	#pragma unroll_loop_end
	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
		bool clipped = true;
		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
		}
		#pragma unroll_loop_end
		if ( clipped ) discard;
	#endif
#endif`
  , t2 = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`
  , n2 = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`
  , i2 = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`
  , r2 = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`
  , s2 = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`
  , o2 = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`
  , a2 = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`
  , l2 = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float luminance( const in vec3 rgb ) {
	const vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );
	return dot( weights, rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`
  , c2 = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_v0 0.339
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_v1 0.276
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_v4 0.046
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_v5 0.016
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_v6 0.0038
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`
  , u2 = `vec3 transformedNormal = objectNormal;
#ifdef USE_TANGENT
	vec3 transformedTangent = objectTangent;
#endif
#ifdef USE_BATCHING
	mat3 bm = mat3( batchingMatrix );
	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );
	transformedNormal = bm * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = bm * transformedTangent;
	#endif
#endif
#ifdef USE_INSTANCING
	mat3 im = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );
	transformedNormal = im * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = im * transformedTangent;
	#endif
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`
  , h2 = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`
  , f2 = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`
  , d2 = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`
  , p2 = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`
  , m2 = "gl_FragColor = linearToOutputTexel( gl_FragColor );"
  , _2 = `
const mat3 LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = mat3(
	vec3( 0.8224621, 0.177538, 0.0 ),
	vec3( 0.0331941, 0.9668058, 0.0 ),
	vec3( 0.0170827, 0.0723974, 0.9105199 )
);
const mat3 LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = mat3(
	vec3( 1.2249401, - 0.2249404, 0.0 ),
	vec3( - 0.0420569, 1.0420571, 0.0 ),
	vec3( - 0.0196376, - 0.0786361, 1.0982735 )
);
vec4 LinearSRGBToLinearDisplayP3( in vec4 value ) {
	return vec4( value.rgb * LINEAR_SRGB_TO_LINEAR_DISPLAY_P3, value.a );
}
vec4 LinearDisplayP3ToLinearSRGB( in vec4 value ) {
	return vec4( value.rgb * LINEAR_DISPLAY_P3_TO_LINEAR_SRGB, value.a );
}
vec4 LinearTransferOETF( in vec4 value ) {
	return value;
}
vec4 sRGBTransferOETF( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}
vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 LinearTosRGB( in vec4 value ) {
	return sRGBTransferOETF( value );
}`
  , g2 = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`
  , v2 = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`
  , y2 = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`
  , x2 = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`
  , T2 = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`
  , b2 = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`
  , S2 = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`
  , M2 = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`
  , w2 = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`
  , E2 = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`
  , A2 = `#ifdef USE_LIGHTMAP
	vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
	vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
	reflectedLight.indirectDiffuse += lightMapIrradiance;
#endif`
  , P2 = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`
  , R2 = `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`
  , C2 = `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`
  , I2 = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
#if defined( USE_LIGHT_PROBES )
	uniform vec3 lightProbe[ 9 ];
#endif
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	#if defined ( LEGACY_LIGHTS )
		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );
		}
		return 1.0;
	#else
		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
		if ( cutoffDistance > 0.0 ) {
			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
		}
		return distanceFalloff;
	#endif
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`
  , L2 = `#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`
  , D2 = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`
  , O2 = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`
  , U2 = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`
  , N2 = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`
  , F2 = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	if( material.anisotropy == 0.0 ) {
		anisotropyV = vec2( 1.0, 0.0 );
	} else {
		anisotropyV /= material.anisotropy;
		material.anisotropy = saturate( material.anisotropy );
	}
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;
#endif`
  , B2 = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecularDirect = vec3( 0.0 );
vec3 clearcoatSpecularIndirect = vec3( 0.0 );
vec3 sheenSpecularDirect = vec3( 0.0 );
vec3 sheenSpecularIndirect = vec3(0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`
  , k2 = `
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
vec3 geometryClearcoatNormal = vec3( 0.0 );
#ifdef USE_CLEARCOAT
	geometryClearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometryPosition, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometryPosition, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if defined( USE_LIGHT_PROBES )
		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
	#endif
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`
  , z2 = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometryNormal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`
  , H2 = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif`
  , V2 = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`
  , G2 = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`
  , W2 = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`
  , j2 = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`
  , X2 = `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );
	
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`
  , q2 = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`
  , K2 = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`
  , Y2 = `#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`
  , $2 = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`
  , Z2 = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`
  , J2 = `#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`
  , Q2 = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
	#endif
#endif`
  , eO = `#ifdef USE_MORPHTARGETS
	uniform float morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
		uniform sampler2DArray morphTargetsTexture;
		uniform ivec2 morphTargetsTextureSize;
		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
			int y = texelIndex / morphTargetsTextureSize.x;
			int x = texelIndex - y * morphTargetsTextureSize.x;
			ivec3 morphUV = ivec3( x, y, morphTargetIndex );
			return texelFetch( morphTargetsTexture, morphUV, 0 );
		}
	#else
		#ifndef USE_MORPHNORMALS
			uniform float morphTargetInfluences[ 8 ];
		#else
			uniform float morphTargetInfluences[ 4 ];
		#endif
	#endif
#endif`
  , tO = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		transformed += morphTarget0 * morphTargetInfluences[ 0 ];
		transformed += morphTarget1 * morphTargetInfluences[ 1 ];
		transformed += morphTarget2 * morphTargetInfluences[ 2 ];
		transformed += morphTarget3 * morphTargetInfluences[ 3 ];
		#ifndef USE_MORPHNORMALS
			transformed += morphTarget4 * morphTargetInfluences[ 4 ];
			transformed += morphTarget5 * morphTargetInfluences[ 5 ];
			transformed += morphTarget6 * morphTargetInfluences[ 6 ];
			transformed += morphTarget7 * morphTargetInfluences[ 7 ];
		#endif
	#endif
#endif`
  , nO = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 nonPerturbedNormal = normal;`
  , iO = `#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`
  , rO = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`
  , sO = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`
  , oO = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`
  , aO = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`
  , lO = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = nonPerturbedNormal;
#endif`
  , cO = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`
  , uO = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`
  , hO = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`
  , fO = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`
  , dO = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec2 packDepthToRG( in highp float v ) {
	return packDepthToRGBA( v ).yx;
}
float unpackRGToDepth( const in highp vec2 v ) {
	return unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`
  , pO = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`
  , mO = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_BATCHING
	mvPosition = batchingMatrix * mvPosition;
#endif
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`
  , _O = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`
  , gO = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`
  , vO = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`
  , yO = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`
  , xO = `#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`
  , TO = `#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`
  , bO = `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`
  , SO = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`
  , MO = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`
  , wO = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	mat4 getBoneMatrix( const in float i ) {
		int size = textureSize( boneTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`
  , EO = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`
  , AO = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`
  , PO = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`
  , RO = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`
  , CO = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`
  , IO = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`
  , LO = `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`
  , DO = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
		vec3 refractedRayExit = position + transmissionRay;
		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
		vec2 refractionCoords = ndcPos.xy / ndcPos.w;
		refractionCoords += 1.0;
		refractionCoords /= 2.0;
		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
		vec3 transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`
  , OO = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`
  , UO = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`
  , NO = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`
  , FO = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_BATCHING
		worldPosition = batchingMatrix * worldPosition;
	#endif
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;
const BO = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`
  , kO = `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`
  , zO = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`
  , HO = `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`
  , VO = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`
  , GO = `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`
  , WO = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`
  , jO = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`
  , XO = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`
  , qO = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`
  , KO = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`
  , YO = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`
  , $O = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`
  , ZO = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`
  , JO = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`
  , QO = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`
  , eU = `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`
  , tU = `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`
  , nU = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`
  , iU = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`
  , rU = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`
  , sU = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`
  , oU = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`
  , aU = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`
  , lU = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`
  , cU = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`
  , uU = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`
  , hU = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`
  , fU = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`
  , dU = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`
  , pU = `#include <common>
#include <batching_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`
  , mU = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`
  , _U = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`
  , gU = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`
  , ft = {
    alphahash_fragment: kD,
    alphahash_pars_fragment: zD,
    alphamap_fragment: HD,
    alphamap_pars_fragment: VD,
    alphatest_fragment: GD,
    alphatest_pars_fragment: WD,
    aomap_fragment: jD,
    aomap_pars_fragment: XD,
    batching_pars_vertex: qD,
    batching_vertex: KD,
    begin_vertex: YD,
    beginnormal_vertex: $D,
    bsdfs: ZD,
    iridescence_fragment: JD,
    bumpmap_pars_fragment: QD,
    clipping_planes_fragment: e2,
    clipping_planes_pars_fragment: t2,
    clipping_planes_pars_vertex: n2,
    clipping_planes_vertex: i2,
    color_fragment: r2,
    color_pars_fragment: s2,
    color_pars_vertex: o2,
    color_vertex: a2,
    common: l2,
    cube_uv_reflection_fragment: c2,
    defaultnormal_vertex: u2,
    displacementmap_pars_vertex: h2,
    displacementmap_vertex: f2,
    emissivemap_fragment: d2,
    emissivemap_pars_fragment: p2,
    colorspace_fragment: m2,
    colorspace_pars_fragment: _2,
    envmap_fragment: g2,
    envmap_common_pars_fragment: v2,
    envmap_pars_fragment: y2,
    envmap_pars_vertex: x2,
    envmap_physical_pars_fragment: L2,
    envmap_vertex: T2,
    fog_vertex: b2,
    fog_pars_vertex: S2,
    fog_fragment: M2,
    fog_pars_fragment: w2,
    gradientmap_pars_fragment: E2,
    lightmap_fragment: A2,
    lightmap_pars_fragment: P2,
    lights_lambert_fragment: R2,
    lights_lambert_pars_fragment: C2,
    lights_pars_begin: I2,
    lights_toon_fragment: D2,
    lights_toon_pars_fragment: O2,
    lights_phong_fragment: U2,
    lights_phong_pars_fragment: N2,
    lights_physical_fragment: F2,
    lights_physical_pars_fragment: B2,
    lights_fragment_begin: k2,
    lights_fragment_maps: z2,
    lights_fragment_end: H2,
    logdepthbuf_fragment: V2,
    logdepthbuf_pars_fragment: G2,
    logdepthbuf_pars_vertex: W2,
    logdepthbuf_vertex: j2,
    map_fragment: X2,
    map_pars_fragment: q2,
    map_particle_fragment: K2,
    map_particle_pars_fragment: Y2,
    metalnessmap_fragment: $2,
    metalnessmap_pars_fragment: Z2,
    morphcolor_vertex: J2,
    morphnormal_vertex: Q2,
    morphtarget_pars_vertex: eO,
    morphtarget_vertex: tO,
    normal_fragment_begin: nO,
    normal_fragment_maps: iO,
    normal_pars_fragment: rO,
    normal_pars_vertex: sO,
    normal_vertex: oO,
    normalmap_pars_fragment: aO,
    clearcoat_normal_fragment_begin: lO,
    clearcoat_normal_fragment_maps: cO,
    clearcoat_pars_fragment: uO,
    iridescence_pars_fragment: hO,
    opaque_fragment: fO,
    packing: dO,
    premultiplied_alpha_fragment: pO,
    project_vertex: mO,
    dithering_fragment: _O,
    dithering_pars_fragment: gO,
    roughnessmap_fragment: vO,
    roughnessmap_pars_fragment: yO,
    shadowmap_pars_fragment: xO,
    shadowmap_pars_vertex: TO,
    shadowmap_vertex: bO,
    shadowmask_pars_fragment: SO,
    skinbase_vertex: MO,
    skinning_pars_vertex: wO,
    skinning_vertex: EO,
    skinnormal_vertex: AO,
    specularmap_fragment: PO,
    specularmap_pars_fragment: RO,
    tonemapping_fragment: CO,
    tonemapping_pars_fragment: IO,
    transmission_fragment: LO,
    transmission_pars_fragment: DO,
    uv_pars_fragment: OO,
    uv_pars_vertex: UO,
    uv_vertex: NO,
    worldpos_vertex: FO,
    background_vert: BO,
    background_frag: kO,
    backgroundCube_vert: zO,
    backgroundCube_frag: HO,
    cube_vert: VO,
    cube_frag: GO,
    depth_vert: WO,
    depth_frag: jO,
    distanceRGBA_vert: XO,
    distanceRGBA_frag: qO,
    equirect_vert: KO,
    equirect_frag: YO,
    linedashed_vert: $O,
    linedashed_frag: ZO,
    meshbasic_vert: JO,
    meshbasic_frag: QO,
    meshlambert_vert: eU,
    meshlambert_frag: tU,
    meshmatcap_vert: nU,
    meshmatcap_frag: iU,
    meshnormal_vert: rU,
    meshnormal_frag: sU,
    meshphong_vert: oU,
    meshphong_frag: aU,
    meshphysical_vert: lU,
    meshphysical_frag: cU,
    meshtoon_vert: uU,
    meshtoon_frag: hU,
    points_vert: fU,
    points_frag: dU,
    shadow_vert: pU,
    shadow_frag: mU,
    sprite_vert: _U,
    sprite_frag: gU
}
  , Pe = {
    common: {
        diffuse: {
            value: new Ke(16777215)
        },
        opacity: {
            value: 1
        },
        map: {
            value: null
        },
        mapTransform: {
            value: new _t
        },
        alphaMap: {
            value: null
        },
        alphaMapTransform: {
            value: new _t
        },
        alphaTest: {
            value: 0
        }
    },
    specularmap: {
        specularMap: {
            value: null
        },
        specularMapTransform: {
            value: new _t
        }
    },
    envmap: {
        envMap: {
            value: null
        },
        flipEnvMap: {
            value: -1
        },
        reflectivity: {
            value: 1
        },
        ior: {
            value: 1.5
        },
        refractionRatio: {
            value: .98
        }
    },
    aomap: {
        aoMap: {
            value: null
        },
        aoMapIntensity: {
            value: 1
        },
        aoMapTransform: {
            value: new _t
        }
    },
    lightmap: {
        lightMap: {
            value: null
        },
        lightMapIntensity: {
            value: 1
        },
        lightMapTransform: {
            value: new _t
        }
    },
    bumpmap: {
        bumpMap: {
            value: null
        },
        bumpMapTransform: {
            value: new _t
        },
        bumpScale: {
            value: 1
        }
    },
    normalmap: {
        normalMap: {
            value: null
        },
        normalMapTransform: {
            value: new _t
        },
        normalScale: {
            value: new Ce(1,1)
        }
    },
    displacementmap: {
        displacementMap: {
            value: null
        },
        displacementMapTransform: {
            value: new _t
        },
        displacementScale: {
            value: 1
        },
        displacementBias: {
            value: 0
        }
    },
    emissivemap: {
        emissiveMap: {
            value: null
        },
        emissiveMapTransform: {
            value: new _t
        }
    },
    metalnessmap: {
        metalnessMap: {
            value: null
        },
        metalnessMapTransform: {
            value: new _t
        }
    },
    roughnessmap: {
        roughnessMap: {
            value: null
        },
        roughnessMapTransform: {
            value: new _t
        }
    },
    gradientmap: {
        gradientMap: {
            value: null
        }
    },
    fog: {
        fogDensity: {
            value: 25e-5
        },
        fogNear: {
            value: 1
        },
        fogFar: {
            value: 2e3
        },
        fogColor: {
            value: new Ke(16777215)
        }
    },
    lights: {
        ambientLightColor: {
            value: []
        },
        lightProbe: {
            value: []
        },
        directionalLights: {
            value: [],
            properties: {
                direction: {},
                color: {}
            }
        },
        directionalLightShadows: {
            value: [],
            properties: {
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {}
            }
        },
        directionalShadowMap: {
            value: []
        },
        directionalShadowMatrix: {
            value: []
        },
        spotLights: {
            value: [],
            properties: {
                color: {},
                position: {},
                direction: {},
                distance: {},
                coneCos: {},
                penumbraCos: {},
                decay: {}
            }
        },
        spotLightShadows: {
            value: [],
            properties: {
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {}
            }
        },
        spotLightMap: {
            value: []
        },
        spotShadowMap: {
            value: []
        },
        spotLightMatrix: {
            value: []
        },
        pointLights: {
            value: [],
            properties: {
                color: {},
                position: {},
                decay: {},
                distance: {}
            }
        },
        pointLightShadows: {
            value: [],
            properties: {
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {},
                shadowCameraNear: {},
                shadowCameraFar: {}
            }
        },
        pointShadowMap: {
            value: []
        },
        pointShadowMatrix: {
            value: []
        },
        hemisphereLights: {
            value: [],
            properties: {
                direction: {},
                skyColor: {},
                groundColor: {}
            }
        },
        rectAreaLights: {
            value: [],
            properties: {
                color: {},
                position: {},
                width: {},
                height: {}
            }
        },
        ltc_1: {
            value: null
        },
        ltc_2: {
            value: null
        }
    },
    points: {
        diffuse: {
            value: new Ke(16777215)
        },
        opacity: {
            value: 1
        },
        size: {
            value: 1
        },
        scale: {
            value: 1
        },
        map: {
            value: null
        },
        alphaMap: {
            value: null
        },
        alphaMapTransform: {
            value: new _t
        },
        alphaTest: {
            value: 0
        },
        uvTransform: {
            value: new _t
        }
    },
    sprite: {
        diffuse: {
            value: new Ke(16777215)
        },
        opacity: {
            value: 1
        },
        center: {
            value: new Ce(.5,.5)
        },
        rotation: {
            value: 0
        },
        map: {
            value: null
        },
        mapTransform: {
            value: new _t
        },
        alphaMap: {
            value: null
        },
        alphaMapTransform: {
            value: new _t
        },
        alphaTest: {
            value: 0
        }
    }
}
  , Ar = {
    basic: {
        uniforms: li([Pe.common, Pe.specularmap, Pe.envmap, Pe.aomap, Pe.lightmap, Pe.fog]),
        vertexShader: ft.meshbasic_vert,
        fragmentShader: ft.meshbasic_frag
    },
    lambert: {
        uniforms: li([Pe.common, Pe.specularmap, Pe.envmap, Pe.aomap, Pe.lightmap, Pe.emissivemap, Pe.bumpmap, Pe.normalmap, Pe.displacementmap, Pe.fog, Pe.lights, {
            emissive: {
                value: new Ke(0)
            }
        }]),
        vertexShader: ft.meshlambert_vert,
        fragmentShader: ft.meshlambert_frag
    },
    phong: {
        uniforms: li([Pe.common, Pe.specularmap, Pe.envmap, Pe.aomap, Pe.lightmap, Pe.emissivemap, Pe.bumpmap, Pe.normalmap, Pe.displacementmap, Pe.fog, Pe.lights, {
            emissive: {
                value: new Ke(0)
            },
            specular: {
                value: new Ke(1118481)
            },
            shininess: {
                value: 30
            }
        }]),
        vertexShader: ft.meshphong_vert,
        fragmentShader: ft.meshphong_frag
    },
    standard: {
        uniforms: li([Pe.common, Pe.envmap, Pe.aomap, Pe.lightmap, Pe.emissivemap, Pe.bumpmap, Pe.normalmap, Pe.displacementmap, Pe.roughnessmap, Pe.metalnessmap, Pe.fog, Pe.lights, {
            emissive: {
                value: new Ke(0)
            },
            roughness: {
                value: 1
            },
            metalness: {
                value: 0
            },
            envMapIntensity: {
                value: 1
            }
        }]),
        vertexShader: ft.meshphysical_vert,
        fragmentShader: ft.meshphysical_frag
    },
    toon: {
        uniforms: li([Pe.common, Pe.aomap, Pe.lightmap, Pe.emissivemap, Pe.bumpmap, Pe.normalmap, Pe.displacementmap, Pe.gradientmap, Pe.fog, Pe.lights, {
            emissive: {
                value: new Ke(0)
            }
        }]),
        vertexShader: ft.meshtoon_vert,
        fragmentShader: ft.meshtoon_frag
    },
    matcap: {
        uniforms: li([Pe.common, Pe.bumpmap, Pe.normalmap, Pe.displacementmap, Pe.fog, {
            matcap: {
                value: null
            }
        }]),
        vertexShader: ft.meshmatcap_vert,
        fragmentShader: ft.meshmatcap_frag
    },
    points: {
        uniforms: li([Pe.points, Pe.fog]),
        vertexShader: ft.points_vert,
        fragmentShader: ft.points_frag
    },
    dashed: {
        uniforms: li([Pe.common, Pe.fog, {
            scale: {
                value: 1
            },
            dashSize: {
                value: 1
            },
            totalSize: {
                value: 2
            }
        }]),
        vertexShader: ft.linedashed_vert,
        fragmentShader: ft.linedashed_frag
    },
    depth: {
        uniforms: li([Pe.common, Pe.displacementmap]),
        vertexShader: ft.depth_vert,
        fragmentShader: ft.depth_frag
    },
    normal: {
        uniforms: li([Pe.common, Pe.bumpmap, Pe.normalmap, Pe.displacementmap, {
            opacity: {
                value: 1
            }
        }]),
        vertexShader: ft.meshnormal_vert,
        fragmentShader: ft.meshnormal_frag
    },
    sprite: {
        uniforms: li([Pe.sprite, Pe.fog]),
        vertexShader: ft.sprite_vert,
        fragmentShader: ft.sprite_frag
    },
    background: {
        uniforms: {
            uvTransform: {
                value: new _t
            },
            t2D: {
                value: null
            },
            backgroundIntensity: {
                value: 1
            }
        },
        vertexShader: ft.background_vert,
        fragmentShader: ft.background_frag
    },
    backgroundCube: {
        uniforms: {
            envMap: {
                value: null
            },
            flipEnvMap: {
                value: -1
            },
            backgroundBlurriness: {
                value: 0
            },
            backgroundIntensity: {
                value: 1
            }
        },
        vertexShader: ft.backgroundCube_vert,
        fragmentShader: ft.backgroundCube_frag
    },
    cube: {
        uniforms: {
            tCube: {
                value: null
            },
            tFlip: {
                value: -1
            },
            opacity: {
                value: 1
            }
        },
        vertexShader: ft.cube_vert,
        fragmentShader: ft.cube_frag
    },
    equirect: {
        uniforms: {
            tEquirect: {
                value: null
            }
        },
        vertexShader: ft.equirect_vert,
        fragmentShader: ft.equirect_frag
    },
    distanceRGBA: {
        uniforms: li([Pe.common, Pe.displacementmap, {
            referencePosition: {
                value: new k
            },
            nearDistance: {
                value: 1
            },
            farDistance: {
                value: 1e3
            }
        }]),
        vertexShader: ft.distanceRGBA_vert,
        fragmentShader: ft.distanceRGBA_frag
    },
    shadow: {
        uniforms: li([Pe.lights, Pe.fog, {
            color: {
                value: new Ke(0)
            },
            opacity: {
                value: 1
            }
        }]),
        vertexShader: ft.shadow_vert,
        fragmentShader: ft.shadow_frag
    }
};
Ar.physical = {
    uniforms: li([Ar.standard.uniforms, {
        clearcoat: {
            value: 0
        },
        clearcoatMap: {
            value: null
        },
        clearcoatMapTransform: {
            value: new _t
        },
        clearcoatNormalMap: {
            value: null
        },
        clearcoatNormalMapTransform: {
            value: new _t
        },
        clearcoatNormalScale: {
            value: new Ce(1,1)
        },
        clearcoatRoughness: {
            value: 0
        },
        clearcoatRoughnessMap: {
            value: null
        },
        clearcoatRoughnessMapTransform: {
            value: new _t
        },
        iridescence: {
            value: 0
        },
        iridescenceMap: {
            value: null
        },
        iridescenceMapTransform: {
            value: new _t
        },
        iridescenceIOR: {
            value: 1.3
        },
        iridescenceThicknessMinimum: {
            value: 100
        },
        iridescenceThicknessMaximum: {
            value: 400
        },
        iridescenceThicknessMap: {
            value: null
        },
        iridescenceThicknessMapTransform: {
            value: new _t
        },
        sheen: {
            value: 0
        },
        sheenColor: {
            value: new Ke(0)
        },
        sheenColorMap: {
            value: null
        },
        sheenColorMapTransform: {
            value: new _t
        },
        sheenRoughness: {
            value: 1
        },
        sheenRoughnessMap: {
            value: null
        },
        sheenRoughnessMapTransform: {
            value: new _t
        },
        transmission: {
            value: 0
        },
        transmissionMap: {
            value: null
        },
        transmissionMapTransform: {
            value: new _t
        },
        transmissionSamplerSize: {
            value: new Ce
        },
        transmissionSamplerMap: {
            value: null
        },
        thickness: {
            value: 0
        },
        thicknessMap: {
            value: null
        },
        thicknessMapTransform: {
            value: new _t
        },
        attenuationDistance: {
            value: 0
        },
        attenuationColor: {
            value: new Ke(0)
        },
        specularColor: {
            value: new Ke(1,1,1)
        },
        specularColorMap: {
            value: null
        },
        specularColorMapTransform: {
            value: new _t
        },
        specularIntensity: {
            value: 1
        },
        specularIntensityMap: {
            value: null
        },
        specularIntensityMapTransform: {
            value: new _t
        },
        anisotropyVector: {
            value: new Ce
        },
        anisotropyMap: {
            value: null
        },
        anisotropyMapTransform: {
            value: new _t
        }
    }]),
    vertexShader: ft.meshphysical_vert,
    fragmentShader: ft.meshphysical_frag
};
const Qu = {
    r: 0,
    b: 0,
    g: 0
};
function vU(r, e, t, n, i, s, o) {
    const a = new Ke(0);
    let c = s === !0 ? 0 : 1, h, d, l = null, f = 0, p = null;
    function g(v, _) {
        let b = !1
          , T = _.isScene === !0 ? _.background : null;
        T && T.isTexture && (T = (_.backgroundBlurriness > 0 ? t : e).get(T)),
        T === null ? y(a, c) : T && T.isColor && (y(T, 1),
        b = !0);
        const S = r.xr.getEnvironmentBlendMode();
        S === "additive" ? n.buffers.color.setClear(0, 0, 0, 1, o) : S === "alpha-blend" && n.buffers.color.setClear(0, 0, 0, 0, o),
        (r.autoClear || b) && r.clear(r.autoClearColor, r.autoClearDepth, r.autoClearStencil),
        T && (T.isCubeTexture || T.mapping === ff) ? (d === void 0 && (d = new en(new Bc(1,1,1),new Vt({
            name: "BackgroundCubeMaterial",
            uniforms: ll(Ar.backgroundCube.uniforms),
            vertexShader: Ar.backgroundCube.vertexShader,
            fragmentShader: Ar.backgroundCube.fragmentShader,
            side: fi,
            depthTest: !1,
            depthWrite: !1,
            fog: !1
        })),
        d.geometry.deleteAttribute("normal"),
        d.geometry.deleteAttribute("uv"),
        d.onBeforeRender = function(E, P, R) {
            this.matrixWorld.copyPosition(R.matrixWorld)
        }
        ,
        Object.defineProperty(d.material, "envMap", {
            get: function() {
                return this.uniforms.envMap.value
            }
        }),
        i.update(d)),
        d.material.uniforms.envMap.value = T,
        d.material.uniforms.flipEnvMap.value = T.isCubeTexture && T.isRenderTargetTexture === !1 ? -1 : 1,
        d.material.uniforms.backgroundBlurriness.value = _.backgroundBlurriness,
        d.material.uniforms.backgroundIntensity.value = _.backgroundIntensity,
        d.material.toneMapped = Rt.getTransfer(T.colorSpace) !== Zt,
        (l !== T || f !== T.version || p !== r.toneMapping) && (d.material.needsUpdate = !0,
        l = T,
        f = T.version,
        p = r.toneMapping),
        d.layers.enableAll(),
        v.unshift(d, d.geometry, d.material, 0, 0, null)) : T && T.isTexture && (h === void 0 && (h = new en(new Tr(2,2),new Vt({
            name: "BackgroundMaterial",
            uniforms: ll(Ar.background.uniforms),
            vertexShader: Ar.background.vertexShader,
            fragmentShader: Ar.background.fragmentShader,
            side: xr,
            depthTest: !1,
            depthWrite: !1,
            fog: !1
        })),
        h.geometry.deleteAttribute("normal"),
        Object.defineProperty(h.material, "map", {
            get: function() {
                return this.uniforms.t2D.value
            }
        }),
        i.update(h)),
        h.material.uniforms.t2D.value = T,
        h.material.uniforms.backgroundIntensity.value = _.backgroundIntensity,
        h.material.toneMapped = Rt.getTransfer(T.colorSpace) !== Zt,
        T.matrixAutoUpdate === !0 && T.updateMatrix(),
        h.material.uniforms.uvTransform.value.copy(T.matrix),
        (l !== T || f !== T.version || p !== r.toneMapping) && (h.material.needsUpdate = !0,
        l = T,
        f = T.version,
        p = r.toneMapping),
        h.layers.enableAll(),
        v.unshift(h, h.geometry, h.material, 0, 0, null))
    }
    function y(v, _) {
        v.getRGB(Qu, Ub(r)),
        n.buffers.color.setClear(Qu.r, Qu.g, Qu.b, _, o)
    }
    return {
        getClearColor: function() {
            return a
        },
        setClearColor: function(v, _=1) {
            a.set(v),
            c = _,
            y(a, c)
        },
        getClearAlpha: function() {
            return c
        },
        setClearAlpha: function(v) {
            c = v,
            y(a, c)
        },
        render: g
    }
}
function yU(r, e, t, n) {
    const i = r.getParameter(r.MAX_VERTEX_ATTRIBS)
      , s = n.isWebGL2 ? null : e.get("OES_vertex_array_object")
      , o = n.isWebGL2 || s !== null
      , a = {}
      , c = v(null);
    let h = c
      , d = !1;
    function l(F, j, K, J, de) {
        let ae = !1;
        if (o) {
            const ue = y(J, K, j);
            h !== ue && (h = ue,
            p(h.object)),
            ae = _(F, J, K, de),
            ae && b(F, J, K, de)
        } else {
            const ue = j.wireframe === !0;
            (h.geometry !== J.id || h.program !== K.id || h.wireframe !== ue) && (h.geometry = J.id,
            h.program = K.id,
            h.wireframe = ue,
            ae = !0)
        }
        de !== null && t.update(de, r.ELEMENT_ARRAY_BUFFER),
        (ae || d) && (d = !1,
        O(F, j, K, J),
        de !== null && r.bindBuffer(r.ELEMENT_ARRAY_BUFFER, t.get(de).buffer))
    }
    function f() {
        return n.isWebGL2 ? r.createVertexArray() : s.createVertexArrayOES()
    }
    function p(F) {
        return n.isWebGL2 ? r.bindVertexArray(F) : s.bindVertexArrayOES(F)
    }
    function g(F) {
        return n.isWebGL2 ? r.deleteVertexArray(F) : s.deleteVertexArrayOES(F)
    }
    function y(F, j, K) {
        const J = K.wireframe === !0;
        let de = a[F.id];
        de === void 0 && (de = {},
        a[F.id] = de);
        let ae = de[j.id];
        ae === void 0 && (ae = {},
        de[j.id] = ae);
        let ue = ae[J];
        return ue === void 0 && (ue = v(f()),
        ae[J] = ue),
        ue
    }
    function v(F) {
        const j = []
          , K = []
          , J = [];
        for (let de = 0; de < i; de++)
            j[de] = 0,
            K[de] = 0,
            J[de] = 0;
        return {
            geometry: null,
            program: null,
            wireframe: !1,
            newAttributes: j,
            enabledAttributes: K,
            attributeDivisors: J,
            object: F,
            attributes: {},
            index: null
        }
    }
    function _(F, j, K, J) {
        const de = h.attributes
          , ae = j.attributes;
        let ue = 0;
        const ge = K.getAttributes();
        for (const Ee in ge)
            if (ge[Ee].location >= 0) {
                const he = de[Ee];
                let xe = ae[Ee];
                if (xe === void 0 && (Ee === "instanceMatrix" && F.instanceMatrix && (xe = F.instanceMatrix),
                Ee === "instanceColor" && F.instanceColor && (xe = F.instanceColor)),
                he === void 0 || he.attribute !== xe || xe && he.data !== xe.data)
                    return !0;
                ue++
            }
        return h.attributesNum !== ue || h.index !== J
    }
    function b(F, j, K, J) {
        const de = {}
          , ae = j.attributes;
        let ue = 0;
        const ge = K.getAttributes();
        for (const Ee in ge)
            if (ge[Ee].location >= 0) {
                let he = ae[Ee];
                he === void 0 && (Ee === "instanceMatrix" && F.instanceMatrix && (he = F.instanceMatrix),
                Ee === "instanceColor" && F.instanceColor && (he = F.instanceColor));
                const xe = {};
                xe.attribute = he,
                he && he.data && (xe.data = he.data),
                de[Ee] = xe,
                ue++
            }
        h.attributes = de,
        h.attributesNum = ue,
        h.index = J
    }
    function T() {
        const F = h.newAttributes;
        for (let j = 0, K = F.length; j < K; j++)
            F[j] = 0
    }
    function S(F) {
        E(F, 0)
    }
    function E(F, j) {
        const K = h.newAttributes
          , J = h.enabledAttributes
          , de = h.attributeDivisors;
        K[F] = 1,
        J[F] === 0 && (r.enableVertexAttribArray(F),
        J[F] = 1),
        de[F] !== j && ((n.isWebGL2 ? r : e.get("ANGLE_instanced_arrays"))[n.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](F, j),
        de[F] = j)
    }
    function P() {
        const F = h.newAttributes
          , j = h.enabledAttributes;
        for (let K = 0, J = j.length; K < J; K++)
            j[K] !== F[K] && (r.disableVertexAttribArray(K),
            j[K] = 0)
    }
    function R(F, j, K, J, de, ae, ue) {
        ue === !0 ? r.vertexAttribIPointer(F, j, K, de, ae) : r.vertexAttribPointer(F, j, K, J, de, ae)
    }
    function O(F, j, K, J) {
        if (n.isWebGL2 === !1 && (F.isInstancedMesh || J.isInstancedBufferGeometry) && e.get("ANGLE_instanced_arrays") === null)
            return;
        T();
        const de = J.attributes
          , ae = K.getAttributes()
          , ue = j.defaultAttributeValues;
        for (const ge in ae) {
            const Ee = ae[ge];
            if (Ee.location >= 0) {
                let oe = de[ge];
                if (oe === void 0 && (ge === "instanceMatrix" && F.instanceMatrix && (oe = F.instanceMatrix),
                ge === "instanceColor" && F.instanceColor && (oe = F.instanceColor)),
                oe !== void 0) {
                    const he = oe.normalized
                      , xe = oe.itemSize
                      , Be = t.get(oe);
                    if (Be === void 0)
                        continue;
                    const De = Be.buffer
                      , et = Be.type
                      , Ze = Be.bytesPerElement
                      , We = n.isWebGL2 === !0 && (et === r.INT || et === r.UNSIGNED_INT || oe.gpuType === vb);
                    if (oe.isInterleavedBufferAttribute) {
                        const Je = oe.data
                          , Q = Je.stride
                          , hn = oe.offset;
                        if (Je.isInstancedInterleavedBuffer) {
                            for (let ze = 0; ze < Ee.locationSize; ze++)
                                E(Ee.location + ze, Je.meshPerAttribute);
                            F.isInstancedMesh !== !0 && J._maxInstanceCount === void 0 && (J._maxInstanceCount = Je.meshPerAttribute * Je.count)
                        } else
                            for (let ze = 0; ze < Ee.locationSize; ze++)
                                S(Ee.location + ze);
                        r.bindBuffer(r.ARRAY_BUFFER, De);
                        for (let ze = 0; ze < Ee.locationSize; ze++)
                            R(Ee.location + ze, xe / Ee.locationSize, et, he, Q * Ze, (hn + xe / Ee.locationSize * ze) * Ze, We)
                    } else {
                        if (oe.isInstancedBufferAttribute) {
                            for (let Je = 0; Je < Ee.locationSize; Je++)
                                E(Ee.location + Je, oe.meshPerAttribute);
                            F.isInstancedMesh !== !0 && J._maxInstanceCount === void 0 && (J._maxInstanceCount = oe.meshPerAttribute * oe.count)
                        } else
                            for (let Je = 0; Je < Ee.locationSize; Je++)
                                S(Ee.location + Je);
                        r.bindBuffer(r.ARRAY_BUFFER, De);
                        for (let Je = 0; Je < Ee.locationSize; Je++)
                            R(Ee.location + Je, xe / Ee.locationSize, et, he, xe * Ze, xe / Ee.locationSize * Je * Ze, We)
                    }
                } else if (ue !== void 0) {
                    const he = ue[ge];
                    if (he !== void 0)
                        switch (he.length) {
                        case 2:
                            r.vertexAttrib2fv(Ee.location, he);
                            break;
                        case 3:
                            r.vertexAttrib3fv(Ee.location, he);
                            break;
                        case 4:
                            r.vertexAttrib4fv(Ee.location, he);
                            break;
                        default:
                            r.vertexAttrib1fv(Ee.location, he)
                        }
                }
            }
        }
        P()
    }
    function w() {
        z();
        for (const F in a) {
            const j = a[F];
            for (const K in j) {
                const J = j[K];
                for (const de in J)
                    g(J[de].object),
                    delete J[de];
                delete j[K]
            }
            delete a[F]
        }
    }
    function I(F) {
        if (a[F.id] === void 0)
            return;
        const j = a[F.id];
        for (const K in j) {
            const J = j[K];
            for (const de in J)
                g(J[de].object),
                delete J[de];
            delete j[K]
        }
        delete a[F.id]
    }
    function V(F) {
        for (const j in a) {
            const K = a[j];
            if (K[F.id] === void 0)
                continue;
            const J = K[F.id];
            for (const de in J)
                g(J[de].object),
                delete J[de];
            delete K[F.id]
        }
    }
    function z() {
        q(),
        d = !0,
        h !== c && (h = c,
        p(h.object))
    }
    function q() {
        c.geometry = null,
        c.program = null,
        c.wireframe = !1
    }
    return {
        setup: l,
        reset: z,
        resetDefaultState: q,
        dispose: w,
        releaseStatesOfGeometry: I,
        releaseStatesOfProgram: V,
        initAttributes: T,
        enableAttribute: S,
        disableUnusedAttributes: P
    }
}
function xU(r, e, t, n) {
    const i = n.isWebGL2;
    let s;
    function o(d) {
        s = d
    }
    function a(d, l) {
        r.drawArrays(s, d, l),
        t.update(l, s, 1)
    }
    function c(d, l, f) {
        if (f === 0)
            return;
        let p, g;
        if (i)
            p = r,
            g = "drawArraysInstanced";
        else if (p = e.get("ANGLE_instanced_arrays"),
        g = "drawArraysInstancedANGLE",
        p === null) {
            console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
            return
        }
        p[g](s, d, l, f),
        t.update(l, s, f)
    }
    function h(d, l, f) {
        if (f === 0)
            return;
        const p = e.get("WEBGL_multi_draw");
        if (p === null)
            for (let g = 0; g < f; g++)
                this.render(d[g], l[g]);
        else {
            p.multiDrawArraysWEBGL(s, d, 0, l, 0, f);
            let g = 0;
            for (let y = 0; y < f; y++)
                g += l[y];
            t.update(g, s, 1)
        }
    }
    this.setMode = o,
    this.render = a,
    this.renderInstances = c,
    this.renderMultiDraw = h
}
function TU(r, e, t) {
    let n;
    function i() {
        if (n !== void 0)
            return n;
        if (e.has("EXT_texture_filter_anisotropic") === !0) {
            const R = e.get("EXT_texture_filter_anisotropic");
            n = r.getParameter(R.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
        } else
            n = 0;
        return n
    }
    function s(R) {
        if (R === "highp") {
            if (r.getShaderPrecisionFormat(r.VERTEX_SHADER, r.HIGH_FLOAT).precision > 0 && r.getShaderPrecisionFormat(r.FRAGMENT_SHADER, r.HIGH_FLOAT).precision > 0)
                return "highp";
            R = "mediump"
        }
        return R === "mediump" && r.getShaderPrecisionFormat(r.VERTEX_SHADER, r.MEDIUM_FLOAT).precision > 0 && r.getShaderPrecisionFormat(r.FRAGMENT_SHADER, r.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp"
    }
    const o = typeof WebGL2RenderingContext < "u" && r.constructor.name === "WebGL2RenderingContext";
    let a = t.precision !== void 0 ? t.precision : "highp";
    const c = s(a);
    c !== a && (console.warn("THREE.WebGLRenderer:", a, "not supported, using", c, "instead."),
    a = c);
    const h = o || e.has("WEBGL_draw_buffers")
      , d = t.logarithmicDepthBuffer === !0
      , l = r.getParameter(r.MAX_TEXTURE_IMAGE_UNITS)
      , f = r.getParameter(r.MAX_VERTEX_TEXTURE_IMAGE_UNITS)
      , p = r.getParameter(r.MAX_TEXTURE_SIZE)
      , g = r.getParameter(r.MAX_CUBE_MAP_TEXTURE_SIZE)
      , y = r.getParameter(r.MAX_VERTEX_ATTRIBS)
      , v = r.getParameter(r.MAX_VERTEX_UNIFORM_VECTORS)
      , _ = r.getParameter(r.MAX_VARYING_VECTORS)
      , b = r.getParameter(r.MAX_FRAGMENT_UNIFORM_VECTORS)
      , T = f > 0
      , S = o || e.has("OES_texture_float")
      , E = T && S
      , P = o ? r.getParameter(r.MAX_SAMPLES) : 0;
    return {
        isWebGL2: o,
        drawBuffers: h,
        getMaxAnisotropy: i,
        getMaxPrecision: s,
        precision: a,
        logarithmicDepthBuffer: d,
        maxTextures: l,
        maxVertexTextures: f,
        maxTextureSize: p,
        maxCubemapSize: g,
        maxAttributes: y,
        maxVertexUniforms: v,
        maxVaryings: _,
        maxFragmentUniforms: b,
        vertexTextures: T,
        floatFragmentTextures: S,
        floatVertexTextures: E,
        maxSamples: P
    }
}
function bU(r) {
    const e = this;
    let t = null
      , n = 0
      , i = !1
      , s = !1;
    const o = new pr
      , a = new _t
      , c = {
        value: null,
        needsUpdate: !1
    };
    this.uniform = c,
    this.numPlanes = 0,
    this.numIntersection = 0,
    this.init = function(l, f) {
        const p = l.length !== 0 || f || n !== 0 || i;
        return i = f,
        n = l.length,
        p
    }
    ,
    this.beginShadows = function() {
        s = !0,
        d(null)
    }
    ,
    this.endShadows = function() {
        s = !1
    }
    ,
    this.setGlobalState = function(l, f) {
        t = d(l, f, 0)
    }
    ,
    this.setState = function(l, f, p) {
        const g = l.clippingPlanes
          , y = l.clipIntersection
          , v = l.clipShadows
          , _ = r.get(l);
        if (!i || g === null || g.length === 0 || s && !v)
            s ? d(null) : h();
        else {
            const b = s ? 0 : n
              , T = b * 4;
            let S = _.clippingState || null;
            c.value = S,
            S = d(g, f, T, p);
            for (let E = 0; E !== T; ++E)
                S[E] = t[E];
            _.clippingState = S,
            this.numIntersection = y ? this.numPlanes : 0,
            this.numPlanes += b
        }
    }
    ;
    function h() {
        c.value !== t && (c.value = t,
        c.needsUpdate = n > 0),
        e.numPlanes = n,
        e.numIntersection = 0
    }
    function d(l, f, p, g) {
        const y = l !== null ? l.length : 0;
        let v = null;
        if (y !== 0) {
            if (v = c.value,
            g !== !0 || v === null) {
                const _ = p + y * 4
                  , b = f.matrixWorldInverse;
                a.getNormalMatrix(b),
                (v === null || v.length < _) && (v = new Float32Array(_));
                for (let T = 0, S = p; T !== y; ++T,
                S += 4)
                    o.copy(l[T]).applyMatrix4(b, a),
                    o.normal.toArray(v, S),
                    v[S + 3] = o.constant
            }
            c.value = v,
            c.needsUpdate = !0
        }
        return e.numPlanes = y,
        e.numIntersection = 0,
        v
    }
}
function SU(r) {
    let e = new WeakMap;
    function t(o, a) {
        return a === Nm ? o.mapping = il : a === Fm && (o.mapping = rl),
        o
    }
    function n(o) {
        if (o && o.isTexture) {
            const a = o.mapping;
            if (a === Nm || a === Fm)
                if (e.has(o)) {
                    const c = e.get(o).texture;
                    return t(c, o.mapping)
                } else {
                    const c = o.image;
                    if (c && c.height > 0) {
                        const h = new UD(c.height / 2);
                        return h.fromEquirectangularTexture(r, o),
                        e.set(o, h),
                        o.addEventListener("dispose", i),
                        t(h.texture, o.mapping)
                    } else
                        return null
                }
        }
        return o
    }
    function i(o) {
        const a = o.target;
        a.removeEventListener("dispose", i);
        const c = e.get(a);
        c !== void 0 && (e.delete(a),
        c.dispose())
    }
    function s() {
        e = new WeakMap
    }
    return {
        get: n,
        dispose: s
    }
}
class vl extends D_ {
    constructor(e=-1, t=1, n=1, i=-1, s=.1, o=2e3) {
        super(),
        this.isOrthographicCamera = !0,
        this.type = "OrthographicCamera",
        this.zoom = 1,
        this.view = null,
        this.left = e,
        this.right = t,
        this.top = n,
        this.bottom = i,
        this.near = s,
        this.far = o,
        this.updateProjectionMatrix()
    }
    copy(e, t) {
        return super.copy(e, t),
        this.left = e.left,
        this.right = e.right,
        this.top = e.top,
        this.bottom = e.bottom,
        this.near = e.near,
        this.far = e.far,
        this.zoom = e.zoom,
        this.view = e.view === null ? null : Object.assign({}, e.view),
        this
    }
    setViewOffset(e, t, n, i, s, o) {
        this.view === null && (this.view = {
            enabled: !0,
            fullWidth: 1,
            fullHeight: 1,
            offsetX: 0,
            offsetY: 0,
            width: 1,
            height: 1
        }),
        this.view.enabled = !0,
        this.view.fullWidth = e,
        this.view.fullHeight = t,
        this.view.offsetX = n,
        this.view.offsetY = i,
        this.view.width = s,
        this.view.height = o,
        this.updateProjectionMatrix()
    }
    clearViewOffset() {
        this.view !== null && (this.view.enabled = !1),
        this.updateProjectionMatrix()
    }
    updateProjectionMatrix() {
        const e = (this.right - this.left) / (2 * this.zoom)
          , t = (this.top - this.bottom) / (2 * this.zoom)
          , n = (this.right + this.left) / 2
          , i = (this.top + this.bottom) / 2;
        let s = n - e
          , o = n + e
          , a = i + t
          , c = i - t;
        if (this.view !== null && this.view.enabled) {
            const h = (this.right - this.left) / this.view.fullWidth / this.zoom
              , d = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
            s += h * this.view.offsetX,
            o = s + h * this.view.width,
            a -= d * this.view.offsetY,
            c = a - d * this.view.height
        }
        this.projectionMatrix.makeOrthographic(s, o, a, c, this.near, this.far, this.coordinateSystem),
        this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return t.object.zoom = this.zoom,
        t.object.left = this.left,
        t.object.right = this.right,
        t.object.top = this.top,
        t.object.bottom = this.bottom,
        t.object.near = this.near,
        t.object.far = this.far,
        this.view !== null && (t.object.view = Object.assign({}, this.view)),
        t
    }
}
const Va = 4
  , py = [.125, .215, .35, .446, .526, .582]
  , So = 20
  , Dp = new vl
  , my = new Ke;
let Op = null
  , Up = 0
  , Np = 0;
const To = (1 + Math.sqrt(5)) / 2
  , xa = 1 / To
  , _y = [new k(1,1,1), new k(-1,1,1), new k(1,1,-1), new k(-1,1,-1), new k(0,To,xa), new k(0,To,-xa), new k(xa,0,To), new k(-xa,0,To), new k(To,xa,0), new k(-To,xa,0)];
class Gm {
    constructor(e) {
        this._renderer = e,
        this._pingPongRenderTarget = null,
        this._lodMax = 0,
        this._cubeSize = 0,
        this._lodPlanes = [],
        this._sizeLods = [],
        this._sigmas = [],
        this._blurMaterial = null,
        this._cubemapMaterial = null,
        this._equirectMaterial = null,
        this._compileMaterial(this._blurMaterial)
    }
    fromScene(e, t=0, n=.1, i=100) {
        Op = this._renderer.getRenderTarget(),
        Up = this._renderer.getActiveCubeFace(),
        Np = this._renderer.getActiveMipmapLevel(),
        this._setSize(256);
        const s = this._allocateTargets();
        return s.depthBuffer = !0,
        this._sceneToCubeUV(e, n, i, s),
        t > 0 && this._blur(s, 0, 0, t),
        this._applyPMREM(s),
        this._cleanup(s),
        s
    }
    fromEquirectangular(e, t=null) {
        return this._fromTexture(e, t)
    }
    fromCubemap(e, t=null) {
        return this._fromTexture(e, t)
    }
    compileCubemapShader() {
        this._cubemapMaterial === null && (this._cubemapMaterial = yy(),
        this._compileMaterial(this._cubemapMaterial))
    }
    compileEquirectangularShader() {
        this._equirectMaterial === null && (this._equirectMaterial = vy(),
        this._compileMaterial(this._equirectMaterial))
    }
    dispose() {
        this._dispose(),
        this._cubemapMaterial !== null && this._cubemapMaterial.dispose(),
        this._equirectMaterial !== null && this._equirectMaterial.dispose()
    }
    _setSize(e) {
        this._lodMax = Math.floor(Math.log2(e)),
        this._cubeSize = Math.pow(2, this._lodMax)
    }
    _dispose() {
        this._blurMaterial !== null && this._blurMaterial.dispose(),
        this._pingPongRenderTarget !== null && this._pingPongRenderTarget.dispose();
        for (let e = 0; e < this._lodPlanes.length; e++)
            this._lodPlanes[e].dispose()
    }
    _cleanup(e) {
        this._renderer.setRenderTarget(Op, Up, Np),
        e.scissorTest = !1,
        eh(e, 0, 0, e.width, e.height)
    }
    _fromTexture(e, t) {
        e.mapping === il || e.mapping === rl ? this._setSize(e.image.length === 0 ? 16 : e.image[0].width || e.image[0].image.width) : this._setSize(e.image.width / 4),
        Op = this._renderer.getRenderTarget(),
        Up = this._renderer.getActiveCubeFace(),
        Np = this._renderer.getActiveMipmapLevel();
        const n = t || this._allocateTargets();
        return this._textureToCubeUV(e, n),
        this._applyPMREM(n),
        this._cleanup(n),
        n
    }
    _allocateTargets() {
        const e = 3 * Math.max(this._cubeSize, 112)
          , t = 4 * this._cubeSize
          , n = {
            magFilter: Ot,
            minFilter: Ot,
            generateMipmaps: !1,
            type: Ur,
            format: Kn,
            colorSpace: gn,
            depthBuffer: !1
        }
          , i = gy(e, t, n);
        if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== e || this._pingPongRenderTarget.height !== t) {
            this._pingPongRenderTarget !== null && this._dispose(),
            this._pingPongRenderTarget = gy(e, t, n);
            const {_lodMax: s} = this;
            ({sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas} = MU(s)),
            this._blurMaterial = wU(s, e, t)
        }
        return i
    }
    _compileMaterial(e) {
        const t = new en(this._lodPlanes[0],e);
        this._renderer.compile(t, Dp)
    }
    _sceneToCubeUV(e, t, n, i) {
        const a = new qn(90,1,t,n)
          , c = [1, -1, 1, 1, 1, 1]
          , h = [1, 1, 1, -1, -1, -1]
          , d = this._renderer
          , l = d.autoClear
          , f = d.toneMapping;
        d.getClearColor(my),
        d.toneMapping = Ns,
        d.autoClear = !1;
        const p = new _r({
            name: "PMREM.Background",
            side: fi,
            depthWrite: !1,
            depthTest: !1
        })
          , g = new en(new Bc,p);
        let y = !1;
        const v = e.background;
        v ? v.isColor && (p.color.copy(v),
        e.background = null,
        y = !0) : (p.color.copy(my),
        y = !0);
        for (let _ = 0; _ < 6; _++) {
            const b = _ % 3;
            b === 0 ? (a.up.set(0, c[_], 0),
            a.lookAt(h[_], 0, 0)) : b === 1 ? (a.up.set(0, 0, c[_]),
            a.lookAt(0, h[_], 0)) : (a.up.set(0, c[_], 0),
            a.lookAt(0, 0, h[_]));
            const T = this._cubeSize;
            eh(i, b * T, _ > 2 ? T : 0, T, T),
            d.setRenderTarget(i),
            y && d.render(g, a),
            d.render(e, a)
        }
        g.geometry.dispose(),
        g.material.dispose(),
        d.toneMapping = f,
        d.autoClear = l,
        e.background = v
    }
    _textureToCubeUV(e, t) {
        const n = this._renderer
          , i = e.mapping === il || e.mapping === rl;
        i ? (this._cubemapMaterial === null && (this._cubemapMaterial = yy()),
        this._cubemapMaterial.uniforms.flipEnvMap.value = e.isRenderTargetTexture === !1 ? -1 : 1) : this._equirectMaterial === null && (this._equirectMaterial = vy());
        const s = i ? this._cubemapMaterial : this._equirectMaterial
          , o = new en(this._lodPlanes[0],s)
          , a = s.uniforms;
        a.envMap.value = e;
        const c = this._cubeSize;
        eh(t, 0, 0, 3 * c, 2 * c),
        n.setRenderTarget(t),
        n.render(o, Dp)
    }
    _applyPMREM(e) {
        const t = this._renderer
          , n = t.autoClear;
        t.autoClear = !1;
        for (let i = 1; i < this._lodPlanes.length; i++) {
            const s = Math.sqrt(this._sigmas[i] * this._sigmas[i] - this._sigmas[i - 1] * this._sigmas[i - 1])
              , o = _y[(i - 1) % _y.length];
            this._blur(e, i - 1, i, s, o)
        }
        t.autoClear = n
    }
    _blur(e, t, n, i, s) {
        const o = this._pingPongRenderTarget;
        this._halfBlur(e, o, t, n, i, "latitudinal", s),
        this._halfBlur(o, e, n, n, i, "longitudinal", s)
    }
    _halfBlur(e, t, n, i, s, o, a) {
        const c = this._renderer
          , h = this._blurMaterial;
        o !== "latitudinal" && o !== "longitudinal" && console.error("blur direction must be either latitudinal or longitudinal!");
        const d = 3
          , l = new en(this._lodPlanes[i],h)
          , f = h.uniforms
          , p = this._sizeLods[n] - 1
          , g = isFinite(s) ? Math.PI / (2 * p) : 2 * Math.PI / (2 * So - 1)
          , y = s / g
          , v = isFinite(s) ? 1 + Math.floor(d * y) : So;
        v > So && console.warn(`sigmaRadians, ${s}, is too large and will clip, as it requested ${v} samples when the maximum is set to ${So}`);
        const _ = [];
        let b = 0;
        for (let R = 0; R < So; ++R) {
            const O = R / y
              , w = Math.exp(-O * O / 2);
            _.push(w),
            R === 0 ? b += w : R < v && (b += 2 * w)
        }
        for (let R = 0; R < _.length; R++)
            _[R] = _[R] / b;
        f.envMap.value = e.texture,
        f.samples.value = v,
        f.weights.value = _,
        f.latitudinal.value = o === "latitudinal",
        a && (f.poleAxis.value = a);
        const {_lodMax: T} = this;
        f.dTheta.value = g,
        f.mipInt.value = T - n;
        const S = this._sizeLods[i]
          , E = 3 * S * (i > T - Va ? i - T + Va : 0)
          , P = 4 * (this._cubeSize - S);
        eh(t, E, P, 3 * S, 2 * S),
        c.setRenderTarget(t),
        c.render(l, Dp)
    }
}
function MU(r) {
    const e = []
      , t = []
      , n = [];
    let i = r;
    const s = r - Va + 1 + py.length;
    for (let o = 0; o < s; o++) {
        const a = Math.pow(2, i);
        t.push(a);
        let c = 1 / a;
        o > r - Va ? c = py[o - r + Va - 1] : o === 0 && (c = 0),
        n.push(c);
        const h = 1 / (a - 2)
          , d = -h
          , l = 1 + h
          , f = [d, d, l, d, l, l, d, d, l, l, d, l]
          , p = 6
          , g = 6
          , y = 3
          , v = 2
          , _ = 1
          , b = new Float32Array(y * g * p)
          , T = new Float32Array(v * g * p)
          , S = new Float32Array(_ * g * p);
        for (let P = 0; P < p; P++) {
            const R = P % 3 * 2 / 3 - 1
              , O = P > 2 ? 0 : -1
              , w = [R, O, 0, R + 2 / 3, O, 0, R + 2 / 3, O + 1, 0, R, O, 0, R + 2 / 3, O + 1, 0, R, O + 1, 0];
            b.set(w, y * g * P),
            T.set(f, v * g * P);
            const I = [P, P, P, P, P, P];
            S.set(I, _ * g * P)
        }
        const E = new mn;
        E.setAttribute("position", new pt(b,y)),
        E.setAttribute("uv", new pt(T,v)),
        E.setAttribute("faceIndex", new pt(S,_)),
        e.push(E),
        i > Va && i--
    }
    return {
        lodPlanes: e,
        sizeLods: t,
        sigmas: n
    }
}
function gy(r, e, t) {
    const n = new vn(r,e,t);
    return n.texture.mapping = ff,
    n.texture.name = "PMREM.cubeUv",
    n.scissorTest = !0,
    n
}
function eh(r, e, t, n, i) {
    r.viewport.set(e, t, n, i),
    r.scissor.set(e, t, n, i)
}
function wU(r, e, t) {
    const n = new Float32Array(So)
      , i = new k(0,1,0);
    return new Vt({
        name: "SphericalGaussianBlur",
        defines: {
            n: So,
            CUBEUV_TEXEL_WIDTH: 1 / e,
            CUBEUV_TEXEL_HEIGHT: 1 / t,
            CUBEUV_MAX_MIP: `${r}.0`
        },
        uniforms: {
            envMap: {
                value: null
            },
            samples: {
                value: 1
            },
            weights: {
                value: n
            },
            latitudinal: {
                value: !1
            },
            dTheta: {
                value: 0
            },
            mipInt: {
                value: 0
            },
            poleAxis: {
                value: i
            }
        },
        vertexShader: U_(),
        fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,
        blending: Si,
        depthTest: !1,
        depthWrite: !1
    })
}
function vy() {
    return new Vt({
        name: "EquirectangularToCubeUV",
        uniforms: {
            envMap: {
                value: null
            }
        },
        vertexShader: U_(),
        fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,
        blending: Si,
        depthTest: !1,
        depthWrite: !1
    })
}
function yy() {
    return new Vt({
        name: "CubemapToCubeUV",
        uniforms: {
            envMap: {
                value: null
            },
            flipEnvMap: {
                value: -1
            }
        },
        vertexShader: U_(),
        fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,
        blending: Si,
        depthTest: !1,
        depthWrite: !1
    })
}
function U_() {
    return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`
}
function EU(r) {
    let e = new WeakMap
      , t = null;
    function n(a) {
        if (a && a.isTexture) {
            const c = a.mapping
              , h = c === Nm || c === Fm
              , d = c === il || c === rl;
            if (h || d)
                if (a.isRenderTargetTexture && a.needsPMREMUpdate === !0) {
                    a.needsPMREMUpdate = !1;
                    let l = e.get(a);
                    return t === null && (t = new Gm(r)),
                    l = h ? t.fromEquirectangular(a, l) : t.fromCubemap(a, l),
                    e.set(a, l),
                    l.texture
                } else {
                    if (e.has(a))
                        return e.get(a).texture;
                    {
                        const l = a.image;
                        if (h && l && l.height > 0 || d && l && i(l)) {
                            t === null && (t = new Gm(r));
                            const f = h ? t.fromEquirectangular(a) : t.fromCubemap(a);
                            return e.set(a, f),
                            a.addEventListener("dispose", s),
                            f.texture
                        } else
                            return null
                    }
                }
        }
        return a
    }
    function i(a) {
        let c = 0;
        const h = 6;
        for (let d = 0; d < h; d++)
            a[d] !== void 0 && c++;
        return c === h
    }
    function s(a) {
        const c = a.target;
        c.removeEventListener("dispose", s);
        const h = e.get(c);
        h !== void 0 && (e.delete(c),
        h.dispose())
    }
    function o() {
        e = new WeakMap,
        t !== null && (t.dispose(),
        t = null)
    }
    return {
        get: n,
        dispose: o
    }
}
function AU(r) {
    const e = {};
    function t(n) {
        if (e[n] !== void 0)
            return e[n];
        let i;
        switch (n) {
        case "WEBGL_depth_texture":
            i = r.getExtension("WEBGL_depth_texture") || r.getExtension("MOZ_WEBGL_depth_texture") || r.getExtension("WEBKIT_WEBGL_depth_texture");
            break;
        case "EXT_texture_filter_anisotropic":
            i = r.getExtension("EXT_texture_filter_anisotropic") || r.getExtension("MOZ_EXT_texture_filter_anisotropic") || r.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
            break;
        case "WEBGL_compressed_texture_s3tc":
            i = r.getExtension("WEBGL_compressed_texture_s3tc") || r.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || r.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
            break;
        case "WEBGL_compressed_texture_pvrtc":
            i = r.getExtension("WEBGL_compressed_texture_pvrtc") || r.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
            break;
        default:
            i = r.getExtension(n)
        }
        return e[n] = i,
        i
    }
    return {
        has: function(n) {
            return t(n) !== null
        },
        init: function(n) {
            n.isWebGL2 ? t("EXT_color_buffer_float") : (t("WEBGL_depth_texture"),
            t("OES_texture_float"),
            t("OES_texture_half_float"),
            t("OES_texture_half_float_linear"),
            t("OES_standard_derivatives"),
            t("OES_element_index_uint"),
            t("OES_vertex_array_object"),
            t("ANGLE_instanced_arrays")),
            t("OES_texture_float_linear"),
            t("EXT_color_buffer_half_float"),
            t("WEBGL_multisampled_render_to_texture")
        },
        get: function(n) {
            const i = t(n);
            return i === null && console.warn("THREE.WebGLRenderer: " + n + " extension not supported."),
            i
        }
    }
}
function PU(r, e, t, n) {
    const i = {}
      , s = new WeakMap;
    function o(l) {
        const f = l.target;
        f.index !== null && e.remove(f.index);
        for (const g in f.attributes)
            e.remove(f.attributes[g]);
        for (const g in f.morphAttributes) {
            const y = f.morphAttributes[g];
            for (let v = 0, _ = y.length; v < _; v++)
                e.remove(y[v])
        }
        f.removeEventListener("dispose", o),
        delete i[f.id];
        const p = s.get(f);
        p && (e.remove(p),
        s.delete(f)),
        n.releaseStatesOfGeometry(f),
        f.isInstancedBufferGeometry === !0 && delete f._maxInstanceCount,
        t.memory.geometries--
    }
    function a(l, f) {
        return i[f.id] === !0 || (f.addEventListener("dispose", o),
        i[f.id] = !0,
        t.memory.geometries++),
        f
    }
    function c(l) {
        const f = l.attributes;
        for (const g in f)
            e.update(f[g], r.ARRAY_BUFFER);
        const p = l.morphAttributes;
        for (const g in p) {
            const y = p[g];
            for (let v = 0, _ = y.length; v < _; v++)
                e.update(y[v], r.ARRAY_BUFFER)
        }
    }
    function h(l) {
        const f = []
          , p = l.index
          , g = l.attributes.position;
        let y = 0;
        if (p !== null) {
            const b = p.array;
            y = p.version;
            for (let T = 0, S = b.length; T < S; T += 3) {
                const E = b[T + 0]
                  , P = b[T + 1]
                  , R = b[T + 2];
                f.push(E, P, P, R, R, E)
            }
        } else if (g !== void 0) {
            const b = g.array;
            y = g.version;
            for (let T = 0, S = b.length / 3 - 1; T < S; T += 3) {
                const E = T + 0
                  , P = T + 1
                  , R = T + 2;
                f.push(E, P, P, R, R, E)
            }
        } else
            return;
        const v = new (Pb(f) ? Ob : Db)(f,1);
        v.version = y;
        const _ = s.get(l);
        _ && e.remove(_),
        s.set(l, v)
    }
    function d(l) {
        const f = s.get(l);
        if (f) {
            const p = l.index;
            p !== null && f.version < p.version && h(l)
        } else
            h(l);
        return s.get(l)
    }
    return {
        get: a,
        update: c,
        getWireframeAttribute: d
    }
}
function RU(r, e, t, n) {
    const i = n.isWebGL2;
    let s;
    function o(p) {
        s = p
    }
    let a, c;
    function h(p) {
        a = p.type,
        c = p.bytesPerElement
    }
    function d(p, g) {
        r.drawElements(s, g, a, p * c),
        t.update(g, s, 1)
    }
    function l(p, g, y) {
        if (y === 0)
            return;
        let v, _;
        if (i)
            v = r,
            _ = "drawElementsInstanced";
        else if (v = e.get("ANGLE_instanced_arrays"),
        _ = "drawElementsInstancedANGLE",
        v === null) {
            console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
            return
        }
        v[_](s, g, a, p * c, y),
        t.update(g, s, y)
    }
    function f(p, g, y) {
        if (y === 0)
            return;
        const v = e.get("WEBGL_multi_draw");
        if (v === null)
            for (let _ = 0; _ < y; _++)
                this.render(p[_] / c, g[_]);
        else {
            v.multiDrawElementsWEBGL(s, g, 0, a, p, 0, y);
            let _ = 0;
            for (let b = 0; b < y; b++)
                _ += g[b];
            t.update(_, s, 1)
        }
    }
    this.setMode = o,
    this.setIndex = h,
    this.render = d,
    this.renderInstances = l,
    this.renderMultiDraw = f
}
function CU(r) {
    const e = {
        geometries: 0,
        textures: 0
    }
      , t = {
        frame: 0,
        calls: 0,
        triangles: 0,
        points: 0,
        lines: 0
    };
    function n(s, o, a) {
        switch (t.calls++,
        o) {
        case r.TRIANGLES:
            t.triangles += a * (s / 3);
            break;
        case r.LINES:
            t.lines += a * (s / 2);
            break;
        case r.LINE_STRIP:
            t.lines += a * (s - 1);
            break;
        case r.LINE_LOOP:
            t.lines += a * s;
            break;
        case r.POINTS:
            t.points += a * s;
            break;
        default:
            console.error("THREE.WebGLInfo: Unknown draw mode:", o);
            break
        }
    }
    function i() {
        t.calls = 0,
        t.triangles = 0,
        t.points = 0,
        t.lines = 0
    }
    return {
        memory: e,
        render: t,
        programs: null,
        autoReset: !0,
        reset: i,
        update: n
    }
}
function IU(r, e) {
    return r[0] - e[0]
}
function LU(r, e) {
    return Math.abs(e[1]) - Math.abs(r[1])
}
function DU(r, e, t) {
    const n = {}
      , i = new Float32Array(8)
      , s = new WeakMap
      , o = new Ct
      , a = [];
    for (let h = 0; h < 8; h++)
        a[h] = [h, 0];
    function c(h, d, l) {
        const f = h.morphTargetInfluences;
        if (e.isWebGL2 === !0) {
            const p = d.morphAttributes.position || d.morphAttributes.normal || d.morphAttributes.color
              , g = p !== void 0 ? p.length : 0;
            let y = s.get(d);
            if (y === void 0 || y.count !== g) {
                let F = function() {
                    z.dispose(),
                    s.delete(d),
                    d.removeEventListener("dispose", F)
                };
                y !== void 0 && y.texture.dispose();
                const b = d.morphAttributes.position !== void 0
                  , T = d.morphAttributes.normal !== void 0
                  , S = d.morphAttributes.color !== void 0
                  , E = d.morphAttributes.position || []
                  , P = d.morphAttributes.normal || []
                  , R = d.morphAttributes.color || [];
                let O = 0;
                b === !0 && (O = 1),
                T === !0 && (O = 2),
                S === !0 && (O = 3);
                let w = d.attributes.position.count * O
                  , I = 1;
                w > e.maxTextureSize && (I = Math.ceil(w / e.maxTextureSize),
                w = e.maxTextureSize);
                const V = new Float32Array(w * I * 4 * g)
                  , z = new Ib(V,w,I,g);
                z.type = wn,
                z.needsUpdate = !0;
                const q = O * 4;
                for (let j = 0; j < g; j++) {
                    const K = E[j]
                      , J = P[j]
                      , de = R[j]
                      , ae = w * I * 4 * j;
                    for (let ue = 0; ue < K.count; ue++) {
                        const ge = ue * q;
                        b === !0 && (o.fromBufferAttribute(K, ue),
                        V[ae + ge + 0] = o.x,
                        V[ae + ge + 1] = o.y,
                        V[ae + ge + 2] = o.z,
                        V[ae + ge + 3] = 0),
                        T === !0 && (o.fromBufferAttribute(J, ue),
                        V[ae + ge + 4] = o.x,
                        V[ae + ge + 5] = o.y,
                        V[ae + ge + 6] = o.z,
                        V[ae + ge + 7] = 0),
                        S === !0 && (o.fromBufferAttribute(de, ue),
                        V[ae + ge + 8] = o.x,
                        V[ae + ge + 9] = o.y,
                        V[ae + ge + 10] = o.z,
                        V[ae + ge + 11] = de.itemSize === 4 ? o.w : 1)
                    }
                }
                y = {
                    count: g,
                    texture: z,
                    size: new Ce(w,I)
                },
                s.set(d, y),
                d.addEventListener("dispose", F)
            }
            let v = 0;
            for (let b = 0; b < f.length; b++)
                v += f[b];
            const _ = d.morphTargetsRelative ? 1 : 1 - v;
            l.getUniforms().setValue(r, "morphTargetBaseInfluence", _),
            l.getUniforms().setValue(r, "morphTargetInfluences", f),
            l.getUniforms().setValue(r, "morphTargetsTexture", y.texture, t),
            l.getUniforms().setValue(r, "morphTargetsTextureSize", y.size)
        } else {
            const p = f === void 0 ? 0 : f.length;
            let g = n[d.id];
            if (g === void 0 || g.length !== p) {
                g = [];
                for (let T = 0; T < p; T++)
                    g[T] = [T, 0];
                n[d.id] = g
            }
            for (let T = 0; T < p; T++) {
                const S = g[T];
                S[0] = T,
                S[1] = f[T]
            }
            g.sort(LU);
            for (let T = 0; T < 8; T++)
                T < p && g[T][1] ? (a[T][0] = g[T][0],
                a[T][1] = g[T][1]) : (a[T][0] = Number.MAX_SAFE_INTEGER,
                a[T][1] = 0);
            a.sort(IU);
            const y = d.morphAttributes.position
              , v = d.morphAttributes.normal;
            let _ = 0;
            for (let T = 0; T < 8; T++) {
                const S = a[T]
                  , E = S[0]
                  , P = S[1];
                E !== Number.MAX_SAFE_INTEGER && P ? (y && d.getAttribute("morphTarget" + T) !== y[E] && d.setAttribute("morphTarget" + T, y[E]),
                v && d.getAttribute("morphNormal" + T) !== v[E] && d.setAttribute("morphNormal" + T, v[E]),
                i[T] = P,
                _ += P) : (y && d.hasAttribute("morphTarget" + T) === !0 && d.deleteAttribute("morphTarget" + T),
                v && d.hasAttribute("morphNormal" + T) === !0 && d.deleteAttribute("morphNormal" + T),
                i[T] = 0)
            }
            const b = d.morphTargetsRelative ? 1 : 1 - _;
            l.getUniforms().setValue(r, "morphTargetBaseInfluence", b),
            l.getUniforms().setValue(r, "morphTargetInfluences", i)
        }
    }
    return {
        update: c
    }
}
function OU(r, e, t, n) {
    let i = new WeakMap;
    function s(c) {
        const h = n.render.frame
          , d = c.geometry
          , l = e.get(c, d);
        if (i.get(l) !== h && (e.update(l),
        i.set(l, h)),
        c.isInstancedMesh && (c.hasEventListener("dispose", a) === !1 && c.addEventListener("dispose", a),
        i.get(c) !== h && (t.update(c.instanceMatrix, r.ARRAY_BUFFER),
        c.instanceColor !== null && t.update(c.instanceColor, r.ARRAY_BUFFER),
        i.set(c, h))),
        c.isSkinnedMesh) {
            const f = c.skeleton;
            i.get(f) !== h && (f.update(),
            i.set(f, h))
        }
        return l
    }
    function o() {
        i = new WeakMap
    }
    function a(c) {
        const h = c.target;
        h.removeEventListener("dispose", a),
        t.remove(h.instanceMatrix),
        h.instanceColor !== null && t.remove(h.instanceColor)
    }
    return {
        update: s,
        dispose: o
    }
}
class N_ extends Pn {
    constructor(e, t, n, i, s, o, a, c, h, d) {
        if (d = d !== void 0 ? d : Ro,
        d !== Ro && d !== Oo)
            throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
        n === void 0 && d === Ro && (n = ns),
        n === void 0 && d === Oo && (n = Fs),
        super(null, i, s, o, a, c, d, n, h),
        this.isDepthTexture = !0,
        this.image = {
            width: e,
            height: t
        },
        this.magFilter = a !== void 0 ? a : Jt,
        this.minFilter = c !== void 0 ? c : Jt,
        this.flipY = !1,
        this.generateMipmaps = !1,
        this.compareFunction = null
    }
    copy(e) {
        return super.copy(e),
        this.compareFunction = e.compareFunction,
        this
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return this.compareFunction !== null && (t.compareFunction = this.compareFunction),
        t
    }
}
const Bb = new Pn
  , kb = new N_(1,1);
kb.compareFunction = Ab;
const zb = new Ib
  , Hb = new Tc
  , Vb = new Nb
  , xy = []
  , Ty = []
  , by = new Float32Array(16)
  , Sy = new Float32Array(9)
  , My = new Float32Array(4);
function yl(r, e, t) {
    const n = r[0];
    if (n <= 0 || n > 0)
        return r;
    const i = e * t;
    let s = xy[i];
    if (s === void 0 && (s = new Float32Array(i),
    xy[i] = s),
    e !== 0) {
        n.toArray(s, 0);
        for (let o = 1, a = 0; o !== e; ++o)
            a += t,
            r[o].toArray(s, a)
    }
    return s
}
function Un(r, e) {
    if (r.length !== e.length)
        return !1;
    for (let t = 0, n = r.length; t < n; t++)
        if (r[t] !== e[t])
            return !1;
    return !0
}
function Nn(r, e) {
    for (let t = 0, n = e.length; t < n; t++)
        r[t] = e[t]
}
function _f(r, e) {
    let t = Ty[e];
    t === void 0 && (t = new Int32Array(e),
    Ty[e] = t);
    for (let n = 0; n !== e; ++n)
        t[n] = r.allocateTextureUnit();
    return t
}
function UU(r, e) {
    const t = this.cache;
    t[0] !== e && (r.uniform1f(this.addr, e),
    t[0] = e)
}
function NU(r, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y) && (r.uniform2f(this.addr, e.x, e.y),
        t[0] = e.x,
        t[1] = e.y);
    else {
        if (Un(t, e))
            return;
        r.uniform2fv(this.addr, e),
        Nn(t, e)
    }
}
function FU(r, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (r.uniform3f(this.addr, e.x, e.y, e.z),
        t[0] = e.x,
        t[1] = e.y,
        t[2] = e.z);
    else if (e.r !== void 0)
        (t[0] !== e.r || t[1] !== e.g || t[2] !== e.b) && (r.uniform3f(this.addr, e.r, e.g, e.b),
        t[0] = e.r,
        t[1] = e.g,
        t[2] = e.b);
    else {
        if (Un(t, e))
            return;
        r.uniform3fv(this.addr, e),
        Nn(t, e)
    }
}
function BU(r, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (r.uniform4f(this.addr, e.x, e.y, e.z, e.w),
        t[0] = e.x,
        t[1] = e.y,
        t[2] = e.z,
        t[3] = e.w);
    else {
        if (Un(t, e))
            return;
        r.uniform4fv(this.addr, e),
        Nn(t, e)
    }
}
function kU(r, e) {
    const t = this.cache
      , n = e.elements;
    if (n === void 0) {
        if (Un(t, e))
            return;
        r.uniformMatrix2fv(this.addr, !1, e),
        Nn(t, e)
    } else {
        if (Un(t, n))
            return;
        My.set(n),
        r.uniformMatrix2fv(this.addr, !1, My),
        Nn(t, n)
    }
}
function zU(r, e) {
    const t = this.cache
      , n = e.elements;
    if (n === void 0) {
        if (Un(t, e))
            return;
        r.uniformMatrix3fv(this.addr, !1, e),
        Nn(t, e)
    } else {
        if (Un(t, n))
            return;
        Sy.set(n),
        r.uniformMatrix3fv(this.addr, !1, Sy),
        Nn(t, n)
    }
}
function HU(r, e) {
    const t = this.cache
      , n = e.elements;
    if (n === void 0) {
        if (Un(t, e))
            return;
        r.uniformMatrix4fv(this.addr, !1, e),
        Nn(t, e)
    } else {
        if (Un(t, n))
            return;
        by.set(n),
        r.uniformMatrix4fv(this.addr, !1, by),
        Nn(t, n)
    }
}
function VU(r, e) {
    const t = this.cache;
    t[0] !== e && (r.uniform1i(this.addr, e),
    t[0] = e)
}
function GU(r, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y) && (r.uniform2i(this.addr, e.x, e.y),
        t[0] = e.x,
        t[1] = e.y);
    else {
        if (Un(t, e))
            return;
        r.uniform2iv(this.addr, e),
        Nn(t, e)
    }
}
function WU(r, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (r.uniform3i(this.addr, e.x, e.y, e.z),
        t[0] = e.x,
        t[1] = e.y,
        t[2] = e.z);
    else {
        if (Un(t, e))
            return;
        r.uniform3iv(this.addr, e),
        Nn(t, e)
    }
}
function jU(r, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (r.uniform4i(this.addr, e.x, e.y, e.z, e.w),
        t[0] = e.x,
        t[1] = e.y,
        t[2] = e.z,
        t[3] = e.w);
    else {
        if (Un(t, e))
            return;
        r.uniform4iv(this.addr, e),
        Nn(t, e)
    }
}
function XU(r, e) {
    const t = this.cache;
    t[0] !== e && (r.uniform1ui(this.addr, e),
    t[0] = e)
}
function qU(r, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y) && (r.uniform2ui(this.addr, e.x, e.y),
        t[0] = e.x,
        t[1] = e.y);
    else {
        if (Un(t, e))
            return;
        r.uniform2uiv(this.addr, e),
        Nn(t, e)
    }
}
function KU(r, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (r.uniform3ui(this.addr, e.x, e.y, e.z),
        t[0] = e.x,
        t[1] = e.y,
        t[2] = e.z);
    else {
        if (Un(t, e))
            return;
        r.uniform3uiv(this.addr, e),
        Nn(t, e)
    }
}
function YU(r, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (r.uniform4ui(this.addr, e.x, e.y, e.z, e.w),
        t[0] = e.x,
        t[1] = e.y,
        t[2] = e.z,
        t[3] = e.w);
    else {
        if (Un(t, e))
            return;
        r.uniform4uiv(this.addr, e),
        Nn(t, e)
    }
}
function $U(r, e, t) {
    const n = this.cache
      , i = t.allocateTextureUnit();
    n[0] !== i && (r.uniform1i(this.addr, i),
    n[0] = i);
    const s = this.type === r.SAMPLER_2D_SHADOW ? kb : Bb;
    t.setTexture2D(e || s, i)
}
function ZU(r, e, t) {
    const n = this.cache
      , i = t.allocateTextureUnit();
    n[0] !== i && (r.uniform1i(this.addr, i),
    n[0] = i),
    t.setTexture3D(e || Hb, i)
}
function JU(r, e, t) {
    const n = this.cache
      , i = t.allocateTextureUnit();
    n[0] !== i && (r.uniform1i(this.addr, i),
    n[0] = i),
    t.setTextureCube(e || Vb, i)
}
function QU(r, e, t) {
    const n = this.cache
      , i = t.allocateTextureUnit();
    n[0] !== i && (r.uniform1i(this.addr, i),
    n[0] = i),
    t.setTexture2DArray(e || zb, i)
}
function eN(r) {
    switch (r) {
    case 5126:
        return UU;
    case 35664:
        return NU;
    case 35665:
        return FU;
    case 35666:
        return BU;
    case 35674:
        return kU;
    case 35675:
        return zU;
    case 35676:
        return HU;
    case 5124:
    case 35670:
        return VU;
    case 35667:
    case 35671:
        return GU;
    case 35668:
    case 35672:
        return WU;
    case 35669:
    case 35673:
        return jU;
    case 5125:
        return XU;
    case 36294:
        return qU;
    case 36295:
        return KU;
    case 36296:
        return YU;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
        return $U;
    case 35679:
    case 36299:
    case 36307:
        return ZU;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
        return JU;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
        return QU
    }
}
function tN(r, e) {
    r.uniform1fv(this.addr, e)
}
function nN(r, e) {
    const t = yl(e, this.size, 2);
    r.uniform2fv(this.addr, t)
}
function iN(r, e) {
    const t = yl(e, this.size, 3);
    r.uniform3fv(this.addr, t)
}
function rN(r, e) {
    const t = yl(e, this.size, 4);
    r.uniform4fv(this.addr, t)
}
function sN(r, e) {
    const t = yl(e, this.size, 4);
    r.uniformMatrix2fv(this.addr, !1, t)
}
function oN(r, e) {
    const t = yl(e, this.size, 9);
    r.uniformMatrix3fv(this.addr, !1, t)
}
function aN(r, e) {
    const t = yl(e, this.size, 16);
    r.uniformMatrix4fv(this.addr, !1, t)
}
function lN(r, e) {
    r.uniform1iv(this.addr, e)
}
function cN(r, e) {
    r.uniform2iv(this.addr, e)
}
function uN(r, e) {
    r.uniform3iv(this.addr, e)
}
function hN(r, e) {
    r.uniform4iv(this.addr, e)
}
function fN(r, e) {
    r.uniform1uiv(this.addr, e)
}
function dN(r, e) {
    r.uniform2uiv(this.addr, e)
}
function pN(r, e) {
    r.uniform3uiv(this.addr, e)
}
function mN(r, e) {
    r.uniform4uiv(this.addr, e)
}
function _N(r, e, t) {
    const n = this.cache
      , i = e.length
      , s = _f(t, i);
    Un(n, s) || (r.uniform1iv(this.addr, s),
    Nn(n, s));
    for (let o = 0; o !== i; ++o)
        t.setTexture2D(e[o] || Bb, s[o])
}
function gN(r, e, t) {
    const n = this.cache
      , i = e.length
      , s = _f(t, i);
    Un(n, s) || (r.uniform1iv(this.addr, s),
    Nn(n, s));
    for (let o = 0; o !== i; ++o)
        t.setTexture3D(e[o] || Hb, s[o])
}
function vN(r, e, t) {
    const n = this.cache
      , i = e.length
      , s = _f(t, i);
    Un(n, s) || (r.uniform1iv(this.addr, s),
    Nn(n, s));
    for (let o = 0; o !== i; ++o)
        t.setTextureCube(e[o] || Vb, s[o])
}
function yN(r, e, t) {
    const n = this.cache
      , i = e.length
      , s = _f(t, i);
    Un(n, s) || (r.uniform1iv(this.addr, s),
    Nn(n, s));
    for (let o = 0; o !== i; ++o)
        t.setTexture2DArray(e[o] || zb, s[o])
}
function xN(r) {
    switch (r) {
    case 5126:
        return tN;
    case 35664:
        return nN;
    case 35665:
        return iN;
    case 35666:
        return rN;
    case 35674:
        return sN;
    case 35675:
        return oN;
    case 35676:
        return aN;
    case 5124:
    case 35670:
        return lN;
    case 35667:
    case 35671:
        return cN;
    case 35668:
    case 35672:
        return uN;
    case 35669:
    case 35673:
        return hN;
    case 5125:
        return fN;
    case 36294:
        return dN;
    case 36295:
        return pN;
    case 36296:
        return mN;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
        return _N;
    case 35679:
    case 36299:
    case 36307:
        return gN;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
        return vN;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
        return yN
    }
}
class TN {
    constructor(e, t, n) {
        this.id = e,
        this.addr = n,
        this.cache = [],
        this.type = t.type,
        this.setValue = eN(t.type)
    }
}
class bN {
    constructor(e, t, n) {
        this.id = e,
        this.addr = n,
        this.cache = [],
        this.type = t.type,
        this.size = t.size,
        this.setValue = xN(t.type)
    }
}
class SN {
    constructor(e) {
        this.id = e,
        this.seq = [],
        this.map = {}
    }
    setValue(e, t, n) {
        const i = this.seq;
        for (let s = 0, o = i.length; s !== o; ++s) {
            const a = i[s];
            a.setValue(e, t[a.id], n)
        }
    }
}
const Fp = /(\w+)(\])?(\[|\.)?/g;
function wy(r, e) {
    r.seq.push(e),
    r.map[e.id] = e
}
function MN(r, e, t) {
    const n = r.name
      , i = n.length;
    for (Fp.lastIndex = 0; ; ) {
        const s = Fp.exec(n)
          , o = Fp.lastIndex;
        let a = s[1];
        const c = s[2] === "]"
          , h = s[3];
        if (c && (a = a | 0),
        h === void 0 || h === "[" && o + 2 === i) {
            wy(t, h === void 0 ? new TN(a,r,e) : new bN(a,r,e));
            break
        } else {
            let l = t.map[a];
            l === void 0 && (l = new SN(a),
            wy(t, l)),
            t = l
        }
    }
}
class Oh {
    constructor(e, t) {
        this.seq = [],
        this.map = {};
        const n = e.getProgramParameter(t, e.ACTIVE_UNIFORMS);
        for (let i = 0; i < n; ++i) {
            const s = e.getActiveUniform(t, i)
              , o = e.getUniformLocation(t, s.name);
            MN(s, o, this)
        }
    }
    setValue(e, t, n, i) {
        const s = this.map[t];
        s !== void 0 && s.setValue(e, n, i)
    }
    setOptional(e, t, n) {
        const i = t[n];
        i !== void 0 && this.setValue(e, n, i)
    }
    static upload(e, t, n, i) {
        for (let s = 0, o = t.length; s !== o; ++s) {
            const a = t[s]
              , c = n[a.id];
            c.needsUpdate !== !1 && a.setValue(e, c.value, i)
        }
    }
    static seqWithValue(e, t) {
        const n = [];
        for (let i = 0, s = e.length; i !== s; ++i) {
            const o = e[i];
            o.id in t && n.push(o)
        }
        return n
    }
}
function Ey(r, e, t) {
    const n = r.createShader(e);
    return r.shaderSource(n, t),
    r.compileShader(n),
    n
}
const wN = 37297;
let EN = 0;
function AN(r, e) {
    const t = r.split(`
`)
      , n = []
      , i = Math.max(e - 6, 0)
      , s = Math.min(e + 6, t.length);
    for (let o = i; o < s; o++) {
        const a = o + 1;
        n.push(`${a === e ? ">" : " "} ${a}: ${t[o]}`)
    }
    return n.join(`
`)
}
function PN(r) {
    const e = Rt.getPrimaries(Rt.workingColorSpace)
      , t = Rt.getPrimaries(r);
    let n;
    switch (e === t ? n = "" : e === Yh && t === Kh ? n = "LinearDisplayP3ToLinearSRGB" : e === Kh && t === Yh && (n = "LinearSRGBToLinearDisplayP3"),
    r) {
    case gn:
    case pf:
        return [n, "LinearTransferOETF"];
    case Ft:
    case C_:
        return [n, "sRGBTransferOETF"];
    default:
        return console.warn("THREE.WebGLProgram: Unsupported color space:", r),
        [n, "LinearTransferOETF"]
    }
}
function Ay(r, e, t) {
    const n = r.getShaderParameter(e, r.COMPILE_STATUS)
      , i = r.getShaderInfoLog(e).trim();
    if (n && i === "")
        return "";
    const s = /ERROR: 0:(\d+)/.exec(i);
    if (s) {
        const o = parseInt(s[1]);
        return t.toUpperCase() + `

` + i + `

` + AN(r.getShaderSource(e), o)
    } else
        return i
}
function RN(r, e) {
    const t = PN(e);
    return `vec4 ${r}( vec4 value ) { return ${t[0]}( ${t[1]}( value ) ); }`
}
function CN(r, e) {
    let t;
    switch (e) {
    case AL:
        t = "Linear";
        break;
    case PL:
        t = "Reinhard";
        break;
    case RL:
        t = "OptimizedCineon";
        break;
    case CL:
        t = "ACESFilmic";
        break;
    case IL:
        t = "Custom";
        break;
    default:
        console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e),
        t = "Linear"
    }
    return "vec3 " + r + "( vec3 color ) { return " + t + "ToneMapping( color ); }"
}
function IN(r) {
    return [r.extensionDerivatives || r.envMapCubeUVHeight || r.bumpMap || r.normalMapTangentSpace || r.clearcoatNormalMap || r.flatShading || r.shaderID === "physical" ? "#extension GL_OES_standard_derivatives : enable" : "", (r.extensionFragDepth || r.logarithmicDepthBuffer) && r.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", r.extensionDrawBuffers && r.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (r.extensionShaderTextureLOD || r.envMap || r.transmission) && r.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(fc).join(`
`)
}
function LN(r) {
    const e = [];
    for (const t in r) {
        const n = r[t];
        n !== !1 && e.push("#define " + t + " " + n)
    }
    return e.join(`
`)
}
function DN(r, e) {
    const t = {}
      , n = r.getProgramParameter(e, r.ACTIVE_ATTRIBUTES);
    for (let i = 0; i < n; i++) {
        const s = r.getActiveAttrib(e, i)
          , o = s.name;
        let a = 1;
        s.type === r.FLOAT_MAT2 && (a = 2),
        s.type === r.FLOAT_MAT3 && (a = 3),
        s.type === r.FLOAT_MAT4 && (a = 4),
        t[o] = {
            type: s.type,
            location: r.getAttribLocation(e, o),
            locationSize: a
        }
    }
    return t
}
function fc(r) {
    return r !== ""
}
function Py(r, e) {
    const t = e.numSpotLightShadows + e.numSpotLightMaps - e.numSpotLightShadowsWithMaps;
    return r.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, t).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, e.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows)
}
function Ry(r, e) {
    return r.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection)
}
const ON = /^[ \t]*#include +<([\w\d./]+)>/gm;
function Wm(r) {
    return r.replace(ON, NN)
}
const UN = new Map([["encodings_fragment", "colorspace_fragment"], ["encodings_pars_fragment", "colorspace_pars_fragment"], ["output_fragment", "opaque_fragment"]]);
function NN(r, e) {
    let t = ft[e];
    if (t === void 0) {
        const n = UN.get(e);
        if (n !== void 0)
            t = ft[n],
            console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.', e, n);
        else
            throw new Error("Can not resolve #include <" + e + ">")
    }
    return Wm(t)
}
const FN = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function Cy(r) {
    return r.replace(FN, BN)
}
function BN(r, e, t, n) {
    let i = "";
    for (let s = parseInt(e); s < parseInt(t); s++)
        i += n.replace(/\[\s*i\s*\]/g, "[ " + s + " ]").replace(/UNROLLED_LOOP_INDEX/g, s);
    return i
}
function Iy(r) {
    let e = "precision " + r.precision + ` float;
precision ` + r.precision + " int;";
    return r.precision === "highp" ? e += `
#define HIGH_PRECISION` : r.precision === "mediump" ? e += `
#define MEDIUM_PRECISION` : r.precision === "lowp" && (e += `
#define LOW_PRECISION`),
    e
}
function kN(r) {
    let e = "SHADOWMAP_TYPE_BASIC";
    return r.shadowMapType === pb ? e = "SHADOWMAP_TYPE_PCF" : r.shadowMapType === tL ? e = "SHADOWMAP_TYPE_PCF_SOFT" : r.shadowMapType === Jr && (e = "SHADOWMAP_TYPE_VSM"),
    e
}
function zN(r) {
    let e = "ENVMAP_TYPE_CUBE";
    if (r.envMap)
        switch (r.envMapMode) {
        case il:
        case rl:
            e = "ENVMAP_TYPE_CUBE";
            break;
        case ff:
            e = "ENVMAP_TYPE_CUBE_UV";
            break
        }
    return e
}
function HN(r) {
    let e = "ENVMAP_MODE_REFLECTION";
    if (r.envMap)
        switch (r.envMapMode) {
        case rl:
            e = "ENVMAP_MODE_REFRACTION";
            break
        }
    return e
}
function VN(r) {
    let e = "ENVMAP_BLENDING_NONE";
    if (r.envMap)
        switch (r.combine) {
        case mb:
            e = "ENVMAP_BLENDING_MULTIPLY";
            break;
        case wL:
            e = "ENVMAP_BLENDING_MIX";
            break;
        case EL:
            e = "ENVMAP_BLENDING_ADD";
            break
        }
    return e
}
function GN(r) {
    const e = r.envMapCubeUVHeight;
    if (e === null)
        return null;
    const t = Math.log2(e) - 2
      , n = 1 / e;
    return {
        texelWidth: 1 / (3 * Math.max(Math.pow(2, t), 7 * 16)),
        texelHeight: n,
        maxMip: t
    }
}
function WN(r, e, t, n) {
    const i = r.getContext()
      , s = t.defines;
    let o = t.vertexShader
      , a = t.fragmentShader;
    const c = kN(t)
      , h = zN(t)
      , d = HN(t)
      , l = VN(t)
      , f = GN(t)
      , p = t.isWebGL2 ? "" : IN(t)
      , g = LN(s)
      , y = i.createProgram();
    let v, _, b = t.glslVersion ? "#version " + t.glslVersion + `
` : "";
    t.isRawShaderMaterial ? (v = ["#define SHADER_TYPE " + t.shaderType, "#define SHADER_NAME " + t.shaderName, g].filter(fc).join(`
`),
    v.length > 0 && (v += `
`),
    _ = [p, "#define SHADER_TYPE " + t.shaderType, "#define SHADER_NAME " + t.shaderName, g].filter(fc).join(`
`),
    _.length > 0 && (_ += `
`)) : (v = [Iy(t), "#define SHADER_TYPE " + t.shaderType, "#define SHADER_NAME " + t.shaderName, g, t.batching ? "#define USE_BATCHING" : "", t.instancing ? "#define USE_INSTANCING" : "", t.instancingColor ? "#define USE_INSTANCING_COLOR" : "", t.useFog && t.fog ? "#define USE_FOG" : "", t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "", t.map ? "#define USE_MAP" : "", t.envMap ? "#define USE_ENVMAP" : "", t.envMap ? "#define " + d : "", t.lightMap ? "#define USE_LIGHTMAP" : "", t.aoMap ? "#define USE_AOMAP" : "", t.bumpMap ? "#define USE_BUMPMAP" : "", t.normalMap ? "#define USE_NORMALMAP" : "", t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", t.displacementMap ? "#define USE_DISPLACEMENTMAP" : "", t.emissiveMap ? "#define USE_EMISSIVEMAP" : "", t.anisotropy ? "#define USE_ANISOTROPY" : "", t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", t.specularMap ? "#define USE_SPECULARMAP" : "", t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", t.metalnessMap ? "#define USE_METALNESSMAP" : "", t.alphaMap ? "#define USE_ALPHAMAP" : "", t.alphaHash ? "#define USE_ALPHAHASH" : "", t.transmission ? "#define USE_TRANSMISSION" : "", t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", t.thicknessMap ? "#define USE_THICKNESSMAP" : "", t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", t.mapUv ? "#define MAP_UV " + t.mapUv : "", t.alphaMapUv ? "#define ALPHAMAP_UV " + t.alphaMapUv : "", t.lightMapUv ? "#define LIGHTMAP_UV " + t.lightMapUv : "", t.aoMapUv ? "#define AOMAP_UV " + t.aoMapUv : "", t.emissiveMapUv ? "#define EMISSIVEMAP_UV " + t.emissiveMapUv : "", t.bumpMapUv ? "#define BUMPMAP_UV " + t.bumpMapUv : "", t.normalMapUv ? "#define NORMALMAP_UV " + t.normalMapUv : "", t.displacementMapUv ? "#define DISPLACEMENTMAP_UV " + t.displacementMapUv : "", t.metalnessMapUv ? "#define METALNESSMAP_UV " + t.metalnessMapUv : "", t.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + t.roughnessMapUv : "", t.anisotropyMapUv ? "#define ANISOTROPYMAP_UV " + t.anisotropyMapUv : "", t.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + t.clearcoatMapUv : "", t.clearcoatNormalMapUv ? "#define CLEARCOAT_NORMALMAP_UV " + t.clearcoatNormalMapUv : "", t.clearcoatRoughnessMapUv ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + t.clearcoatRoughnessMapUv : "", t.iridescenceMapUv ? "#define IRIDESCENCEMAP_UV " + t.iridescenceMapUv : "", t.iridescenceThicknessMapUv ? "#define IRIDESCENCE_THICKNESSMAP_UV " + t.iridescenceThicknessMapUv : "", t.sheenColorMapUv ? "#define SHEEN_COLORMAP_UV " + t.sheenColorMapUv : "", t.sheenRoughnessMapUv ? "#define SHEEN_ROUGHNESSMAP_UV " + t.sheenRoughnessMapUv : "", t.specularMapUv ? "#define SPECULARMAP_UV " + t.specularMapUv : "", t.specularColorMapUv ? "#define SPECULAR_COLORMAP_UV " + t.specularColorMapUv : "", t.specularIntensityMapUv ? "#define SPECULAR_INTENSITYMAP_UV " + t.specularIntensityMapUv : "", t.transmissionMapUv ? "#define TRANSMISSIONMAP_UV " + t.transmissionMapUv : "", t.thicknessMapUv ? "#define THICKNESSMAP_UV " + t.thicknessMapUv : "", t.vertexTangents && t.flatShading === !1 ? "#define USE_TANGENT" : "", t.vertexColors ? "#define USE_COLOR" : "", t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", t.vertexUv1s ? "#define USE_UV1" : "", t.vertexUv2s ? "#define USE_UV2" : "", t.vertexUv3s ? "#define USE_UV3" : "", t.pointsUvs ? "#define USE_POINTS_UV" : "", t.flatShading ? "#define FLAT_SHADED" : "", t.skinning ? "#define USE_SKINNING" : "", t.morphTargets ? "#define USE_MORPHTARGETS" : "", t.morphNormals && t.flatShading === !1 ? "#define USE_MORPHNORMALS" : "", t.morphColors && t.isWebGL2 ? "#define USE_MORPHCOLORS" : "", t.morphTargetsCount > 0 && t.isWebGL2 ? "#define MORPHTARGETS_TEXTURE" : "", t.morphTargetsCount > 0 && t.isWebGL2 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + t.morphTextureStride : "", t.morphTargetsCount > 0 && t.isWebGL2 ? "#define MORPHTARGETS_COUNT " + t.morphTargetsCount : "", t.doubleSided ? "#define DOUBLE_SIDED" : "", t.flipSided ? "#define FLIP_SIDED" : "", t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", t.shadowMapEnabled ? "#define " + c : "", t.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", t.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "", t.useLegacyLights ? "#define LEGACY_LIGHTS" : "", t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", t.logarithmicDepthBuffer && t.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "	attribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "	attribute vec3 instanceColor;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_UV1", "	attribute vec2 uv1;", "#endif", "#ifdef USE_UV2", "	attribute vec2 uv2;", "#endif", "#ifdef USE_UV3", "	attribute vec2 uv3;", "#endif", "#ifdef USE_TANGENT", "	attribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "	attribute vec4 color;", "#elif defined( USE_COLOR )", "	attribute vec3 color;", "#endif", "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )", "	attribute vec3 morphTarget0;", "	attribute vec3 morphTarget1;", "	attribute vec3 morphTarget2;", "	attribute vec3 morphTarget3;", "	#ifdef USE_MORPHNORMALS", "		attribute vec3 morphNormal0;", "		attribute vec3 morphNormal1;", "		attribute vec3 morphNormal2;", "		attribute vec3 morphNormal3;", "	#else", "		attribute vec3 morphTarget4;", "		attribute vec3 morphTarget5;", "		attribute vec3 morphTarget6;", "		attribute vec3 morphTarget7;", "	#endif", "#endif", "#ifdef USE_SKINNING", "	attribute vec4 skinIndex;", "	attribute vec4 skinWeight;", "#endif", `
`].filter(fc).join(`
`),
    _ = [p, Iy(t), "#define SHADER_TYPE " + t.shaderType, "#define SHADER_NAME " + t.shaderName, g, t.useFog && t.fog ? "#define USE_FOG" : "", t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "", t.map ? "#define USE_MAP" : "", t.matcap ? "#define USE_MATCAP" : "", t.envMap ? "#define USE_ENVMAP" : "", t.envMap ? "#define " + h : "", t.envMap ? "#define " + d : "", t.envMap ? "#define " + l : "", f ? "#define CUBEUV_TEXEL_WIDTH " + f.texelWidth : "", f ? "#define CUBEUV_TEXEL_HEIGHT " + f.texelHeight : "", f ? "#define CUBEUV_MAX_MIP " + f.maxMip + ".0" : "", t.lightMap ? "#define USE_LIGHTMAP" : "", t.aoMap ? "#define USE_AOMAP" : "", t.bumpMap ? "#define USE_BUMPMAP" : "", t.normalMap ? "#define USE_NORMALMAP" : "", t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", t.emissiveMap ? "#define USE_EMISSIVEMAP" : "", t.anisotropy ? "#define USE_ANISOTROPY" : "", t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", t.clearcoat ? "#define USE_CLEARCOAT" : "", t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", t.iridescence ? "#define USE_IRIDESCENCE" : "", t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", t.specularMap ? "#define USE_SPECULARMAP" : "", t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", t.metalnessMap ? "#define USE_METALNESSMAP" : "", t.alphaMap ? "#define USE_ALPHAMAP" : "", t.alphaTest ? "#define USE_ALPHATEST" : "", t.alphaHash ? "#define USE_ALPHAHASH" : "", t.sheen ? "#define USE_SHEEN" : "", t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", t.transmission ? "#define USE_TRANSMISSION" : "", t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", t.thicknessMap ? "#define USE_THICKNESSMAP" : "", t.vertexTangents && t.flatShading === !1 ? "#define USE_TANGENT" : "", t.vertexColors || t.instancingColor ? "#define USE_COLOR" : "", t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", t.vertexUv1s ? "#define USE_UV1" : "", t.vertexUv2s ? "#define USE_UV2" : "", t.vertexUv3s ? "#define USE_UV3" : "", t.pointsUvs ? "#define USE_POINTS_UV" : "", t.gradientMap ? "#define USE_GRADIENTMAP" : "", t.flatShading ? "#define FLAT_SHADED" : "", t.doubleSided ? "#define DOUBLE_SIDED" : "", t.flipSided ? "#define FLIP_SIDED" : "", t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", t.shadowMapEnabled ? "#define " + c : "", t.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", t.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "", t.useLegacyLights ? "#define LEGACY_LIGHTS" : "", t.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "", t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", t.logarithmicDepthBuffer && t.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", t.toneMapping !== Ns ? "#define TONE_MAPPING" : "", t.toneMapping !== Ns ? ft.tonemapping_pars_fragment : "", t.toneMapping !== Ns ? CN("toneMapping", t.toneMapping) : "", t.dithering ? "#define DITHERING" : "", t.opaque ? "#define OPAQUE" : "", ft.colorspace_pars_fragment, RN("linearToOutputTexel", t.outputColorSpace), t.useDepthPacking ? "#define DEPTH_PACKING " + t.depthPacking : "", `
`].filter(fc).join(`
`)),
    o = Wm(o),
    o = Py(o, t),
    o = Ry(o, t),
    a = Wm(a),
    a = Py(a, t),
    a = Ry(a, t),
    o = Cy(o),
    a = Cy(a),
    t.isWebGL2 && t.isRawShaderMaterial !== !0 && (b = `#version 300 es
`,
    v = ["precision mediump sampler2DArray;", "#define attribute in", "#define varying out", "#define texture2D texture"].join(`
`) + `
` + v,
    _ = ["precision mediump sampler2DArray;", "#define varying in", t.glslVersion === $0 ? "" : "layout(location = 0) out highp vec4 pc_fragColor;", t.glslVersion === $0 ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join(`
`) + `
` + _);
    const T = b + v + o
      , S = b + _ + a
      , E = Ey(i, i.VERTEX_SHADER, T)
      , P = Ey(i, i.FRAGMENT_SHADER, S);
    i.attachShader(y, E),
    i.attachShader(y, P),
    t.index0AttributeName !== void 0 ? i.bindAttribLocation(y, 0, t.index0AttributeName) : t.morphTargets === !0 && i.bindAttribLocation(y, 0, "position"),
    i.linkProgram(y);
    function R(V) {
        if (r.debug.checkShaderErrors) {
            const z = i.getProgramInfoLog(y).trim()
              , q = i.getShaderInfoLog(E).trim()
              , F = i.getShaderInfoLog(P).trim();
            let j = !0
              , K = !0;
            if (i.getProgramParameter(y, i.LINK_STATUS) === !1)
                if (j = !1,
                typeof r.debug.onShaderError == "function")
                    r.debug.onShaderError(i, y, E, P);
                else {
                    const J = Ay(i, E, "vertex")
                      , de = Ay(i, P, "fragment");
                    console.error("THREE.WebGLProgram: Shader Error " + i.getError() + " - VALIDATE_STATUS " + i.getProgramParameter(y, i.VALIDATE_STATUS) + `

Program Info Log: ` + z + `
` + J + `
` + de)
                }
            else
                z !== "" ? console.warn("THREE.WebGLProgram: Program Info Log:", z) : (q === "" || F === "") && (K = !1);
            K && (V.diagnostics = {
                runnable: j,
                programLog: z,
                vertexShader: {
                    log: q,
                    prefix: v
                },
                fragmentShader: {
                    log: F,
                    prefix: _
                }
            })
        }
        i.deleteShader(E),
        i.deleteShader(P),
        O = new Oh(i,y),
        w = DN(i, y)
    }
    let O;
    this.getUniforms = function() {
        return O === void 0 && R(this),
        O
    }
    ;
    let w;
    this.getAttributes = function() {
        return w === void 0 && R(this),
        w
    }
    ;
    let I = t.rendererExtensionParallelShaderCompile === !1;
    return this.isReady = function() {
        return I === !1 && (I = i.getProgramParameter(y, wN)),
        I
    }
    ,
    this.destroy = function() {
        n.releaseStatesOfProgram(this),
        i.deleteProgram(y),
        this.program = void 0
    }
    ,
    this.type = t.shaderType,
    this.name = t.shaderName,
    this.id = EN++,
    this.cacheKey = e,
    this.usedTimes = 1,
    this.program = y,
    this.vertexShader = E,
    this.fragmentShader = P,
    this
}
let jN = 0;
class XN {
    constructor() {
        this.shaderCache = new Map,
        this.materialCache = new Map
    }
    update(e) {
        const t = e.vertexShader
          , n = e.fragmentShader
          , i = this._getShaderStage(t)
          , s = this._getShaderStage(n)
          , o = this._getShaderCacheForMaterial(e);
        return o.has(i) === !1 && (o.add(i),
        i.usedTimes++),
        o.has(s) === !1 && (o.add(s),
        s.usedTimes++),
        this
    }
    remove(e) {
        const t = this.materialCache.get(e);
        for (const n of t)
            n.usedTimes--,
            n.usedTimes === 0 && this.shaderCache.delete(n.code);
        return this.materialCache.delete(e),
        this
    }
    getVertexShaderID(e) {
        return this._getShaderStage(e.vertexShader).id
    }
    getFragmentShaderID(e) {
        return this._getShaderStage(e.fragmentShader).id
    }
    dispose() {
        this.shaderCache.clear(),
        this.materialCache.clear()
    }
    _getShaderCacheForMaterial(e) {
        const t = this.materialCache;
        let n = t.get(e);
        return n === void 0 && (n = new Set,
        t.set(e, n)),
        n
    }
    _getShaderStage(e) {
        const t = this.shaderCache;
        let n = t.get(e);
        return n === void 0 && (n = new qN(e),
        t.set(e, n)),
        n
    }
}
class qN {
    constructor(e) {
        this.id = jN++,
        this.code = e,
        this.usedTimes = 0
    }
}
function KN(r, e, t, n, i, s, o) {
    const a = new L_
      , c = new XN
      , h = []
      , d = i.isWebGL2
      , l = i.logarithmicDepthBuffer
      , f = i.vertexTextures;
    let p = i.precision;
    const g = {
        MeshDepthMaterial: "depth",
        MeshDistanceMaterial: "distanceRGBA",
        MeshNormalMaterial: "normal",
        MeshBasicMaterial: "basic",
        MeshLambertMaterial: "lambert",
        MeshPhongMaterial: "phong",
        MeshToonMaterial: "toon",
        MeshStandardMaterial: "physical",
        MeshPhysicalMaterial: "physical",
        MeshMatcapMaterial: "matcap",
        LineBasicMaterial: "basic",
        LineDashedMaterial: "dashed",
        PointsMaterial: "points",
        ShadowMaterial: "shadow",
        SpriteMaterial: "sprite"
    };
    function y(w) {
        return w === 0 ? "uv" : `uv${w}`
    }
    function v(w, I, V, z, q) {
        const F = z.fog
          , j = q.geometry
          , K = w.isMeshStandardMaterial ? z.environment : null
          , J = (w.isMeshStandardMaterial ? t : e).get(w.envMap || K)
          , de = J && J.mapping === ff ? J.image.height : null
          , ae = g[w.type];
        w.precision !== null && (p = i.getMaxPrecision(w.precision),
        p !== w.precision && console.warn("THREE.WebGLProgram.getParameters:", w.precision, "not supported, using", p, "instead."));
        const ue = j.morphAttributes.position || j.morphAttributes.normal || j.morphAttributes.color
          , ge = ue !== void 0 ? ue.length : 0;
        let Ee = 0;
        j.morphAttributes.position !== void 0 && (Ee = 1),
        j.morphAttributes.normal !== void 0 && (Ee = 2),
        j.morphAttributes.color !== void 0 && (Ee = 3);
        let oe, he, xe, Be;
        if (ae) {
            const Rn = Ar[ae];
            oe = Rn.vertexShader,
            he = Rn.fragmentShader
        } else
            oe = w.vertexShader,
            he = w.fragmentShader,
            c.update(w),
            xe = c.getVertexShaderID(w),
            Be = c.getFragmentShaderID(w);
        const De = r.getRenderTarget()
          , et = q.isInstancedMesh === !0
          , Ze = q.isBatchedMesh === !0
          , We = !!w.map
          , Je = !!w.matcap
          , Q = !!J
          , hn = !!w.aoMap
          , ze = !!w.lightMap
          , at = !!w.bumpMap
          , qe = !!w.normalMap
          , It = !!w.displacementMap
          , tt = !!w.emissiveMap
          , Ye = !!w.metalnessMap
          , dt = !!w.roughnessMap
          , on = w.anisotropy > 0
          , Lt = w.clearcoat > 0
          , B = w.iridescence > 0
          , L = w.sheen > 0
          , ee = w.transmission > 0
          , Te = on && !!w.anisotropyMap
          , pe = Lt && !!w.clearcoatMap
          , be = Lt && !!w.clearcoatNormalMap
          , Ne = Lt && !!w.clearcoatRoughnessMap
          , Me = B && !!w.iridescenceMap
          , Ae = B && !!w.iridescenceThicknessMap
          , G = L && !!w.sheenColorMap
          , _e = L && !!w.sheenRoughnessMap
          , fe = !!w.specularMap
          , je = !!w.specularColorMap
          , Fe = !!w.specularIntensityMap
          , Ge = ee && !!w.transmissionMap
          , Oe = ee && !!w.thicknessMap
          , Le = !!w.gradientMap
          , rt = !!w.alphaMap
          , X = w.alphaTest > 0
          , we = !!w.alphaHash
          , me = !!w.extensions
          , le = !!j.attributes.uv1
          , Se = !!j.attributes.uv2
          , He = !!j.attributes.uv3;
        let ut = Ns;
        return w.toneMapped && (De === null || De.isXRRenderTarget === !0) && (ut = r.toneMapping),
        {
            isWebGL2: d,
            shaderID: ae,
            shaderType: w.type,
            shaderName: w.name,
            vertexShader: oe,
            fragmentShader: he,
            defines: w.defines,
            customVertexShaderID: xe,
            customFragmentShaderID: Be,
            isRawShaderMaterial: w.isRawShaderMaterial === !0,
            glslVersion: w.glslVersion,
            precision: p,
            batching: Ze,
            instancing: et,
            instancingColor: et && q.instanceColor !== null,
            supportsVertexTextures: f,
            outputColorSpace: De === null ? r.outputColorSpace : De.isXRRenderTarget === !0 ? De.texture.colorSpace : gn,
            map: We,
            matcap: Je,
            envMap: Q,
            envMapMode: Q && J.mapping,
            envMapCubeUVHeight: de,
            aoMap: hn,
            lightMap: ze,
            bumpMap: at,
            normalMap: qe,
            displacementMap: f && It,
            emissiveMap: tt,
            normalMapObjectSpace: qe && w.normalMapType === XL,
            normalMapTangentSpace: qe && w.normalMapType === Eb,
            metalnessMap: Ye,
            roughnessMap: dt,
            anisotropy: on,
            anisotropyMap: Te,
            clearcoat: Lt,
            clearcoatMap: pe,
            clearcoatNormalMap: be,
            clearcoatRoughnessMap: Ne,
            iridescence: B,
            iridescenceMap: Me,
            iridescenceThicknessMap: Ae,
            sheen: L,
            sheenColorMap: G,
            sheenRoughnessMap: _e,
            specularMap: fe,
            specularColorMap: je,
            specularIntensityMap: Fe,
            transmission: ee,
            transmissionMap: Ge,
            thicknessMap: Oe,
            gradientMap: Le,
            opaque: w.transparent === !1 && w.blending === qa,
            alphaMap: rt,
            alphaTest: X,
            alphaHash: we,
            combine: w.combine,
            mapUv: We && y(w.map.channel),
            aoMapUv: hn && y(w.aoMap.channel),
            lightMapUv: ze && y(w.lightMap.channel),
            bumpMapUv: at && y(w.bumpMap.channel),
            normalMapUv: qe && y(w.normalMap.channel),
            displacementMapUv: It && y(w.displacementMap.channel),
            emissiveMapUv: tt && y(w.emissiveMap.channel),
            metalnessMapUv: Ye && y(w.metalnessMap.channel),
            roughnessMapUv: dt && y(w.roughnessMap.channel),
            anisotropyMapUv: Te && y(w.anisotropyMap.channel),
            clearcoatMapUv: pe && y(w.clearcoatMap.channel),
            clearcoatNormalMapUv: be && y(w.clearcoatNormalMap.channel),
            clearcoatRoughnessMapUv: Ne && y(w.clearcoatRoughnessMap.channel),
            iridescenceMapUv: Me && y(w.iridescenceMap.channel),
            iridescenceThicknessMapUv: Ae && y(w.iridescenceThicknessMap.channel),
            sheenColorMapUv: G && y(w.sheenColorMap.channel),
            sheenRoughnessMapUv: _e && y(w.sheenRoughnessMap.channel),
            specularMapUv: fe && y(w.specularMap.channel),
            specularColorMapUv: je && y(w.specularColorMap.channel),
            specularIntensityMapUv: Fe && y(w.specularIntensityMap.channel),
            transmissionMapUv: Ge && y(w.transmissionMap.channel),
            thicknessMapUv: Oe && y(w.thicknessMap.channel),
            alphaMapUv: rt && y(w.alphaMap.channel),
            vertexTangents: !!j.attributes.tangent && (qe || on),
            vertexColors: w.vertexColors,
            vertexAlphas: w.vertexColors === !0 && !!j.attributes.color && j.attributes.color.itemSize === 4,
            vertexUv1s: le,
            vertexUv2s: Se,
            vertexUv3s: He,
            pointsUvs: q.isPoints === !0 && !!j.attributes.uv && (We || rt),
            fog: !!F,
            useFog: w.fog === !0,
            fogExp2: F && F.isFogExp2,
            flatShading: w.flatShading === !0,
            sizeAttenuation: w.sizeAttenuation === !0,
            logarithmicDepthBuffer: l,
            skinning: q.isSkinnedMesh === !0,
            morphTargets: j.morphAttributes.position !== void 0,
            morphNormals: j.morphAttributes.normal !== void 0,
            morphColors: j.morphAttributes.color !== void 0,
            morphTargetsCount: ge,
            morphTextureStride: Ee,
            numDirLights: I.directional.length,
            numPointLights: I.point.length,
            numSpotLights: I.spot.length,
            numSpotLightMaps: I.spotLightMap.length,
            numRectAreaLights: I.rectArea.length,
            numHemiLights: I.hemi.length,
            numDirLightShadows: I.directionalShadowMap.length,
            numPointLightShadows: I.pointShadowMap.length,
            numSpotLightShadows: I.spotShadowMap.length,
            numSpotLightShadowsWithMaps: I.numSpotLightShadowsWithMaps,
            numLightProbes: I.numLightProbes,
            numClippingPlanes: o.numPlanes,
            numClipIntersection: o.numIntersection,
            dithering: w.dithering,
            shadowMapEnabled: r.shadowMap.enabled && V.length > 0,
            shadowMapType: r.shadowMap.type,
            toneMapping: ut,
            useLegacyLights: r._useLegacyLights,
            decodeVideoTexture: We && w.map.isVideoTexture === !0 && Rt.getTransfer(w.map.colorSpace) === Zt,
            premultipliedAlpha: w.premultipliedAlpha,
            doubleSided: w.side === mr,
            flipSided: w.side === fi,
            useDepthPacking: w.depthPacking >= 0,
            depthPacking: w.depthPacking || 0,
            index0AttributeName: w.index0AttributeName,
            extensionDerivatives: me && w.extensions.derivatives === !0,
            extensionFragDepth: me && w.extensions.fragDepth === !0,
            extensionDrawBuffers: me && w.extensions.drawBuffers === !0,
            extensionShaderTextureLOD: me && w.extensions.shaderTextureLOD === !0,
            rendererExtensionFragDepth: d || n.has("EXT_frag_depth"),
            rendererExtensionDrawBuffers: d || n.has("WEBGL_draw_buffers"),
            rendererExtensionShaderTextureLod: d || n.has("EXT_shader_texture_lod"),
            rendererExtensionParallelShaderCompile: n.has("KHR_parallel_shader_compile"),
            customProgramCacheKey: w.customProgramCacheKey()
        }
    }
    function _(w) {
        const I = [];
        if (w.shaderID ? I.push(w.shaderID) : (I.push(w.customVertexShaderID),
        I.push(w.customFragmentShaderID)),
        w.defines !== void 0)
            for (const V in w.defines)
                I.push(V),
                I.push(w.defines[V]);
        return w.isRawShaderMaterial === !1 && (b(I, w),
        T(I, w),
        I.push(r.outputColorSpace)),
        I.push(w.customProgramCacheKey),
        I.join()
    }
    function b(w, I) {
        w.push(I.precision),
        w.push(I.outputColorSpace),
        w.push(I.envMapMode),
        w.push(I.envMapCubeUVHeight),
        w.push(I.mapUv),
        w.push(I.alphaMapUv),
        w.push(I.lightMapUv),
        w.push(I.aoMapUv),
        w.push(I.bumpMapUv),
        w.push(I.normalMapUv),
        w.push(I.displacementMapUv),
        w.push(I.emissiveMapUv),
        w.push(I.metalnessMapUv),
        w.push(I.roughnessMapUv),
        w.push(I.anisotropyMapUv),
        w.push(I.clearcoatMapUv),
        w.push(I.clearcoatNormalMapUv),
        w.push(I.clearcoatRoughnessMapUv),
        w.push(I.iridescenceMapUv),
        w.push(I.iridescenceThicknessMapUv),
        w.push(I.sheenColorMapUv),
        w.push(I.sheenRoughnessMapUv),
        w.push(I.specularMapUv),
        w.push(I.specularColorMapUv),
        w.push(I.specularIntensityMapUv),
        w.push(I.transmissionMapUv),
        w.push(I.thicknessMapUv),
        w.push(I.combine),
        w.push(I.fogExp2),
        w.push(I.sizeAttenuation),
        w.push(I.morphTargetsCount),
        w.push(I.morphAttributeCount),
        w.push(I.numDirLights),
        w.push(I.numPointLights),
        w.push(I.numSpotLights),
        w.push(I.numSpotLightMaps),
        w.push(I.numHemiLights),
        w.push(I.numRectAreaLights),
        w.push(I.numDirLightShadows),
        w.push(I.numPointLightShadows),
        w.push(I.numSpotLightShadows),
        w.push(I.numSpotLightShadowsWithMaps),
        w.push(I.numLightProbes),
        w.push(I.shadowMapType),
        w.push(I.toneMapping),
        w.push(I.numClippingPlanes),
        w.push(I.numClipIntersection),
        w.push(I.depthPacking)
    }
    function T(w, I) {
        a.disableAll(),
        I.isWebGL2 && a.enable(0),
        I.supportsVertexTextures && a.enable(1),
        I.instancing && a.enable(2),
        I.instancingColor && a.enable(3),
        I.matcap && a.enable(4),
        I.envMap && a.enable(5),
        I.normalMapObjectSpace && a.enable(6),
        I.normalMapTangentSpace && a.enable(7),
        I.clearcoat && a.enable(8),
        I.iridescence && a.enable(9),
        I.alphaTest && a.enable(10),
        I.vertexColors && a.enable(11),
        I.vertexAlphas && a.enable(12),
        I.vertexUv1s && a.enable(13),
        I.vertexUv2s && a.enable(14),
        I.vertexUv3s && a.enable(15),
        I.vertexTangents && a.enable(16),
        I.anisotropy && a.enable(17),
        I.alphaHash && a.enable(18),
        I.batching && a.enable(19),
        w.push(a.mask),
        a.disableAll(),
        I.fog && a.enable(0),
        I.useFog && a.enable(1),
        I.flatShading && a.enable(2),
        I.logarithmicDepthBuffer && a.enable(3),
        I.skinning && a.enable(4),
        I.morphTargets && a.enable(5),
        I.morphNormals && a.enable(6),
        I.morphColors && a.enable(7),
        I.premultipliedAlpha && a.enable(8),
        I.shadowMapEnabled && a.enable(9),
        I.useLegacyLights && a.enable(10),
        I.doubleSided && a.enable(11),
        I.flipSided && a.enable(12),
        I.useDepthPacking && a.enable(13),
        I.dithering && a.enable(14),
        I.transmission && a.enable(15),
        I.sheen && a.enable(16),
        I.opaque && a.enable(17),
        I.pointsUvs && a.enable(18),
        I.decodeVideoTexture && a.enable(19),
        w.push(a.mask)
    }
    function S(w) {
        const I = g[w.type];
        let V;
        if (I) {
            const z = Ar[I];
            V = ID.clone(z.uniforms)
        } else
            V = w.uniforms;
        return V
    }
    function E(w, I) {
        let V;
        for (let z = 0, q = h.length; z < q; z++) {
            const F = h[z];
            if (F.cacheKey === I) {
                V = F,
                ++V.usedTimes;
                break
            }
        }
        return V === void 0 && (V = new WN(r,I,w,s),
        h.push(V)),
        V
    }
    function P(w) {
        if (--w.usedTimes === 0) {
            const I = h.indexOf(w);
            h[I] = h[h.length - 1],
            h.pop(),
            w.destroy()
        }
    }
    function R(w) {
        c.remove(w)
    }
    function O() {
        c.dispose()
    }
    return {
        getParameters: v,
        getProgramCacheKey: _,
        getUniforms: S,
        acquireProgram: E,
        releaseProgram: P,
        releaseShaderCache: R,
        programs: h,
        dispose: O
    }
}
function YN() {
    let r = new WeakMap;
    function e(s) {
        let o = r.get(s);
        return o === void 0 && (o = {},
        r.set(s, o)),
        o
    }
    function t(s) {
        r.delete(s)
    }
    function n(s, o, a) {
        r.get(s)[o] = a
    }
    function i() {
        r = new WeakMap
    }
    return {
        get: e,
        remove: t,
        update: n,
        dispose: i
    }
}
function $N(r, e) {
    return r.groupOrder !== e.groupOrder ? r.groupOrder - e.groupOrder : r.renderOrder !== e.renderOrder ? r.renderOrder - e.renderOrder : r.material.id !== e.material.id ? r.material.id - e.material.id : r.z !== e.z ? r.z - e.z : r.id - e.id
}
function Ly(r, e) {
    return r.groupOrder !== e.groupOrder ? r.groupOrder - e.groupOrder : r.renderOrder !== e.renderOrder ? r.renderOrder - e.renderOrder : r.z !== e.z ? e.z - r.z : r.id - e.id
}
function Dy() {
    const r = [];
    let e = 0;
    const t = []
      , n = []
      , i = [];
    function s() {
        e = 0,
        t.length = 0,
        n.length = 0,
        i.length = 0
    }
    function o(l, f, p, g, y, v) {
        let _ = r[e];
        return _ === void 0 ? (_ = {
            id: l.id,
            object: l,
            geometry: f,
            material: p,
            groupOrder: g,
            renderOrder: l.renderOrder,
            z: y,
            group: v
        },
        r[e] = _) : (_.id = l.id,
        _.object = l,
        _.geometry = f,
        _.material = p,
        _.groupOrder = g,
        _.renderOrder = l.renderOrder,
        _.z = y,
        _.group = v),
        e++,
        _
    }
    function a(l, f, p, g, y, v) {
        const _ = o(l, f, p, g, y, v);
        p.transmission > 0 ? n.push(_) : p.transparent === !0 ? i.push(_) : t.push(_)
    }
    function c(l, f, p, g, y, v) {
        const _ = o(l, f, p, g, y, v);
        p.transmission > 0 ? n.unshift(_) : p.transparent === !0 ? i.unshift(_) : t.unshift(_)
    }
    function h(l, f) {
        t.length > 1 && t.sort(l || $N),
        n.length > 1 && n.sort(f || Ly),
        i.length > 1 && i.sort(f || Ly)
    }
    function d() {
        for (let l = e, f = r.length; l < f; l++) {
            const p = r[l];
            if (p.id === null)
                break;
            p.id = null,
            p.object = null,
            p.geometry = null,
            p.material = null,
            p.group = null
        }
    }
    return {
        opaque: t,
        transmissive: n,
        transparent: i,
        init: s,
        push: a,
        unshift: c,
        finish: d,
        sort: h
    }
}
function ZN() {
    let r = new WeakMap;
    function e(n, i) {
        const s = r.get(n);
        let o;
        return s === void 0 ? (o = new Dy,
        r.set(n, [o])) : i >= s.length ? (o = new Dy,
        s.push(o)) : o = s[i],
        o
    }
    function t() {
        r = new WeakMap
    }
    return {
        get: e,
        dispose: t
    }
}
function JN() {
    const r = {};
    return {
        get: function(e) {
            if (r[e.id] !== void 0)
                return r[e.id];
            let t;
            switch (e.type) {
            case "DirectionalLight":
                t = {
                    direction: new k,
                    color: new Ke
                };
                break;
            case "SpotLight":
                t = {
                    position: new k,
                    direction: new k,
                    color: new Ke,
                    distance: 0,
                    coneCos: 0,
                    penumbraCos: 0,
                    decay: 0
                };
                break;
            case "PointLight":
                t = {
                    position: new k,
                    color: new Ke,
                    distance: 0,
                    decay: 0
                };
                break;
            case "HemisphereLight":
                t = {
                    direction: new k,
                    skyColor: new Ke,
                    groundColor: new Ke
                };
                break;
            case "RectAreaLight":
                t = {
                    color: new Ke,
                    position: new k,
                    halfWidth: new k,
                    halfHeight: new k
                };
                break
            }
            return r[e.id] = t,
            t
        }
    }
}
function QN() {
    const r = {};
    return {
        get: function(e) {
            if (r[e.id] !== void 0)
                return r[e.id];
            let t;
            switch (e.type) {
            case "DirectionalLight":
                t = {
                    shadowBias: 0,
                    shadowNormalBias: 0,
                    shadowRadius: 1,
                    shadowMapSize: new Ce
                };
                break;
            case "SpotLight":
                t = {
                    shadowBias: 0,
                    shadowNormalBias: 0,
                    shadowRadius: 1,
                    shadowMapSize: new Ce
                };
                break;
            case "PointLight":
                t = {
                    shadowBias: 0,
                    shadowNormalBias: 0,
                    shadowRadius: 1,
                    shadowMapSize: new Ce,
                    shadowCameraNear: 1,
                    shadowCameraFar: 1e3
                };
                break
            }
            return r[e.id] = t,
            t
        }
    }
}
let e3 = 0;
function t3(r, e) {
    return (e.castShadow ? 2 : 0) - (r.castShadow ? 2 : 0) + (e.map ? 1 : 0) - (r.map ? 1 : 0)
}
function n3(r, e) {
    const t = new JN
      , n = QN()
      , i = {
        version: 0,
        hash: {
            directionalLength: -1,
            pointLength: -1,
            spotLength: -1,
            rectAreaLength: -1,
            hemiLength: -1,
            numDirectionalShadows: -1,
            numPointShadows: -1,
            numSpotShadows: -1,
            numSpotMaps: -1,
            numLightProbes: -1
        },
        ambient: [0, 0, 0],
        probe: [],
        directional: [],
        directionalShadow: [],
        directionalShadowMap: [],
        directionalShadowMatrix: [],
        spot: [],
        spotLightMap: [],
        spotShadow: [],
        spotShadowMap: [],
        spotLightMatrix: [],
        rectArea: [],
        rectAreaLTC1: null,
        rectAreaLTC2: null,
        point: [],
        pointShadow: [],
        pointShadowMap: [],
        pointShadowMatrix: [],
        hemi: [],
        numSpotLightShadowsWithMaps: 0,
        numLightProbes: 0
    };
    for (let d = 0; d < 9; d++)
        i.probe.push(new k);
    const s = new k
      , o = new it
      , a = new it;
    function c(d, l) {
        let f = 0
          , p = 0
          , g = 0;
        for (let z = 0; z < 9; z++)
            i.probe[z].set(0, 0, 0);
        let y = 0
          , v = 0
          , _ = 0
          , b = 0
          , T = 0
          , S = 0
          , E = 0
          , P = 0
          , R = 0
          , O = 0
          , w = 0;
        d.sort(t3);
        const I = l === !0 ? Math.PI : 1;
        for (let z = 0, q = d.length; z < q; z++) {
            const F = d[z]
              , j = F.color
              , K = F.intensity
              , J = F.distance
              , de = F.shadow && F.shadow.map ? F.shadow.map.texture : null;
            if (F.isAmbientLight)
                f += j.r * K * I,
                p += j.g * K * I,
                g += j.b * K * I;
            else if (F.isLightProbe) {
                for (let ae = 0; ae < 9; ae++)
                    i.probe[ae].addScaledVector(F.sh.coefficients[ae], K);
                w++
            } else if (F.isDirectionalLight) {
                const ae = t.get(F);
                if (ae.color.copy(F.color).multiplyScalar(F.intensity * I),
                F.castShadow) {
                    const ue = F.shadow
                      , ge = n.get(F);
                    ge.shadowBias = ue.bias,
                    ge.shadowNormalBias = ue.normalBias,
                    ge.shadowRadius = ue.radius,
                    ge.shadowMapSize = ue.mapSize,
                    i.directionalShadow[y] = ge,
                    i.directionalShadowMap[y] = de,
                    i.directionalShadowMatrix[y] = F.shadow.matrix,
                    S++
                }
                i.directional[y] = ae,
                y++
            } else if (F.isSpotLight) {
                const ae = t.get(F);
                ae.position.setFromMatrixPosition(F.matrixWorld),
                ae.color.copy(j).multiplyScalar(K * I),
                ae.distance = J,
                ae.coneCos = Math.cos(F.angle),
                ae.penumbraCos = Math.cos(F.angle * (1 - F.penumbra)),
                ae.decay = F.decay,
                i.spot[_] = ae;
                const ue = F.shadow;
                if (F.map && (i.spotLightMap[R] = F.map,
                R++,
                ue.updateMatrices(F),
                F.castShadow && O++),
                i.spotLightMatrix[_] = ue.matrix,
                F.castShadow) {
                    const ge = n.get(F);
                    ge.shadowBias = ue.bias,
                    ge.shadowNormalBias = ue.normalBias,
                    ge.shadowRadius = ue.radius,
                    ge.shadowMapSize = ue.mapSize,
                    i.spotShadow[_] = ge,
                    i.spotShadowMap[_] = de,
                    P++
                }
                _++
            } else if (F.isRectAreaLight) {
                const ae = t.get(F);
                ae.color.copy(j).multiplyScalar(K),
                ae.halfWidth.set(F.width * .5, 0, 0),
                ae.halfHeight.set(0, F.height * .5, 0),
                i.rectArea[b] = ae,
                b++
            } else if (F.isPointLight) {
                const ae = t.get(F);
                if (ae.color.copy(F.color).multiplyScalar(F.intensity * I),
                ae.distance = F.distance,
                ae.decay = F.decay,
                F.castShadow) {
                    const ue = F.shadow
                      , ge = n.get(F);
                    ge.shadowBias = ue.bias,
                    ge.shadowNormalBias = ue.normalBias,
                    ge.shadowRadius = ue.radius,
                    ge.shadowMapSize = ue.mapSize,
                    ge.shadowCameraNear = ue.camera.near,
                    ge.shadowCameraFar = ue.camera.far,
                    i.pointShadow[v] = ge,
                    i.pointShadowMap[v] = de,
                    i.pointShadowMatrix[v] = F.shadow.matrix,
                    E++
                }
                i.point[v] = ae,
                v++
            } else if (F.isHemisphereLight) {
                const ae = t.get(F);
                ae.skyColor.copy(F.color).multiplyScalar(K * I),
                ae.groundColor.copy(F.groundColor).multiplyScalar(K * I),
                i.hemi[T] = ae,
                T++
            }
        }
        b > 0 && (e.isWebGL2 || r.has("OES_texture_float_linear") === !0 ? (i.rectAreaLTC1 = Pe.LTC_FLOAT_1,
        i.rectAreaLTC2 = Pe.LTC_FLOAT_2) : r.has("OES_texture_half_float_linear") === !0 ? (i.rectAreaLTC1 = Pe.LTC_HALF_1,
        i.rectAreaLTC2 = Pe.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")),
        i.ambient[0] = f,
        i.ambient[1] = p,
        i.ambient[2] = g;
        const V = i.hash;
        (V.directionalLength !== y || V.pointLength !== v || V.spotLength !== _ || V.rectAreaLength !== b || V.hemiLength !== T || V.numDirectionalShadows !== S || V.numPointShadows !== E || V.numSpotShadows !== P || V.numSpotMaps !== R || V.numLightProbes !== w) && (i.directional.length = y,
        i.spot.length = _,
        i.rectArea.length = b,
        i.point.length = v,
        i.hemi.length = T,
        i.directionalShadow.length = S,
        i.directionalShadowMap.length = S,
        i.pointShadow.length = E,
        i.pointShadowMap.length = E,
        i.spotShadow.length = P,
        i.spotShadowMap.length = P,
        i.directionalShadowMatrix.length = S,
        i.pointShadowMatrix.length = E,
        i.spotLightMatrix.length = P + R - O,
        i.spotLightMap.length = R,
        i.numSpotLightShadowsWithMaps = O,
        i.numLightProbes = w,
        V.directionalLength = y,
        V.pointLength = v,
        V.spotLength = _,
        V.rectAreaLength = b,
        V.hemiLength = T,
        V.numDirectionalShadows = S,
        V.numPointShadows = E,
        V.numSpotShadows = P,
        V.numSpotMaps = R,
        V.numLightProbes = w,
        i.version = e3++)
    }
    function h(d, l) {
        let f = 0
          , p = 0
          , g = 0
          , y = 0
          , v = 0;
        const _ = l.matrixWorldInverse;
        for (let b = 0, T = d.length; b < T; b++) {
            const S = d[b];
            if (S.isDirectionalLight) {
                const E = i.directional[f];
                E.direction.setFromMatrixPosition(S.matrixWorld),
                s.setFromMatrixPosition(S.target.matrixWorld),
                E.direction.sub(s),
                E.direction.transformDirection(_),
                f++
            } else if (S.isSpotLight) {
                const E = i.spot[g];
                E.position.setFromMatrixPosition(S.matrixWorld),
                E.position.applyMatrix4(_),
                E.direction.setFromMatrixPosition(S.matrixWorld),
                s.setFromMatrixPosition(S.target.matrixWorld),
                E.direction.sub(s),
                E.direction.transformDirection(_),
                g++
            } else if (S.isRectAreaLight) {
                const E = i.rectArea[y];
                E.position.setFromMatrixPosition(S.matrixWorld),
                E.position.applyMatrix4(_),
                a.identity(),
                o.copy(S.matrixWorld),
                o.premultiply(_),
                a.extractRotation(o),
                E.halfWidth.set(S.width * .5, 0, 0),
                E.halfHeight.set(0, S.height * .5, 0),
                E.halfWidth.applyMatrix4(a),
                E.halfHeight.applyMatrix4(a),
                y++
            } else if (S.isPointLight) {
                const E = i.point[p];
                E.position.setFromMatrixPosition(S.matrixWorld),
                E.position.applyMatrix4(_),
                p++
            } else if (S.isHemisphereLight) {
                const E = i.hemi[v];
                E.direction.setFromMatrixPosition(S.matrixWorld),
                E.direction.transformDirection(_),
                v++
            }
        }
    }
    return {
        setup: c,
        setupView: h,
        state: i
    }
}
function Oy(r, e) {
    const t = new n3(r,e)
      , n = []
      , i = [];
    function s() {
        n.length = 0,
        i.length = 0
    }
    function o(l) {
        n.push(l)
    }
    function a(l) {
        i.push(l)
    }
    function c(l) {
        t.setup(n, l)
    }
    function h(l) {
        t.setupView(n, l)
    }
    return {
        init: s,
        state: {
            lightsArray: n,
            shadowsArray: i,
            lights: t
        },
        setupLights: c,
        setupLightsView: h,
        pushLight: o,
        pushShadow: a
    }
}
function i3(r, e) {
    let t = new WeakMap;
    function n(s, o=0) {
        const a = t.get(s);
        let c;
        return a === void 0 ? (c = new Oy(r,e),
        t.set(s, [c])) : o >= a.length ? (c = new Oy(r,e),
        a.push(c)) : c = a[o],
        c
    }
    function i() {
        t = new WeakMap
    }
    return {
        get: n,
        dispose: i
    }
}
class F_ extends nr {
    constructor(e) {
        super(),
        this.isMeshDepthMaterial = !0,
        this.type = "MeshDepthMaterial",
        this.depthPacking = Fc,
        this.map = null,
        this.alphaMap = null,
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.depthPacking = e.depthPacking,
        this.map = e.map,
        this.alphaMap = e.alphaMap,
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this
    }
}
class r3 extends nr {
    constructor(e) {
        super(),
        this.isMeshDistanceMaterial = !0,
        this.type = "MeshDistanceMaterial",
        this.map = null,
        this.alphaMap = null,
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.map = e.map,
        this.alphaMap = e.alphaMap,
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this
    }
}
const s3 = `void main() {
	gl_Position = vec4( position, 1.0 );
}`
  , o3 = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;
function a3(r, e, t) {
    let n = new O_;
    const i = new Ce
      , s = new Ce
      , o = new Ct
      , a = new F_({
        depthPacking: R_
    })
      , c = new r3
      , h = {}
      , d = t.maxTextureSize
      , l = {
        [xr]: fi,
        [fi]: xr,
        [mr]: mr
    }
      , f = new Vt({
        defines: {
            VSM_SAMPLES: 8
        },
        uniforms: {
            shadow_pass: {
                value: null
            },
            resolution: {
                value: new Ce
            },
            radius: {
                value: 4
            }
        },
        vertexShader: s3,
        fragmentShader: o3
    })
      , p = f.clone();
    p.defines.HORIZONTAL_PASS = 1;
    const g = new mn;
    g.setAttribute("position", new pt(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]),3));
    const y = new en(g,f)
      , v = this;
    this.enabled = !1,
    this.autoUpdate = !0,
    this.needsUpdate = !1,
    this.type = pb;
    let _ = this.type;
    this.render = function(E, P, R) {
        if (v.enabled === !1 || v.autoUpdate === !1 && v.needsUpdate === !1 || E.length === 0)
            return;
        const O = r.getRenderTarget()
          , w = r.getActiveCubeFace()
          , I = r.getActiveMipmapLevel()
          , V = r.state;
        V.setBlending(Si),
        V.buffers.color.setClear(1, 1, 1, 1),
        V.buffers.depth.setTest(!0),
        V.setScissorTest(!1);
        const z = _ !== Jr && this.type === Jr
          , q = _ === Jr && this.type !== Jr;
        for (let F = 0, j = E.length; F < j; F++) {
            const K = E[F]
              , J = K.shadow;
            if (J === void 0) {
                console.warn("THREE.WebGLShadowMap:", K, "has no shadow.");
                continue
            }
            if (J.autoUpdate === !1 && J.needsUpdate === !1)
                continue;
            i.copy(J.mapSize);
            const de = J.getFrameExtents();
            if (i.multiply(de),
            s.copy(J.mapSize),
            (i.x > d || i.y > d) && (i.x > d && (s.x = Math.floor(d / de.x),
            i.x = s.x * de.x,
            J.mapSize.x = s.x),
            i.y > d && (s.y = Math.floor(d / de.y),
            i.y = s.y * de.y,
            J.mapSize.y = s.y)),
            J.map === null || z === !0 || q === !0) {
                const ue = this.type !== Jr ? {
                    minFilter: Jt,
                    magFilter: Jt
                } : {};
                J.map !== null && J.map.dispose(),
                J.map = new vn(i.x,i.y,ue),
                J.map.texture.name = K.name + ".shadowMap",
                J.camera.updateProjectionMatrix()
            }
            r.setRenderTarget(J.map),
            r.clear();
            const ae = J.getViewportCount();
            for (let ue = 0; ue < ae; ue++) {
                const ge = J.getViewport(ue);
                o.set(s.x * ge.x, s.y * ge.y, s.x * ge.z, s.y * ge.w),
                V.viewport(o),
                J.updateMatrices(K, ue),
                n = J.getFrustum(),
                S(P, R, J.camera, K, this.type)
            }
            J.isPointLightShadow !== !0 && this.type === Jr && b(J, R),
            J.needsUpdate = !1
        }
        _ = this.type,
        v.needsUpdate = !1,
        r.setRenderTarget(O, w, I)
    }
    ;
    function b(E, P) {
        const R = e.update(y);
        f.defines.VSM_SAMPLES !== E.blurSamples && (f.defines.VSM_SAMPLES = E.blurSamples,
        p.defines.VSM_SAMPLES = E.blurSamples,
        f.needsUpdate = !0,
        p.needsUpdate = !0),
        E.mapPass === null && (E.mapPass = new vn(i.x,i.y)),
        f.uniforms.shadow_pass.value = E.map.texture,
        f.uniforms.resolution.value = E.mapSize,
        f.uniforms.radius.value = E.radius,
        r.setRenderTarget(E.mapPass),
        r.clear(),
        r.renderBufferDirect(P, null, R, f, y, null),
        p.uniforms.shadow_pass.value = E.mapPass.texture,
        p.uniforms.resolution.value = E.mapSize,
        p.uniforms.radius.value = E.radius,
        r.setRenderTarget(E.map),
        r.clear(),
        r.renderBufferDirect(P, null, R, p, y, null)
    }
    function T(E, P, R, O) {
        let w = null;
        const I = R.isPointLight === !0 ? E.customDistanceMaterial : E.customDepthMaterial;
        if (I !== void 0)
            w = I;
        else if (w = R.isPointLight === !0 ? c : a,
        r.localClippingEnabled && P.clipShadows === !0 && Array.isArray(P.clippingPlanes) && P.clippingPlanes.length !== 0 || P.displacementMap && P.displacementScale !== 0 || P.alphaMap && P.alphaTest > 0 || P.map && P.alphaTest > 0) {
            const V = w.uuid
              , z = P.uuid;
            let q = h[V];
            q === void 0 && (q = {},
            h[V] = q);
            let F = q[z];
            F === void 0 && (F = w.clone(),
            q[z] = F),
            w = F
        }
        if (w.visible = P.visible,
        w.wireframe = P.wireframe,
        O === Jr ? w.side = P.shadowSide !== null ? P.shadowSide : P.side : w.side = P.shadowSide !== null ? P.shadowSide : l[P.side],
        w.alphaMap = P.alphaMap,
        w.alphaTest = P.alphaTest,
        w.map = P.map,
        w.clipShadows = P.clipShadows,
        w.clippingPlanes = P.clippingPlanes,
        w.clipIntersection = P.clipIntersection,
        w.displacementMap = P.displacementMap,
        w.displacementScale = P.displacementScale,
        w.displacementBias = P.displacementBias,
        w.wireframeLinewidth = P.wireframeLinewidth,
        w.linewidth = P.linewidth,
        R.isPointLight === !0 && w.isMeshDistanceMaterial === !0) {
            const V = r.properties.get(w);
            V.light = R
        }
        return w
    }
    function S(E, P, R, O, w) {
        if (E.visible === !1)
            return;
        if (E.layers.test(P.layers) && (E.isMesh || E.isLine || E.isPoints) && (E.castShadow || E.receiveShadow && w === Jr) && (!E.frustumCulled || n.intersectsObject(E))) {
            E.modelViewMatrix.multiplyMatrices(R.matrixWorldInverse, E.matrixWorld);
            const z = e.update(E)
              , q = E.material;
            if (Array.isArray(q)) {
                const F = z.groups;
                for (let j = 0, K = F.length; j < K; j++) {
                    const J = F[j]
                      , de = q[J.materialIndex];
                    if (de && de.visible) {
                        const ae = T(E, de, O, w);
                        E.onBeforeShadow(r, E, P, R, z, ae, J),
                        r.renderBufferDirect(R, null, z, ae, E, J),
                        E.onAfterShadow(r, E, P, R, z, ae, J)
                    }
                }
            } else if (q.visible) {
                const F = T(E, q, O, w);
                E.onBeforeShadow(r, E, P, R, z, F, null),
                r.renderBufferDirect(R, null, z, F, E, null),
                E.onAfterShadow(r, E, P, R, z, F, null)
            }
        }
        const V = E.children;
        for (let z = 0, q = V.length; z < q; z++)
            S(V[z], P, R, O, w)
    }
}
function l3(r, e, t) {
    const n = t.isWebGL2;
    function i() {
        let X = !1;
        const we = new Ct;
        let me = null;
        const le = new Ct(0,0,0,0);
        return {
            setMask: function(Se) {
                me !== Se && !X && (r.colorMask(Se, Se, Se, Se),
                me = Se)
            },
            setLocked: function(Se) {
                X = Se
            },
            setClear: function(Se, He, ut, Ut, Rn) {
                Rn === !0 && (Se *= Ut,
                He *= Ut,
                ut *= Ut),
                we.set(Se, He, ut, Ut),
                le.equals(we) === !1 && (r.clearColor(Se, He, ut, Ut),
                le.copy(we))
            },
            reset: function() {
                X = !1,
                me = null,
                le.set(-1, 0, 0, 0)
            }
        }
    }
    function s() {
        let X = !1
          , we = null
          , me = null
          , le = null;
        return {
            setTest: function(Se) {
                Se ? Ze(r.DEPTH_TEST) : We(r.DEPTH_TEST)
            },
            setMask: function(Se) {
                we !== Se && !X && (r.depthMask(Se),
                we = Se)
            },
            setFunc: function(Se) {
                if (me !== Se) {
                    switch (Se) {
                    case vL:
                        r.depthFunc(r.NEVER);
                        break;
                    case yL:
                        r.depthFunc(r.ALWAYS);
                        break;
                    case xL:
                        r.depthFunc(r.LESS);
                        break;
                    case jh:
                        r.depthFunc(r.LEQUAL);
                        break;
                    case TL:
                        r.depthFunc(r.EQUAL);
                        break;
                    case bL:
                        r.depthFunc(r.GEQUAL);
                        break;
                    case SL:
                        r.depthFunc(r.GREATER);
                        break;
                    case ML:
                        r.depthFunc(r.NOTEQUAL);
                        break;
                    default:
                        r.depthFunc(r.LEQUAL)
                    }
                    me = Se
                }
            },
            setLocked: function(Se) {
                X = Se
            },
            setClear: function(Se) {
                le !== Se && (r.clearDepth(Se),
                le = Se)
            },
            reset: function() {
                X = !1,
                we = null,
                me = null,
                le = null
            }
        }
    }
    function o() {
        let X = !1
          , we = null
          , me = null
          , le = null
          , Se = null
          , He = null
          , ut = null
          , Ut = null
          , Rn = null;
        return {
            setTest: function(Et) {
                X || (Et ? Ze(r.STENCIL_TEST) : We(r.STENCIL_TEST))
            },
            setMask: function(Et) {
                we !== Et && !X && (r.stencilMask(Et),
                we = Et)
            },
            setFunc: function(Et, Cn, _i) {
                (me !== Et || le !== Cn || Se !== _i) && (r.stencilFunc(Et, Cn, _i),
                me = Et,
                le = Cn,
                Se = _i)
            },
            setOp: function(Et, Cn, _i) {
                (He !== Et || ut !== Cn || Ut !== _i) && (r.stencilOp(Et, Cn, _i),
                He = Et,
                ut = Cn,
                Ut = _i)
            },
            setLocked: function(Et) {
                X = Et
            },
            setClear: function(Et) {
                Rn !== Et && (r.clearStencil(Et),
                Rn = Et)
            },
            reset: function() {
                X = !1,
                we = null,
                me = null,
                le = null,
                Se = null,
                He = null,
                ut = null,
                Ut = null,
                Rn = null
            }
        }
    }
    const a = new i
      , c = new s
      , h = new o
      , d = new WeakMap
      , l = new WeakMap;
    let f = {}
      , p = {}
      , g = new WeakMap
      , y = []
      , v = null
      , _ = !1
      , b = null
      , T = null
      , S = null
      , E = null
      , P = null
      , R = null
      , O = null
      , w = new Ke(0,0,0)
      , I = 0
      , V = !1
      , z = null
      , q = null
      , F = null
      , j = null
      , K = null;
    const J = r.getParameter(r.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
    let de = !1
      , ae = 0;
    const ue = r.getParameter(r.VERSION);
    ue.indexOf("WebGL") !== -1 ? (ae = parseFloat(/^WebGL (\d)/.exec(ue)[1]),
    de = ae >= 1) : ue.indexOf("OpenGL ES") !== -1 && (ae = parseFloat(/^OpenGL ES (\d)/.exec(ue)[1]),
    de = ae >= 2);
    let ge = null
      , Ee = {};
    const oe = r.getParameter(r.SCISSOR_BOX)
      , he = r.getParameter(r.VIEWPORT)
      , xe = new Ct().fromArray(oe)
      , Be = new Ct().fromArray(he);
    function De(X, we, me, le) {
        const Se = new Uint8Array(4)
          , He = r.createTexture();
        r.bindTexture(X, He),
        r.texParameteri(X, r.TEXTURE_MIN_FILTER, r.NEAREST),
        r.texParameteri(X, r.TEXTURE_MAG_FILTER, r.NEAREST);
        for (let ut = 0; ut < me; ut++)
            n && (X === r.TEXTURE_3D || X === r.TEXTURE_2D_ARRAY) ? r.texImage3D(we, 0, r.RGBA, 1, 1, le, 0, r.RGBA, r.UNSIGNED_BYTE, Se) : r.texImage2D(we + ut, 0, r.RGBA, 1, 1, 0, r.RGBA, r.UNSIGNED_BYTE, Se);
        return He
    }
    const et = {};
    et[r.TEXTURE_2D] = De(r.TEXTURE_2D, r.TEXTURE_2D, 1),
    et[r.TEXTURE_CUBE_MAP] = De(r.TEXTURE_CUBE_MAP, r.TEXTURE_CUBE_MAP_POSITIVE_X, 6),
    n && (et[r.TEXTURE_2D_ARRAY] = De(r.TEXTURE_2D_ARRAY, r.TEXTURE_2D_ARRAY, 1, 1),
    et[r.TEXTURE_3D] = De(r.TEXTURE_3D, r.TEXTURE_3D, 1, 1)),
    a.setClear(0, 0, 0, 1),
    c.setClear(1),
    h.setClear(0),
    Ze(r.DEPTH_TEST),
    c.setFunc(jh),
    tt(!1),
    Ye(g0),
    Ze(r.CULL_FACE),
    qe(Si);
    function Ze(X) {
        f[X] !== !0 && (r.enable(X),
        f[X] = !0)
    }
    function We(X) {
        f[X] !== !1 && (r.disable(X),
        f[X] = !1)
    }
    function Je(X, we) {
        return p[X] !== we ? (r.bindFramebuffer(X, we),
        p[X] = we,
        n && (X === r.DRAW_FRAMEBUFFER && (p[r.FRAMEBUFFER] = we),
        X === r.FRAMEBUFFER && (p[r.DRAW_FRAMEBUFFER] = we)),
        !0) : !1
    }
    function Q(X, we) {
        let me = y
          , le = !1;
        if (X)
            if (me = g.get(we),
            me === void 0 && (me = [],
            g.set(we, me)),
            X.isWebGLMultipleRenderTargets) {
                const Se = X.texture;
                if (me.length !== Se.length || me[0] !== r.COLOR_ATTACHMENT0) {
                    for (let He = 0, ut = Se.length; He < ut; He++)
                        me[He] = r.COLOR_ATTACHMENT0 + He;
                    me.length = Se.length,
                    le = !0
                }
            } else
                me[0] !== r.COLOR_ATTACHMENT0 && (me[0] = r.COLOR_ATTACHMENT0,
                le = !0);
        else
            me[0] !== r.BACK && (me[0] = r.BACK,
            le = !0);
        le && (t.isWebGL2 ? r.drawBuffers(me) : e.get("WEBGL_draw_buffers").drawBuffersWEBGL(me))
    }
    function hn(X) {
        return v !== X ? (r.useProgram(X),
        v = X,
        !0) : !1
    }
    const ze = {
        [bo]: r.FUNC_ADD,
        [iL]: r.FUNC_SUBTRACT,
        [rL]: r.FUNC_REVERSE_SUBTRACT
    };
    if (n)
        ze[x0] = r.MIN,
        ze[T0] = r.MAX;
    else {
        const X = e.get("EXT_blend_minmax");
        X !== null && (ze[x0] = X.MIN_EXT,
        ze[T0] = X.MAX_EXT)
    }
    const at = {
        [sL]: r.ZERO,
        [oL]: r.ONE,
        [aL]: r.SRC_COLOR,
        [Om]: r.SRC_ALPHA,
        [dL]: r.SRC_ALPHA_SATURATE,
        [hL]: r.DST_COLOR,
        [cL]: r.DST_ALPHA,
        [lL]: r.ONE_MINUS_SRC_COLOR,
        [Um]: r.ONE_MINUS_SRC_ALPHA,
        [fL]: r.ONE_MINUS_DST_COLOR,
        [uL]: r.ONE_MINUS_DST_ALPHA,
        [pL]: r.CONSTANT_COLOR,
        [mL]: r.ONE_MINUS_CONSTANT_COLOR,
        [_L]: r.CONSTANT_ALPHA,
        [gL]: r.ONE_MINUS_CONSTANT_ALPHA
    };
    function qe(X, we, me, le, Se, He, ut, Ut, Rn, Et) {
        if (X === Si) {
            _ === !0 && (We(r.BLEND),
            _ = !1);
            return
        }
        if (_ === !1 && (Ze(r.BLEND),
        _ = !0),
        X !== nL) {
            if (X !== b || Et !== V) {
                if ((T !== bo || P !== bo) && (r.blendEquation(r.FUNC_ADD),
                T = bo,
                P = bo),
                Et)
                    switch (X) {
                    case qa:
                        r.blendFuncSeparate(r.ONE, r.ONE_MINUS_SRC_ALPHA, r.ONE, r.ONE_MINUS_SRC_ALPHA);
                        break;
                    case Dc:
                        r.blendFunc(r.ONE, r.ONE);
                        break;
                    case v0:
                        r.blendFuncSeparate(r.ZERO, r.ONE_MINUS_SRC_COLOR, r.ZERO, r.ONE);
                        break;
                    case y0:
                        r.blendFuncSeparate(r.ZERO, r.SRC_COLOR, r.ZERO, r.SRC_ALPHA);
                        break;
                    default:
                        console.error("THREE.WebGLState: Invalid blending: ", X);
                        break
                    }
                else
                    switch (X) {
                    case qa:
                        r.blendFuncSeparate(r.SRC_ALPHA, r.ONE_MINUS_SRC_ALPHA, r.ONE, r.ONE_MINUS_SRC_ALPHA);
                        break;
                    case Dc:
                        r.blendFunc(r.SRC_ALPHA, r.ONE);
                        break;
                    case v0:
                        r.blendFuncSeparate(r.ZERO, r.ONE_MINUS_SRC_COLOR, r.ZERO, r.ONE);
                        break;
                    case y0:
                        r.blendFunc(r.ZERO, r.SRC_COLOR);
                        break;
                    default:
                        console.error("THREE.WebGLState: Invalid blending: ", X);
                        break
                    }
                S = null,
                E = null,
                R = null,
                O = null,
                w.set(0, 0, 0),
                I = 0,
                b = X,
                V = Et
            }
            return
        }
        Se = Se || we,
        He = He || me,
        ut = ut || le,
        (we !== T || Se !== P) && (r.blendEquationSeparate(ze[we], ze[Se]),
        T = we,
        P = Se),
        (me !== S || le !== E || He !== R || ut !== O) && (r.blendFuncSeparate(at[me], at[le], at[He], at[ut]),
        S = me,
        E = le,
        R = He,
        O = ut),
        (Ut.equals(w) === !1 || Rn !== I) && (r.blendColor(Ut.r, Ut.g, Ut.b, Rn),
        w.copy(Ut),
        I = Rn),
        b = X,
        V = !1
    }
    function It(X, we) {
        X.side === mr ? We(r.CULL_FACE) : Ze(r.CULL_FACE);
        let me = X.side === fi;
        we && (me = !me),
        tt(me),
        X.blending === qa && X.transparent === !1 ? qe(Si) : qe(X.blending, X.blendEquation, X.blendSrc, X.blendDst, X.blendEquationAlpha, X.blendSrcAlpha, X.blendDstAlpha, X.blendColor, X.blendAlpha, X.premultipliedAlpha),
        c.setFunc(X.depthFunc),
        c.setTest(X.depthTest),
        c.setMask(X.depthWrite),
        a.setMask(X.colorWrite);
        const le = X.stencilWrite;
        h.setTest(le),
        le && (h.setMask(X.stencilWriteMask),
        h.setFunc(X.stencilFunc, X.stencilRef, X.stencilFuncMask),
        h.setOp(X.stencilFail, X.stencilZFail, X.stencilZPass)),
        on(X.polygonOffset, X.polygonOffsetFactor, X.polygonOffsetUnits),
        X.alphaToCoverage === !0 ? Ze(r.SAMPLE_ALPHA_TO_COVERAGE) : We(r.SAMPLE_ALPHA_TO_COVERAGE)
    }
    function tt(X) {
        z !== X && (X ? r.frontFace(r.CW) : r.frontFace(r.CCW),
        z = X)
    }
    function Ye(X) {
        X !== QI ? (Ze(r.CULL_FACE),
        X !== q && (X === g0 ? r.cullFace(r.BACK) : X === eL ? r.cullFace(r.FRONT) : r.cullFace(r.FRONT_AND_BACK))) : We(r.CULL_FACE),
        q = X
    }
    function dt(X) {
        X !== F && (de && r.lineWidth(X),
        F = X)
    }
    function on(X, we, me) {
        X ? (Ze(r.POLYGON_OFFSET_FILL),
        (j !== we || K !== me) && (r.polygonOffset(we, me),
        j = we,
        K = me)) : We(r.POLYGON_OFFSET_FILL)
    }
    function Lt(X) {
        X ? Ze(r.SCISSOR_TEST) : We(r.SCISSOR_TEST)
    }
    function B(X) {
        X === void 0 && (X = r.TEXTURE0 + J - 1),
        ge !== X && (r.activeTexture(X),
        ge = X)
    }
    function L(X, we, me) {
        me === void 0 && (ge === null ? me = r.TEXTURE0 + J - 1 : me = ge);
        let le = Ee[me];
        le === void 0 && (le = {
            type: void 0,
            texture: void 0
        },
        Ee[me] = le),
        (le.type !== X || le.texture !== we) && (ge !== me && (r.activeTexture(me),
        ge = me),
        r.bindTexture(X, we || et[X]),
        le.type = X,
        le.texture = we)
    }
    function ee() {
        const X = Ee[ge];
        X !== void 0 && X.type !== void 0 && (r.bindTexture(X.type, null),
        X.type = void 0,
        X.texture = void 0)
    }
    function Te() {
        try {
            r.compressedTexImage2D.apply(r, arguments)
        } catch (X) {
            console.error("THREE.WebGLState:", X)
        }
    }
    function pe() {
        try {
            r.compressedTexImage3D.apply(r, arguments)
        } catch (X) {
            console.error("THREE.WebGLState:", X)
        }
    }
    function be() {
        try {
            r.texSubImage2D.apply(r, arguments)
        } catch (X) {
            console.error("THREE.WebGLState:", X)
        }
    }
    function Ne() {
        try {
            r.texSubImage3D.apply(r, arguments)
        } catch (X) {
            console.error("THREE.WebGLState:", X)
        }
    }
    function Me() {
        try {
            r.compressedTexSubImage2D.apply(r, arguments)
        } catch (X) {
            console.error("THREE.WebGLState:", X)
        }
    }
    function Ae() {
        try {
            r.compressedTexSubImage3D.apply(r, arguments)
        } catch (X) {
            console.error("THREE.WebGLState:", X)
        }
    }
    function G() {
        try {
            r.texStorage2D.apply(r, arguments)
        } catch (X) {
            console.error("THREE.WebGLState:", X)
        }
    }
    function _e() {
        try {
            r.texStorage3D.apply(r, arguments)
        } catch (X) {
            console.error("THREE.WebGLState:", X)
        }
    }
    function fe() {
        try {
            r.texImage2D.apply(r, arguments)
        } catch (X) {
            console.error("THREE.WebGLState:", X)
        }
    }
    function je() {
        try {
            r.texImage3D.apply(r, arguments)
        } catch (X) {
            console.error("THREE.WebGLState:", X)
        }
    }
    function Fe(X) {
        xe.equals(X) === !1 && (r.scissor(X.x, X.y, X.z, X.w),
        xe.copy(X))
    }
    function Ge(X) {
        Be.equals(X) === !1 && (r.viewport(X.x, X.y, X.z, X.w),
        Be.copy(X))
    }
    function Oe(X, we) {
        let me = l.get(we);
        me === void 0 && (me = new WeakMap,
        l.set(we, me));
        let le = me.get(X);
        le === void 0 && (le = r.getUniformBlockIndex(we, X.name),
        me.set(X, le))
    }
    function Le(X, we) {
        const le = l.get(we).get(X);
        d.get(we) !== le && (r.uniformBlockBinding(we, le, X.__bindingPointIndex),
        d.set(we, le))
    }
    function rt() {
        r.disable(r.BLEND),
        r.disable(r.CULL_FACE),
        r.disable(r.DEPTH_TEST),
        r.disable(r.POLYGON_OFFSET_FILL),
        r.disable(r.SCISSOR_TEST),
        r.disable(r.STENCIL_TEST),
        r.disable(r.SAMPLE_ALPHA_TO_COVERAGE),
        r.blendEquation(r.FUNC_ADD),
        r.blendFunc(r.ONE, r.ZERO),
        r.blendFuncSeparate(r.ONE, r.ZERO, r.ONE, r.ZERO),
        r.blendColor(0, 0, 0, 0),
        r.colorMask(!0, !0, !0, !0),
        r.clearColor(0, 0, 0, 0),
        r.depthMask(!0),
        r.depthFunc(r.LESS),
        r.clearDepth(1),
        r.stencilMask(4294967295),
        r.stencilFunc(r.ALWAYS, 0, 4294967295),
        r.stencilOp(r.KEEP, r.KEEP, r.KEEP),
        r.clearStencil(0),
        r.cullFace(r.BACK),
        r.frontFace(r.CCW),
        r.polygonOffset(0, 0),
        r.activeTexture(r.TEXTURE0),
        r.bindFramebuffer(r.FRAMEBUFFER, null),
        n === !0 && (r.bindFramebuffer(r.DRAW_FRAMEBUFFER, null),
        r.bindFramebuffer(r.READ_FRAMEBUFFER, null)),
        r.useProgram(null),
        r.lineWidth(1),
        r.scissor(0, 0, r.canvas.width, r.canvas.height),
        r.viewport(0, 0, r.canvas.width, r.canvas.height),
        f = {},
        ge = null,
        Ee = {},
        p = {},
        g = new WeakMap,
        y = [],
        v = null,
        _ = !1,
        b = null,
        T = null,
        S = null,
        E = null,
        P = null,
        R = null,
        O = null,
        w = new Ke(0,0,0),
        I = 0,
        V = !1,
        z = null,
        q = null,
        F = null,
        j = null,
        K = null,
        xe.set(0, 0, r.canvas.width, r.canvas.height),
        Be.set(0, 0, r.canvas.width, r.canvas.height),
        a.reset(),
        c.reset(),
        h.reset()
    }
    return {
        buffers: {
            color: a,
            depth: c,
            stencil: h
        },
        enable: Ze,
        disable: We,
        bindFramebuffer: Je,
        drawBuffers: Q,
        useProgram: hn,
        setBlending: qe,
        setMaterial: It,
        setFlipSided: tt,
        setCullFace: Ye,
        setLineWidth: dt,
        setPolygonOffset: on,
        setScissorTest: Lt,
        activeTexture: B,
        bindTexture: L,
        unbindTexture: ee,
        compressedTexImage2D: Te,
        compressedTexImage3D: pe,
        texImage2D: fe,
        texImage3D: je,
        updateUBOMapping: Oe,
        uniformBlockBinding: Le,
        texStorage2D: G,
        texStorage3D: _e,
        texSubImage2D: be,
        texSubImage3D: Ne,
        compressedTexSubImage2D: Me,
        compressedTexSubImage3D: Ae,
        scissor: Fe,
        viewport: Ge,
        reset: rt
    }
}
function c3(r, e, t, n, i, s, o) {
    const a = i.isWebGL2
      , c = i.maxTextures
      , h = i.maxCubemapSize
      , d = i.maxTextureSize
      , l = i.maxSamples
      , f = e.has("WEBGL_multisampled_render_to_texture") ? e.get("WEBGL_multisampled_render_to_texture") : null
      , p = typeof navigator > "u" ? !1 : /OculusBrowser/g.test(navigator.userAgent)
      , g = new WeakMap;
    let y;
    const v = new WeakMap;
    let _ = !1;
    try {
        _ = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1,1).getContext("2d") !== null
    } catch {}
    function b(B, L) {
        return _ ? new OffscreenCanvas(B,L) : Uc("canvas")
    }
    function T(B, L, ee, Te) {
        let pe = 1;
        if ((B.width > Te || B.height > Te) && (pe = Te / Math.max(B.width, B.height)),
        pe < 1 || L === !0)
            if (typeof HTMLImageElement < "u" && B instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && B instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && B instanceof ImageBitmap) {
                const be = L ? Zh : Math.floor
                  , Ne = be(pe * B.width)
                  , Me = be(pe * B.height);
                y === void 0 && (y = b(Ne, Me));
                const Ae = ee ? b(Ne, Me) : y;
                return Ae.width = Ne,
                Ae.height = Me,
                Ae.getContext("2d").drawImage(B, 0, 0, Ne, Me),
                console.warn("THREE.WebGLRenderer: Texture has been resized from (" + B.width + "x" + B.height + ") to (" + Ne + "x" + Me + ")."),
                Ae
            } else
                return "data"in B && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + B.width + "x" + B.height + ")."),
                B;
        return B
    }
    function S(B) {
        return Vm(B.width) && Vm(B.height)
    }
    function E(B) {
        return a ? !1 : B.wrapS !== hi || B.wrapT !== hi || B.minFilter !== Jt && B.minFilter !== Ot
    }
    function P(B, L) {
        return B.generateMipmaps && L && B.minFilter !== Jt && B.minFilter !== Ot
    }
    function R(B) {
        r.generateMipmap(B)
    }
    function O(B, L, ee, Te, pe=!1) {
        if (a === !1)
            return L;
        if (B !== null) {
            if (r[B] !== void 0)
                return r[B];
            console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + B + "'")
        }
        let be = L;
        if (L === r.RED && (ee === r.FLOAT && (be = r.R32F),
        ee === r.HALF_FLOAT && (be = r.R16F),
        ee === r.UNSIGNED_BYTE && (be = r.R8)),
        L === r.RED_INTEGER && (ee === r.UNSIGNED_BYTE && (be = r.R8UI),
        ee === r.UNSIGNED_SHORT && (be = r.R16UI),
        ee === r.UNSIGNED_INT && (be = r.R32UI),
        ee === r.BYTE && (be = r.R8I),
        ee === r.SHORT && (be = r.R16I),
        ee === r.INT && (be = r.R32I)),
        L === r.RG && (ee === r.FLOAT && (be = r.RG32F),
        ee === r.HALF_FLOAT && (be = r.RG16F),
        ee === r.UNSIGNED_BYTE && (be = r.RG8)),
        L === r.RGBA) {
            const Ne = pe ? qh : Rt.getTransfer(Te);
            ee === r.FLOAT && (be = r.RGBA32F),
            ee === r.HALF_FLOAT && (be = r.RGBA16F),
            ee === r.UNSIGNED_BYTE && (be = Ne === Zt ? r.SRGB8_ALPHA8 : r.RGBA8),
            ee === r.UNSIGNED_SHORT_4_4_4_4 && (be = r.RGBA4),
            ee === r.UNSIGNED_SHORT_5_5_5_1 && (be = r.RGB5_A1)
        }
        return (be === r.R16F || be === r.R32F || be === r.RG16F || be === r.RG32F || be === r.RGBA16F || be === r.RGBA32F) && e.get("EXT_color_buffer_float"),
        be
    }
    function w(B, L, ee) {
        return P(B, ee) === !0 || B.isFramebufferTexture && B.minFilter !== Jt && B.minFilter !== Ot ? Math.log2(Math.max(L.width, L.height)) + 1 : B.mipmaps !== void 0 && B.mipmaps.length > 0 ? B.mipmaps.length : B.isCompressedTexture && Array.isArray(B.image) ? L.mipmaps.length : 1
    }
    function I(B) {
        return B === Jt || B === Bm || B === Lh ? r.NEAREST : r.LINEAR
    }
    function V(B) {
        const L = B.target;
        L.removeEventListener("dispose", V),
        q(L),
        L.isVideoTexture && g.delete(L)
    }
    function z(B) {
        const L = B.target;
        L.removeEventListener("dispose", z),
        j(L)
    }
    function q(B) {
        const L = n.get(B);
        if (L.__webglInit === void 0)
            return;
        const ee = B.source
          , Te = v.get(ee);
        if (Te) {
            const pe = Te[L.__cacheKey];
            pe.usedTimes--,
            pe.usedTimes === 0 && F(B),
            Object.keys(Te).length === 0 && v.delete(ee)
        }
        n.remove(B)
    }
    function F(B) {
        const L = n.get(B);
        r.deleteTexture(L.__webglTexture);
        const ee = B.source
          , Te = v.get(ee);
        delete Te[L.__cacheKey],
        o.memory.textures--
    }
    function j(B) {
        const L = B.texture
          , ee = n.get(B)
          , Te = n.get(L);
        if (Te.__webglTexture !== void 0 && (r.deleteTexture(Te.__webglTexture),
        o.memory.textures--),
        B.depthTexture && B.depthTexture.dispose(),
        B.isWebGLCubeRenderTarget)
            for (let pe = 0; pe < 6; pe++) {
                if (Array.isArray(ee.__webglFramebuffer[pe]))
                    for (let be = 0; be < ee.__webglFramebuffer[pe].length; be++)
                        r.deleteFramebuffer(ee.__webglFramebuffer[pe][be]);
                else
                    r.deleteFramebuffer(ee.__webglFramebuffer[pe]);
                ee.__webglDepthbuffer && r.deleteRenderbuffer(ee.__webglDepthbuffer[pe])
            }
        else {
            if (Array.isArray(ee.__webglFramebuffer))
                for (let pe = 0; pe < ee.__webglFramebuffer.length; pe++)
                    r.deleteFramebuffer(ee.__webglFramebuffer[pe]);
            else
                r.deleteFramebuffer(ee.__webglFramebuffer);
            if (ee.__webglDepthbuffer && r.deleteRenderbuffer(ee.__webglDepthbuffer),
            ee.__webglMultisampledFramebuffer && r.deleteFramebuffer(ee.__webglMultisampledFramebuffer),
            ee.__webglColorRenderbuffer)
                for (let pe = 0; pe < ee.__webglColorRenderbuffer.length; pe++)
                    ee.__webglColorRenderbuffer[pe] && r.deleteRenderbuffer(ee.__webglColorRenderbuffer[pe]);
            ee.__webglDepthRenderbuffer && r.deleteRenderbuffer(ee.__webglDepthRenderbuffer)
        }
        if (B.isWebGLMultipleRenderTargets)
            for (let pe = 0, be = L.length; pe < be; pe++) {
                const Ne = n.get(L[pe]);
                Ne.__webglTexture && (r.deleteTexture(Ne.__webglTexture),
                o.memory.textures--),
                n.remove(L[pe])
            }
        n.remove(L),
        n.remove(B)
    }
    let K = 0;
    function J() {
        K = 0
    }
    function de() {
        const B = K;
        return B >= c && console.warn("THREE.WebGLTextures: Trying to use " + B + " texture units while this GPU supports only " + c),
        K += 1,
        B
    }
    function ae(B) {
        const L = [];
        return L.push(B.wrapS),
        L.push(B.wrapT),
        L.push(B.wrapR || 0),
        L.push(B.magFilter),
        L.push(B.minFilter),
        L.push(B.anisotropy),
        L.push(B.internalFormat),
        L.push(B.format),
        L.push(B.type),
        L.push(B.generateMipmaps),
        L.push(B.premultiplyAlpha),
        L.push(B.flipY),
        L.push(B.unpackAlignment),
        L.push(B.colorSpace),
        L.join()
    }
    function ue(B, L) {
        const ee = n.get(B);
        if (B.isVideoTexture && on(B),
        B.isRenderTargetTexture === !1 && B.version > 0 && ee.__version !== B.version) {
            const Te = B.image;
            if (Te === null)
                console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
            else if (Te.complete === !1)
                console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
            else {
                Ze(ee, B, L);
                return
            }
        }
        t.bindTexture(r.TEXTURE_2D, ee.__webglTexture, r.TEXTURE0 + L)
    }
    function ge(B, L) {
        const ee = n.get(B);
        if (B.version > 0 && ee.__version !== B.version) {
            Ze(ee, B, L);
            return
        }
        t.bindTexture(r.TEXTURE_2D_ARRAY, ee.__webglTexture, r.TEXTURE0 + L)
    }
    function Ee(B, L) {
        const ee = n.get(B);
        if (B.version > 0 && ee.__version !== B.version) {
            Ze(ee, B, L);
            return
        }
        t.bindTexture(r.TEXTURE_3D, ee.__webglTexture, r.TEXTURE0 + L)
    }
    function oe(B, L) {
        const ee = n.get(B);
        if (B.version > 0 && ee.__version !== B.version) {
            We(ee, B, L);
            return
        }
        t.bindTexture(r.TEXTURE_CUBE_MAP, ee.__webglTexture, r.TEXTURE0 + L)
    }
    const he = {
        [ii]: r.REPEAT,
        [hi]: r.CLAMP_TO_EDGE,
        [sl]: r.MIRRORED_REPEAT
    }
      , xe = {
        [Jt]: r.NEAREST,
        [Bm]: r.NEAREST_MIPMAP_NEAREST,
        [Lh]: r.NEAREST_MIPMAP_LINEAR,
        [Ot]: r.LINEAR,
        [gb]: r.LINEAR_MIPMAP_NEAREST,
        [Do]: r.LINEAR_MIPMAP_LINEAR
    }
      , Be = {
        [qL]: r.NEVER,
        [QL]: r.ALWAYS,
        [KL]: r.LESS,
        [Ab]: r.LEQUAL,
        [YL]: r.EQUAL,
        [JL]: r.GEQUAL,
        [$L]: r.GREATER,
        [ZL]: r.NOTEQUAL
    };
    function De(B, L, ee) {
        if (ee ? (r.texParameteri(B, r.TEXTURE_WRAP_S, he[L.wrapS]),
        r.texParameteri(B, r.TEXTURE_WRAP_T, he[L.wrapT]),
        (B === r.TEXTURE_3D || B === r.TEXTURE_2D_ARRAY) && r.texParameteri(B, r.TEXTURE_WRAP_R, he[L.wrapR]),
        r.texParameteri(B, r.TEXTURE_MAG_FILTER, xe[L.magFilter]),
        r.texParameteri(B, r.TEXTURE_MIN_FILTER, xe[L.minFilter])) : (r.texParameteri(B, r.TEXTURE_WRAP_S, r.CLAMP_TO_EDGE),
        r.texParameteri(B, r.TEXTURE_WRAP_T, r.CLAMP_TO_EDGE),
        (B === r.TEXTURE_3D || B === r.TEXTURE_2D_ARRAY) && r.texParameteri(B, r.TEXTURE_WRAP_R, r.CLAMP_TO_EDGE),
        (L.wrapS !== hi || L.wrapT !== hi) && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."),
        r.texParameteri(B, r.TEXTURE_MAG_FILTER, I(L.magFilter)),
        r.texParameteri(B, r.TEXTURE_MIN_FILTER, I(L.minFilter)),
        L.minFilter !== Jt && L.minFilter !== Ot && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")),
        L.compareFunction && (r.texParameteri(B, r.TEXTURE_COMPARE_MODE, r.COMPARE_REF_TO_TEXTURE),
        r.texParameteri(B, r.TEXTURE_COMPARE_FUNC, Be[L.compareFunction])),
        e.has("EXT_texture_filter_anisotropic") === !0) {
            const Te = e.get("EXT_texture_filter_anisotropic");
            if (L.magFilter === Jt || L.minFilter !== Lh && L.minFilter !== Do || L.type === wn && e.has("OES_texture_float_linear") === !1 || a === !1 && L.type === Ur && e.has("OES_texture_half_float_linear") === !1)
                return;
            (L.anisotropy > 1 || n.get(L).__currentAnisotropy) && (r.texParameterf(B, Te.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(L.anisotropy, i.getMaxAnisotropy())),
            n.get(L).__currentAnisotropy = L.anisotropy)
        }
    }
    function et(B, L) {
        let ee = !1;
        B.__webglInit === void 0 && (B.__webglInit = !0,
        L.addEventListener("dispose", V));
        const Te = L.source;
        let pe = v.get(Te);
        pe === void 0 && (pe = {},
        v.set(Te, pe));
        const be = ae(L);
        if (be !== B.__cacheKey) {
            pe[be] === void 0 && (pe[be] = {
                texture: r.createTexture(),
                usedTimes: 0
            },
            o.memory.textures++,
            ee = !0),
            pe[be].usedTimes++;
            const Ne = pe[B.__cacheKey];
            Ne !== void 0 && (pe[B.__cacheKey].usedTimes--,
            Ne.usedTimes === 0 && F(L)),
            B.__cacheKey = be,
            B.__webglTexture = pe[be].texture
        }
        return ee
    }
    function Ze(B, L, ee) {
        let Te = r.TEXTURE_2D;
        (L.isDataArrayTexture || L.isCompressedArrayTexture) && (Te = r.TEXTURE_2D_ARRAY),
        L.isData3DTexture && (Te = r.TEXTURE_3D);
        const pe = et(B, L)
          , be = L.source;
        t.bindTexture(Te, B.__webglTexture, r.TEXTURE0 + ee);
        const Ne = n.get(be);
        if (be.version !== Ne.__version || pe === !0) {
            t.activeTexture(r.TEXTURE0 + ee);
            const Me = Rt.getPrimaries(Rt.workingColorSpace)
              , Ae = L.colorSpace === Ni ? null : Rt.getPrimaries(L.colorSpace)
              , G = L.colorSpace === Ni || Me === Ae ? r.NONE : r.BROWSER_DEFAULT_WEBGL;
            r.pixelStorei(r.UNPACK_FLIP_Y_WEBGL, L.flipY),
            r.pixelStorei(r.UNPACK_PREMULTIPLY_ALPHA_WEBGL, L.premultiplyAlpha),
            r.pixelStorei(r.UNPACK_ALIGNMENT, L.unpackAlignment),
            r.pixelStorei(r.UNPACK_COLORSPACE_CONVERSION_WEBGL, G);
            const _e = E(L) && S(L.image) === !1;
            let fe = T(L.image, _e, !1, d);
            fe = Lt(L, fe);
            const je = S(fe) || a
              , Fe = s.convert(L.format, L.colorSpace);
            let Ge = s.convert(L.type)
              , Oe = O(L.internalFormat, Fe, Ge, L.colorSpace, L.isVideoTexture);
            De(Te, L, je);
            let Le;
            const rt = L.mipmaps
              , X = a && L.isVideoTexture !== !0 && Oe !== Mb
              , we = Ne.__version === void 0 || pe === !0
              , me = w(L, fe, je);
            if (L.isDepthTexture)
                Oe = r.DEPTH_COMPONENT,
                a ? L.type === wn ? Oe = r.DEPTH_COMPONENT32F : L.type === ns ? Oe = r.DEPTH_COMPONENT24 : L.type === Fs ? Oe = r.DEPTH24_STENCIL8 : Oe = r.DEPTH_COMPONENT16 : L.type === wn && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."),
                L.format === Ro && Oe === r.DEPTH_COMPONENT && L.type !== A_ && L.type !== ns && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."),
                L.type = ns,
                Ge = s.convert(L.type)),
                L.format === Oo && Oe === r.DEPTH_COMPONENT && (Oe = r.DEPTH_STENCIL,
                L.type !== Fs && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."),
                L.type = Fs,
                Ge = s.convert(L.type))),
                we && (X ? t.texStorage2D(r.TEXTURE_2D, 1, Oe, fe.width, fe.height) : t.texImage2D(r.TEXTURE_2D, 0, Oe, fe.width, fe.height, 0, Fe, Ge, null));
            else if (L.isDataTexture)
                if (rt.length > 0 && je) {
                    X && we && t.texStorage2D(r.TEXTURE_2D, me, Oe, rt[0].width, rt[0].height);
                    for (let le = 0, Se = rt.length; le < Se; le++)
                        Le = rt[le],
                        X ? t.texSubImage2D(r.TEXTURE_2D, le, 0, 0, Le.width, Le.height, Fe, Ge, Le.data) : t.texImage2D(r.TEXTURE_2D, le, Oe, Le.width, Le.height, 0, Fe, Ge, Le.data);
                    L.generateMipmaps = !1
                } else
                    X ? (we && t.texStorage2D(r.TEXTURE_2D, me, Oe, fe.width, fe.height),
                    t.texSubImage2D(r.TEXTURE_2D, 0, 0, 0, fe.width, fe.height, Fe, Ge, fe.data)) : t.texImage2D(r.TEXTURE_2D, 0, Oe, fe.width, fe.height, 0, Fe, Ge, fe.data);
            else if (L.isCompressedTexture)
                if (L.isCompressedArrayTexture) {
                    X && we && t.texStorage3D(r.TEXTURE_2D_ARRAY, me, Oe, rt[0].width, rt[0].height, fe.depth);
                    for (let le = 0, Se = rt.length; le < Se; le++)
                        Le = rt[le],
                        L.format !== Kn ? Fe !== null ? X ? t.compressedTexSubImage3D(r.TEXTURE_2D_ARRAY, le, 0, 0, 0, Le.width, Le.height, fe.depth, Fe, Le.data, 0, 0) : t.compressedTexImage3D(r.TEXTURE_2D_ARRAY, le, Oe, Le.width, Le.height, fe.depth, 0, Le.data, 0, 0) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : X ? t.texSubImage3D(r.TEXTURE_2D_ARRAY, le, 0, 0, 0, Le.width, Le.height, fe.depth, Fe, Ge, Le.data) : t.texImage3D(r.TEXTURE_2D_ARRAY, le, Oe, Le.width, Le.height, fe.depth, 0, Fe, Ge, Le.data)
                } else {
                    X && we && t.texStorage2D(r.TEXTURE_2D, me, Oe, rt[0].width, rt[0].height);
                    for (let le = 0, Se = rt.length; le < Se; le++)
                        Le = rt[le],
                        L.format !== Kn ? Fe !== null ? X ? t.compressedTexSubImage2D(r.TEXTURE_2D, le, 0, 0, Le.width, Le.height, Fe, Le.data) : t.compressedTexImage2D(r.TEXTURE_2D, le, Oe, Le.width, Le.height, 0, Le.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : X ? t.texSubImage2D(r.TEXTURE_2D, le, 0, 0, Le.width, Le.height, Fe, Ge, Le.data) : t.texImage2D(r.TEXTURE_2D, le, Oe, Le.width, Le.height, 0, Fe, Ge, Le.data)
                }
            else if (L.isDataArrayTexture)
                X ? (we && t.texStorage3D(r.TEXTURE_2D_ARRAY, me, Oe, fe.width, fe.height, fe.depth),
                t.texSubImage3D(r.TEXTURE_2D_ARRAY, 0, 0, 0, 0, fe.width, fe.height, fe.depth, Fe, Ge, fe.data)) : t.texImage3D(r.TEXTURE_2D_ARRAY, 0, Oe, fe.width, fe.height, fe.depth, 0, Fe, Ge, fe.data);
            else if (L.isData3DTexture)
                X ? (we && t.texStorage3D(r.TEXTURE_3D, me, Oe, fe.width, fe.height, fe.depth),
                t.texSubImage3D(r.TEXTURE_3D, 0, 0, 0, 0, fe.width, fe.height, fe.depth, Fe, Ge, fe.data)) : t.texImage3D(r.TEXTURE_3D, 0, Oe, fe.width, fe.height, fe.depth, 0, Fe, Ge, fe.data);
            else if (L.isFramebufferTexture) {
                if (we)
                    if (X)
                        t.texStorage2D(r.TEXTURE_2D, me, Oe, fe.width, fe.height);
                    else {
                        let le = fe.width
                          , Se = fe.height;
                        for (let He = 0; He < me; He++)
                            t.texImage2D(r.TEXTURE_2D, He, Oe, le, Se, 0, Fe, Ge, null),
                            le >>= 1,
                            Se >>= 1
                    }
            } else if (rt.length > 0 && je) {
                X && we && t.texStorage2D(r.TEXTURE_2D, me, Oe, rt[0].width, rt[0].height);
                for (let le = 0, Se = rt.length; le < Se; le++)
                    Le = rt[le],
                    X ? t.texSubImage2D(r.TEXTURE_2D, le, 0, 0, Fe, Ge, Le) : t.texImage2D(r.TEXTURE_2D, le, Oe, Fe, Ge, Le);
                L.generateMipmaps = !1
            } else
                X ? (we && t.texStorage2D(r.TEXTURE_2D, me, Oe, fe.width, fe.height),
                t.texSubImage2D(r.TEXTURE_2D, 0, 0, 0, Fe, Ge, fe)) : t.texImage2D(r.TEXTURE_2D, 0, Oe, Fe, Ge, fe);
            P(L, je) && R(Te),
            Ne.__version = be.version,
            L.onUpdate && L.onUpdate(L)
        }
        B.__version = L.version
    }
    function We(B, L, ee) {
        if (L.image.length !== 6)
            return;
        const Te = et(B, L)
          , pe = L.source;
        t.bindTexture(r.TEXTURE_CUBE_MAP, B.__webglTexture, r.TEXTURE0 + ee);
        const be = n.get(pe);
        if (pe.version !== be.__version || Te === !0) {
            t.activeTexture(r.TEXTURE0 + ee);
            const Ne = Rt.getPrimaries(Rt.workingColorSpace)
              , Me = L.colorSpace === Ni ? null : Rt.getPrimaries(L.colorSpace)
              , Ae = L.colorSpace === Ni || Ne === Me ? r.NONE : r.BROWSER_DEFAULT_WEBGL;
            r.pixelStorei(r.UNPACK_FLIP_Y_WEBGL, L.flipY),
            r.pixelStorei(r.UNPACK_PREMULTIPLY_ALPHA_WEBGL, L.premultiplyAlpha),
            r.pixelStorei(r.UNPACK_ALIGNMENT, L.unpackAlignment),
            r.pixelStorei(r.UNPACK_COLORSPACE_CONVERSION_WEBGL, Ae);
            const G = L.isCompressedTexture || L.image[0].isCompressedTexture
              , _e = L.image[0] && L.image[0].isDataTexture
              , fe = [];
            for (let le = 0; le < 6; le++)
                !G && !_e ? fe[le] = T(L.image[le], !1, !0, h) : fe[le] = _e ? L.image[le].image : L.image[le],
                fe[le] = Lt(L, fe[le]);
            const je = fe[0]
              , Fe = S(je) || a
              , Ge = s.convert(L.format, L.colorSpace)
              , Oe = s.convert(L.type)
              , Le = O(L.internalFormat, Ge, Oe, L.colorSpace)
              , rt = a && L.isVideoTexture !== !0
              , X = be.__version === void 0 || Te === !0;
            let we = w(L, je, Fe);
            De(r.TEXTURE_CUBE_MAP, L, Fe);
            let me;
            if (G) {
                rt && X && t.texStorage2D(r.TEXTURE_CUBE_MAP, we, Le, je.width, je.height);
                for (let le = 0; le < 6; le++) {
                    me = fe[le].mipmaps;
                    for (let Se = 0; Se < me.length; Se++) {
                        const He = me[Se];
                        L.format !== Kn ? Ge !== null ? rt ? t.compressedTexSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + le, Se, 0, 0, He.width, He.height, Ge, He.data) : t.compressedTexImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + le, Se, Le, He.width, He.height, 0, He.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : rt ? t.texSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + le, Se, 0, 0, He.width, He.height, Ge, Oe, He.data) : t.texImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + le, Se, Le, He.width, He.height, 0, Ge, Oe, He.data)
                    }
                }
            } else {
                me = L.mipmaps,
                rt && X && (me.length > 0 && we++,
                t.texStorage2D(r.TEXTURE_CUBE_MAP, we, Le, fe[0].width, fe[0].height));
                for (let le = 0; le < 6; le++)
                    if (_e) {
                        rt ? t.texSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + le, 0, 0, 0, fe[le].width, fe[le].height, Ge, Oe, fe[le].data) : t.texImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + le, 0, Le, fe[le].width, fe[le].height, 0, Ge, Oe, fe[le].data);
                        for (let Se = 0; Se < me.length; Se++) {
                            const ut = me[Se].image[le].image;
                            rt ? t.texSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + le, Se + 1, 0, 0, ut.width, ut.height, Ge, Oe, ut.data) : t.texImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + le, Se + 1, Le, ut.width, ut.height, 0, Ge, Oe, ut.data)
                        }
                    } else {
                        rt ? t.texSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + le, 0, 0, 0, Ge, Oe, fe[le]) : t.texImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + le, 0, Le, Ge, Oe, fe[le]);
                        for (let Se = 0; Se < me.length; Se++) {
                            const He = me[Se];
                            rt ? t.texSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + le, Se + 1, 0, 0, Ge, Oe, He.image[le]) : t.texImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + le, Se + 1, Le, Ge, Oe, He.image[le])
                        }
                    }
            }
            P(L, Fe) && R(r.TEXTURE_CUBE_MAP),
            be.__version = pe.version,
            L.onUpdate && L.onUpdate(L)
        }
        B.__version = L.version
    }
    function Je(B, L, ee, Te, pe, be) {
        const Ne = s.convert(ee.format, ee.colorSpace)
          , Me = s.convert(ee.type)
          , Ae = O(ee.internalFormat, Ne, Me, ee.colorSpace);
        if (!n.get(L).__hasExternalTextures) {
            const _e = Math.max(1, L.width >> be)
              , fe = Math.max(1, L.height >> be);
            pe === r.TEXTURE_3D || pe === r.TEXTURE_2D_ARRAY ? t.texImage3D(pe, be, Ae, _e, fe, L.depth, 0, Ne, Me, null) : t.texImage2D(pe, be, Ae, _e, fe, 0, Ne, Me, null)
        }
        t.bindFramebuffer(r.FRAMEBUFFER, B),
        dt(L) ? f.framebufferTexture2DMultisampleEXT(r.FRAMEBUFFER, Te, pe, n.get(ee).__webglTexture, 0, Ye(L)) : (pe === r.TEXTURE_2D || pe >= r.TEXTURE_CUBE_MAP_POSITIVE_X && pe <= r.TEXTURE_CUBE_MAP_NEGATIVE_Z) && r.framebufferTexture2D(r.FRAMEBUFFER, Te, pe, n.get(ee).__webglTexture, be),
        t.bindFramebuffer(r.FRAMEBUFFER, null)
    }
    function Q(B, L, ee) {
        if (r.bindRenderbuffer(r.RENDERBUFFER, B),
        L.depthBuffer && !L.stencilBuffer) {
            let Te = a === !0 ? r.DEPTH_COMPONENT24 : r.DEPTH_COMPONENT16;
            if (ee || dt(L)) {
                const pe = L.depthTexture;
                pe && pe.isDepthTexture && (pe.type === wn ? Te = r.DEPTH_COMPONENT32F : pe.type === ns && (Te = r.DEPTH_COMPONENT24));
                const be = Ye(L);
                dt(L) ? f.renderbufferStorageMultisampleEXT(r.RENDERBUFFER, be, Te, L.width, L.height) : r.renderbufferStorageMultisample(r.RENDERBUFFER, be, Te, L.width, L.height)
            } else
                r.renderbufferStorage(r.RENDERBUFFER, Te, L.width, L.height);
            r.framebufferRenderbuffer(r.FRAMEBUFFER, r.DEPTH_ATTACHMENT, r.RENDERBUFFER, B)
        } else if (L.depthBuffer && L.stencilBuffer) {
            const Te = Ye(L);
            ee && dt(L) === !1 ? r.renderbufferStorageMultisample(r.RENDERBUFFER, Te, r.DEPTH24_STENCIL8, L.width, L.height) : dt(L) ? f.renderbufferStorageMultisampleEXT(r.RENDERBUFFER, Te, r.DEPTH24_STENCIL8, L.width, L.height) : r.renderbufferStorage(r.RENDERBUFFER, r.DEPTH_STENCIL, L.width, L.height),
            r.framebufferRenderbuffer(r.FRAMEBUFFER, r.DEPTH_STENCIL_ATTACHMENT, r.RENDERBUFFER, B)
        } else {
            const Te = L.isWebGLMultipleRenderTargets === !0 ? L.texture : [L.texture];
            for (let pe = 0; pe < Te.length; pe++) {
                const be = Te[pe]
                  , Ne = s.convert(be.format, be.colorSpace)
                  , Me = s.convert(be.type)
                  , Ae = O(be.internalFormat, Ne, Me, be.colorSpace)
                  , G = Ye(L);
                ee && dt(L) === !1 ? r.renderbufferStorageMultisample(r.RENDERBUFFER, G, Ae, L.width, L.height) : dt(L) ? f.renderbufferStorageMultisampleEXT(r.RENDERBUFFER, G, Ae, L.width, L.height) : r.renderbufferStorage(r.RENDERBUFFER, Ae, L.width, L.height)
            }
        }
        r.bindRenderbuffer(r.RENDERBUFFER, null)
    }
    function hn(B, L) {
        if (L && L.isWebGLCubeRenderTarget)
            throw new Error("Depth Texture with cube render targets is not supported");
        if (t.bindFramebuffer(r.FRAMEBUFFER, B),
        !(L.depthTexture && L.depthTexture.isDepthTexture))
            throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
        (!n.get(L.depthTexture).__webglTexture || L.depthTexture.image.width !== L.width || L.depthTexture.image.height !== L.height) && (L.depthTexture.image.width = L.width,
        L.depthTexture.image.height = L.height,
        L.depthTexture.needsUpdate = !0),
        ue(L.depthTexture, 0);
        const Te = n.get(L.depthTexture).__webglTexture
          , pe = Ye(L);
        if (L.depthTexture.format === Ro)
            dt(L) ? f.framebufferTexture2DMultisampleEXT(r.FRAMEBUFFER, r.DEPTH_ATTACHMENT, r.TEXTURE_2D, Te, 0, pe) : r.framebufferTexture2D(r.FRAMEBUFFER, r.DEPTH_ATTACHMENT, r.TEXTURE_2D, Te, 0);
        else if (L.depthTexture.format === Oo)
            dt(L) ? f.framebufferTexture2DMultisampleEXT(r.FRAMEBUFFER, r.DEPTH_STENCIL_ATTACHMENT, r.TEXTURE_2D, Te, 0, pe) : r.framebufferTexture2D(r.FRAMEBUFFER, r.DEPTH_STENCIL_ATTACHMENT, r.TEXTURE_2D, Te, 0);
        else
            throw new Error("Unknown depthTexture format")
    }
    function ze(B) {
        const L = n.get(B)
          , ee = B.isWebGLCubeRenderTarget === !0;
        if (B.depthTexture && !L.__autoAllocateDepthBuffer) {
            if (ee)
                throw new Error("target.depthTexture not supported in Cube render targets");
            hn(L.__webglFramebuffer, B)
        } else if (ee) {
            L.__webglDepthbuffer = [];
            for (let Te = 0; Te < 6; Te++)
                t.bindFramebuffer(r.FRAMEBUFFER, L.__webglFramebuffer[Te]),
                L.__webglDepthbuffer[Te] = r.createRenderbuffer(),
                Q(L.__webglDepthbuffer[Te], B, !1)
        } else
            t.bindFramebuffer(r.FRAMEBUFFER, L.__webglFramebuffer),
            L.__webglDepthbuffer = r.createRenderbuffer(),
            Q(L.__webglDepthbuffer, B, !1);
        t.bindFramebuffer(r.FRAMEBUFFER, null)
    }
    function at(B, L, ee) {
        const Te = n.get(B);
        L !== void 0 && Je(Te.__webglFramebuffer, B, B.texture, r.COLOR_ATTACHMENT0, r.TEXTURE_2D, 0),
        ee !== void 0 && ze(B)
    }
    function qe(B) {
        const L = B.texture
          , ee = n.get(B)
          , Te = n.get(L);
        B.addEventListener("dispose", z),
        B.isWebGLMultipleRenderTargets !== !0 && (Te.__webglTexture === void 0 && (Te.__webglTexture = r.createTexture()),
        Te.__version = L.version,
        o.memory.textures++);
        const pe = B.isWebGLCubeRenderTarget === !0
          , be = B.isWebGLMultipleRenderTargets === !0
          , Ne = S(B) || a;
        if (pe) {
            ee.__webglFramebuffer = [];
            for (let Me = 0; Me < 6; Me++)
                if (a && L.mipmaps && L.mipmaps.length > 0) {
                    ee.__webglFramebuffer[Me] = [];
                    for (let Ae = 0; Ae < L.mipmaps.length; Ae++)
                        ee.__webglFramebuffer[Me][Ae] = r.createFramebuffer()
                } else
                    ee.__webglFramebuffer[Me] = r.createFramebuffer()
        } else {
            if (a && L.mipmaps && L.mipmaps.length > 0) {
                ee.__webglFramebuffer = [];
                for (let Me = 0; Me < L.mipmaps.length; Me++)
                    ee.__webglFramebuffer[Me] = r.createFramebuffer()
            } else
                ee.__webglFramebuffer = r.createFramebuffer();
            if (be)
                if (i.drawBuffers) {
                    const Me = B.texture;
                    for (let Ae = 0, G = Me.length; Ae < G; Ae++) {
                        const _e = n.get(Me[Ae]);
                        _e.__webglTexture === void 0 && (_e.__webglTexture = r.createTexture(),
                        o.memory.textures++)
                    }
                } else
                    console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");
            if (a && B.samples > 0 && dt(B) === !1) {
                const Me = be ? L : [L];
                ee.__webglMultisampledFramebuffer = r.createFramebuffer(),
                ee.__webglColorRenderbuffer = [],
                t.bindFramebuffer(r.FRAMEBUFFER, ee.__webglMultisampledFramebuffer);
                for (let Ae = 0; Ae < Me.length; Ae++) {
                    const G = Me[Ae];
                    ee.__webglColorRenderbuffer[Ae] = r.createRenderbuffer(),
                    r.bindRenderbuffer(r.RENDERBUFFER, ee.__webglColorRenderbuffer[Ae]);
                    const _e = s.convert(G.format, G.colorSpace)
                      , fe = s.convert(G.type)
                      , je = O(G.internalFormat, _e, fe, G.colorSpace, B.isXRRenderTarget === !0)
                      , Fe = Ye(B);
                    r.renderbufferStorageMultisample(r.RENDERBUFFER, Fe, je, B.width, B.height),
                    r.framebufferRenderbuffer(r.FRAMEBUFFER, r.COLOR_ATTACHMENT0 + Ae, r.RENDERBUFFER, ee.__webglColorRenderbuffer[Ae])
                }
                r.bindRenderbuffer(r.RENDERBUFFER, null),
                B.depthBuffer && (ee.__webglDepthRenderbuffer = r.createRenderbuffer(),
                Q(ee.__webglDepthRenderbuffer, B, !0)),
                t.bindFramebuffer(r.FRAMEBUFFER, null)
            }
        }
        if (pe) {
            t.bindTexture(r.TEXTURE_CUBE_MAP, Te.__webglTexture),
            De(r.TEXTURE_CUBE_MAP, L, Ne);
            for (let Me = 0; Me < 6; Me++)
                if (a && L.mipmaps && L.mipmaps.length > 0)
                    for (let Ae = 0; Ae < L.mipmaps.length; Ae++)
                        Je(ee.__webglFramebuffer[Me][Ae], B, L, r.COLOR_ATTACHMENT0, r.TEXTURE_CUBE_MAP_POSITIVE_X + Me, Ae);
                else
                    Je(ee.__webglFramebuffer[Me], B, L, r.COLOR_ATTACHMENT0, r.TEXTURE_CUBE_MAP_POSITIVE_X + Me, 0);
            P(L, Ne) && R(r.TEXTURE_CUBE_MAP),
            t.unbindTexture()
        } else if (be) {
            const Me = B.texture;
            for (let Ae = 0, G = Me.length; Ae < G; Ae++) {
                const _e = Me[Ae]
                  , fe = n.get(_e);
                t.bindTexture(r.TEXTURE_2D, fe.__webglTexture),
                De(r.TEXTURE_2D, _e, Ne),
                Je(ee.__webglFramebuffer, B, _e, r.COLOR_ATTACHMENT0 + Ae, r.TEXTURE_2D, 0),
                P(_e, Ne) && R(r.TEXTURE_2D)
            }
            t.unbindTexture()
        } else {
            let Me = r.TEXTURE_2D;
            if ((B.isWebGL3DRenderTarget || B.isWebGLArrayRenderTarget) && (a ? Me = B.isWebGL3DRenderTarget ? r.TEXTURE_3D : r.TEXTURE_2D_ARRAY : console.error("THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.")),
            t.bindTexture(Me, Te.__webglTexture),
            De(Me, L, Ne),
            a && L.mipmaps && L.mipmaps.length > 0)
                for (let Ae = 0; Ae < L.mipmaps.length; Ae++)
                    Je(ee.__webglFramebuffer[Ae], B, L, r.COLOR_ATTACHMENT0, Me, Ae);
            else
                Je(ee.__webglFramebuffer, B, L, r.COLOR_ATTACHMENT0, Me, 0);
            P(L, Ne) && R(Me),
            t.unbindTexture()
        }
        B.depthBuffer && ze(B)
    }
    function It(B) {
        const L = S(B) || a
          , ee = B.isWebGLMultipleRenderTargets === !0 ? B.texture : [B.texture];
        for (let Te = 0, pe = ee.length; Te < pe; Te++) {
            const be = ee[Te];
            if (P(be, L)) {
                const Ne = B.isWebGLCubeRenderTarget ? r.TEXTURE_CUBE_MAP : r.TEXTURE_2D
                  , Me = n.get(be).__webglTexture;
                t.bindTexture(Ne, Me),
                R(Ne),
                t.unbindTexture()
            }
        }
    }
    function tt(B) {
        if (a && B.samples > 0 && dt(B) === !1) {
            const L = B.isWebGLMultipleRenderTargets ? B.texture : [B.texture]
              , ee = B.width
              , Te = B.height;
            let pe = r.COLOR_BUFFER_BIT;
            const be = []
              , Ne = B.stencilBuffer ? r.DEPTH_STENCIL_ATTACHMENT : r.DEPTH_ATTACHMENT
              , Me = n.get(B)
              , Ae = B.isWebGLMultipleRenderTargets === !0;
            if (Ae)
                for (let G = 0; G < L.length; G++)
                    t.bindFramebuffer(r.FRAMEBUFFER, Me.__webglMultisampledFramebuffer),
                    r.framebufferRenderbuffer(r.FRAMEBUFFER, r.COLOR_ATTACHMENT0 + G, r.RENDERBUFFER, null),
                    t.bindFramebuffer(r.FRAMEBUFFER, Me.__webglFramebuffer),
                    r.framebufferTexture2D(r.DRAW_FRAMEBUFFER, r.COLOR_ATTACHMENT0 + G, r.TEXTURE_2D, null, 0);
            t.bindFramebuffer(r.READ_FRAMEBUFFER, Me.__webglMultisampledFramebuffer),
            t.bindFramebuffer(r.DRAW_FRAMEBUFFER, Me.__webglFramebuffer);
            for (let G = 0; G < L.length; G++) {
                be.push(r.COLOR_ATTACHMENT0 + G),
                B.depthBuffer && be.push(Ne);
                const _e = Me.__ignoreDepthValues !== void 0 ? Me.__ignoreDepthValues : !1;
                if (_e === !1 && (B.depthBuffer && (pe |= r.DEPTH_BUFFER_BIT),
                B.stencilBuffer && (pe |= r.STENCIL_BUFFER_BIT)),
                Ae && r.framebufferRenderbuffer(r.READ_FRAMEBUFFER, r.COLOR_ATTACHMENT0, r.RENDERBUFFER, Me.__webglColorRenderbuffer[G]),
                _e === !0 && (r.invalidateFramebuffer(r.READ_FRAMEBUFFER, [Ne]),
                r.invalidateFramebuffer(r.DRAW_FRAMEBUFFER, [Ne])),
                Ae) {
                    const fe = n.get(L[G]).__webglTexture;
                    r.framebufferTexture2D(r.DRAW_FRAMEBUFFER, r.COLOR_ATTACHMENT0, r.TEXTURE_2D, fe, 0)
                }
                r.blitFramebuffer(0, 0, ee, Te, 0, 0, ee, Te, pe, r.NEAREST),
                p && r.invalidateFramebuffer(r.READ_FRAMEBUFFER, be)
            }
            if (t.bindFramebuffer(r.READ_FRAMEBUFFER, null),
            t.bindFramebuffer(r.DRAW_FRAMEBUFFER, null),
            Ae)
                for (let G = 0; G < L.length; G++) {
                    t.bindFramebuffer(r.FRAMEBUFFER, Me.__webglMultisampledFramebuffer),
                    r.framebufferRenderbuffer(r.FRAMEBUFFER, r.COLOR_ATTACHMENT0 + G, r.RENDERBUFFER, Me.__webglColorRenderbuffer[G]);
                    const _e = n.get(L[G]).__webglTexture;
                    t.bindFramebuffer(r.FRAMEBUFFER, Me.__webglFramebuffer),
                    r.framebufferTexture2D(r.DRAW_FRAMEBUFFER, r.COLOR_ATTACHMENT0 + G, r.TEXTURE_2D, _e, 0)
                }
            t.bindFramebuffer(r.DRAW_FRAMEBUFFER, Me.__webglMultisampledFramebuffer)
        }
    }
    function Ye(B) {
        return Math.min(l, B.samples)
    }
    function dt(B) {
        const L = n.get(B);
        return a && B.samples > 0 && e.has("WEBGL_multisampled_render_to_texture") === !0 && L.__useRenderToTexture !== !1
    }
    function on(B) {
        const L = o.render.frame;
        g.get(B) !== L && (g.set(B, L),
        B.update())
    }
    function Lt(B, L) {
        const ee = B.colorSpace
          , Te = B.format
          , pe = B.type;
        return B.isCompressedTexture === !0 || B.isVideoTexture === !0 || B.format === Hm || ee !== gn && ee !== Ni && (Rt.getTransfer(ee) === Zt ? a === !1 ? e.has("EXT_sRGB") === !0 && Te === Kn ? (B.format = Hm,
        B.minFilter = Ot,
        B.generateMipmaps = !1) : L = Rb.sRGBToLinear(L) : (Te !== Kn || pe !== Vn) && console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture color space:", ee)),
        L
    }
    this.allocateTextureUnit = de,
    this.resetTextureUnits = J,
    this.setTexture2D = ue,
    this.setTexture2DArray = ge,
    this.setTexture3D = Ee,
    this.setTextureCube = oe,
    this.rebindTextures = at,
    this.setupRenderTarget = qe,
    this.updateRenderTargetMipmap = It,
    this.updateMultisampleRenderTarget = tt,
    this.setupDepthRenderbuffer = ze,
    this.setupFrameBufferTexture = Je,
    this.useMultisampledRTT = dt
}
function u3(r, e, t) {
    const n = t.isWebGL2;
    function i(s, o=Ni) {
        let a;
        const c = Rt.getTransfer(o);
        if (s === Vn)
            return r.UNSIGNED_BYTE;
        if (s === yb)
            return r.UNSIGNED_SHORT_4_4_4_4;
        if (s === xb)
            return r.UNSIGNED_SHORT_5_5_5_1;
        if (s === DL)
            return r.BYTE;
        if (s === OL)
            return r.SHORT;
        if (s === A_)
            return r.UNSIGNED_SHORT;
        if (s === vb)
            return r.INT;
        if (s === ns)
            return r.UNSIGNED_INT;
        if (s === wn)
            return r.FLOAT;
        if (s === Ur)
            return n ? r.HALF_FLOAT : (a = e.get("OES_texture_half_float"),
            a !== null ? a.HALF_FLOAT_OES : null);
        if (s === UL)
            return r.ALPHA;
        if (s === Kn)
            return r.RGBA;
        if (s === NL)
            return r.LUMINANCE;
        if (s === FL)
            return r.LUMINANCE_ALPHA;
        if (s === Ro)
            return r.DEPTH_COMPONENT;
        if (s === Oo)
            return r.DEPTH_STENCIL;
        if (s === Hm)
            return a = e.get("EXT_sRGB"),
            a !== null ? a.SRGB_ALPHA_EXT : null;
        if (s === BL)
            return r.RED;
        if (s === Tb)
            return r.RED_INTEGER;
        if (s === kL)
            return r.RG;
        if (s === bb)
            return r.RG_INTEGER;
        if (s === Sb)
            return r.RGBA_INTEGER;
        if (s === up || s === hp || s === fp || s === dp)
            if (c === Zt)
                if (a = e.get("WEBGL_compressed_texture_s3tc_srgb"),
                a !== null) {
                    if (s === up)
                        return a.COMPRESSED_SRGB_S3TC_DXT1_EXT;
                    if (s === hp)
                        return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
                    if (s === fp)
                        return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
                    if (s === dp)
                        return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
                } else
                    return null;
            else if (a = e.get("WEBGL_compressed_texture_s3tc"),
            a !== null) {
                if (s === up)
                    return a.COMPRESSED_RGB_S3TC_DXT1_EXT;
                if (s === hp)
                    return a.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                if (s === fp)
                    return a.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                if (s === dp)
                    return a.COMPRESSED_RGBA_S3TC_DXT5_EXT
            } else
                return null;
        if (s === M0 || s === w0 || s === E0 || s === A0)
            if (a = e.get("WEBGL_compressed_texture_pvrtc"),
            a !== null) {
                if (s === M0)
                    return a.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                if (s === w0)
                    return a.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                if (s === E0)
                    return a.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                if (s === A0)
                    return a.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
            } else
                return null;
        if (s === Mb)
            return a = e.get("WEBGL_compressed_texture_etc1"),
            a !== null ? a.COMPRESSED_RGB_ETC1_WEBGL : null;
        if (s === P0 || s === R0)
            if (a = e.get("WEBGL_compressed_texture_etc"),
            a !== null) {
                if (s === P0)
                    return c === Zt ? a.COMPRESSED_SRGB8_ETC2 : a.COMPRESSED_RGB8_ETC2;
                if (s === R0)
                    return c === Zt ? a.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : a.COMPRESSED_RGBA8_ETC2_EAC
            } else
                return null;
        if (s === C0 || s === I0 || s === L0 || s === D0 || s === O0 || s === U0 || s === N0 || s === F0 || s === B0 || s === k0 || s === z0 || s === H0 || s === V0 || s === G0)
            if (a = e.get("WEBGL_compressed_texture_astc"),
            a !== null) {
                if (s === C0)
                    return c === Zt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : a.COMPRESSED_RGBA_ASTC_4x4_KHR;
                if (s === I0)
                    return c === Zt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : a.COMPRESSED_RGBA_ASTC_5x4_KHR;
                if (s === L0)
                    return c === Zt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : a.COMPRESSED_RGBA_ASTC_5x5_KHR;
                if (s === D0)
                    return c === Zt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : a.COMPRESSED_RGBA_ASTC_6x5_KHR;
                if (s === O0)
                    return c === Zt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : a.COMPRESSED_RGBA_ASTC_6x6_KHR;
                if (s === U0)
                    return c === Zt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : a.COMPRESSED_RGBA_ASTC_8x5_KHR;
                if (s === N0)
                    return c === Zt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : a.COMPRESSED_RGBA_ASTC_8x6_KHR;
                if (s === F0)
                    return c === Zt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : a.COMPRESSED_RGBA_ASTC_8x8_KHR;
                if (s === B0)
                    return c === Zt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : a.COMPRESSED_RGBA_ASTC_10x5_KHR;
                if (s === k0)
                    return c === Zt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : a.COMPRESSED_RGBA_ASTC_10x6_KHR;
                if (s === z0)
                    return c === Zt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : a.COMPRESSED_RGBA_ASTC_10x8_KHR;
                if (s === H0)
                    return c === Zt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : a.COMPRESSED_RGBA_ASTC_10x10_KHR;
                if (s === V0)
                    return c === Zt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : a.COMPRESSED_RGBA_ASTC_12x10_KHR;
                if (s === G0)
                    return c === Zt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : a.COMPRESSED_RGBA_ASTC_12x12_KHR
            } else
                return null;
        if (s === pp || s === W0 || s === j0)
            if (a = e.get("EXT_texture_compression_bptc"),
            a !== null) {
                if (s === pp)
                    return c === Zt ? a.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : a.COMPRESSED_RGBA_BPTC_UNORM_EXT;
                if (s === W0)
                    return a.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
                if (s === j0)
                    return a.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT
            } else
                return null;
        if (s === zL || s === X0 || s === q0 || s === K0)
            if (a = e.get("EXT_texture_compression_rgtc"),
            a !== null) {
                if (s === pp)
                    return a.COMPRESSED_RED_RGTC1_EXT;
                if (s === X0)
                    return a.COMPRESSED_SIGNED_RED_RGTC1_EXT;
                if (s === q0)
                    return a.COMPRESSED_RED_GREEN_RGTC2_EXT;
                if (s === K0)
                    return a.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT
            } else
                return null;
        return s === Fs ? n ? r.UNSIGNED_INT_24_8 : (a = e.get("WEBGL_depth_texture"),
        a !== null ? a.UNSIGNED_INT_24_8_WEBGL : null) : r[s] !== void 0 ? r[s] : null
    }
    return {
        convert: i
    }
}
class h3 extends qn {
    constructor(e=[]) {
        super(),
        this.isArrayCamera = !0,
        this.cameras = e
    }
}
class gr extends Yt {
    constructor() {
        super(),
        this.isGroup = !0,
        this.type = "Group"
    }
}
const f3 = {
    type: "move"
};
class Bp {
    constructor() {
        this._targetRay = null,
        this._grip = null,
        this._hand = null
    }
    getHandSpace() {
        return this._hand === null && (this._hand = new gr,
        this._hand.matrixAutoUpdate = !1,
        this._hand.visible = !1,
        this._hand.joints = {},
        this._hand.inputState = {
            pinching: !1
        }),
        this._hand
    }
    getTargetRaySpace() {
        return this._targetRay === null && (this._targetRay = new gr,
        this._targetRay.matrixAutoUpdate = !1,
        this._targetRay.visible = !1,
        this._targetRay.hasLinearVelocity = !1,
        this._targetRay.linearVelocity = new k,
        this._targetRay.hasAngularVelocity = !1,
        this._targetRay.angularVelocity = new k),
        this._targetRay
    }
    getGripSpace() {
        return this._grip === null && (this._grip = new gr,
        this._grip.matrixAutoUpdate = !1,
        this._grip.visible = !1,
        this._grip.hasLinearVelocity = !1,
        this._grip.linearVelocity = new k,
        this._grip.hasAngularVelocity = !1,
        this._grip.angularVelocity = new k),
        this._grip
    }
    dispatchEvent(e) {
        return this._targetRay !== null && this._targetRay.dispatchEvent(e),
        this._grip !== null && this._grip.dispatchEvent(e),
        this._hand !== null && this._hand.dispatchEvent(e),
        this
    }
    connect(e) {
        if (e && e.hand) {
            const t = this._hand;
            if (t)
                for (const n of e.hand.values())
                    this._getHandJoint(t, n)
        }
        return this.dispatchEvent({
            type: "connected",
            data: e
        }),
        this
    }
    disconnect(e) {
        return this.dispatchEvent({
            type: "disconnected",
            data: e
        }),
        this._targetRay !== null && (this._targetRay.visible = !1),
        this._grip !== null && (this._grip.visible = !1),
        this._hand !== null && (this._hand.visible = !1),
        this
    }
    update(e, t, n) {
        let i = null
          , s = null
          , o = null;
        const a = this._targetRay
          , c = this._grip
          , h = this._hand;
        if (e && t.session.visibilityState !== "visible-blurred") {
            if (h && e.hand) {
                o = !0;
                for (const y of e.hand.values()) {
                    const v = t.getJointPose(y, n)
                      , _ = this._getHandJoint(h, y);
                    v !== null && (_.matrix.fromArray(v.transform.matrix),
                    _.matrix.decompose(_.position, _.rotation, _.scale),
                    _.matrixWorldNeedsUpdate = !0,
                    _.jointRadius = v.radius),
                    _.visible = v !== null
                }
                const d = h.joints["index-finger-tip"]
                  , l = h.joints["thumb-tip"]
                  , f = d.position.distanceTo(l.position)
                  , p = .02
                  , g = .005;
                h.inputState.pinching && f > p + g ? (h.inputState.pinching = !1,
                this.dispatchEvent({
                    type: "pinchend",
                    handedness: e.handedness,
                    target: this
                })) : !h.inputState.pinching && f <= p - g && (h.inputState.pinching = !0,
                this.dispatchEvent({
                    type: "pinchstart",
                    handedness: e.handedness,
                    target: this
                }))
            } else
                c !== null && e.gripSpace && (s = t.getPose(e.gripSpace, n),
                s !== null && (c.matrix.fromArray(s.transform.matrix),
                c.matrix.decompose(c.position, c.rotation, c.scale),
                c.matrixWorldNeedsUpdate = !0,
                s.linearVelocity ? (c.hasLinearVelocity = !0,
                c.linearVelocity.copy(s.linearVelocity)) : c.hasLinearVelocity = !1,
                s.angularVelocity ? (c.hasAngularVelocity = !0,
                c.angularVelocity.copy(s.angularVelocity)) : c.hasAngularVelocity = !1));
            a !== null && (i = t.getPose(e.targetRaySpace, n),
            i === null && s !== null && (i = s),
            i !== null && (a.matrix.fromArray(i.transform.matrix),
            a.matrix.decompose(a.position, a.rotation, a.scale),
            a.matrixWorldNeedsUpdate = !0,
            i.linearVelocity ? (a.hasLinearVelocity = !0,
            a.linearVelocity.copy(i.linearVelocity)) : a.hasLinearVelocity = !1,
            i.angularVelocity ? (a.hasAngularVelocity = !0,
            a.angularVelocity.copy(i.angularVelocity)) : a.hasAngularVelocity = !1,
            this.dispatchEvent(f3)))
        }
        return a !== null && (a.visible = i !== null),
        c !== null && (c.visible = s !== null),
        h !== null && (h.visible = o !== null),
        this
    }
    _getHandJoint(e, t) {
        if (e.joints[t.jointName] === void 0) {
            const n = new gr;
            n.matrixAutoUpdate = !1,
            n.visible = !1,
            e.joints[t.jointName] = n,
            e.add(n)
        }
        return e.joints[t.jointName]
    }
}
class d3 extends Sr {
    constructor(e, t) {
        super();
        const n = this;
        let i = null
          , s = 1
          , o = null
          , a = "local-floor"
          , c = 1
          , h = null
          , d = null
          , l = null
          , f = null
          , p = null
          , g = null;
        const y = t.getContextAttributes();
        let v = null
          , _ = null;
        const b = []
          , T = []
          , S = new Ce;
        let E = null;
        const P = new qn;
        P.layers.enable(1),
        P.viewport = new Ct;
        const R = new qn;
        R.layers.enable(2),
        R.viewport = new Ct;
        const O = [P, R]
          , w = new h3;
        w.layers.enable(1),
        w.layers.enable(2);
        let I = null
          , V = null;
        this.cameraAutoUpdate = !0,
        this.enabled = !1,
        this.isPresenting = !1,
        this.getController = function(oe) {
            let he = b[oe];
            return he === void 0 && (he = new Bp,
            b[oe] = he),
            he.getTargetRaySpace()
        }
        ,
        this.getControllerGrip = function(oe) {
            let he = b[oe];
            return he === void 0 && (he = new Bp,
            b[oe] = he),
            he.getGripSpace()
        }
        ,
        this.getHand = function(oe) {
            let he = b[oe];
            return he === void 0 && (he = new Bp,
            b[oe] = he),
            he.getHandSpace()
        }
        ;
        function z(oe) {
            const he = T.indexOf(oe.inputSource);
            if (he === -1)
                return;
            const xe = b[he];
            xe !== void 0 && (xe.update(oe.inputSource, oe.frame, h || o),
            xe.dispatchEvent({
                type: oe.type,
                data: oe.inputSource
            }))
        }
        function q() {
            i.removeEventListener("select", z),
            i.removeEventListener("selectstart", z),
            i.removeEventListener("selectend", z),
            i.removeEventListener("squeeze", z),
            i.removeEventListener("squeezestart", z),
            i.removeEventListener("squeezeend", z),
            i.removeEventListener("end", q),
            i.removeEventListener("inputsourceschange", F);
            for (let oe = 0; oe < b.length; oe++) {
                const he = T[oe];
                he !== null && (T[oe] = null,
                b[oe].disconnect(he))
            }
            I = null,
            V = null,
            e.setRenderTarget(v),
            p = null,
            f = null,
            l = null,
            i = null,
            _ = null,
            Ee.stop(),
            n.isPresenting = !1,
            e.setPixelRatio(E),
            e.setSize(S.width, S.height, !1),
            n.dispatchEvent({
                type: "sessionend"
            })
        }
        this.setFramebufferScaleFactor = function(oe) {
            s = oe,
            n.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")
        }
        ,
        this.setReferenceSpaceType = function(oe) {
            a = oe,
            n.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")
        }
        ,
        this.getReferenceSpace = function() {
            return h || o
        }
        ,
        this.setReferenceSpace = function(oe) {
            h = oe
        }
        ,
        this.getBaseLayer = function() {
            return f !== null ? f : p
        }
        ,
        this.getBinding = function() {
            return l
        }
        ,
        this.getFrame = function() {
            return g
        }
        ,
        this.getSession = function() {
            return i
        }
        ,
        this.setSession = async function(oe) {
            if (i = oe,
            i !== null) {
                if (v = e.getRenderTarget(),
                i.addEventListener("select", z),
                i.addEventListener("selectstart", z),
                i.addEventListener("selectend", z),
                i.addEventListener("squeeze", z),
                i.addEventListener("squeezestart", z),
                i.addEventListener("squeezeend", z),
                i.addEventListener("end", q),
                i.addEventListener("inputsourceschange", F),
                y.xrCompatible !== !0 && await t.makeXRCompatible(),
                E = e.getPixelRatio(),
                e.getSize(S),
                i.renderState.layers === void 0 || e.capabilities.isWebGL2 === !1) {
                    const he = {
                        antialias: i.renderState.layers === void 0 ? y.antialias : !0,
                        alpha: !0,
                        depth: y.depth,
                        stencil: y.stencil,
                        framebufferScaleFactor: s
                    };
                    p = new XRWebGLLayer(i,t,he),
                    i.updateRenderState({
                        baseLayer: p
                    }),
                    e.setPixelRatio(1),
                    e.setSize(p.framebufferWidth, p.framebufferHeight, !1),
                    _ = new vn(p.framebufferWidth,p.framebufferHeight,{
                        format: Kn,
                        type: Vn,
                        colorSpace: e.outputColorSpace,
                        stencilBuffer: y.stencil
                    })
                } else {
                    let he = null
                      , xe = null
                      , Be = null;
                    y.depth && (Be = y.stencil ? t.DEPTH24_STENCIL8 : t.DEPTH_COMPONENT24,
                    he = y.stencil ? Oo : Ro,
                    xe = y.stencil ? Fs : ns);
                    const De = {
                        colorFormat: t.RGBA8,
                        depthFormat: Be,
                        scaleFactor: s
                    };
                    l = new XRWebGLBinding(i,t),
                    f = l.createProjectionLayer(De),
                    i.updateRenderState({
                        layers: [f]
                    }),
                    e.setPixelRatio(1),
                    e.setSize(f.textureWidth, f.textureHeight, !1),
                    _ = new vn(f.textureWidth,f.textureHeight,{
                        format: Kn,
                        type: Vn,
                        depthTexture: new N_(f.textureWidth,f.textureHeight,xe,void 0,void 0,void 0,void 0,void 0,void 0,he),
                        stencilBuffer: y.stencil,
                        colorSpace: e.outputColorSpace,
                        samples: y.antialias ? 4 : 0
                    });
                    const et = e.properties.get(_);
                    et.__ignoreDepthValues = f.ignoreDepthValues
                }
                _.isXRRenderTarget = !0,
                this.setFoveation(c),
                h = null,
                o = await i.requestReferenceSpace(a),
                Ee.setContext(i),
                Ee.start(),
                n.isPresenting = !0,
                n.dispatchEvent({
                    type: "sessionstart"
                })
            }
        }
        ,
        this.getEnvironmentBlendMode = function() {
            if (i !== null)
                return i.environmentBlendMode
        }
        ;
        function F(oe) {
            for (let he = 0; he < oe.removed.length; he++) {
                const xe = oe.removed[he]
                  , Be = T.indexOf(xe);
                Be >= 0 && (T[Be] = null,
                b[Be].disconnect(xe))
            }
            for (let he = 0; he < oe.added.length; he++) {
                const xe = oe.added[he];
                let Be = T.indexOf(xe);
                if (Be === -1) {
                    for (let et = 0; et < b.length; et++)
                        if (et >= T.length) {
                            T.push(xe),
                            Be = et;
                            break
                        } else if (T[et] === null) {
                            T[et] = xe,
                            Be = et;
                            break
                        }
                    if (Be === -1)
                        break
                }
                const De = b[Be];
                De && De.connect(xe)
            }
        }
        const j = new k
          , K = new k;
        function J(oe, he, xe) {
            j.setFromMatrixPosition(he.matrixWorld),
            K.setFromMatrixPosition(xe.matrixWorld);
            const Be = j.distanceTo(K)
              , De = he.projectionMatrix.elements
              , et = xe.projectionMatrix.elements
              , Ze = De[14] / (De[10] - 1)
              , We = De[14] / (De[10] + 1)
              , Je = (De[9] + 1) / De[5]
              , Q = (De[9] - 1) / De[5]
              , hn = (De[8] - 1) / De[0]
              , ze = (et[8] + 1) / et[0]
              , at = Ze * hn
              , qe = Ze * ze
              , It = Be / (-hn + ze)
              , tt = It * -hn;
            he.matrixWorld.decompose(oe.position, oe.quaternion, oe.scale),
            oe.translateX(tt),
            oe.translateZ(It),
            oe.matrixWorld.compose(oe.position, oe.quaternion, oe.scale),
            oe.matrixWorldInverse.copy(oe.matrixWorld).invert();
            const Ye = Ze + It
              , dt = We + It
              , on = at - tt
              , Lt = qe + (Be - tt)
              , B = Je * We / dt * Ye
              , L = Q * We / dt * Ye;
            oe.projectionMatrix.makePerspective(on, Lt, B, L, Ye, dt),
            oe.projectionMatrixInverse.copy(oe.projectionMatrix).invert()
        }
        function de(oe, he) {
            he === null ? oe.matrixWorld.copy(oe.matrix) : oe.matrixWorld.multiplyMatrices(he.matrixWorld, oe.matrix),
            oe.matrixWorldInverse.copy(oe.matrixWorld).invert()
        }
        this.updateCamera = function(oe) {
            if (i === null)
                return;
            w.near = R.near = P.near = oe.near,
            w.far = R.far = P.far = oe.far,
            (I !== w.near || V !== w.far) && (i.updateRenderState({
                depthNear: w.near,
                depthFar: w.far
            }),
            I = w.near,
            V = w.far);
            const he = oe.parent
              , xe = w.cameras;
            de(w, he);
            for (let Be = 0; Be < xe.length; Be++)
                de(xe[Be], he);
            xe.length === 2 ? J(w, P, R) : w.projectionMatrix.copy(P.projectionMatrix),
            ae(oe, w, he)
        }
        ;
        function ae(oe, he, xe) {
            xe === null ? oe.matrix.copy(he.matrixWorld) : (oe.matrix.copy(xe.matrixWorld),
            oe.matrix.invert(),
            oe.matrix.multiply(he.matrixWorld)),
            oe.matrix.decompose(oe.position, oe.quaternion, oe.scale),
            oe.updateMatrixWorld(!0),
            oe.projectionMatrix.copy(he.projectionMatrix),
            oe.projectionMatrixInverse.copy(he.projectionMatrixInverse),
            oe.isPerspectiveCamera && (oe.fov = al * 2 * Math.atan(1 / oe.projectionMatrix.elements[5]),
            oe.zoom = 1)
        }
        this.getCamera = function() {
            return w
        }
        ,
        this.getFoveation = function() {
            if (!(f === null && p === null))
                return c
        }
        ,
        this.setFoveation = function(oe) {
            c = oe,
            f !== null && (f.fixedFoveation = oe),
            p !== null && p.fixedFoveation !== void 0 && (p.fixedFoveation = oe)
        }
        ;
        let ue = null;
        function ge(oe, he) {
            if (d = he.getViewerPose(h || o),
            g = he,
            d !== null) {
                const xe = d.views;
                p !== null && (e.setRenderTargetFramebuffer(_, p.framebuffer),
                e.setRenderTarget(_));
                let Be = !1;
                xe.length !== w.cameras.length && (w.cameras.length = 0,
                Be = !0);
                for (let De = 0; De < xe.length; De++) {
                    const et = xe[De];
                    let Ze = null;
                    if (p !== null)
                        Ze = p.getViewport(et);
                    else {
                        const Je = l.getViewSubImage(f, et);
                        Ze = Je.viewport,
                        De === 0 && (e.setRenderTargetTextures(_, Je.colorTexture, f.ignoreDepthValues ? void 0 : Je.depthStencilTexture),
                        e.setRenderTarget(_))
                    }
                    let We = O[De];
                    We === void 0 && (We = new qn,
                    We.layers.enable(De),
                    We.viewport = new Ct,
                    O[De] = We),
                    We.matrix.fromArray(et.transform.matrix),
                    We.matrix.decompose(We.position, We.quaternion, We.scale),
                    We.projectionMatrix.fromArray(et.projectionMatrix),
                    We.projectionMatrixInverse.copy(We.projectionMatrix).invert(),
                    We.viewport.set(Ze.x, Ze.y, Ze.width, Ze.height),
                    De === 0 && (w.matrix.copy(We.matrix),
                    w.matrix.decompose(w.position, w.quaternion, w.scale)),
                    Be === !0 && w.cameras.push(We)
                }
            }
            for (let xe = 0; xe < b.length; xe++) {
                const Be = T[xe]
                  , De = b[xe];
                Be !== null && De !== void 0 && De.update(Be, he, h || o)
            }
            ue && ue(oe, he),
            he.detectedPlanes && n.dispatchEvent({
                type: "planesdetected",
                data: he
            }),
            g = null
        }
        const Ee = new Fb;
        Ee.setAnimationLoop(ge),
        this.setAnimationLoop = function(oe) {
            ue = oe
        }
        ,
        this.dispose = function() {}
    }
}
function p3(r, e) {
    function t(v, _) {
        v.matrixAutoUpdate === !0 && v.updateMatrix(),
        _.value.copy(v.matrix)
    }
    function n(v, _) {
        _.color.getRGB(v.fogColor.value, Ub(r)),
        _.isFog ? (v.fogNear.value = _.near,
        v.fogFar.value = _.far) : _.isFogExp2 && (v.fogDensity.value = _.density)
    }
    function i(v, _, b, T, S) {
        _.isMeshBasicMaterial || _.isMeshLambertMaterial ? s(v, _) : _.isMeshToonMaterial ? (s(v, _),
        l(v, _)) : _.isMeshPhongMaterial ? (s(v, _),
        d(v, _)) : _.isMeshStandardMaterial ? (s(v, _),
        f(v, _),
        _.isMeshPhysicalMaterial && p(v, _, S)) : _.isMeshMatcapMaterial ? (s(v, _),
        g(v, _)) : _.isMeshDepthMaterial ? s(v, _) : _.isMeshDistanceMaterial ? (s(v, _),
        y(v, _)) : _.isMeshNormalMaterial ? s(v, _) : _.isLineBasicMaterial ? (o(v, _),
        _.isLineDashedMaterial && a(v, _)) : _.isPointsMaterial ? c(v, _, b, T) : _.isSpriteMaterial ? h(v, _) : _.isShadowMaterial ? (v.color.value.copy(_.color),
        v.opacity.value = _.opacity) : _.isShaderMaterial && (_.uniformsNeedUpdate = !1)
    }
    function s(v, _) {
        v.opacity.value = _.opacity,
        _.color && v.diffuse.value.copy(_.color),
        _.emissive && v.emissive.value.copy(_.emissive).multiplyScalar(_.emissiveIntensity),
        _.map && (v.map.value = _.map,
        t(_.map, v.mapTransform)),
        _.alphaMap && (v.alphaMap.value = _.alphaMap,
        t(_.alphaMap, v.alphaMapTransform)),
        _.bumpMap && (v.bumpMap.value = _.bumpMap,
        t(_.bumpMap, v.bumpMapTransform),
        v.bumpScale.value = _.bumpScale,
        _.side === fi && (v.bumpScale.value *= -1)),
        _.normalMap && (v.normalMap.value = _.normalMap,
        t(_.normalMap, v.normalMapTransform),
        v.normalScale.value.copy(_.normalScale),
        _.side === fi && v.normalScale.value.negate()),
        _.displacementMap && (v.displacementMap.value = _.displacementMap,
        t(_.displacementMap, v.displacementMapTransform),
        v.displacementScale.value = _.displacementScale,
        v.displacementBias.value = _.displacementBias),
        _.emissiveMap && (v.emissiveMap.value = _.emissiveMap,
        t(_.emissiveMap, v.emissiveMapTransform)),
        _.specularMap && (v.specularMap.value = _.specularMap,
        t(_.specularMap, v.specularMapTransform)),
        _.alphaTest > 0 && (v.alphaTest.value = _.alphaTest);
        const b = e.get(_).envMap;
        if (b && (v.envMap.value = b,
        v.flipEnvMap.value = b.isCubeTexture && b.isRenderTargetTexture === !1 ? -1 : 1,
        v.reflectivity.value = _.reflectivity,
        v.ior.value = _.ior,
        v.refractionRatio.value = _.refractionRatio),
        _.lightMap) {
            v.lightMap.value = _.lightMap;
            const T = r._useLegacyLights === !0 ? Math.PI : 1;
            v.lightMapIntensity.value = _.lightMapIntensity * T,
            t(_.lightMap, v.lightMapTransform)
        }
        _.aoMap && (v.aoMap.value = _.aoMap,
        v.aoMapIntensity.value = _.aoMapIntensity,
        t(_.aoMap, v.aoMapTransform))
    }
    function o(v, _) {
        v.diffuse.value.copy(_.color),
        v.opacity.value = _.opacity,
        _.map && (v.map.value = _.map,
        t(_.map, v.mapTransform))
    }
    function a(v, _) {
        v.dashSize.value = _.dashSize,
        v.totalSize.value = _.dashSize + _.gapSize,
        v.scale.value = _.scale
    }
    function c(v, _, b, T) {
        v.diffuse.value.copy(_.color),
        v.opacity.value = _.opacity,
        v.size.value = _.size * b,
        v.scale.value = T * .5,
        _.map && (v.map.value = _.map,
        t(_.map, v.uvTransform)),
        _.alphaMap && (v.alphaMap.value = _.alphaMap,
        t(_.alphaMap, v.alphaMapTransform)),
        _.alphaTest > 0 && (v.alphaTest.value = _.alphaTest)
    }
    function h(v, _) {
        v.diffuse.value.copy(_.color),
        v.opacity.value = _.opacity,
        v.rotation.value = _.rotation,
        _.map && (v.map.value = _.map,
        t(_.map, v.mapTransform)),
        _.alphaMap && (v.alphaMap.value = _.alphaMap,
        t(_.alphaMap, v.alphaMapTransform)),
        _.alphaTest > 0 && (v.alphaTest.value = _.alphaTest)
    }
    function d(v, _) {
        v.specular.value.copy(_.specular),
        v.shininess.value = Math.max(_.shininess, 1e-4)
    }
    function l(v, _) {
        _.gradientMap && (v.gradientMap.value = _.gradientMap)
    }
    function f(v, _) {
        v.metalness.value = _.metalness,
        _.metalnessMap && (v.metalnessMap.value = _.metalnessMap,
        t(_.metalnessMap, v.metalnessMapTransform)),
        v.roughness.value = _.roughness,
        _.roughnessMap && (v.roughnessMap.value = _.roughnessMap,
        t(_.roughnessMap, v.roughnessMapTransform)),
        e.get(_).envMap && (v.envMapIntensity.value = _.envMapIntensity)
    }
    function p(v, _, b) {
        v.ior.value = _.ior,
        _.sheen > 0 && (v.sheenColor.value.copy(_.sheenColor).multiplyScalar(_.sheen),
        v.sheenRoughness.value = _.sheenRoughness,
        _.sheenColorMap && (v.sheenColorMap.value = _.sheenColorMap,
        t(_.sheenColorMap, v.sheenColorMapTransform)),
        _.sheenRoughnessMap && (v.sheenRoughnessMap.value = _.sheenRoughnessMap,
        t(_.sheenRoughnessMap, v.sheenRoughnessMapTransform))),
        _.clearcoat > 0 && (v.clearcoat.value = _.clearcoat,
        v.clearcoatRoughness.value = _.clearcoatRoughness,
        _.clearcoatMap && (v.clearcoatMap.value = _.clearcoatMap,
        t(_.clearcoatMap, v.clearcoatMapTransform)),
        _.clearcoatRoughnessMap && (v.clearcoatRoughnessMap.value = _.clearcoatRoughnessMap,
        t(_.clearcoatRoughnessMap, v.clearcoatRoughnessMapTransform)),
        _.clearcoatNormalMap && (v.clearcoatNormalMap.value = _.clearcoatNormalMap,
        t(_.clearcoatNormalMap, v.clearcoatNormalMapTransform),
        v.clearcoatNormalScale.value.copy(_.clearcoatNormalScale),
        _.side === fi && v.clearcoatNormalScale.value.negate())),
        _.iridescence > 0 && (v.iridescence.value = _.iridescence,
        v.iridescenceIOR.value = _.iridescenceIOR,
        v.iridescenceThicknessMinimum.value = _.iridescenceThicknessRange[0],
        v.iridescenceThicknessMaximum.value = _.iridescenceThicknessRange[1],
        _.iridescenceMap && (v.iridescenceMap.value = _.iridescenceMap,
        t(_.iridescenceMap, v.iridescenceMapTransform)),
        _.iridescenceThicknessMap && (v.iridescenceThicknessMap.value = _.iridescenceThicknessMap,
        t(_.iridescenceThicknessMap, v.iridescenceThicknessMapTransform))),
        _.transmission > 0 && (v.transmission.value = _.transmission,
        v.transmissionSamplerMap.value = b.texture,
        v.transmissionSamplerSize.value.set(b.width, b.height),
        _.transmissionMap && (v.transmissionMap.value = _.transmissionMap,
        t(_.transmissionMap, v.transmissionMapTransform)),
        v.thickness.value = _.thickness,
        _.thicknessMap && (v.thicknessMap.value = _.thicknessMap,
        t(_.thicknessMap, v.thicknessMapTransform)),
        v.attenuationDistance.value = _.attenuationDistance,
        v.attenuationColor.value.copy(_.attenuationColor)),
        _.anisotropy > 0 && (v.anisotropyVector.value.set(_.anisotropy * Math.cos(_.anisotropyRotation), _.anisotropy * Math.sin(_.anisotropyRotation)),
        _.anisotropyMap && (v.anisotropyMap.value = _.anisotropyMap,
        t(_.anisotropyMap, v.anisotropyMapTransform))),
        v.specularIntensity.value = _.specularIntensity,
        v.specularColor.value.copy(_.specularColor),
        _.specularColorMap && (v.specularColorMap.value = _.specularColorMap,
        t(_.specularColorMap, v.specularColorMapTransform)),
        _.specularIntensityMap && (v.specularIntensityMap.value = _.specularIntensityMap,
        t(_.specularIntensityMap, v.specularIntensityMapTransform))
    }
    function g(v, _) {
        _.matcap && (v.matcap.value = _.matcap)
    }
    function y(v, _) {
        const b = e.get(_).light;
        v.referencePosition.value.setFromMatrixPosition(b.matrixWorld),
        v.nearDistance.value = b.shadow.camera.near,
        v.farDistance.value = b.shadow.camera.far
    }
    return {
        refreshFogUniforms: n,
        refreshMaterialUniforms: i
    }
}
function m3(r, e, t, n) {
    let i = {}
      , s = {}
      , o = [];
    const a = t.isWebGL2 ? r.getParameter(r.MAX_UNIFORM_BUFFER_BINDINGS) : 0;
    function c(b, T) {
        const S = T.program;
        n.uniformBlockBinding(b, S)
    }
    function h(b, T) {
        let S = i[b.id];
        S === void 0 && (g(b),
        S = d(b),
        i[b.id] = S,
        b.addEventListener("dispose", v));
        const E = T.program;
        n.updateUBOMapping(b, E);
        const P = e.render.frame;
        s[b.id] !== P && (f(b),
        s[b.id] = P)
    }
    function d(b) {
        const T = l();
        b.__bindingPointIndex = T;
        const S = r.createBuffer()
          , E = b.__size
          , P = b.usage;
        return r.bindBuffer(r.UNIFORM_BUFFER, S),
        r.bufferData(r.UNIFORM_BUFFER, E, P),
        r.bindBuffer(r.UNIFORM_BUFFER, null),
        r.bindBufferBase(r.UNIFORM_BUFFER, T, S),
        S
    }
    function l() {
        for (let b = 0; b < a; b++)
            if (o.indexOf(b) === -1)
                return o.push(b),
                b;
        return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."),
        0
    }
    function f(b) {
        const T = i[b.id]
          , S = b.uniforms
          , E = b.__cache;
        r.bindBuffer(r.UNIFORM_BUFFER, T);
        for (let P = 0, R = S.length; P < R; P++) {
            const O = S[P];
            if (p(O, P, E) === !0) {
                const w = O.__offset
                  , I = Array.isArray(O.value) ? O.value : [O.value];
                let V = 0;
                for (let z = 0; z < I.length; z++) {
                    const q = I[z]
                      , F = y(q);
                    typeof q == "number" ? (O.__data[0] = q,
                    r.bufferSubData(r.UNIFORM_BUFFER, w + V, O.__data)) : q.isMatrix3 ? (O.__data[0] = q.elements[0],
                    O.__data[1] = q.elements[1],
                    O.__data[2] = q.elements[2],
                    O.__data[3] = q.elements[0],
                    O.__data[4] = q.elements[3],
                    O.__data[5] = q.elements[4],
                    O.__data[6] = q.elements[5],
                    O.__data[7] = q.elements[0],
                    O.__data[8] = q.elements[6],
                    O.__data[9] = q.elements[7],
                    O.__data[10] = q.elements[8],
                    O.__data[11] = q.elements[0]) : (q.toArray(O.__data, V),
                    V += F.storage / Float32Array.BYTES_PER_ELEMENT)
                }
                r.bufferSubData(r.UNIFORM_BUFFER, w, O.__data)
            }
        }
        r.bindBuffer(r.UNIFORM_BUFFER, null)
    }
    function p(b, T, S) {
        const E = b.value;
        if (S[T] === void 0) {
            if (typeof E == "number")
                S[T] = E;
            else {
                const P = Array.isArray(E) ? E : [E]
                  , R = [];
                for (let O = 0; O < P.length; O++)
                    R.push(P[O].clone());
                S[T] = R
            }
            return !0
        } else if (typeof E == "number") {
            if (S[T] !== E)
                return S[T] = E,
                !0
        } else {
            const P = Array.isArray(S[T]) ? S[T] : [S[T]]
              , R = Array.isArray(E) ? E : [E];
            for (let O = 0; O < P.length; O++) {
                const w = P[O];
                if (w.equals(R[O]) === !1)
                    return w.copy(R[O]),
                    !0
            }
        }
        return !1
    }
    function g(b) {
        const T = b.uniforms;
        let S = 0;
        const E = 16;
        let P = 0;
        for (let R = 0, O = T.length; R < O; R++) {
            const w = T[R]
              , I = {
                boundary: 0,
                storage: 0
            }
              , V = Array.isArray(w.value) ? w.value : [w.value];
            for (let z = 0, q = V.length; z < q; z++) {
                const F = V[z]
                  , j = y(F);
                I.boundary += j.boundary,
                I.storage += j.storage
            }
            if (w.__data = new Float32Array(I.storage / Float32Array.BYTES_PER_ELEMENT),
            w.__offset = S,
            R > 0) {
                P = S % E;
                const z = E - P;
                P !== 0 && z - I.boundary < 0 && (S += E - P,
                w.__offset = S)
            }
            S += I.storage
        }
        return P = S % E,
        P > 0 && (S += E - P),
        b.__size = S,
        b.__cache = {},
        this
    }
    function y(b) {
        const T = {
            boundary: 0,
            storage: 0
        };
        return typeof b == "number" ? (T.boundary = 4,
        T.storage = 4) : b.isVector2 ? (T.boundary = 8,
        T.storage = 8) : b.isVector3 || b.isColor ? (T.boundary = 16,
        T.storage = 12) : b.isVector4 ? (T.boundary = 16,
        T.storage = 16) : b.isMatrix3 ? (T.boundary = 48,
        T.storage = 48) : b.isMatrix4 ? (T.boundary = 64,
        T.storage = 64) : b.isTexture ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", b),
        T
    }
    function v(b) {
        const T = b.target;
        T.removeEventListener("dispose", v);
        const S = o.indexOf(T.__bindingPointIndex);
        o.splice(S, 1),
        r.deleteBuffer(i[T.id]),
        delete i[T.id],
        delete s[T.id]
    }
    function _() {
        for (const b in i)
            r.deleteBuffer(i[b]);
        o = [],
        i = {},
        s = {}
    }
    return {
        bind: c,
        update: h,
        dispose: _
    }
}
class Gb {
    constructor(e={}) {
        const {canvas: t=pD(), context: n=null, depth: i=!0, stencil: s=!0, alpha: o=!1, antialias: a=!1, premultipliedAlpha: c=!0, preserveDrawingBuffer: h=!1, powerPreference: d="default", failIfMajorPerformanceCaveat: l=!1} = e;
        this.isWebGLRenderer = !0;
        let f;
        n !== null ? f = n.getContextAttributes().alpha : f = o;
        const p = new Uint32Array(4)
          , g = new Int32Array(4);
        let y = null
          , v = null;
        const _ = []
          , b = [];
        this.domElement = t,
        this.debug = {
            checkShaderErrors: !0,
            onShaderError: null
        },
        this.autoClear = !0,
        this.autoClearColor = !0,
        this.autoClearDepth = !0,
        this.autoClearStencil = !0,
        this.sortObjects = !0,
        this.clippingPlanes = [],
        this.localClippingEnabled = !1,
        this._outputColorSpace = Ft,
        this._useLegacyLights = !1,
        this.toneMapping = Ns,
        this.toneMappingExposure = 1;
        const T = this;
        let S = !1
          , E = 0
          , P = 0
          , R = null
          , O = -1
          , w = null;
        const I = new Ct
          , V = new Ct;
        let z = null;
        const q = new Ke(0);
        let F = 0
          , j = t.width
          , K = t.height
          , J = 1
          , de = null
          , ae = null;
        const ue = new Ct(0,0,j,K)
          , ge = new Ct(0,0,j,K);
        let Ee = !1;
        const oe = new O_;
        let he = !1
          , xe = !1
          , Be = null;
        const De = new it
          , et = new Ce
          , Ze = new k
          , We = {
            background: null,
            fog: null,
            environment: null,
            overrideMaterial: null,
            isScene: !0
        };
        function Je() {
            return R === null ? J : 1
        }
        let Q = n;
        function hn(U, $) {
            for (let ne = 0; ne < U.length; ne++) {
                const ie = U[ne]
                  , te = t.getContext(ie, $);
                if (te !== null)
                    return te
            }
            return null
        }
        try {
            const U = {
                alpha: !0,
                depth: i,
                stencil: s,
                antialias: a,
                premultipliedAlpha: c,
                preserveDrawingBuffer: h,
                powerPreference: d,
                failIfMajorPerformanceCaveat: l
            };
            if ("setAttribute"in t && t.setAttribute("data-engine", `three.js r${gl}`),
            t.addEventListener("webglcontextlost", rt, !1),
            t.addEventListener("webglcontextrestored", X, !1),
            t.addEventListener("webglcontextcreationerror", we, !1),
            Q === null) {
                const $ = ["webgl2", "webgl", "experimental-webgl"];
                if (T.isWebGL1Renderer === !0 && $.shift(),
                Q = hn($, U),
                Q === null)
                    throw hn($) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.")
            }
            typeof WebGLRenderingContext < "u" && Q instanceof WebGLRenderingContext && console.warn("THREE.WebGLRenderer: WebGL 1 support was deprecated in r153 and will be removed in r163."),
            Q.getShaderPrecisionFormat === void 0 && (Q.getShaderPrecisionFormat = function() {
                return {
                    rangeMin: 1,
                    rangeMax: 1,
                    precision: 1
                }
            }
            )
        } catch (U) {
            throw console.error("THREE.WebGLRenderer: " + U.message),
            U
        }
        let ze, at, qe, It, tt, Ye, dt, on, Lt, B, L, ee, Te, pe, be, Ne, Me, Ae, G, _e, fe, je, Fe, Ge;
        function Oe() {
            ze = new AU(Q),
            at = new TU(Q,ze,e),
            ze.init(at),
            je = new u3(Q,ze,at),
            qe = new l3(Q,ze,at),
            It = new CU(Q),
            tt = new YN,
            Ye = new c3(Q,ze,qe,tt,at,je,It),
            dt = new SU(T),
            on = new EU(T),
            Lt = new BD(Q,at),
            Fe = new yU(Q,ze,Lt,at),
            B = new PU(Q,Lt,It,Fe),
            L = new OU(Q,B,Lt,It),
            G = new DU(Q,at,Ye),
            Ne = new bU(tt),
            ee = new KN(T,dt,on,ze,at,Fe,Ne),
            Te = new p3(T,tt),
            pe = new ZN,
            be = new i3(ze,at),
            Ae = new vU(T,dt,on,qe,L,f,c),
            Me = new a3(T,L,at),
            Ge = new m3(Q,It,at,qe),
            _e = new xU(Q,ze,It,at),
            fe = new RU(Q,ze,It,at),
            It.programs = ee.programs,
            T.capabilities = at,
            T.extensions = ze,
            T.properties = tt,
            T.renderLists = pe,
            T.shadowMap = Me,
            T.state = qe,
            T.info = It
        }
        Oe();
        const Le = new d3(T,Q);
        this.xr = Le,
        this.getContext = function() {
            return Q
        }
        ,
        this.getContextAttributes = function() {
            return Q.getContextAttributes()
        }
        ,
        this.forceContextLoss = function() {
            const U = ze.get("WEBGL_lose_context");
            U && U.loseContext()
        }
        ,
        this.forceContextRestore = function() {
            const U = ze.get("WEBGL_lose_context");
            U && U.restoreContext()
        }
        ,
        this.getPixelRatio = function() {
            return J
        }
        ,
        this.setPixelRatio = function(U) {
            U !== void 0 && (J = U,
            this.setSize(j, K, !1))
        }
        ,
        this.getSize = function(U) {
            return U.set(j, K)
        }
        ,
        this.setSize = function(U, $, ne=!0) {
            if (Le.isPresenting) {
                console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
                return
            }
            j = U,
            K = $,
            t.width = Math.floor(U * J),
            t.height = Math.floor($ * J),
            ne === !0 && (t.style.width = U + "px",
            t.style.height = $ + "px"),
            this.setViewport(0, 0, U, $)
        }
        ,
        this.getDrawingBufferSize = function(U) {
            return U.set(j * J, K * J).floor()
        }
        ,
        this.setDrawingBufferSize = function(U, $, ne) {
            j = U,
            K = $,
            J = ne,
            t.width = Math.floor(U * ne),
            t.height = Math.floor($ * ne),
            this.setViewport(0, 0, U, $)
        }
        ,
        this.getCurrentViewport = function(U) {
            return U.copy(I)
        }
        ,
        this.getViewport = function(U) {
            return U.copy(ue)
        }
        ,
        this.setViewport = function(U, $, ne, ie) {
            U.isVector4 ? ue.set(U.x, U.y, U.z, U.w) : ue.set(U, $, ne, ie),
            qe.viewport(I.copy(ue).multiplyScalar(J).floor())
        }
        ,
        this.getScissor = function(U) {
            return U.copy(ge)
        }
        ,
        this.setScissor = function(U, $, ne, ie) {
            U.isVector4 ? ge.set(U.x, U.y, U.z, U.w) : ge.set(U, $, ne, ie),
            qe.scissor(V.copy(ge).multiplyScalar(J).floor())
        }
        ,
        this.getScissorTest = function() {
            return Ee
        }
        ,
        this.setScissorTest = function(U) {
            qe.setScissorTest(Ee = U)
        }
        ,
        this.setOpaqueSort = function(U) {
            de = U
        }
        ,
        this.setTransparentSort = function(U) {
            ae = U
        }
        ,
        this.getClearColor = function(U) {
            return U.copy(Ae.getClearColor())
        }
        ,
        this.setClearColor = function() {
            Ae.setClearColor.apply(Ae, arguments)
        }
        ,
        this.getClearAlpha = function() {
            return Ae.getClearAlpha()
        }
        ,
        this.setClearAlpha = function() {
            Ae.setClearAlpha.apply(Ae, arguments)
        }
        ,
        this.clear = function(U=!0, $=!0, ne=!0) {
            let ie = 0;
            if (U) {
                let te = !1;
                if (R !== null) {
                    const Ie = R.texture.format;
                    te = Ie === Sb || Ie === bb || Ie === Tb
                }
                if (te) {
                    const Ie = R.texture.type
                      , ke = Ie === Vn || Ie === ns || Ie === A_ || Ie === Fs || Ie === yb || Ie === xb
                      , Xe = Ae.getClearColor()
                      , Qe = Ae.getClearAlpha()
                      , lt = Xe.r
                      , st = Xe.g
                      , ot = Xe.b;
                    ke ? (p[0] = lt,
                    p[1] = st,
                    p[2] = ot,
                    p[3] = Qe,
                    Q.clearBufferuiv(Q.COLOR, 0, p)) : (g[0] = lt,
                    g[1] = st,
                    g[2] = ot,
                    g[3] = Qe,
                    Q.clearBufferiv(Q.COLOR, 0, g))
                } else
                    ie |= Q.COLOR_BUFFER_BIT
            }
            $ && (ie |= Q.DEPTH_BUFFER_BIT),
            ne && (ie |= Q.STENCIL_BUFFER_BIT,
            this.state.buffers.stencil.setMask(4294967295)),
            Q.clear(ie)
        }
        ,
        this.clearColor = function() {
            this.clear(!0, !1, !1)
        }
        ,
        this.clearDepth = function() {
            this.clear(!1, !0, !1)
        }
        ,
        this.clearStencil = function() {
            this.clear(!1, !1, !0)
        }
        ,
        this.dispose = function() {
            t.removeEventListener("webglcontextlost", rt, !1),
            t.removeEventListener("webglcontextrestored", X, !1),
            t.removeEventListener("webglcontextcreationerror", we, !1),
            pe.dispose(),
            be.dispose(),
            tt.dispose(),
            dt.dispose(),
            on.dispose(),
            L.dispose(),
            Fe.dispose(),
            Ge.dispose(),
            ee.dispose(),
            Le.dispose(),
            Le.removeEventListener("sessionstart", Rn),
            Le.removeEventListener("sessionend", Et),
            Be && (Be.dispose(),
            Be = null),
            Cn.stop()
        }
        ;
        function rt(U) {
            U.preventDefault(),
            console.log("THREE.WebGLRenderer: Context Lost."),
            S = !0
        }
        function X() {
            console.log("THREE.WebGLRenderer: Context Restored."),
            S = !1;
            const U = It.autoReset
              , $ = Me.enabled
              , ne = Me.autoUpdate
              , ie = Me.needsUpdate
              , te = Me.type;
            Oe(),
            It.autoReset = U,
            Me.enabled = $,
            Me.autoUpdate = ne,
            Me.needsUpdate = ie,
            Me.type = te
        }
        function we(U) {
            console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", U.statusMessage)
        }
        function me(U) {
            const $ = U.target;
            $.removeEventListener("dispose", me),
            le($)
        }
        function le(U) {
            Se(U),
            tt.remove(U)
        }
        function Se(U) {
            const $ = tt.get(U).programs;
            $ !== void 0 && ($.forEach(function(ne) {
                ee.releaseProgram(ne)
            }),
            U.isShaderMaterial && ee.releaseShaderCache(U))
        }
        this.renderBufferDirect = function(U, $, ne, ie, te, Ie) {
            $ === null && ($ = We);
            const ke = te.isMesh && te.matrixWorld.determinant() < 0
              , Xe = Ml(U, $, ne, ie, te);
            qe.setMaterial(ie, ke);
            let Qe = ne.index
              , lt = 1;
            if (ie.wireframe === !0) {
                if (Qe = B.getWireframeAttribute(ne),
                Qe === void 0)
                    return;
                lt = 2
            }
            const st = ne.drawRange
              , ot = ne.attributes.position;
            let At = st.start * lt
              , Wn = (st.start + st.count) * lt;
            Ie !== null && (At = Math.max(At, Ie.start * lt),
            Wn = Math.min(Wn, (Ie.start + Ie.count) * lt)),
            Qe !== null ? (At = Math.max(At, 0),
            Wn = Math.min(Wn, Qe.count)) : ot != null && (At = Math.max(At, 0),
            Wn = Math.min(Wn, ot.count));
            const fn = Wn - At;
            if (fn < 0 || fn === 1 / 0)
                return;
            Fe.setup(te, ie, Xe, ne, Qe);
            let Ei, Bt = _e;
            if (Qe !== null && (Ei = Lt.get(Qe),
            Bt = fe,
            Bt.setIndex(Ei)),
            te.isMesh)
                ie.wireframe === !0 ? (qe.setLineWidth(ie.wireframeLinewidth * Je()),
                Bt.setMode(Q.LINES)) : Bt.setMode(Q.TRIANGLES);
            else if (te.isLine) {
                let nt = ie.linewidth;
                nt === void 0 && (nt = 1),
                qe.setLineWidth(nt * Je()),
                te.isLineSegments ? Bt.setMode(Q.LINES) : te.isLineLoop ? Bt.setMode(Q.LINE_LOOP) : Bt.setMode(Q.LINE_STRIP)
            } else
                te.isPoints ? Bt.setMode(Q.POINTS) : te.isSprite && Bt.setMode(Q.TRIANGLES);
            if (te.isBatchedMesh)
                Bt.renderMultiDraw(te._multiDrawStarts, te._multiDrawCounts, te._multiDrawCount);
            else if (te.isInstancedMesh)
                Bt.renderInstances(At, fn, te.count);
            else if (ne.isInstancedBufferGeometry) {
                const nt = ne._maxInstanceCount !== void 0 ? ne._maxInstanceCount : 1 / 0
                  , hs = Math.min(ne.instanceCount, nt);
                Bt.renderInstances(At, fn, hs)
            } else
                Bt.render(At, fn)
        }
        ;
        function He(U, $, ne) {
            U.transparent === !0 && U.side === mr && U.forceSinglePass === !1 ? (U.side = fi,
            U.needsUpdate = !0,
            wi(U, $, ne),
            U.side = xr,
            U.needsUpdate = !0,
            wi(U, $, ne),
            U.side = mr) : wi(U, $, ne)
        }
        this.compile = function(U, $, ne=null) {
            ne === null && (ne = U),
            v = be.get(ne),
            v.init(),
            b.push(v),
            ne.traverseVisible(function(te) {
                te.isLight && te.layers.test($.layers) && (v.pushLight(te),
                te.castShadow && v.pushShadow(te))
            }),
            U !== ne && U.traverseVisible(function(te) {
                te.isLight && te.layers.test($.layers) && (v.pushLight(te),
                te.castShadow && v.pushShadow(te))
            }),
            v.setupLights(T._useLegacyLights);
            const ie = new Set;
            return U.traverse(function(te) {
                const Ie = te.material;
                if (Ie)
                    if (Array.isArray(Ie))
                        for (let ke = 0; ke < Ie.length; ke++) {
                            const Xe = Ie[ke];
                            He(Xe, ne, te),
                            ie.add(Xe)
                        }
                    else
                        He(Ie, ne, te),
                        ie.add(Ie)
            }),
            b.pop(),
            v = null,
            ie
        }
        ,
        this.compileAsync = function(U, $, ne=null) {
            const ie = this.compile(U, $, ne);
            return new Promise(te=>{
                function Ie() {
                    if (ie.forEach(function(ke) {
                        tt.get(ke).currentProgram.isReady() && ie.delete(ke)
                    }),
                    ie.size === 0) {
                        te(U);
                        return
                    }
                    setTimeout(Ie, 10)
                }
                ze.get("KHR_parallel_shader_compile") !== null ? Ie() : setTimeout(Ie, 10)
            }
            )
        }
        ;
        let ut = null;
        function Ut(U) {
            ut && ut(U)
        }
        function Rn() {
            Cn.stop()
        }
        function Et() {
            Cn.start()
        }
        const Cn = new Fb;
        Cn.setAnimationLoop(Ut),
        typeof self < "u" && Cn.setContext(self),
        this.setAnimationLoop = function(U) {
            ut = U,
            Le.setAnimationLoop(U),
            U === null ? Cn.stop() : Cn.start()
        }
        ,
        Le.addEventListener("sessionstart", Rn),
        Le.addEventListener("sessionend", Et),
        this.render = function(U, $) {
            if ($ !== void 0 && $.isCamera !== !0) {
                console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
                return
            }
            if (S === !0)
                return;
            U.matrixWorldAutoUpdate === !0 && U.updateMatrixWorld(),
            $.parent === null && $.matrixWorldAutoUpdate === !0 && $.updateMatrixWorld(),
            Le.enabled === !0 && Le.isPresenting === !0 && (Le.cameraAutoUpdate === !0 && Le.updateCamera($),
            $ = Le.getCamera()),
            U.isScene === !0 && U.onBeforeRender(T, U, $, R),
            v = be.get(U, b.length),
            v.init(),
            b.push(v),
            De.multiplyMatrices($.projectionMatrix, $.matrixWorldInverse),
            oe.setFromProjectionMatrix(De),
            xe = this.localClippingEnabled,
            he = Ne.init(this.clippingPlanes, xe),
            y = pe.get(U, _.length),
            y.init(),
            _.push(y),
            _i(U, $, 0, T.sortObjects),
            y.finish(),
            T.sortObjects === !0 && y.sort(de, ae),
            this.info.render.frame++,
            he === !0 && Ne.beginShadows();
            const ne = v.state.shadowsArray;
            if (Me.render(ne, U, $),
            he === !0 && Ne.endShadows(),
            this.info.autoReset === !0 && this.info.reset(),
            Ae.render(y, U),
            v.setupLights(T._useLegacyLights),
            $.isArrayCamera) {
                const ie = $.cameras;
                for (let te = 0, Ie = ie.length; te < Ie; te++) {
                    const ke = ie[te];
                    Ho(y, U, ke, ke.viewport)
                }
            } else
                Ho(y, U, $);
            R !== null && (Ye.updateMultisampleRenderTarget(R),
            Ye.updateRenderTargetMipmap(R)),
            U.isScene === !0 && U.onAfterRender(T, U, $),
            Fe.resetDefaultState(),
            O = -1,
            w = null,
            b.pop(),
            b.length > 0 ? v = b[b.length - 1] : v = null,
            _.pop(),
            _.length > 0 ? y = _[_.length - 1] : y = null
        }
        ;
        function _i(U, $, ne, ie) {
            if (U.visible === !1)
                return;
            if (U.layers.test($.layers)) {
                if (U.isGroup)
                    ne = U.renderOrder;
                else if (U.isLOD)
                    U.autoUpdate === !0 && U.update($);
                else if (U.isLight)
                    v.pushLight(U),
                    U.castShadow && v.pushShadow(U);
                else if (U.isSprite) {
                    if (!U.frustumCulled || oe.intersectsSprite(U)) {
                        ie && Ze.setFromMatrixPosition(U.matrixWorld).applyMatrix4(De);
                        const ke = L.update(U)
                          , Xe = U.material;
                        Xe.visible && y.push(U, ke, Xe, ne, Ze.z, null)
                    }
                } else if ((U.isMesh || U.isLine || U.isPoints) && (!U.frustumCulled || oe.intersectsObject(U))) {
                    const ke = L.update(U)
                      , Xe = U.material;
                    if (ie && (U.boundingSphere !== void 0 ? (U.boundingSphere === null && U.computeBoundingSphere(),
                    Ze.copy(U.boundingSphere.center)) : (ke.boundingSphere === null && ke.computeBoundingSphere(),
                    Ze.copy(ke.boundingSphere.center)),
                    Ze.applyMatrix4(U.matrixWorld).applyMatrix4(De)),
                    Array.isArray(Xe)) {
                        const Qe = ke.groups;
                        for (let lt = 0, st = Qe.length; lt < st; lt++) {
                            const ot = Qe[lt]
                              , At = Xe[ot.materialIndex];
                            At && At.visible && y.push(U, ke, At, ne, Ze.z, ot)
                        }
                    } else
                        Xe.visible && y.push(U, ke, Xe, ne, Ze.z, null)
                }
            }
            const Ie = U.children;
            for (let ke = 0, Xe = Ie.length; ke < Xe; ke++)
                _i(Ie[ke], $, ne, ie)
        }
        function Ho(U, $, ne, ie) {
            const te = U.opaque
              , Ie = U.transmissive
              , ke = U.transparent;
            v.setupLightsView(ne),
            he === !0 && Ne.setGlobalState(T.clippingPlanes, ne),
            Ie.length > 0 && Sl(te, Ie, $, ne),
            ie && qe.viewport(I.copy(ie)),
            te.length > 0 && us(te, $, ne),
            Ie.length > 0 && us(Ie, $, ne),
            ke.length > 0 && us(ke, $, ne),
            qe.buffers.depth.setTest(!0),
            qe.buffers.depth.setMask(!0),
            qe.buffers.color.setMask(!0),
            qe.setPolygonOffset(!1)
        }
        function Sl(U, $, ne, ie) {
            if ((ne.isScene === !0 ? ne.overrideMaterial : null) !== null)
                return;
            const Ie = at.isWebGL2;
            Be === null && (Be = new vn(1,1,{
                generateMipmaps: !0,
                type: ze.has("EXT_color_buffer_half_float") ? Ur : Vn,
                minFilter: Do,
                samples: Ie ? 4 : 0
            })),
            T.getDrawingBufferSize(et),
            Ie ? Be.setSize(et.x, et.y) : Be.setSize(Zh(et.x), Zh(et.y));
            const ke = T.getRenderTarget();
            T.setRenderTarget(Be),
            T.getClearColor(q),
            F = T.getClearAlpha(),
            F < 1 && T.setClearColor(16777215, .5),
            T.clear();
            const Xe = T.toneMapping;
            T.toneMapping = Ns,
            us(U, ne, ie),
            Ye.updateMultisampleRenderTarget(Be),
            Ye.updateRenderTargetMipmap(Be);
            let Qe = !1;
            for (let lt = 0, st = $.length; lt < st; lt++) {
                const ot = $[lt]
                  , At = ot.object
                  , Wn = ot.geometry
                  , fn = ot.material
                  , Ei = ot.group;
                if (fn.side === mr && At.layers.test(ie.layers)) {
                    const Bt = fn.side;
                    fn.side = fi,
                    fn.needsUpdate = !0,
                    Vo(At, ne, ie, Wn, fn, Ei),
                    fn.side = Bt,
                    fn.needsUpdate = !0,
                    Qe = !0
                }
            }
            Qe === !0 && (Ye.updateMultisampleRenderTarget(Be),
            Ye.updateRenderTargetMipmap(Be)),
            T.setRenderTarget(ke),
            T.setClearColor(q, F),
            T.toneMapping = Xe
        }
        function us(U, $, ne) {
            const ie = $.isScene === !0 ? $.overrideMaterial : null;
            for (let te = 0, Ie = U.length; te < Ie; te++) {
                const ke = U[te]
                  , Xe = ke.object
                  , Qe = ke.geometry
                  , lt = ie === null ? ke.material : ie
                  , st = ke.group;
                Xe.layers.test(ne.layers) && Vo(Xe, $, ne, Qe, lt, st)
            }
        }
        function Vo(U, $, ne, ie, te, Ie) {
            U.onBeforeRender(T, $, ne, ie, te, Ie),
            U.modelViewMatrix.multiplyMatrices(ne.matrixWorldInverse, U.matrixWorld),
            U.normalMatrix.getNormalMatrix(U.modelViewMatrix),
            te.onBeforeRender(T, $, ne, ie, U, Ie),
            te.transparent === !0 && te.side === mr && te.forceSinglePass === !1 ? (te.side = fi,
            te.needsUpdate = !0,
            T.renderBufferDirect(ne, $, ie, te, U, Ie),
            te.side = xr,
            te.needsUpdate = !0,
            T.renderBufferDirect(ne, $, ie, te, U, Ie),
            te.side = mr) : T.renderBufferDirect(ne, $, ie, te, U, Ie),
            U.onAfterRender(T, $, ne, ie, te, Ie)
        }
        function wi(U, $, ne) {
            $.isScene !== !0 && ($ = We);
            const ie = tt.get(U)
              , te = v.state.lights
              , Ie = v.state.shadowsArray
              , ke = te.state.version
              , Xe = ee.getParameters(U, te.state, Ie, $, ne)
              , Qe = ee.getProgramCacheKey(Xe);
            let lt = ie.programs;
            ie.environment = U.isMeshStandardMaterial ? $.environment : null,
            ie.fog = $.fog,
            ie.envMap = (U.isMeshStandardMaterial ? on : dt).get(U.envMap || ie.environment),
            lt === void 0 && (U.addEventListener("dispose", me),
            lt = new Map,
            ie.programs = lt);
            let st = lt.get(Qe);
            if (st !== void 0) {
                if (ie.currentProgram === st && ie.lightsStateVersion === ke)
                    return Go(U, Xe),
                    st
            } else
                Xe.uniforms = ee.getUniforms(U),
                U.onBuild(ne, Xe, T),
                U.onBeforeCompile(Xe, T),
                st = ee.acquireProgram(Xe, Qe),
                lt.set(Qe, st),
                ie.uniforms = Xe.uniforms;
            const ot = ie.uniforms;
            return (!U.isShaderMaterial && !U.isRawShaderMaterial || U.clipping === !0) && (ot.clippingPlanes = Ne.uniform),
            Go(U, Xe),
            ie.needsLights = wl(U),
            ie.lightsStateVersion = ke,
            ie.needsLights && (ot.ambientLightColor.value = te.state.ambient,
            ot.lightProbe.value = te.state.probe,
            ot.directionalLights.value = te.state.directional,
            ot.directionalLightShadows.value = te.state.directionalShadow,
            ot.spotLights.value = te.state.spot,
            ot.spotLightShadows.value = te.state.spotShadow,
            ot.rectAreaLights.value = te.state.rectArea,
            ot.ltc_1.value = te.state.rectAreaLTC1,
            ot.ltc_2.value = te.state.rectAreaLTC2,
            ot.pointLights.value = te.state.point,
            ot.pointLightShadows.value = te.state.pointShadow,
            ot.hemisphereLights.value = te.state.hemi,
            ot.directionalShadowMap.value = te.state.directionalShadowMap,
            ot.directionalShadowMatrix.value = te.state.directionalShadowMatrix,
            ot.spotShadowMap.value = te.state.spotShadowMap,
            ot.spotLightMatrix.value = te.state.spotLightMatrix,
            ot.spotLightMap.value = te.state.spotLightMap,
            ot.pointShadowMap.value = te.state.pointShadowMap,
            ot.pointShadowMatrix.value = te.state.pointShadowMatrix),
            ie.currentProgram = st,
            ie.uniformsList = null,
            st
        }
        function Vs(U) {
            if (U.uniformsList === null) {
                const $ = U.currentProgram.getUniforms();
                U.uniformsList = Oh.seqWithValue($.seq, U.uniforms)
            }
            return U.uniformsList
        }
        function Go(U, $) {
            const ne = tt.get(U);
            ne.outputColorSpace = $.outputColorSpace,
            ne.batching = $.batching,
            ne.instancing = $.instancing,
            ne.instancingColor = $.instancingColor,
            ne.skinning = $.skinning,
            ne.morphTargets = $.morphTargets,
            ne.morphNormals = $.morphNormals,
            ne.morphColors = $.morphColors,
            ne.morphTargetsCount = $.morphTargetsCount,
            ne.numClippingPlanes = $.numClippingPlanes,
            ne.numIntersection = $.numClipIntersection,
            ne.vertexAlphas = $.vertexAlphas,
            ne.vertexTangents = $.vertexTangents,
            ne.toneMapping = $.toneMapping
        }
        function Ml(U, $, ne, ie, te) {
            $.isScene !== !0 && ($ = We),
            Ye.resetTextureUnits();
            const Ie = $.fog
              , ke = ie.isMeshStandardMaterial ? $.environment : null
              , Xe = R === null ? T.outputColorSpace : R.isXRRenderTarget === !0 ? R.texture.colorSpace : gn
              , Qe = (ie.isMeshStandardMaterial ? on : dt).get(ie.envMap || ke)
              , lt = ie.vertexColors === !0 && !!ne.attributes.color && ne.attributes.color.itemSize === 4
              , st = !!ne.attributes.tangent && (!!ie.normalMap || ie.anisotropy > 0)
              , ot = !!ne.morphAttributes.position
              , At = !!ne.morphAttributes.normal
              , Wn = !!ne.morphAttributes.color;
            let fn = Ns;
            ie.toneMapped && (R === null || R.isXRRenderTarget === !0) && (fn = T.toneMapping);
            const Ei = ne.morphAttributes.position || ne.morphAttributes.normal || ne.morphAttributes.color
              , Bt = Ei !== void 0 ? Ei.length : 0
              , nt = tt.get(ie)
              , hs = v.state.lights;
            if (he === !0 && (xe === !0 || U !== w)) {
                const Yn = U === w && ie.id === O;
                Ne.setState(ie, U, Yn)
            }
            let Gt = !1;
            ie.version === nt.__version ? (nt.needsLights && nt.lightsStateVersion !== hs.state.version || nt.outputColorSpace !== Xe || te.isBatchedMesh && nt.batching === !1 || !te.isBatchedMesh && nt.batching === !0 || te.isInstancedMesh && nt.instancing === !1 || !te.isInstancedMesh && nt.instancing === !0 || te.isSkinnedMesh && nt.skinning === !1 || !te.isSkinnedMesh && nt.skinning === !0 || te.isInstancedMesh && nt.instancingColor === !0 && te.instanceColor === null || te.isInstancedMesh && nt.instancingColor === !1 && te.instanceColor !== null || nt.envMap !== Qe || ie.fog === !0 && nt.fog !== Ie || nt.numClippingPlanes !== void 0 && (nt.numClippingPlanes !== Ne.numPlanes || nt.numIntersection !== Ne.numIntersection) || nt.vertexAlphas !== lt || nt.vertexTangents !== st || nt.morphTargets !== ot || nt.morphNormals !== At || nt.morphColors !== Wn || nt.toneMapping !== fn || at.isWebGL2 === !0 && nt.morphTargetsCount !== Bt) && (Gt = !0) : (Gt = !0,
            nt.__version = ie.version);
            let sr = nt.currentProgram;
            Gt === !0 && (sr = wi(ie, $, te));
            let Br = !1
              , or = !1
              , Gs = !1;
            const an = sr.getUniforms()
              , ar = nt.uniforms;
            if (qe.useProgram(sr.program) && (Br = !0,
            or = !0,
            Gs = !0),
            ie.id !== O && (O = ie.id,
            or = !0),
            Br || w !== U) {
                an.setValue(Q, "projectionMatrix", U.projectionMatrix),
                an.setValue(Q, "viewMatrix", U.matrixWorldInverse);
                const Yn = an.map.cameraPosition;
                Yn !== void 0 && Yn.setValue(Q, Ze.setFromMatrixPosition(U.matrixWorld)),
                at.logarithmicDepthBuffer && an.setValue(Q, "logDepthBufFC", 2 / (Math.log(U.far + 1) / Math.LN2)),
                (ie.isMeshPhongMaterial || ie.isMeshToonMaterial || ie.isMeshLambertMaterial || ie.isMeshBasicMaterial || ie.isMeshStandardMaterial || ie.isShaderMaterial) && an.setValue(Q, "isOrthographic", U.isOrthographicCamera === !0),
                w !== U && (w = U,
                or = !0,
                Gs = !0)
            }
            if (te.isSkinnedMesh) {
                an.setOptional(Q, te, "bindMatrix"),
                an.setOptional(Q, te, "bindMatrixInverse");
                const Yn = te.skeleton;
                Yn && (at.floatVertexTextures ? (Yn.boneTexture === null && Yn.computeBoneTexture(),
                an.setValue(Q, "boneTexture", Yn.boneTexture, Ye)) : console.warn("THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."))
            }
            te.isBatchedMesh && (an.setOptional(Q, te, "batchingTexture"),
            an.setValue(Q, "batchingTexture", te._matricesTexture, Ye));
            const Ws = ne.morphAttributes;
            if ((Ws.position !== void 0 || Ws.normal !== void 0 || Ws.color !== void 0 && at.isWebGL2 === !0) && G.update(te, ne, sr),
            (or || nt.receiveShadow !== te.receiveShadow) && (nt.receiveShadow = te.receiveShadow,
            an.setValue(Q, "receiveShadow", te.receiveShadow)),
            ie.isMeshGouraudMaterial && ie.envMap !== null && (ar.envMap.value = Qe,
            ar.flipEnvMap.value = Qe.isCubeTexture && Qe.isRenderTargetTexture === !1 ? -1 : 1),
            or && (an.setValue(Q, "toneMappingExposure", T.toneMappingExposure),
            nt.needsLights && rr(ar, Gs),
            Ie && ie.fog === !0 && Te.refreshFogUniforms(ar, Ie),
            Te.refreshMaterialUniforms(ar, ie, J, K, Be),
            Oh.upload(Q, Vs(nt), ar, Ye)),
            ie.isShaderMaterial && ie.uniformsNeedUpdate === !0 && (Oh.upload(Q, Vs(nt), ar, Ye),
            ie.uniformsNeedUpdate = !1),
            ie.isSpriteMaterial && an.setValue(Q, "center", te.center),
            an.setValue(Q, "modelViewMatrix", te.modelViewMatrix),
            an.setValue(Q, "normalMatrix", te.normalMatrix),
            an.setValue(Q, "modelMatrix", te.matrixWorld),
            ie.isShaderMaterial || ie.isRawShaderMaterial) {
                const Yn = ie.uniformsGroups;
                for (let js = 0, El = Yn.length; js < El; js++)
                    if (at.isWebGL2) {
                        const lr = Yn[js];
                        Ge.update(lr, sr),
                        Ge.bind(lr, sr)
                    } else
                        console.warn("THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2.")
            }
            return sr
        }
        function rr(U, $) {
            U.ambientLightColor.needsUpdate = $,
            U.lightProbe.needsUpdate = $,
            U.directionalLights.needsUpdate = $,
            U.directionalLightShadows.needsUpdate = $,
            U.pointLights.needsUpdate = $,
            U.pointLightShadows.needsUpdate = $,
            U.spotLights.needsUpdate = $,
            U.spotLightShadows.needsUpdate = $,
            U.rectAreaLights.needsUpdate = $,
            U.hemisphereLights.needsUpdate = $
        }
        function wl(U) {
            return U.isMeshLambertMaterial || U.isMeshToonMaterial || U.isMeshPhongMaterial || U.isMeshStandardMaterial || U.isShadowMaterial || U.isShaderMaterial && U.lights === !0
        }
        this.getActiveCubeFace = function() {
            return E
        }
        ,
        this.getActiveMipmapLevel = function() {
            return P
        }
        ,
        this.getRenderTarget = function() {
            return R
        }
        ,
        this.setRenderTargetTextures = function(U, $, ne) {
            tt.get(U.texture).__webglTexture = $,
            tt.get(U.depthTexture).__webglTexture = ne;
            const ie = tt.get(U);
            ie.__hasExternalTextures = !0,
            ie.__hasExternalTextures && (ie.__autoAllocateDepthBuffer = ne === void 0,
            ie.__autoAllocateDepthBuffer || ze.has("WEBGL_multisampled_render_to_texture") === !0 && (console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"),
            ie.__useRenderToTexture = !1))
        }
        ,
        this.setRenderTargetFramebuffer = function(U, $) {
            const ne = tt.get(U);
            ne.__webglFramebuffer = $,
            ne.__useDefaultFramebuffer = $ === void 0
        }
        ,
        this.setRenderTarget = function(U, $=0, ne=0) {
            R = U,
            E = $,
            P = ne;
            let ie = !0
              , te = null
              , Ie = !1
              , ke = !1;
            if (U) {
                const Qe = tt.get(U);
                Qe.__useDefaultFramebuffer !== void 0 ? (qe.bindFramebuffer(Q.FRAMEBUFFER, null),
                ie = !1) : Qe.__webglFramebuffer === void 0 ? Ye.setupRenderTarget(U) : Qe.__hasExternalTextures && Ye.rebindTextures(U, tt.get(U.texture).__webglTexture, tt.get(U.depthTexture).__webglTexture);
                const lt = U.texture;
                (lt.isData3DTexture || lt.isDataArrayTexture || lt.isCompressedArrayTexture) && (ke = !0);
                const st = tt.get(U).__webglFramebuffer;
                U.isWebGLCubeRenderTarget ? (Array.isArray(st[$]) ? te = st[$][ne] : te = st[$],
                Ie = !0) : at.isWebGL2 && U.samples > 0 && Ye.useMultisampledRTT(U) === !1 ? te = tt.get(U).__webglMultisampledFramebuffer : Array.isArray(st) ? te = st[ne] : te = st,
                I.copy(U.viewport),
                V.copy(U.scissor),
                z = U.scissorTest
            } else
                I.copy(ue).multiplyScalar(J).floor(),
                V.copy(ge).multiplyScalar(J).floor(),
                z = Ee;
            if (qe.bindFramebuffer(Q.FRAMEBUFFER, te) && at.drawBuffers && ie && qe.drawBuffers(U, te),
            qe.viewport(I),
            qe.scissor(V),
            qe.setScissorTest(z),
            Ie) {
                const Qe = tt.get(U.texture);
                Q.framebufferTexture2D(Q.FRAMEBUFFER, Q.COLOR_ATTACHMENT0, Q.TEXTURE_CUBE_MAP_POSITIVE_X + $, Qe.__webglTexture, ne)
            } else if (ke) {
                const Qe = tt.get(U.texture)
                  , lt = $ || 0;
                Q.framebufferTextureLayer(Q.FRAMEBUFFER, Q.COLOR_ATTACHMENT0, Qe.__webglTexture, ne || 0, lt)
            }
            O = -1
        }
        ,
        this.readRenderTargetPixels = function(U, $, ne, ie, te, Ie, ke) {
            if (!(U && U.isWebGLRenderTarget)) {
                console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
                return
            }
            let Xe = tt.get(U).__webglFramebuffer;
            if (U.isWebGLCubeRenderTarget && ke !== void 0 && (Xe = Xe[ke]),
            Xe) {
                qe.bindFramebuffer(Q.FRAMEBUFFER, Xe);
                try {
                    const Qe = U.texture
                      , lt = Qe.format
                      , st = Qe.type;
                    if (lt !== Kn && je.convert(lt) !== Q.getParameter(Q.IMPLEMENTATION_COLOR_READ_FORMAT)) {
                        console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                        return
                    }
                    const ot = st === Ur && (ze.has("EXT_color_buffer_half_float") || at.isWebGL2 && ze.has("EXT_color_buffer_float"));
                    if (st !== Vn && je.convert(st) !== Q.getParameter(Q.IMPLEMENTATION_COLOR_READ_TYPE) && !(st === wn && (at.isWebGL2 || ze.has("OES_texture_float") || ze.has("WEBGL_color_buffer_float"))) && !ot) {
                        console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                        return
                    }
                    $ >= 0 && $ <= U.width - ie && ne >= 0 && ne <= U.height - te && Q.readPixels($, ne, ie, te, je.convert(lt), je.convert(st), Ie)
                } finally {
                    const Qe = R !== null ? tt.get(R).__webglFramebuffer : null;
                    qe.bindFramebuffer(Q.FRAMEBUFFER, Qe)
                }
            }
        }
        ,
        this.copyFramebufferToTexture = function(U, $, ne=0) {
            const ie = Math.pow(2, -ne)
              , te = Math.floor($.image.width * ie)
              , Ie = Math.floor($.image.height * ie);
            Ye.setTexture2D($, 0),
            Q.copyTexSubImage2D(Q.TEXTURE_2D, ne, 0, 0, U.x, U.y, te, Ie),
            qe.unbindTexture()
        }
        ,
        this.copyTextureToTexture = function(U, $, ne, ie=0) {
            const te = $.image.width
              , Ie = $.image.height
              , ke = je.convert(ne.format)
              , Xe = je.convert(ne.type);
            Ye.setTexture2D(ne, 0),
            Q.pixelStorei(Q.UNPACK_FLIP_Y_WEBGL, ne.flipY),
            Q.pixelStorei(Q.UNPACK_PREMULTIPLY_ALPHA_WEBGL, ne.premultiplyAlpha),
            Q.pixelStorei(Q.UNPACK_ALIGNMENT, ne.unpackAlignment),
            $.isDataTexture ? Q.texSubImage2D(Q.TEXTURE_2D, ie, U.x, U.y, te, Ie, ke, Xe, $.image.data) : $.isCompressedTexture ? Q.compressedTexSubImage2D(Q.TEXTURE_2D, ie, U.x, U.y, $.mipmaps[0].width, $.mipmaps[0].height, ke, $.mipmaps[0].data) : Q.texSubImage2D(Q.TEXTURE_2D, ie, U.x, U.y, ke, Xe, $.image),
            ie === 0 && ne.generateMipmaps && Q.generateMipmap(Q.TEXTURE_2D),
            qe.unbindTexture()
        }
        ,
        this.copyTextureToTexture3D = function(U, $, ne, ie, te=0) {
            if (T.isWebGL1Renderer) {
                console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
                return
            }
            const Ie = U.max.x - U.min.x + 1
              , ke = U.max.y - U.min.y + 1
              , Xe = U.max.z - U.min.z + 1
              , Qe = je.convert(ie.format)
              , lt = je.convert(ie.type);
            let st;
            if (ie.isData3DTexture)
                Ye.setTexture3D(ie, 0),
                st = Q.TEXTURE_3D;
            else if (ie.isDataArrayTexture)
                Ye.setTexture2DArray(ie, 0),
                st = Q.TEXTURE_2D_ARRAY;
            else {
                console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
                return
            }
            Q.pixelStorei(Q.UNPACK_FLIP_Y_WEBGL, ie.flipY),
            Q.pixelStorei(Q.UNPACK_PREMULTIPLY_ALPHA_WEBGL, ie.premultiplyAlpha),
            Q.pixelStorei(Q.UNPACK_ALIGNMENT, ie.unpackAlignment);
            const ot = Q.getParameter(Q.UNPACK_ROW_LENGTH)
              , At = Q.getParameter(Q.UNPACK_IMAGE_HEIGHT)
              , Wn = Q.getParameter(Q.UNPACK_SKIP_PIXELS)
              , fn = Q.getParameter(Q.UNPACK_SKIP_ROWS)
              , Ei = Q.getParameter(Q.UNPACK_SKIP_IMAGES)
              , Bt = ne.isCompressedTexture ? ne.mipmaps[0] : ne.image;
            Q.pixelStorei(Q.UNPACK_ROW_LENGTH, Bt.width),
            Q.pixelStorei(Q.UNPACK_IMAGE_HEIGHT, Bt.height),
            Q.pixelStorei(Q.UNPACK_SKIP_PIXELS, U.min.x),
            Q.pixelStorei(Q.UNPACK_SKIP_ROWS, U.min.y),
            Q.pixelStorei(Q.UNPACK_SKIP_IMAGES, U.min.z),
            ne.isDataTexture || ne.isData3DTexture ? Q.texSubImage3D(st, te, $.x, $.y, $.z, Ie, ke, Xe, Qe, lt, Bt.data) : ne.isCompressedArrayTexture ? (console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."),
            Q.compressedTexSubImage3D(st, te, $.x, $.y, $.z, Ie, ke, Xe, Qe, Bt.data)) : Q.texSubImage3D(st, te, $.x, $.y, $.z, Ie, ke, Xe, Qe, lt, Bt),
            Q.pixelStorei(Q.UNPACK_ROW_LENGTH, ot),
            Q.pixelStorei(Q.UNPACK_IMAGE_HEIGHT, At),
            Q.pixelStorei(Q.UNPACK_SKIP_PIXELS, Wn),
            Q.pixelStorei(Q.UNPACK_SKIP_ROWS, fn),
            Q.pixelStorei(Q.UNPACK_SKIP_IMAGES, Ei),
            te === 0 && ie.generateMipmaps && Q.generateMipmap(st),
            qe.unbindTexture()
        }
        ,
        this.initTexture = function(U) {
            U.isCubeTexture ? Ye.setTextureCube(U, 0) : U.isData3DTexture ? Ye.setTexture3D(U, 0) : U.isDataArrayTexture || U.isCompressedArrayTexture ? Ye.setTexture2DArray(U, 0) : Ye.setTexture2D(U, 0),
            qe.unbindTexture()
        }
        ,
        this.resetState = function() {
            E = 0,
            P = 0,
            R = null,
            qe.reset(),
            Fe.reset()
        }
        ,
        typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{
            detail: this
        }))
    }
    get coordinateSystem() {
        return is
    }
    get outputColorSpace() {
        return this._outputColorSpace
    }
    set outputColorSpace(e) {
        this._outputColorSpace = e;
        const t = this.getContext();
        t.drawingBufferColorSpace = e === C_ ? "display-p3" : "srgb",
        t.unpackColorSpace = Rt.workingColorSpace === pf ? "display-p3" : "srgb"
    }
    get physicallyCorrectLights() {
        return console.warn("THREE.WebGLRenderer: The property .physicallyCorrectLights has been removed. Set renderer.useLegacyLights instead."),
        !this.useLegacyLights
    }
    set physicallyCorrectLights(e) {
        console.warn("THREE.WebGLRenderer: The property .physicallyCorrectLights has been removed. Set renderer.useLegacyLights instead."),
        this.useLegacyLights = !e
    }
    get outputEncoding() {
        return console.warn("THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead."),
        this.outputColorSpace === Ft ? Dr : df
    }
    set outputEncoding(e) {
        console.warn("THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead."),
        this.outputColorSpace = e === Dr ? Ft : gn
    }
    get useLegacyLights() {
        return console.warn("THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."),
        this._useLegacyLights
    }
    set useLegacyLights(e) {
        console.warn("THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."),
        this._useLegacyLights = e
    }
}
class _3 extends Gb {
}
_3.prototype.isWebGL1Renderer = !0;
class jm extends Yt {
    constructor() {
        super(),
        this.isScene = !0,
        this.type = "Scene",
        this.background = null,
        this.environment = null,
        this.fog = null,
        this.backgroundBlurriness = 0,
        this.backgroundIntensity = 1,
        this.overrideMaterial = null,
        typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{
            detail: this
        }))
    }
    copy(e, t) {
        return super.copy(e, t),
        e.background !== null && (this.background = e.background.clone()),
        e.environment !== null && (this.environment = e.environment.clone()),
        e.fog !== null && (this.fog = e.fog.clone()),
        this.backgroundBlurriness = e.backgroundBlurriness,
        this.backgroundIntensity = e.backgroundIntensity,
        e.overrideMaterial !== null && (this.overrideMaterial = e.overrideMaterial.clone()),
        this.matrixAutoUpdate = e.matrixAutoUpdate,
        this
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return this.fog !== null && (t.object.fog = this.fog.toJSON()),
        this.backgroundBlurriness > 0 && (t.object.backgroundBlurriness = this.backgroundBlurriness),
        this.backgroundIntensity !== 1 && (t.object.backgroundIntensity = this.backgroundIntensity),
        t
    }
}
class g3 {
    constructor(e, t) {
        this.isInterleavedBuffer = !0,
        this.array = e,
        this.stride = t,
        this.count = e !== void 0 ? e.length / t : 0,
        this.usage = zm,
        this._updateRange = {
            offset: 0,
            count: -1
        },
        this.updateRanges = [],
        this.version = 0,
        this.uuid = vr()
    }
    onUploadCallback() {}
    set needsUpdate(e) {
        e === !0 && this.version++
    }
    get updateRange() {
        return console.warn('THREE.InterleavedBuffer: "updateRange" is deprecated and removed in r169. Use "addUpdateRange()" instead.'),
        this._updateRange
    }
    setUsage(e) {
        return this.usage = e,
        this
    }
    addUpdateRange(e, t) {
        this.updateRanges.push({
            start: e,
            count: t
        })
    }
    clearUpdateRanges() {
        this.updateRanges.length = 0
    }
    copy(e) {
        return this.array = new e.array.constructor(e.array),
        this.count = e.count,
        this.stride = e.stride,
        this.usage = e.usage,
        this
    }
    copyAt(e, t, n) {
        e *= this.stride,
        n *= t.stride;
        for (let i = 0, s = this.stride; i < s; i++)
            this.array[e + i] = t.array[n + i];
        return this
    }
    set(e, t=0) {
        return this.array.set(e, t),
        this
    }
    clone(e) {
        e.arrayBuffers === void 0 && (e.arrayBuffers = {}),
        this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = vr()),
        e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
        const t = new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid])
          , n = new this.constructor(t,this.stride);
        return n.setUsage(this.usage),
        n
    }
    onUpload(e) {
        return this.onUploadCallback = e,
        this
    }
    toJSON(e) {
        return e.arrayBuffers === void 0 && (e.arrayBuffers = {}),
        this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = vr()),
        e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer))),
        {
            uuid: this.uuid,
            buffer: this.array.buffer._uuid,
            type: this.array.constructor.name,
            stride: this.stride
        }
    }
}
const ai = new k;
class B_ {
    constructor(e, t, n, i=!1) {
        this.isInterleavedBufferAttribute = !0,
        this.name = "",
        this.data = e,
        this.itemSize = t,
        this.offset = n,
        this.normalized = i
    }
    get count() {
        return this.data.count
    }
    get array() {
        return this.data.array
    }
    set needsUpdate(e) {
        this.data.needsUpdate = e
    }
    applyMatrix4(e) {
        for (let t = 0, n = this.data.count; t < n; t++)
            ai.fromBufferAttribute(this, t),
            ai.applyMatrix4(e),
            this.setXYZ(t, ai.x, ai.y, ai.z);
        return this
    }
    applyNormalMatrix(e) {
        for (let t = 0, n = this.count; t < n; t++)
            ai.fromBufferAttribute(this, t),
            ai.applyNormalMatrix(e),
            this.setXYZ(t, ai.x, ai.y, ai.z);
        return this
    }
    transformDirection(e) {
        for (let t = 0, n = this.count; t < n; t++)
            ai.fromBufferAttribute(this, t),
            ai.transformDirection(e),
            this.setXYZ(t, ai.x, ai.y, ai.z);
        return this
    }
    setX(e, t) {
        return this.normalized && (t = Nt(t, this.array)),
        this.data.array[e * this.data.stride + this.offset] = t,
        this
    }
    setY(e, t) {
        return this.normalized && (t = Nt(t, this.array)),
        this.data.array[e * this.data.stride + this.offset + 1] = t,
        this
    }
    setZ(e, t) {
        return this.normalized && (t = Nt(t, this.array)),
        this.data.array[e * this.data.stride + this.offset + 2] = t,
        this
    }
    setW(e, t) {
        return this.normalized && (t = Nt(t, this.array)),
        this.data.array[e * this.data.stride + this.offset + 3] = t,
        this
    }
    getX(e) {
        let t = this.data.array[e * this.data.stride + this.offset];
        return this.normalized && (t = Rr(t, this.array)),
        t
    }
    getY(e) {
        let t = this.data.array[e * this.data.stride + this.offset + 1];
        return this.normalized && (t = Rr(t, this.array)),
        t
    }
    getZ(e) {
        let t = this.data.array[e * this.data.stride + this.offset + 2];
        return this.normalized && (t = Rr(t, this.array)),
        t
    }
    getW(e) {
        let t = this.data.array[e * this.data.stride + this.offset + 3];
        return this.normalized && (t = Rr(t, this.array)),
        t
    }
    setXY(e, t, n) {
        return e = e * this.data.stride + this.offset,
        this.normalized && (t = Nt(t, this.array),
        n = Nt(n, this.array)),
        this.data.array[e + 0] = t,
        this.data.array[e + 1] = n,
        this
    }
    setXYZ(e, t, n, i) {
        return e = e * this.data.stride + this.offset,
        this.normalized && (t = Nt(t, this.array),
        n = Nt(n, this.array),
        i = Nt(i, this.array)),
        this.data.array[e + 0] = t,
        this.data.array[e + 1] = n,
        this.data.array[e + 2] = i,
        this
    }
    setXYZW(e, t, n, i, s) {
        return e = e * this.data.stride + this.offset,
        this.normalized && (t = Nt(t, this.array),
        n = Nt(n, this.array),
        i = Nt(i, this.array),
        s = Nt(s, this.array)),
        this.data.array[e + 0] = t,
        this.data.array[e + 1] = n,
        this.data.array[e + 2] = i,
        this.data.array[e + 3] = s,
        this
    }
    clone(e) {
        if (e === void 0) {
            console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");
            const t = [];
            for (let n = 0; n < this.count; n++) {
                const i = n * this.data.stride + this.offset;
                for (let s = 0; s < this.itemSize; s++)
                    t.push(this.data.array[i + s])
            }
            return new pt(new this.array.constructor(t),this.itemSize,this.normalized)
        } else
            return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}),
            e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)),
            new B_(e.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)
    }
    toJSON(e) {
        if (e === void 0) {
            console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");
            const t = [];
            for (let n = 0; n < this.count; n++) {
                const i = n * this.data.stride + this.offset;
                for (let s = 0; s < this.itemSize; s++)
                    t.push(this.data.array[i + s])
            }
            return {
                itemSize: this.itemSize,
                type: this.array.constructor.name,
                array: t,
                normalized: this.normalized
            }
        } else
            return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}),
            e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)),
            {
                isInterleavedBufferAttribute: !0,
                itemSize: this.itemSize,
                data: this.data.uuid,
                offset: this.offset,
                normalized: this.normalized
            }
    }
}
const Uy = new k
  , Ny = new Ct
  , Fy = new Ct
  , v3 = new k
  , By = new it
  , th = new k
  , kp = new Mr
  , ky = new it
  , zp = new Bo;
class Wb extends en {
    constructor(e, t) {
        super(e, t),
        this.isSkinnedMesh = !0,
        this.type = "SkinnedMesh",
        this.bindMode = b0,
        this.bindMatrix = new it,
        this.bindMatrixInverse = new it,
        this.boundingBox = null,
        this.boundingSphere = null
    }
    computeBoundingBox() {
        const e = this.geometry;
        this.boundingBox === null && (this.boundingBox = new yn),
        this.boundingBox.makeEmpty();
        const t = e.getAttribute("position");
        for (let n = 0; n < t.count; n++)
            this.getVertexPosition(n, th),
            this.boundingBox.expandByPoint(th)
    }
    computeBoundingSphere() {
        const e = this.geometry;
        this.boundingSphere === null && (this.boundingSphere = new Mr),
        this.boundingSphere.makeEmpty();
        const t = e.getAttribute("position");
        for (let n = 0; n < t.count; n++)
            this.getVertexPosition(n, th),
            this.boundingSphere.expandByPoint(th)
    }
    copy(e, t) {
        return super.copy(e, t),
        this.bindMode = e.bindMode,
        this.bindMatrix.copy(e.bindMatrix),
        this.bindMatrixInverse.copy(e.bindMatrixInverse),
        this.skeleton = e.skeleton,
        e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()),
        e.boundingSphere !== null && (this.boundingSphere = e.boundingSphere.clone()),
        this
    }
    raycast(e, t) {
        const n = this.material
          , i = this.matrixWorld;
        n !== void 0 && (this.boundingSphere === null && this.computeBoundingSphere(),
        kp.copy(this.boundingSphere),
        kp.applyMatrix4(i),
        e.ray.intersectsSphere(kp) !== !1 && (ky.copy(i).invert(),
        zp.copy(e.ray).applyMatrix4(ky),
        !(this.boundingBox !== null && zp.intersectsBox(this.boundingBox) === !1) && this._computeIntersections(e, t, zp)))
    }
    getVertexPosition(e, t) {
        return super.getVertexPosition(e, t),
        this.applyBoneTransform(e, t),
        t
    }
    bind(e, t) {
        this.skeleton = e,
        t === void 0 && (this.updateMatrixWorld(!0),
        this.skeleton.calculateInverses(),
        t = this.matrixWorld),
        this.bindMatrix.copy(t),
        this.bindMatrixInverse.copy(t).invert()
    }
    pose() {
        this.skeleton.pose()
    }
    normalizeSkinWeights() {
        const e = new Ct
          , t = this.geometry.attributes.skinWeight;
        for (let n = 0, i = t.count; n < i; n++) {
            e.fromBufferAttribute(t, n);
            const s = 1 / e.manhattanLength();
            s !== 1 / 0 ? e.multiplyScalar(s) : e.set(1, 0, 0, 0),
            t.setXYZW(n, e.x, e.y, e.z, e.w)
        }
    }
    updateMatrixWorld(e) {
        super.updateMatrixWorld(e),
        this.bindMode === b0 ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : this.bindMode === LL ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
    }
    applyBoneTransform(e, t) {
        const n = this.skeleton
          , i = this.geometry;
        Ny.fromBufferAttribute(i.attributes.skinIndex, e),
        Fy.fromBufferAttribute(i.attributes.skinWeight, e),
        Uy.copy(t).applyMatrix4(this.bindMatrix),
        t.set(0, 0, 0);
        for (let s = 0; s < 4; s++) {
            const o = Fy.getComponent(s);
            if (o !== 0) {
                const a = Ny.getComponent(s);
                By.multiplyMatrices(n.bones[a].matrixWorld, n.boneInverses[a]),
                t.addScaledVector(v3.copy(Uy).applyMatrix4(By), o)
            }
        }
        return t.applyMatrix4(this.bindMatrixInverse)
    }
    boneTransform(e, t) {
        return console.warn("THREE.SkinnedMesh: .boneTransform() was renamed to .applyBoneTransform() in r151."),
        this.applyBoneTransform(e, t)
    }
}
class jb extends Yt {
    constructor() {
        super(),
        this.isBone = !0,
        this.type = "Bone"
    }
}
class Xb extends Pn {
    constructor(e=null, t=1, n=1, i, s, o, a, c, h=Jt, d=Jt, l, f) {
        super(null, o, a, c, h, d, i, s, l, f),
        this.isDataTexture = !0,
        this.image = {
            data: e,
            width: t,
            height: n
        },
        this.generateMipmaps = !1,
        this.flipY = !1,
        this.unpackAlignment = 1
    }
}
const zy = new it
  , y3 = new it;
class k_ {
    constructor(e=[], t=[]) {
        this.uuid = vr(),
        this.bones = e.slice(0),
        this.boneInverses = t,
        this.boneMatrices = null,
        this.boneTexture = null,
        this.init()
    }
    init() {
        const e = this.bones
          , t = this.boneInverses;
        if (this.boneMatrices = new Float32Array(e.length * 16),
        t.length === 0)
            this.calculateInverses();
        else if (e.length !== t.length) {
            console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."),
            this.boneInverses = [];
            for (let n = 0, i = this.bones.length; n < i; n++)
                this.boneInverses.push(new it)
        }
    }
    calculateInverses() {
        this.boneInverses.length = 0;
        for (let e = 0, t = this.bones.length; e < t; e++) {
            const n = new it;
            this.bones[e] && n.copy(this.bones[e].matrixWorld).invert(),
            this.boneInverses.push(n)
        }
    }
    pose() {
        for (let e = 0, t = this.bones.length; e < t; e++) {
            const n = this.bones[e];
            n && n.matrixWorld.copy(this.boneInverses[e]).invert()
        }
        for (let e = 0, t = this.bones.length; e < t; e++) {
            const n = this.bones[e];
            n && (n.parent && n.parent.isBone ? (n.matrix.copy(n.parent.matrixWorld).invert(),
            n.matrix.multiply(n.matrixWorld)) : n.matrix.copy(n.matrixWorld),
            n.matrix.decompose(n.position, n.quaternion, n.scale))
        }
    }
    update() {
        const e = this.bones
          , t = this.boneInverses
          , n = this.boneMatrices
          , i = this.boneTexture;
        for (let s = 0, o = e.length; s < o; s++) {
            const a = e[s] ? e[s].matrixWorld : y3;
            zy.multiplyMatrices(a, t[s]),
            zy.toArray(n, s * 16)
        }
        i !== null && (i.needsUpdate = !0)
    }
    clone() {
        return new k_(this.bones,this.boneInverses)
    }
    computeBoneTexture() {
        let e = Math.sqrt(this.bones.length * 4);
        e = Math.ceil(e / 4) * 4,
        e = Math.max(e, 4);
        const t = new Float32Array(e * e * 4);
        t.set(this.boneMatrices);
        const n = new Xb(t,e,e,Kn,wn);
        return n.needsUpdate = !0,
        this.boneMatrices = t,
        this.boneTexture = n,
        this
    }
    getBoneByName(e) {
        for (let t = 0, n = this.bones.length; t < n; t++) {
            const i = this.bones[t];
            if (i.name === e)
                return i
        }
    }
    dispose() {
        this.boneTexture !== null && (this.boneTexture.dispose(),
        this.boneTexture = null)
    }
    fromJSON(e, t) {
        this.uuid = e.uuid;
        for (let n = 0, i = e.bones.length; n < i; n++) {
            const s = e.bones[n];
            let o = t[s];
            o === void 0 && (console.warn("THREE.Skeleton: No bone found with UUID:", s),
            o = new jb),
            this.bones.push(o),
            this.boneInverses.push(new it().fromArray(e.boneInverses[n]))
        }
        return this.init(),
        this
    }
    toJSON() {
        const e = {
            metadata: {
                version: 4.6,
                type: "Skeleton",
                generator: "Skeleton.toJSON"
            },
            bones: [],
            boneInverses: []
        };
        e.uuid = this.uuid;
        const t = this.bones
          , n = this.boneInverses;
        for (let i = 0, s = t.length; i < s; i++) {
            const o = t[i];
            e.bones.push(o.uuid);
            const a = n[i];
            e.boneInverses.push(a.toArray())
        }
        return e
    }
}
class cl extends pt {
    constructor(e, t, n, i=1) {
        super(e, t, n),
        this.isInstancedBufferAttribute = !0,
        this.meshPerAttribute = i
    }
    copy(e) {
        return super.copy(e),
        this.meshPerAttribute = e.meshPerAttribute,
        this
    }
    toJSON() {
        const e = super.toJSON();
        return e.meshPerAttribute = this.meshPerAttribute,
        e.isInstancedBufferAttribute = !0,
        e
    }
}
const Ta = new it
  , Hy = new it
  , nh = []
  , Vy = new yn
  , x3 = new it
  , Jl = new en
  , Ql = new Mr;
class z_ extends en {
    constructor(e, t, n) {
        super(e, t),
        this.isInstancedMesh = !0,
        this.instanceMatrix = new cl(new Float32Array(n * 16),16),
        this.instanceColor = null,
        this.count = n,
        this.boundingBox = null,
        this.boundingSphere = null;
        for (let i = 0; i < n; i++)
            this.setMatrixAt(i, x3)
    }
    computeBoundingBox() {
        const e = this.geometry
          , t = this.count;
        this.boundingBox === null && (this.boundingBox = new yn),
        e.boundingBox === null && e.computeBoundingBox(),
        this.boundingBox.makeEmpty();
        for (let n = 0; n < t; n++)
            this.getMatrixAt(n, Ta),
            Vy.copy(e.boundingBox).applyMatrix4(Ta),
            this.boundingBox.union(Vy)
    }
    computeBoundingSphere() {
        const e = this.geometry
          , t = this.count;
        this.boundingSphere === null && (this.boundingSphere = new Mr),
        e.boundingSphere === null && e.computeBoundingSphere(),
        this.boundingSphere.makeEmpty();
        for (let n = 0; n < t; n++)
            this.getMatrixAt(n, Ta),
            Ql.copy(e.boundingSphere).applyMatrix4(Ta),
            this.boundingSphere.union(Ql)
    }
    copy(e, t) {
        return super.copy(e, t),
        this.instanceMatrix.copy(e.instanceMatrix),
        e.instanceColor !== null && (this.instanceColor = e.instanceColor.clone()),
        this.count = e.count,
        e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()),
        e.boundingSphere !== null && (this.boundingSphere = e.boundingSphere.clone()),
        this
    }
    getColorAt(e, t) {
        t.fromArray(this.instanceColor.array, e * 3)
    }
    getMatrixAt(e, t) {
        t.fromArray(this.instanceMatrix.array, e * 16)
    }
    raycast(e, t) {
        const n = this.matrixWorld
          , i = this.count;
        if (Jl.geometry = this.geometry,
        Jl.material = this.material,
        Jl.material !== void 0 && (this.boundingSphere === null && this.computeBoundingSphere(),
        Ql.copy(this.boundingSphere),
        Ql.applyMatrix4(n),
        e.ray.intersectsSphere(Ql) !== !1))
            for (let s = 0; s < i; s++) {
                this.getMatrixAt(s, Ta),
                Hy.multiplyMatrices(n, Ta),
                Jl.matrixWorld = Hy,
                Jl.raycast(e, nh);
                for (let o = 0, a = nh.length; o < a; o++) {
                    const c = nh[o];
                    c.instanceId = s,
                    c.object = this,
                    t.push(c)
                }
                nh.length = 0
            }
    }
    setColorAt(e, t) {
        this.instanceColor === null && (this.instanceColor = new cl(new Float32Array(this.instanceMatrix.count * 3),3)),
        t.toArray(this.instanceColor.array, e * 3)
    }
    setMatrixAt(e, t) {
        t.toArray(this.instanceMatrix.array, e * 16)
    }
    updateMorphTargets() {}
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
}
class H_ extends nr {
    constructor(e) {
        super(),
        this.isLineBasicMaterial = !0,
        this.type = "LineBasicMaterial",
        this.color = new Ke(16777215),
        this.map = null,
        this.linewidth = 1,
        this.linecap = "round",
        this.linejoin = "round",
        this.fog = !0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.color.copy(e.color),
        this.map = e.map,
        this.linewidth = e.linewidth,
        this.linecap = e.linecap,
        this.linejoin = e.linejoin,
        this.fog = e.fog,
        this
    }
}
const Gy = new k
  , Wy = new k
  , jy = new it
  , Hp = new Bo
  , ih = new Mr;
class V_ extends Yt {
    constructor(e=new mn, t=new H_) {
        super(),
        this.isLine = !0,
        this.type = "Line",
        this.geometry = e,
        this.material = t,
        this.updateMorphTargets()
    }
    copy(e, t) {
        return super.copy(e, t),
        this.material = Array.isArray(e.material) ? e.material.slice() : e.material,
        this.geometry = e.geometry,
        this
    }
    computeLineDistances() {
        const e = this.geometry;
        if (e.index === null) {
            const t = e.attributes.position
              , n = [0];
            for (let i = 1, s = t.count; i < s; i++)
                Gy.fromBufferAttribute(t, i - 1),
                Wy.fromBufferAttribute(t, i),
                n[i] = n[i - 1],
                n[i] += Gy.distanceTo(Wy);
            e.setAttribute("lineDistance", new di(n,1))
        } else
            console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
        return this
    }
    raycast(e, t) {
        const n = this.geometry
          , i = this.matrixWorld
          , s = e.params.Line.threshold
          , o = n.drawRange;
        if (n.boundingSphere === null && n.computeBoundingSphere(),
        ih.copy(n.boundingSphere),
        ih.applyMatrix4(i),
        ih.radius += s,
        e.ray.intersectsSphere(ih) === !1)
            return;
        jy.copy(i).invert(),
        Hp.copy(e.ray).applyMatrix4(jy);
        const a = s / ((this.scale.x + this.scale.y + this.scale.z) / 3)
          , c = a * a
          , h = new k
          , d = new k
          , l = new k
          , f = new k
          , p = this.isLineSegments ? 2 : 1
          , g = n.index
          , v = n.attributes.position;
        if (g !== null) {
            const _ = Math.max(0, o.start)
              , b = Math.min(g.count, o.start + o.count);
            for (let T = _, S = b - 1; T < S; T += p) {
                const E = g.getX(T)
                  , P = g.getX(T + 1);
                if (h.fromBufferAttribute(v, E),
                d.fromBufferAttribute(v, P),
                Hp.distanceSqToSegment(h, d, f, l) > c)
                    continue;
                f.applyMatrix4(this.matrixWorld);
                const O = e.ray.origin.distanceTo(f);
                O < e.near || O > e.far || t.push({
                    distance: O,
                    point: l.clone().applyMatrix4(this.matrixWorld),
                    index: T,
                    face: null,
                    faceIndex: null,
                    object: this
                })
            }
        } else {
            const _ = Math.max(0, o.start)
              , b = Math.min(v.count, o.start + o.count);
            for (let T = _, S = b - 1; T < S; T += p) {
                if (h.fromBufferAttribute(v, T),
                d.fromBufferAttribute(v, T + 1),
                Hp.distanceSqToSegment(h, d, f, l) > c)
                    continue;
                f.applyMatrix4(this.matrixWorld);
                const P = e.ray.origin.distanceTo(f);
                P < e.near || P > e.far || t.push({
                    distance: P,
                    point: l.clone().applyMatrix4(this.matrixWorld),
                    index: T,
                    face: null,
                    faceIndex: null,
                    object: this
                })
            }
        }
    }
    updateMorphTargets() {
        const t = this.geometry.morphAttributes
          , n = Object.keys(t);
        if (n.length > 0) {
            const i = t[n[0]];
            if (i !== void 0) {
                this.morphTargetInfluences = [],
                this.morphTargetDictionary = {};
                for (let s = 0, o = i.length; s < o; s++) {
                    const a = i[s].name || String(s);
                    this.morphTargetInfluences.push(0),
                    this.morphTargetDictionary[a] = s
                }
            }
        }
    }
}
const Xy = new k
  , qy = new k;
class T3 extends V_ {
    constructor(e, t) {
        super(e, t),
        this.isLineSegments = !0,
        this.type = "LineSegments"
    }
    computeLineDistances() {
        const e = this.geometry;
        if (e.index === null) {
            const t = e.attributes.position
              , n = [];
            for (let i = 0, s = t.count; i < s; i += 2)
                Xy.fromBufferAttribute(t, i),
                qy.fromBufferAttribute(t, i + 1),
                n[i] = i === 0 ? 0 : n[i - 1],
                n[i + 1] = n[i] + Xy.distanceTo(qy);
            e.setAttribute("lineDistance", new di(n,1))
        } else
            console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
        return this
    }
}
class b3 extends V_ {
    constructor(e, t) {
        super(e, t),
        this.isLineLoop = !0,
        this.type = "LineLoop"
    }
}
class qb extends nr {
    constructor(e) {
        super(),
        this.isPointsMaterial = !0,
        this.type = "PointsMaterial",
        this.color = new Ke(16777215),
        this.map = null,
        this.alphaMap = null,
        this.size = 1,
        this.sizeAttenuation = !0,
        this.fog = !0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.color.copy(e.color),
        this.map = e.map,
        this.alphaMap = e.alphaMap,
        this.size = e.size,
        this.sizeAttenuation = e.sizeAttenuation,
        this.fog = e.fog,
        this
    }
}
const Ky = new it
  , Xm = new Bo
  , rh = new Mr
  , sh = new k;
class gf extends Yt {
    constructor(e=new mn, t=new qb) {
        super(),
        this.isPoints = !0,
        this.type = "Points",
        this.geometry = e,
        this.material = t,
        this.updateMorphTargets()
    }
    copy(e, t) {
        return super.copy(e, t),
        this.material = Array.isArray(e.material) ? e.material.slice() : e.material,
        this.geometry = e.geometry,
        this
    }
    raycast(e, t) {
        const n = this.geometry
          , i = this.matrixWorld
          , s = e.params.Points.threshold
          , o = n.drawRange;
        if (n.boundingSphere === null && n.computeBoundingSphere(),
        rh.copy(n.boundingSphere),
        rh.applyMatrix4(i),
        rh.radius += s,
        e.ray.intersectsSphere(rh) === !1)
            return;
        Ky.copy(i).invert(),
        Xm.copy(e.ray).applyMatrix4(Ky);
        const a = s / ((this.scale.x + this.scale.y + this.scale.z) / 3)
          , c = a * a
          , h = n.index
          , l = n.attributes.position;
        if (h !== null) {
            const f = Math.max(0, o.start)
              , p = Math.min(h.count, o.start + o.count);
            for (let g = f, y = p; g < y; g++) {
                const v = h.getX(g);
                sh.fromBufferAttribute(l, v),
                Yy(sh, v, c, i, e, t, this)
            }
        } else {
            const f = Math.max(0, o.start)
              , p = Math.min(l.count, o.start + o.count);
            for (let g = f, y = p; g < y; g++)
                sh.fromBufferAttribute(l, g),
                Yy(sh, g, c, i, e, t, this)
        }
    }
    updateMorphTargets() {
        const t = this.geometry.morphAttributes
          , n = Object.keys(t);
        if (n.length > 0) {
            const i = t[n[0]];
            if (i !== void 0) {
                this.morphTargetInfluences = [],
                this.morphTargetDictionary = {};
                for (let s = 0, o = i.length; s < o; s++) {
                    const a = i[s].name || String(s);
                    this.morphTargetInfluences.push(0),
                    this.morphTargetDictionary[a] = s
                }
            }
        }
    }
}
function Yy(r, e, t, n, i, s, o) {
    const a = Xm.distanceSqToPoint(r);
    if (a < t) {
        const c = new k;
        Xm.closestPointToPoint(r, c),
        c.applyMatrix4(n);
        const h = i.ray.origin.distanceTo(c);
        if (h < i.near || h > i.far)
            return;
        s.push({
            distance: h,
            distanceToRay: Math.sqrt(a),
            point: c,
            index: e,
            face: null,
            object: o
        })
    }
}
class S3 extends Pn {
    constructor(e, t, n, i, s, o, a, c, h) {
        super(e, t, n, i, s, o, a, c, h),
        this.isVideoTexture = !0,
        this.minFilter = o !== void 0 ? o : Ot,
        this.magFilter = s !== void 0 ? s : Ot,
        this.generateMipmaps = !1;
        const d = this;
        function l() {
            d.needsUpdate = !0,
            e.requestVideoFrameCallback(l)
        }
        "requestVideoFrameCallback"in e && e.requestVideoFrameCallback(l)
    }
    clone() {
        return new this.constructor(this.image).copy(this)
    }
    update() {
        const e = this.image;
        "requestVideoFrameCallback"in e === !1 && e.readyState >= e.HAVE_CURRENT_DATA && (this.needsUpdate = !0)
    }
}
class G_ extends mn {
    constructor(e=1, t=1, n=1, i=32, s=1, o=!1, a=0, c=Math.PI * 2) {
        super(),
        this.type = "CylinderGeometry",
        this.parameters = {
            radiusTop: e,
            radiusBottom: t,
            height: n,
            radialSegments: i,
            heightSegments: s,
            openEnded: o,
            thetaStart: a,
            thetaLength: c
        };
        const h = this;
        i = Math.floor(i),
        s = Math.floor(s);
        const d = []
          , l = []
          , f = []
          , p = [];
        let g = 0;
        const y = []
          , v = n / 2;
        let _ = 0;
        b(),
        o === !1 && (e > 0 && T(!0),
        t > 0 && T(!1)),
        this.setIndex(d),
        this.setAttribute("position", new di(l,3)),
        this.setAttribute("normal", new di(f,3)),
        this.setAttribute("uv", new di(p,2));
        function b() {
            const S = new k
              , E = new k;
            let P = 0;
            const R = (t - e) / n;
            for (let O = 0; O <= s; O++) {
                const w = []
                  , I = O / s
                  , V = I * (t - e) + e;
                for (let z = 0; z <= i; z++) {
                    const q = z / i
                      , F = q * c + a
                      , j = Math.sin(F)
                      , K = Math.cos(F);
                    E.x = V * j,
                    E.y = -I * n + v,
                    E.z = V * K,
                    l.push(E.x, E.y, E.z),
                    S.set(j, R, K).normalize(),
                    f.push(S.x, S.y, S.z),
                    p.push(q, 1 - I),
                    w.push(g++)
                }
                y.push(w)
            }
            for (let O = 0; O < i; O++)
                for (let w = 0; w < s; w++) {
                    const I = y[w][O]
                      , V = y[w + 1][O]
                      , z = y[w + 1][O + 1]
                      , q = y[w][O + 1];
                    d.push(I, V, q),
                    d.push(V, z, q),
                    P += 6
                }
            h.addGroup(_, P, 0),
            _ += P
        }
        function T(S) {
            const E = g
              , P = new Ce
              , R = new k;
            let O = 0;
            const w = S === !0 ? e : t
              , I = S === !0 ? 1 : -1;
            for (let z = 1; z <= i; z++)
                l.push(0, v * I, 0),
                f.push(0, I, 0),
                p.push(.5, .5),
                g++;
            const V = g;
            for (let z = 0; z <= i; z++) {
                const F = z / i * c + a
                  , j = Math.cos(F)
                  , K = Math.sin(F);
                R.x = w * K,
                R.y = v * I,
                R.z = w * j,
                l.push(R.x, R.y, R.z),
                f.push(0, I, 0),
                P.x = j * .5 + .5,
                P.y = K * .5 * I + .5,
                p.push(P.x, P.y),
                g++
            }
            for (let z = 0; z < i; z++) {
                const q = E + z
                  , F = V + z;
                S === !0 ? d.push(F, F + 1, q) : d.push(F + 1, F, q),
                O += 3
            }
            h.addGroup(_, O, S === !0 ? 1 : 2),
            _ += O
        }
    }
    copy(e) {
        return super.copy(e),
        this.parameters = Object.assign({}, e.parameters),
        this
    }
    static fromJSON(e) {
        return new G_(e.radiusTop,e.radiusBottom,e.height,e.radialSegments,e.heightSegments,e.openEnded,e.thetaStart,e.thetaLength)
    }
}
class W_ extends mn {
    constructor(e=1, t=32, n=16, i=0, s=Math.PI * 2, o=0, a=Math.PI) {
        super(),
        this.type = "SphereGeometry",
        this.parameters = {
            radius: e,
            widthSegments: t,
            heightSegments: n,
            phiStart: i,
            phiLength: s,
            thetaStart: o,
            thetaLength: a
        },
        t = Math.max(3, Math.floor(t)),
        n = Math.max(2, Math.floor(n));
        const c = Math.min(o + a, Math.PI);
        let h = 0;
        const d = []
          , l = new k
          , f = new k
          , p = []
          , g = []
          , y = []
          , v = [];
        for (let _ = 0; _ <= n; _++) {
            const b = []
              , T = _ / n;
            let S = 0;
            _ === 0 && o === 0 ? S = .5 / t : _ === n && c === Math.PI && (S = -.5 / t);
            for (let E = 0; E <= t; E++) {
                const P = E / t;
                l.x = -e * Math.cos(i + P * s) * Math.sin(o + T * a),
                l.y = e * Math.cos(o + T * a),
                l.z = e * Math.sin(i + P * s) * Math.sin(o + T * a),
                g.push(l.x, l.y, l.z),
                f.copy(l).normalize(),
                y.push(f.x, f.y, f.z),
                v.push(P + S, 1 - T),
                b.push(h++)
            }
            d.push(b)
        }
        for (let _ = 0; _ < n; _++)
            for (let b = 0; b < t; b++) {
                const T = d[_][b + 1]
                  , S = d[_][b]
                  , E = d[_ + 1][b]
                  , P = d[_ + 1][b + 1];
                (_ !== 0 || o > 0) && p.push(T, S, P),
                (_ !== n - 1 || c < Math.PI) && p.push(S, E, P)
            }
        this.setIndex(p),
        this.setAttribute("position", new di(g,3)),
        this.setAttribute("normal", new di(y,3)),
        this.setAttribute("uv", new di(v,2))
    }
    copy(e) {
        return super.copy(e),
        this.parameters = Object.assign({}, e.parameters),
        this
    }
    static fromJSON(e) {
        return new W_(e.radius,e.widthSegments,e.heightSegments,e.phiStart,e.phiLength,e.thetaStart,e.thetaLength)
    }
}
class j_ extends nr {
    constructor(e) {
        super(),
        this.isMeshStandardMaterial = !0,
        this.defines = {
            STANDARD: ""
        },
        this.type = "MeshStandardMaterial",
        this.color = new Ke(16777215),
        this.roughness = 1,
        this.metalness = 0,
        this.map = null,
        this.lightMap = null,
        this.lightMapIntensity = 1,
        this.aoMap = null,
        this.aoMapIntensity = 1,
        this.emissive = new Ke(0),
        this.emissiveIntensity = 1,
        this.emissiveMap = null,
        this.bumpMap = null,
        this.bumpScale = 1,
        this.normalMap = null,
        this.normalMapType = Eb,
        this.normalScale = new Ce(1,1),
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.roughnessMap = null,
        this.metalnessMap = null,
        this.alphaMap = null,
        this.envMap = null,
        this.envMapIntensity = 1,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.wireframeLinecap = "round",
        this.wireframeLinejoin = "round",
        this.flatShading = !1,
        this.fog = !0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.defines = {
            STANDARD: ""
        },
        this.color.copy(e.color),
        this.roughness = e.roughness,
        this.metalness = e.metalness,
        this.map = e.map,
        this.lightMap = e.lightMap,
        this.lightMapIntensity = e.lightMapIntensity,
        this.aoMap = e.aoMap,
        this.aoMapIntensity = e.aoMapIntensity,
        this.emissive.copy(e.emissive),
        this.emissiveMap = e.emissiveMap,
        this.emissiveIntensity = e.emissiveIntensity,
        this.bumpMap = e.bumpMap,
        this.bumpScale = e.bumpScale,
        this.normalMap = e.normalMap,
        this.normalMapType = e.normalMapType,
        this.normalScale.copy(e.normalScale),
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this.roughnessMap = e.roughnessMap,
        this.metalnessMap = e.metalnessMap,
        this.alphaMap = e.alphaMap,
        this.envMap = e.envMap,
        this.envMapIntensity = e.envMapIntensity,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.wireframeLinecap = e.wireframeLinecap,
        this.wireframeLinejoin = e.wireframeLinejoin,
        this.flatShading = e.flatShading,
        this.fog = e.fog,
        this
    }
}
class cs extends j_ {
    constructor(e) {
        super(),
        this.isMeshPhysicalMaterial = !0,
        this.defines = {
            STANDARD: "",
            PHYSICAL: ""
        },
        this.type = "MeshPhysicalMaterial",
        this.anisotropyRotation = 0,
        this.anisotropyMap = null,
        this.clearcoatMap = null,
        this.clearcoatRoughness = 0,
        this.clearcoatRoughnessMap = null,
        this.clearcoatNormalScale = new Ce(1,1),
        this.clearcoatNormalMap = null,
        this.ior = 1.5,
        Object.defineProperty(this, "reflectivity", {
            get: function() {
                return Hn(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1)
            },
            set: function(t) {
                this.ior = (1 + .4 * t) / (1 - .4 * t)
            }
        }),
        this.iridescenceMap = null,
        this.iridescenceIOR = 1.3,
        this.iridescenceThicknessRange = [100, 400],
        this.iridescenceThicknessMap = null,
        this.sheenColor = new Ke(0),
        this.sheenColorMap = null,
        this.sheenRoughness = 1,
        this.sheenRoughnessMap = null,
        this.transmissionMap = null,
        this.thickness = 0,
        this.thicknessMap = null,
        this.attenuationDistance = 1 / 0,
        this.attenuationColor = new Ke(1,1,1),
        this.specularIntensity = 1,
        this.specularIntensityMap = null,
        this.specularColor = new Ke(1,1,1),
        this.specularColorMap = null,
        this._anisotropy = 0,
        this._clearcoat = 0,
        this._iridescence = 0,
        this._sheen = 0,
        this._transmission = 0,
        this.setValues(e)
    }
    get anisotropy() {
        return this._anisotropy
    }
    set anisotropy(e) {
        this._anisotropy > 0 != e > 0 && this.version++,
        this._anisotropy = e
    }
    get clearcoat() {
        return this._clearcoat
    }
    set clearcoat(e) {
        this._clearcoat > 0 != e > 0 && this.version++,
        this._clearcoat = e
    }
    get iridescence() {
        return this._iridescence
    }
    set iridescence(e) {
        this._iridescence > 0 != e > 0 && this.version++,
        this._iridescence = e
    }
    get sheen() {
        return this._sheen
    }
    set sheen(e) {
        this._sheen > 0 != e > 0 && this.version++,
        this._sheen = e
    }
    get transmission() {
        return this._transmission
    }
    set transmission(e) {
        this._transmission > 0 != e > 0 && this.version++,
        this._transmission = e
    }
    copy(e) {
        return super.copy(e),
        this.defines = {
            STANDARD: "",
            PHYSICAL: ""
        },
        this.anisotropy = e.anisotropy,
        this.anisotropyRotation = e.anisotropyRotation,
        this.anisotropyMap = e.anisotropyMap,
        this.clearcoat = e.clearcoat,
        this.clearcoatMap = e.clearcoatMap,
        this.clearcoatRoughness = e.clearcoatRoughness,
        this.clearcoatRoughnessMap = e.clearcoatRoughnessMap,
        this.clearcoatNormalMap = e.clearcoatNormalMap,
        this.clearcoatNormalScale.copy(e.clearcoatNormalScale),
        this.ior = e.ior,
        this.iridescence = e.iridescence,
        this.iridescenceMap = e.iridescenceMap,
        this.iridescenceIOR = e.iridescenceIOR,
        this.iridescenceThicknessRange = [...e.iridescenceThicknessRange],
        this.iridescenceThicknessMap = e.iridescenceThicknessMap,
        this.sheen = e.sheen,
        this.sheenColor.copy(e.sheenColor),
        this.sheenColorMap = e.sheenColorMap,
        this.sheenRoughness = e.sheenRoughness,
        this.sheenRoughnessMap = e.sheenRoughnessMap,
        this.transmission = e.transmission,
        this.transmissionMap = e.transmissionMap,
        this.thickness = e.thickness,
        this.thicknessMap = e.thicknessMap,
        this.attenuationDistance = e.attenuationDistance,
        this.attenuationColor.copy(e.attenuationColor),
        this.specularIntensity = e.specularIntensity,
        this.specularIntensityMap = e.specularIntensityMap,
        this.specularColor.copy(e.specularColor),
        this.specularColorMap = e.specularColorMap,
        this
    }
}
function oh(r, e, t) {
    return !r || !t && r.constructor === e ? r : typeof e.BYTES_PER_ELEMENT == "number" ? new e(r) : Array.prototype.slice.call(r)
}
function M3(r) {
    return ArrayBuffer.isView(r) && !(r instanceof DataView)
}
function w3(r) {
    function e(i, s) {
        return r[i] - r[s]
    }
    const t = r.length
      , n = new Array(t);
    for (let i = 0; i !== t; ++i)
        n[i] = i;
    return n.sort(e),
    n
}
function $y(r, e, t) {
    const n = r.length
      , i = new r.constructor(n);
    for (let s = 0, o = 0; o !== n; ++s) {
        const a = t[s] * e;
        for (let c = 0; c !== e; ++c)
            i[o++] = r[a + c]
    }
    return i
}
function Kb(r, e, t, n) {
    let i = 1
      , s = r[0];
    for (; s !== void 0 && s[n] === void 0; )
        s = r[i++];
    if (s === void 0)
        return;
    let o = s[n];
    if (o !== void 0)
        if (Array.isArray(o))
            do
                o = s[n],
                o !== void 0 && (e.push(s.time),
                t.push.apply(t, o)),
                s = r[i++];
            while (s !== void 0);
        else if (o.toArray !== void 0)
            do
                o = s[n],
                o !== void 0 && (e.push(s.time),
                o.toArray(t, t.length)),
                s = r[i++];
            while (s !== void 0);
        else
            do
                o = s[n],
                o !== void 0 && (e.push(s.time),
                t.push(o)),
                s = r[i++];
            while (s !== void 0)
}
class kc {
    constructor(e, t, n, i) {
        this.parameterPositions = e,
        this._cachedIndex = 0,
        this.resultBuffer = i !== void 0 ? i : new t.constructor(n),
        this.sampleValues = t,
        this.valueSize = n,
        this.settings = null,
        this.DefaultSettings_ = {}
    }
    evaluate(e) {
        const t = this.parameterPositions;
        let n = this._cachedIndex
          , i = t[n]
          , s = t[n - 1];
        e: {
            t: {
                let o;
                n: {
                    i: if (!(e < i)) {
                        for (let a = n + 2; ; ) {
                            if (i === void 0) {
                                if (e < s)
                                    break i;
                                return n = t.length,
                                this._cachedIndex = n,
                                this.copySampleValue_(n - 1)
                            }
                            if (n === a)
                                break;
                            if (s = i,
                            i = t[++n],
                            e < i)
                                break t
                        }
                        o = t.length;
                        break n
                    }
                    if (!(e >= s)) {
                        const a = t[1];
                        e < a && (n = 2,
                        s = a);
                        for (let c = n - 2; ; ) {
                            if (s === void 0)
                                return this._cachedIndex = 0,
                                this.copySampleValue_(0);
                            if (n === c)
                                break;
                            if (i = s,
                            s = t[--n - 1],
                            e >= s)
                                break t
                        }
                        o = n,
                        n = 0;
                        break n
                    }
                    break e
                }
                for (; n < o; ) {
                    const a = n + o >>> 1;
                    e < t[a] ? o = a : n = a + 1
                }
                if (i = t[n],
                s = t[n - 1],
                s === void 0)
                    return this._cachedIndex = 0,
                    this.copySampleValue_(0);
                if (i === void 0)
                    return n = t.length,
                    this._cachedIndex = n,
                    this.copySampleValue_(n - 1)
            }
            this._cachedIndex = n,
            this.intervalChanged_(n, s, i)
        }
        return this.interpolate_(n, s, e, i)
    }
    getSettings_() {
        return this.settings || this.DefaultSettings_
    }
    copySampleValue_(e) {
        const t = this.resultBuffer
          , n = this.sampleValues
          , i = this.valueSize
          , s = e * i;
        for (let o = 0; o !== i; ++o)
            t[o] = n[s + o];
        return t
    }
    interpolate_() {
        throw new Error("call to abstract method")
    }
    intervalChanged_() {}
}
class E3 extends kc {
    constructor(e, t, n, i) {
        super(e, t, n, i),
        this._weightPrev = -0,
        this._offsetPrev = -0,
        this._weightNext = -0,
        this._offsetNext = -0,
        this.DefaultSettings_ = {
            endingStart: za,
            endingEnd: za
        }
    }
    intervalChanged_(e, t, n) {
        const i = this.parameterPositions;
        let s = e - 2
          , o = e + 1
          , a = i[s]
          , c = i[o];
        if (a === void 0)
            switch (this.getSettings_().endingStart) {
            case Ha:
                s = e,
                a = 2 * t - n;
                break;
            case Xh:
                s = i.length - 2,
                a = t + i[s] - i[s + 1];
                break;
            default:
                s = e,
                a = n
            }
        if (c === void 0)
            switch (this.getSettings_().endingEnd) {
            case Ha:
                o = e,
                c = 2 * n - t;
                break;
            case Xh:
                o = 1,
                c = n + i[1] - i[0];
                break;
            default:
                o = e - 1,
                c = t
            }
        const h = (n - t) * .5
          , d = this.valueSize;
        this._weightPrev = h / (t - a),
        this._weightNext = h / (c - n),
        this._offsetPrev = s * d,
        this._offsetNext = o * d
    }
    interpolate_(e, t, n, i) {
        const s = this.resultBuffer
          , o = this.sampleValues
          , a = this.valueSize
          , c = e * a
          , h = c - a
          , d = this._offsetPrev
          , l = this._offsetNext
          , f = this._weightPrev
          , p = this._weightNext
          , g = (n - t) / (i - t)
          , y = g * g
          , v = y * g
          , _ = -f * v + 2 * f * y - f * g
          , b = (1 + f) * v + (-1.5 - 2 * f) * y + (-.5 + f) * g + 1
          , T = (-1 - p) * v + (1.5 + p) * y + .5 * g
          , S = p * v - p * y;
        for (let E = 0; E !== a; ++E)
            s[E] = _ * o[d + E] + b * o[h + E] + T * o[c + E] + S * o[l + E];
        return s
    }
}
class Jh extends kc {
    constructor(e, t, n, i) {
        super(e, t, n, i)
    }
    interpolate_(e, t, n, i) {
        const s = this.resultBuffer
          , o = this.sampleValues
          , a = this.valueSize
          , c = e * a
          , h = c - a
          , d = (n - t) / (i - t)
          , l = 1 - d;
        for (let f = 0; f !== a; ++f)
            s[f] = o[h + f] * l + o[c + f] * d;
        return s
    }
}
class A3 extends kc {
    constructor(e, t, n, i) {
        super(e, t, n, i)
    }
    interpolate_(e) {
        return this.copySampleValue_(e - 1)
    }
}
class Nr {
    constructor(e, t, n, i) {
        if (e === void 0)
            throw new Error("THREE.KeyframeTrack: track name is undefined");
        if (t === void 0 || t.length === 0)
            throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e);
        this.name = e,
        this.times = oh(t, this.TimeBufferType),
        this.values = oh(n, this.ValueBufferType),
        this.setInterpolation(i || this.DefaultInterpolation)
    }
    static toJSON(e) {
        const t = e.constructor;
        let n;
        if (t.toJSON !== this.toJSON)
            n = t.toJSON(e);
        else {
            n = {
                name: e.name,
                times: oh(e.times, Array),
                values: oh(e.values, Array)
            };
            const i = e.getInterpolation();
            i !== e.DefaultInterpolation && (n.interpolation = i)
        }
        return n.type = e.ValueTypeName,
        n
    }
    InterpolantFactoryMethodDiscrete(e) {
        return new A3(this.times,this.values,this.getValueSize(),e)
    }
    InterpolantFactoryMethodLinear(e) {
        return new Jh(this.times,this.values,this.getValueSize(),e)
    }
    InterpolantFactoryMethodSmooth(e) {
        return new E3(this.times,this.values,this.getValueSize(),e)
    }
    setInterpolation(e) {
        let t;
        switch (e) {
        case Oc:
            t = this.InterpolantFactoryMethodDiscrete;
            break;
        case ol:
            t = this.InterpolantFactoryMethodLinear;
            break;
        case mp:
            t = this.InterpolantFactoryMethodSmooth;
            break
        }
        if (t === void 0) {
            const n = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
            if (this.createInterpolant === void 0)
                if (e !== this.DefaultInterpolation)
                    this.setInterpolation(this.DefaultInterpolation);
                else
                    throw new Error(n);
            return console.warn("THREE.KeyframeTrack:", n),
            this
        }
        return this.createInterpolant = t,
        this
    }
    getInterpolation() {
        switch (this.createInterpolant) {
        case this.InterpolantFactoryMethodDiscrete:
            return Oc;
        case this.InterpolantFactoryMethodLinear:
            return ol;
        case this.InterpolantFactoryMethodSmooth:
            return mp
        }
    }
    getValueSize() {
        return this.values.length / this.times.length
    }
    shift(e) {
        if (e !== 0) {
            const t = this.times;
            for (let n = 0, i = t.length; n !== i; ++n)
                t[n] += e
        }
        return this
    }
    scale(e) {
        if (e !== 1) {
            const t = this.times;
            for (let n = 0, i = t.length; n !== i; ++n)
                t[n] *= e
        }
        return this
    }
    trim(e, t) {
        const n = this.times
          , i = n.length;
        let s = 0
          , o = i - 1;
        for (; s !== i && n[s] < e; )
            ++s;
        for (; o !== -1 && n[o] > t; )
            --o;
        if (++o,
        s !== 0 || o !== i) {
            s >= o && (o = Math.max(o, 1),
            s = o - 1);
            const a = this.getValueSize();
            this.times = n.slice(s, o),
            this.values = this.values.slice(s * a, o * a)
        }
        return this
    }
    validate() {
        let e = !0;
        const t = this.getValueSize();
        t - Math.floor(t) !== 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this),
        e = !1);
        const n = this.times
          , i = this.values
          , s = n.length;
        s === 0 && (console.error("THREE.KeyframeTrack: Track is empty.", this),
        e = !1);
        let o = null;
        for (let a = 0; a !== s; a++) {
            const c = n[a];
            if (typeof c == "number" && isNaN(c)) {
                console.error("THREE.KeyframeTrack: Time is not a valid number.", this, a, c),
                e = !1;
                break
            }
            if (o !== null && o > c) {
                console.error("THREE.KeyframeTrack: Out of order keys.", this, a, c, o),
                e = !1;
                break
            }
            o = c
        }
        if (i !== void 0 && M3(i))
            for (let a = 0, c = i.length; a !== c; ++a) {
                const h = i[a];
                if (isNaN(h)) {
                    console.error("THREE.KeyframeTrack: Value is not a valid number.", this, a, h),
                    e = !1;
                    break
                }
            }
        return e
    }
    optimize() {
        const e = this.times.slice()
          , t = this.values.slice()
          , n = this.getValueSize()
          , i = this.getInterpolation() === mp
          , s = e.length - 1;
        let o = 1;
        for (let a = 1; a < s; ++a) {
            let c = !1;
            const h = e[a]
              , d = e[a + 1];
            if (h !== d && (a !== 1 || h !== e[0]))
                if (i)
                    c = !0;
                else {
                    const l = a * n
                      , f = l - n
                      , p = l + n;
                    for (let g = 0; g !== n; ++g) {
                        const y = t[l + g];
                        if (y !== t[f + g] || y !== t[p + g]) {
                            c = !0;
                            break
                        }
                    }
                }
            if (c) {
                if (a !== o) {
                    e[o] = e[a];
                    const l = a * n
                      , f = o * n;
                    for (let p = 0; p !== n; ++p)
                        t[f + p] = t[l + p]
                }
                ++o
            }
        }
        if (s > 0) {
            e[o] = e[s];
            for (let a = s * n, c = o * n, h = 0; h !== n; ++h)
                t[c + h] = t[a + h];
            ++o
        }
        return o !== e.length ? (this.times = e.slice(0, o),
        this.values = t.slice(0, o * n)) : (this.times = e,
        this.values = t),
        this
    }
    clone() {
        const e = this.times.slice()
          , t = this.values.slice()
          , n = this.constructor
          , i = new n(this.name,e,t);
        return i.createInterpolant = this.createInterpolant,
        i
    }
}
Nr.prototype.TimeBufferType = Float32Array;
Nr.prototype.ValueBufferType = Float32Array;
Nr.prototype.DefaultInterpolation = ol;
class xl extends Nr {
}
xl.prototype.ValueTypeName = "bool";
xl.prototype.ValueBufferType = Array;
xl.prototype.DefaultInterpolation = Oc;
xl.prototype.InterpolantFactoryMethodLinear = void 0;
xl.prototype.InterpolantFactoryMethodSmooth = void 0;
class Yb extends Nr {
}
Yb.prototype.ValueTypeName = "color";
class ul extends Nr {
}
ul.prototype.ValueTypeName = "number";
class P3 extends kc {
    constructor(e, t, n, i) {
        super(e, t, n, i)
    }
    interpolate_(e, t, n, i) {
        const s = this.resultBuffer
          , o = this.sampleValues
          , a = this.valueSize
          , c = (n - t) / (i - t);
        let h = e * a;
        for (let d = h + a; h !== d; h += 4)
            Hi.slerpFlat(s, 0, o, h - a, o, h, c);
        return s
    }
}
class Uo extends Nr {
    InterpolantFactoryMethodLinear(e) {
        return new P3(this.times,this.values,this.getValueSize(),e)
    }
}
Uo.prototype.ValueTypeName = "quaternion";
Uo.prototype.DefaultInterpolation = ol;
Uo.prototype.InterpolantFactoryMethodSmooth = void 0;
class Tl extends Nr {
}
Tl.prototype.ValueTypeName = "string";
Tl.prototype.ValueBufferType = Array;
Tl.prototype.DefaultInterpolation = Oc;
Tl.prototype.InterpolantFactoryMethodLinear = void 0;
Tl.prototype.InterpolantFactoryMethodSmooth = void 0;
class hl extends Nr {
}
hl.prototype.ValueTypeName = "vector";
class qm {
    constructor(e, t=-1, n, i=P_) {
        this.name = e,
        this.tracks = n,
        this.duration = t,
        this.blendMode = i,
        this.uuid = vr(),
        this.duration < 0 && this.resetDuration()
    }
    static parse(e) {
        const t = []
          , n = e.tracks
          , i = 1 / (e.fps || 1);
        for (let o = 0, a = n.length; o !== a; ++o)
            t.push(C3(n[o]).scale(i));
        const s = new this(e.name,e.duration,t,e.blendMode);
        return s.uuid = e.uuid,
        s
    }
    static toJSON(e) {
        const t = []
          , n = e.tracks
          , i = {
            name: e.name,
            duration: e.duration,
            tracks: t,
            uuid: e.uuid,
            blendMode: e.blendMode
        };
        for (let s = 0, o = n.length; s !== o; ++s)
            t.push(Nr.toJSON(n[s]));
        return i
    }
    static CreateFromMorphTargetSequence(e, t, n, i) {
        const s = t.length
          , o = [];
        for (let a = 0; a < s; a++) {
            let c = []
              , h = [];
            c.push((a + s - 1) % s, a, (a + 1) % s),
            h.push(0, 1, 0);
            const d = w3(c);
            c = $y(c, 1, d),
            h = $y(h, 1, d),
            !i && c[0] === 0 && (c.push(s),
            h.push(h[0])),
            o.push(new ul(".morphTargetInfluences[" + t[a].name + "]",c,h).scale(1 / n))
        }
        return new this(e,-1,o)
    }
    static findByName(e, t) {
        let n = e;
        if (!Array.isArray(e)) {
            const i = e;
            n = i.geometry && i.geometry.animations || i.animations
        }
        for (let i = 0; i < n.length; i++)
            if (n[i].name === t)
                return n[i];
        return null
    }
    static CreateClipsFromMorphTargetSequences(e, t, n) {
        const i = {}
          , s = /^([\w-]*?)([\d]+)$/;
        for (let a = 0, c = e.length; a < c; a++) {
            const h = e[a]
              , d = h.name.match(s);
            if (d && d.length > 1) {
                const l = d[1];
                let f = i[l];
                f || (i[l] = f = []),
                f.push(h)
            }
        }
        const o = [];
        for (const a in i)
            o.push(this.CreateFromMorphTargetSequence(a, i[a], t, n));
        return o
    }
    static parseAnimation(e, t) {
        if (!e)
            return console.error("THREE.AnimationClip: No animation in JSONLoader data."),
            null;
        const n = function(l, f, p, g, y) {
            if (p.length !== 0) {
                const v = []
                  , _ = [];
                Kb(p, v, _, g),
                v.length !== 0 && y.push(new l(f,v,_))
            }
        }
          , i = []
          , s = e.name || "default"
          , o = e.fps || 30
          , a = e.blendMode;
        let c = e.length || -1;
        const h = e.hierarchy || [];
        for (let l = 0; l < h.length; l++) {
            const f = h[l].keys;
            if (!(!f || f.length === 0))
                if (f[0].morphTargets) {
                    const p = {};
                    let g;
                    for (g = 0; g < f.length; g++)
                        if (f[g].morphTargets)
                            for (let y = 0; y < f[g].morphTargets.length; y++)
                                p[f[g].morphTargets[y]] = -1;
                    for (const y in p) {
                        const v = []
                          , _ = [];
                        for (let b = 0; b !== f[g].morphTargets.length; ++b) {
                            const T = f[g];
                            v.push(T.time),
                            _.push(T.morphTarget === y ? 1 : 0)
                        }
                        i.push(new ul(".morphTargetInfluence[" + y + "]",v,_))
                    }
                    c = p.length * o
                } else {
                    const p = ".bones[" + t[l].name + "]";
                    n(hl, p + ".position", f, "pos", i),
                    n(Uo, p + ".quaternion", f, "rot", i),
                    n(hl, p + ".scale", f, "scl", i)
                }
        }
        return i.length === 0 ? null : new this(s,c,i,a)
    }
    resetDuration() {
        const e = this.tracks;
        let t = 0;
        for (let n = 0, i = e.length; n !== i; ++n) {
            const s = this.tracks[n];
            t = Math.max(t, s.times[s.times.length - 1])
        }
        return this.duration = t,
        this
    }
    trim() {
        for (let e = 0; e < this.tracks.length; e++)
            this.tracks[e].trim(0, this.duration);
        return this
    }
    validate() {
        let e = !0;
        for (let t = 0; t < this.tracks.length; t++)
            e = e && this.tracks[t].validate();
        return e
    }
    optimize() {
        for (let e = 0; e < this.tracks.length; e++)
            this.tracks[e].optimize();
        return this
    }
    clone() {
        const e = [];
        for (let t = 0; t < this.tracks.length; t++)
            e.push(this.tracks[t].clone());
        return new this.constructor(this.name,this.duration,e,this.blendMode)
    }
    toJSON() {
        return this.constructor.toJSON(this)
    }
}
function R3(r) {
    switch (r.toLowerCase()) {
    case "scalar":
    case "double":
    case "float":
    case "number":
    case "integer":
        return ul;
    case "vector":
    case "vector2":
    case "vector3":
    case "vector4":
        return hl;
    case "color":
        return Yb;
    case "quaternion":
        return Uo;
    case "bool":
    case "boolean":
        return xl;
    case "string":
        return Tl
    }
    throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + r)
}
function C3(r) {
    if (r.type === void 0)
        throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
    const e = R3(r.type);
    if (r.times === void 0) {
        const t = []
          , n = [];
        Kb(r.keys, t, n, "value"),
        r.times = t,
        r.values = n
    }
    return e.parse !== void 0 ? e.parse(r) : new e(r.name,r.times,r.values,r.interpolation)
}
const fl = {
    enabled: !1,
    files: {},
    add: function(r, e) {
        this.enabled !== !1 && (this.files[r] = e)
    },
    get: function(r) {
        if (this.enabled !== !1)
            return this.files[r]
    },
    remove: function(r) {
        delete this.files[r]
    },
    clear: function() {
        this.files = {}
    }
};
class I3 {
    constructor(e, t, n) {
        const i = this;
        let s = !1, o = 0, a = 0, c;
        const h = [];
        this.onStart = void 0,
        this.onLoad = e,
        this.onProgress = t,
        this.onError = n,
        this.itemStart = function(d) {
            a++,
            s === !1 && i.onStart !== void 0 && i.onStart(d, o, a),
            s = !0
        }
        ,
        this.itemEnd = function(d) {
            o++,
            i.onProgress !== void 0 && i.onProgress(d, o, a),
            o === a && (s = !1,
            i.onLoad !== void 0 && i.onLoad())
        }
        ,
        this.itemError = function(d) {
            i.onError !== void 0 && i.onError(d)
        }
        ,
        this.resolveURL = function(d) {
            return c ? c(d) : d
        }
        ,
        this.setURLModifier = function(d) {
            return c = d,
            this
        }
        ,
        this.addHandler = function(d, l) {
            return h.push(d, l),
            this
        }
        ,
        this.removeHandler = function(d) {
            const l = h.indexOf(d);
            return l !== -1 && h.splice(l, 2),
            this
        }
        ,
        this.getHandler = function(d) {
            for (let l = 0, f = h.length; l < f; l += 2) {
                const p = h[l]
                  , g = h[l + 1];
                if (p.global && (p.lastIndex = 0),
                p.test(d))
                    return g
            }
            return null
        }
    }
}
const L3 = new I3;
class ko {
    constructor(e) {
        this.manager = e !== void 0 ? e : L3,
        this.crossOrigin = "anonymous",
        this.withCredentials = !1,
        this.path = "",
        this.resourcePath = "",
        this.requestHeader = {}
    }
    load() {}
    loadAsync(e, t) {
        const n = this;
        return new Promise(function(i, s) {
            n.load(e, i, t, s)
        }
        )
    }
    parse() {}
    setCrossOrigin(e) {
        return this.crossOrigin = e,
        this
    }
    setWithCredentials(e) {
        return this.withCredentials = e,
        this
    }
    setPath(e) {
        return this.path = e,
        this
    }
    setResourcePath(e) {
        return this.resourcePath = e,
        this
    }
    setRequestHeader(e) {
        return this.requestHeader = e,
        this
    }
}
ko.DEFAULT_MATERIAL_NAME = "__DEFAULT";
const Zr = {};
class D3 extends Error {
    constructor(e, t) {
        super(e),
        this.response = t
    }
}
class Qh extends ko {
    constructor(e) {
        super(e)
    }
    load(e, t, n, i) {
        e === void 0 && (e = ""),
        this.path !== void 0 && (e = this.path + e),
        e = this.manager.resolveURL(e);
        const s = fl.get(e);
        if (s !== void 0)
            return this.manager.itemStart(e),
            setTimeout(()=>{
                t && t(s),
                this.manager.itemEnd(e)
            }
            , 0),
            s;
        if (Zr[e] !== void 0) {
            Zr[e].push({
                onLoad: t,
                onProgress: n,
                onError: i
            });
            return
        }
        Zr[e] = [],
        Zr[e].push({
            onLoad: t,
            onProgress: n,
            onError: i
        });
        const o = new Request(e,{
            headers: new Headers(this.requestHeader),
            credentials: this.withCredentials ? "include" : "same-origin"
        })
          , a = this.mimeType
          , c = this.responseType;
        fetch(o).then(h=>{
            if (h.status === 200 || h.status === 0) {
                if (h.status === 0 && console.warn("THREE.FileLoader: HTTP Status 0 received."),
                typeof ReadableStream > "u" || h.body === void 0 || h.body.getReader === void 0)
                    return h;
                const d = Zr[e]
                  , l = h.body.getReader()
                  , f = h.headers.get("Content-Length") || h.headers.get("X-File-Size")
                  , p = f ? parseInt(f) : 0
                  , g = p !== 0;
                let y = 0;
                const v = new ReadableStream({
                    start(_) {
                        b();
                        function b() {
                            l.read().then(({done: T, value: S})=>{
                                if (T)
                                    _.close();
                                else {
                                    y += S.byteLength;
                                    const E = new ProgressEvent("progress",{
                                        lengthComputable: g,
                                        loaded: y,
                                        total: p
                                    });
                                    for (let P = 0, R = d.length; P < R; P++) {
                                        const O = d[P];
                                        O.onProgress && O.onProgress(E)
                                    }
                                    _.enqueue(S),
                                    b()
                                }
                            }
                            )
                        }
                    }
                });
                return new Response(v)
            } else
                throw new D3(`fetch for "${h.url}" responded with ${h.status}: ${h.statusText}`,h)
        }
        ).then(h=>{
            switch (c) {
            case "arraybuffer":
                return h.arrayBuffer();
            case "blob":
                return h.blob();
            case "document":
                return h.text().then(d=>new DOMParser().parseFromString(d, a));
            case "json":
                return h.json();
            default:
                if (a === void 0)
                    return h.text();
                {
                    const l = /charset="?([^;"\s]*)"?/i.exec(a)
                      , f = l && l[1] ? l[1].toLowerCase() : void 0
                      , p = new TextDecoder(f);
                    return h.arrayBuffer().then(g=>p.decode(g))
                }
            }
        }
        ).then(h=>{
            fl.add(e, h);
            const d = Zr[e];
            delete Zr[e];
            for (let l = 0, f = d.length; l < f; l++) {
                const p = d[l];
                p.onLoad && p.onLoad(h)
            }
        }
        ).catch(h=>{
            const d = Zr[e];
            if (d === void 0)
                throw this.manager.itemError(e),
                h;
            delete Zr[e];
            for (let l = 0, f = d.length; l < f; l++) {
                const p = d[l];
                p.onError && p.onError(h)
            }
            this.manager.itemError(e)
        }
        ).finally(()=>{
            this.manager.itemEnd(e)
        }
        ),
        this.manager.itemStart(e)
    }
    setResponseType(e) {
        return this.responseType = e,
        this
    }
    setMimeType(e) {
        return this.mimeType = e,
        this
    }
}
class O3 extends ko {
    constructor(e) {
        super(e)
    }
    load(e, t, n, i) {
        this.path !== void 0 && (e = this.path + e),
        e = this.manager.resolveURL(e);
        const s = this
          , o = fl.get(e);
        if (o !== void 0)
            return s.manager.itemStart(e),
            setTimeout(function() {
                t && t(o),
                s.manager.itemEnd(e)
            }, 0),
            o;
        const a = Uc("img");
        function c() {
            d(),
            fl.add(e, this),
            t && t(this),
            s.manager.itemEnd(e)
        }
        function h(l) {
            d(),
            i && i(l),
            s.manager.itemError(e),
            s.manager.itemEnd(e)
        }
        function d() {
            a.removeEventListener("load", c, !1),
            a.removeEventListener("error", h, !1)
        }
        return a.addEventListener("load", c, !1),
        a.addEventListener("error", h, !1),
        e.slice(0, 5) !== "data:" && this.crossOrigin !== void 0 && (a.crossOrigin = this.crossOrigin),
        s.manager.itemStart(e),
        a.src = e,
        a
    }
}
class $b extends ko {
    constructor(e) {
        super(e)
    }
    load(e, t, n, i) {
        const s = new Pn
          , o = new O3(this.manager);
        return o.setCrossOrigin(this.crossOrigin),
        o.setPath(this.path),
        o.load(e, function(a) {
            s.image = a,
            s.needsUpdate = !0,
            t !== void 0 && t(s)
        }, n, i),
        s
    }
}
class X_ extends Yt {
    constructor(e, t=1) {
        super(),
        this.isLight = !0,
        this.type = "Light",
        this.color = new Ke(e),
        this.intensity = t
    }
    dispose() {}
    copy(e, t) {
        return super.copy(e, t),
        this.color.copy(e.color),
        this.intensity = e.intensity,
        this
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return t.object.color = this.color.getHex(),
        t.object.intensity = this.intensity,
        this.groundColor !== void 0 && (t.object.groundColor = this.groundColor.getHex()),
        this.distance !== void 0 && (t.object.distance = this.distance),
        this.angle !== void 0 && (t.object.angle = this.angle),
        this.decay !== void 0 && (t.object.decay = this.decay),
        this.penumbra !== void 0 && (t.object.penumbra = this.penumbra),
        this.shadow !== void 0 && (t.object.shadow = this.shadow.toJSON()),
        t
    }
}
const Vp = new it
  , Zy = new k
  , Jy = new k;
class q_ {
    constructor(e) {
        this.camera = e,
        this.bias = 0,
        this.normalBias = 0,
        this.radius = 1,
        this.blurSamples = 8,
        this.mapSize = new Ce(512,512),
        this.map = null,
        this.mapPass = null,
        this.matrix = new it,
        this.autoUpdate = !0,
        this.needsUpdate = !1,
        this._frustum = new O_,
        this._frameExtents = new Ce(1,1),
        this._viewportCount = 1,
        this._viewports = [new Ct(0,0,1,1)]
    }
    getViewportCount() {
        return this._viewportCount
    }
    getFrustum() {
        return this._frustum
    }
    updateMatrices(e) {
        const t = this.camera
          , n = this.matrix;
        Zy.setFromMatrixPosition(e.matrixWorld),
        t.position.copy(Zy),
        Jy.setFromMatrixPosition(e.target.matrixWorld),
        t.lookAt(Jy),
        t.updateMatrixWorld(),
        Vp.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse),
        this._frustum.setFromProjectionMatrix(Vp),
        n.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1),
        n.multiply(Vp)
    }
    getViewport(e) {
        return this._viewports[e]
    }
    getFrameExtents() {
        return this._frameExtents
    }
    dispose() {
        this.map && this.map.dispose(),
        this.mapPass && this.mapPass.dispose()
    }
    copy(e) {
        return this.camera = e.camera.clone(),
        this.bias = e.bias,
        this.radius = e.radius,
        this.mapSize.copy(e.mapSize),
        this
    }
    clone() {
        return new this.constructor().copy(this)
    }
    toJSON() {
        const e = {};
        return this.bias !== 0 && (e.bias = this.bias),
        this.normalBias !== 0 && (e.normalBias = this.normalBias),
        this.radius !== 1 && (e.radius = this.radius),
        (this.mapSize.x !== 512 || this.mapSize.y !== 512) && (e.mapSize = this.mapSize.toArray()),
        e.camera = this.camera.toJSON(!1).object,
        delete e.camera.matrix,
        e
    }
}
class U3 extends q_ {
    constructor() {
        super(new qn(50,1,.5,500)),
        this.isSpotLightShadow = !0,
        this.focus = 1
    }
    updateMatrices(e) {
        const t = this.camera
          , n = al * 2 * e.angle * this.focus
          , i = this.mapSize.width / this.mapSize.height
          , s = e.distance || t.far;
        (n !== t.fov || i !== t.aspect || s !== t.far) && (t.fov = n,
        t.aspect = i,
        t.far = s,
        t.updateProjectionMatrix()),
        super.updateMatrices(e)
    }
    copy(e) {
        return super.copy(e),
        this.focus = e.focus,
        this
    }
}
class N3 extends X_ {
    constructor(e, t, n=0, i=Math.PI / 3, s=0, o=2) {
        super(e, t),
        this.isSpotLight = !0,
        this.type = "SpotLight",
        this.position.copy(Yt.DEFAULT_UP),
        this.updateMatrix(),
        this.target = new Yt,
        this.distance = n,
        this.angle = i,
        this.penumbra = s,
        this.decay = o,
        this.map = null,
        this.shadow = new U3
    }
    get power() {
        return this.intensity * Math.PI
    }
    set power(e) {
        this.intensity = e / Math.PI
    }
    dispose() {
        this.shadow.dispose()
    }
    copy(e, t) {
        return super.copy(e, t),
        this.distance = e.distance,
        this.angle = e.angle,
        this.penumbra = e.penumbra,
        this.decay = e.decay,
        this.target = e.target.clone(),
        this.shadow = e.shadow.clone(),
        this
    }
}
const Qy = new it
  , ec = new k
  , Gp = new k;
class F3 extends q_ {
    constructor() {
        super(new qn(90,1,.5,500)),
        this.isPointLightShadow = !0,
        this._frameExtents = new Ce(4,2),
        this._viewportCount = 6,
        this._viewports = [new Ct(2,1,1,1), new Ct(0,1,1,1), new Ct(3,1,1,1), new Ct(1,1,1,1), new Ct(3,0,1,1), new Ct(1,0,1,1)],
        this._cubeDirections = [new k(1,0,0), new k(-1,0,0), new k(0,0,1), new k(0,0,-1), new k(0,1,0), new k(0,-1,0)],
        this._cubeUps = [new k(0,1,0), new k(0,1,0), new k(0,1,0), new k(0,1,0), new k(0,0,1), new k(0,0,-1)]
    }
    updateMatrices(e, t=0) {
        const n = this.camera
          , i = this.matrix
          , s = e.distance || n.far;
        s !== n.far && (n.far = s,
        n.updateProjectionMatrix()),
        ec.setFromMatrixPosition(e.matrixWorld),
        n.position.copy(ec),
        Gp.copy(n.position),
        Gp.add(this._cubeDirections[t]),
        n.up.copy(this._cubeUps[t]),
        n.lookAt(Gp),
        n.updateMatrixWorld(),
        i.makeTranslation(-ec.x, -ec.y, -ec.z),
        Qy.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse),
        this._frustum.setFromProjectionMatrix(Qy)
    }
}
class B3 extends X_ {
    constructor(e, t, n=0, i=2) {
        super(e, t),
        this.isPointLight = !0,
        this.type = "PointLight",
        this.distance = n,
        this.decay = i,
        this.shadow = new F3
    }
    get power() {
        return this.intensity * 4 * Math.PI
    }
    set power(e) {
        this.intensity = e / (4 * Math.PI)
    }
    dispose() {
        this.shadow.dispose()
    }
    copy(e, t) {
        return super.copy(e, t),
        this.distance = e.distance,
        this.decay = e.decay,
        this.shadow = e.shadow.clone(),
        this
    }
}
class k3 extends q_ {
    constructor() {
        super(new vl(-5,5,5,-5,.5,500)),
        this.isDirectionalLightShadow = !0
    }
}
class z3 extends X_ {
    constructor(e, t) {
        super(e, t),
        this.isDirectionalLight = !0,
        this.type = "DirectionalLight",
        this.position.copy(Yt.DEFAULT_UP),
        this.updateMatrix(),
        this.target = new Yt,
        this.shadow = new k3
    }
    dispose() {
        this.shadow.dispose()
    }
    copy(e) {
        return super.copy(e),
        this.target = e.target.clone(),
        this.shadow = e.shadow.clone(),
        this
    }
}
class bc {
    static decodeText(e) {
        if (typeof TextDecoder < "u")
            return new TextDecoder().decode(e);
        let t = "";
        for (let n = 0, i = e.length; n < i; n++)
            t += String.fromCharCode(e[n]);
        try {
            return decodeURIComponent(escape(t))
        } catch {
            return t
        }
    }
    static extractUrlBase(e) {
        const t = e.lastIndexOf("/");
        return t === -1 ? "./" : e.slice(0, t + 1)
    }
    static resolveURL(e, t) {
        return typeof e != "string" || e === "" ? "" : (/^https?:\/\//i.test(t) && /^\//.test(e) && (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")),
        /^(https?:)?\/\//i.test(e) || /^data:.*,.*$/i.test(e) || /^blob:.*$/i.test(e) ? e : t + e)
    }
}
class AV extends mn {
    constructor() {
        super(),
        this.isInstancedBufferGeometry = !0,
        this.type = "InstancedBufferGeometry",
        this.instanceCount = 1 / 0
    }
    copy(e) {
        return super.copy(e),
        this.instanceCount = e.instanceCount,
        this
    }
    toJSON() {
        const e = super.toJSON();
        return e.instanceCount = this.instanceCount,
        e.isInstancedBufferGeometry = !0,
        e
    }
}
class H3 extends ko {
    constructor(e) {
        super(e),
        this.isImageBitmapLoader = !0,
        typeof createImageBitmap > "u" && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),
        typeof fetch > "u" && console.warn("THREE.ImageBitmapLoader: fetch() not supported."),
        this.options = {
            premultiplyAlpha: "none"
        }
    }
    setOptions(e) {
        return this.options = e,
        this
    }
    load(e, t, n, i) {
        e === void 0 && (e = ""),
        this.path !== void 0 && (e = this.path + e),
        e = this.manager.resolveURL(e);
        const s = this
          , o = fl.get(e);
        if (o !== void 0)
            return s.manager.itemStart(e),
            setTimeout(function() {
                t && t(o),
                s.manager.itemEnd(e)
            }, 0),
            o;
        const a = {};
        a.credentials = this.crossOrigin === "anonymous" ? "same-origin" : "include",
        a.headers = this.requestHeader,
        fetch(e, a).then(function(c) {
            return c.blob()
        }).then(function(c) {
            return createImageBitmap(c, Object.assign(s.options, {
                colorSpaceConversion: "none"
            }))
        }).then(function(c) {
            fl.add(e, c),
            t && t(c),
            s.manager.itemEnd(e)
        }).catch(function(c) {
            i && i(c),
            s.manager.itemError(e),
            s.manager.itemEnd(e)
        }),
        s.manager.itemStart(e)
    }
}
class V3 {
    constructor(e=!0) {
        this.autoStart = e,
        this.startTime = 0,
        this.oldTime = 0,
        this.elapsedTime = 0,
        this.running = !1
    }
    start() {
        this.startTime = ex(),
        this.oldTime = this.startTime,
        this.elapsedTime = 0,
        this.running = !0
    }
    stop() {
        this.getElapsedTime(),
        this.running = !1,
        this.autoStart = !1
    }
    getElapsedTime() {
        return this.getDelta(),
        this.elapsedTime
    }
    getDelta() {
        let e = 0;
        if (this.autoStart && !this.running)
            return this.start(),
            0;
        if (this.running) {
            const t = ex();
            e = (t - this.oldTime) / 1e3,
            this.oldTime = t,
            this.elapsedTime += e
        }
        return e
    }
}
function ex() {
    return (typeof performance > "u" ? Date : performance).now()
}
class G3 {
    constructor(e, t, n) {
        this.binding = e,
        this.valueSize = n;
        let i, s, o;
        switch (t) {
        case "quaternion":
            i = this._slerp,
            s = this._slerpAdditive,
            o = this._setAdditiveIdentityQuaternion,
            this.buffer = new Float64Array(n * 6),
            this._workIndex = 5;
            break;
        case "string":
        case "bool":
            i = this._select,
            s = this._select,
            o = this._setAdditiveIdentityOther,
            this.buffer = new Array(n * 5);
            break;
        default:
            i = this._lerp,
            s = this._lerpAdditive,
            o = this._setAdditiveIdentityNumeric,
            this.buffer = new Float64Array(n * 5)
        }
        this._mixBufferRegion = i,
        this._mixBufferRegionAdditive = s,
        this._setIdentity = o,
        this._origIndex = 3,
        this._addIndex = 4,
        this.cumulativeWeight = 0,
        this.cumulativeWeightAdditive = 0,
        this.useCount = 0,
        this.referenceCount = 0
    }
    accumulate(e, t) {
        const n = this.buffer
          , i = this.valueSize
          , s = e * i + i;
        let o = this.cumulativeWeight;
        if (o === 0) {
            for (let a = 0; a !== i; ++a)
                n[s + a] = n[a];
            o = t
        } else {
            o += t;
            const a = t / o;
            this._mixBufferRegion(n, s, 0, a, i)
        }
        this.cumulativeWeight = o
    }
    accumulateAdditive(e) {
        const t = this.buffer
          , n = this.valueSize
          , i = n * this._addIndex;
        this.cumulativeWeightAdditive === 0 && this._setIdentity(),
        this._mixBufferRegionAdditive(t, i, 0, e, n),
        this.cumulativeWeightAdditive += e
    }
    apply(e) {
        const t = this.valueSize
          , n = this.buffer
          , i = e * t + t
          , s = this.cumulativeWeight
          , o = this.cumulativeWeightAdditive
          , a = this.binding;
        if (this.cumulativeWeight = 0,
        this.cumulativeWeightAdditive = 0,
        s < 1) {
            const c = t * this._origIndex;
            this._mixBufferRegion(n, i, c, 1 - s, t)
        }
        o > 0 && this._mixBufferRegionAdditive(n, i, this._addIndex * t, 1, t);
        for (let c = t, h = t + t; c !== h; ++c)
            if (n[c] !== n[c + t]) {
                a.setValue(n, i);
                break
            }
    }
    saveOriginalState() {
        const e = this.binding
          , t = this.buffer
          , n = this.valueSize
          , i = n * this._origIndex;
        e.getValue(t, i);
        for (let s = n, o = i; s !== o; ++s)
            t[s] = t[i + s % n];
        this._setIdentity(),
        this.cumulativeWeight = 0,
        this.cumulativeWeightAdditive = 0
    }
    restoreOriginalState() {
        const e = this.valueSize * 3;
        this.binding.setValue(this.buffer, e)
    }
    _setAdditiveIdentityNumeric() {
        const e = this._addIndex * this.valueSize
          , t = e + this.valueSize;
        for (let n = e; n < t; n++)
            this.buffer[n] = 0
    }
    _setAdditiveIdentityQuaternion() {
        this._setAdditiveIdentityNumeric(),
        this.buffer[this._addIndex * this.valueSize + 3] = 1
    }
    _setAdditiveIdentityOther() {
        const e = this._origIndex * this.valueSize
          , t = this._addIndex * this.valueSize;
        for (let n = 0; n < this.valueSize; n++)
            this.buffer[t + n] = this.buffer[e + n]
    }
    _select(e, t, n, i, s) {
        if (i >= .5)
            for (let o = 0; o !== s; ++o)
                e[t + o] = e[n + o]
    }
    _slerp(e, t, n, i) {
        Hi.slerpFlat(e, t, e, t, e, n, i)
    }
    _slerpAdditive(e, t, n, i, s) {
        const o = this._workIndex * s;
        Hi.multiplyQuaternionsFlat(e, o, e, t, e, n),
        Hi.slerpFlat(e, t, e, t, e, o, i)
    }
    _lerp(e, t, n, i, s) {
        const o = 1 - i;
        for (let a = 0; a !== s; ++a) {
            const c = t + a;
            e[c] = e[c] * o + e[n + a] * i
        }
    }
    _lerpAdditive(e, t, n, i, s) {
        for (let o = 0; o !== s; ++o) {
            const a = t + o;
            e[a] = e[a] + e[n + o] * i
        }
    }
}
const K_ = "\\[\\]\\.:\\/"
  , W3 = new RegExp("[" + K_ + "]","g")
  , Y_ = "[^" + K_ + "]"
  , j3 = "[^" + K_.replace("\\.", "") + "]"
  , X3 = /((?:WC+[\/:])*)/.source.replace("WC", Y_)
  , q3 = /(WCOD+)?/.source.replace("WCOD", j3)
  , K3 = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", Y_)
  , Y3 = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", Y_)
  , $3 = new RegExp("^" + X3 + q3 + K3 + Y3 + "$")
  , Z3 = ["material", "materials", "bones", "map"];
class J3 {
    constructor(e, t, n) {
        const i = n || Pt.parseTrackName(t);
        this._targetGroup = e,
        this._bindings = e.subscribe_(t, i)
    }
    getValue(e, t) {
        this.bind();
        const n = this._targetGroup.nCachedObjects_
          , i = this._bindings[n];
        i !== void 0 && i.getValue(e, t)
    }
    setValue(e, t) {
        const n = this._bindings;
        for (let i = this._targetGroup.nCachedObjects_, s = n.length; i !== s; ++i)
            n[i].setValue(e, t)
    }
    bind() {
        const e = this._bindings;
        for (let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t)
            e[t].bind()
    }
    unbind() {
        const e = this._bindings;
        for (let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t)
            e[t].unbind()
    }
}
class Pt {
    constructor(e, t, n) {
        this.path = t,
        this.parsedPath = n || Pt.parseTrackName(t),
        this.node = Pt.findNode(e, this.parsedPath.nodeName),
        this.rootNode = e,
        this.getValue = this._getValue_unbound,
        this.setValue = this._setValue_unbound
    }
    static create(e, t, n) {
        return e && e.isAnimationObjectGroup ? new Pt.Composite(e,t,n) : new Pt(e,t,n)
    }
    static sanitizeNodeName(e) {
        return e.replace(/\s/g, "_").replace(W3, "")
    }
    static parseTrackName(e) {
        const t = $3.exec(e);
        if (t === null)
            throw new Error("PropertyBinding: Cannot parse trackName: " + e);
        const n = {
            nodeName: t[2],
            objectName: t[3],
            objectIndex: t[4],
            propertyName: t[5],
            propertyIndex: t[6]
        }
          , i = n.nodeName && n.nodeName.lastIndexOf(".");
        if (i !== void 0 && i !== -1) {
            const s = n.nodeName.substring(i + 1);
            Z3.indexOf(s) !== -1 && (n.nodeName = n.nodeName.substring(0, i),
            n.objectName = s)
        }
        if (n.propertyName === null || n.propertyName.length === 0)
            throw new Error("PropertyBinding: can not parse propertyName from trackName: " + e);
        return n
    }
    static findNode(e, t) {
        if (t === void 0 || t === "" || t === "." || t === -1 || t === e.name || t === e.uuid)
            return e;
        if (e.skeleton) {
            const n = e.skeleton.getBoneByName(t);
            if (n !== void 0)
                return n
        }
        if (e.children) {
            const n = function(s) {
                for (let o = 0; o < s.length; o++) {
                    const a = s[o];
                    if (a.name === t || a.uuid === t)
                        return a;
                    const c = n(a.children);
                    if (c)
                        return c
                }
                return null
            }
              , i = n(e.children);
            if (i)
                return i
        }
        return null
    }
    _getValue_unavailable() {}
    _setValue_unavailable() {}
    _getValue_direct(e, t) {
        e[t] = this.targetObject[this.propertyName]
    }
    _getValue_array(e, t) {
        const n = this.resolvedProperty;
        for (let i = 0, s = n.length; i !== s; ++i)
            e[t++] = n[i]
    }
    _getValue_arrayElement(e, t) {
        e[t] = this.resolvedProperty[this.propertyIndex]
    }
    _getValue_toArray(e, t) {
        this.resolvedProperty.toArray(e, t)
    }
    _setValue_direct(e, t) {
        this.targetObject[this.propertyName] = e[t]
    }
    _setValue_direct_setNeedsUpdate(e, t) {
        this.targetObject[this.propertyName] = e[t],
        this.targetObject.needsUpdate = !0
    }
    _setValue_direct_setMatrixWorldNeedsUpdate(e, t) {
        this.targetObject[this.propertyName] = e[t],
        this.targetObject.matrixWorldNeedsUpdate = !0
    }
    _setValue_array(e, t) {
        const n = this.resolvedProperty;
        for (let i = 0, s = n.length; i !== s; ++i)
            n[i] = e[t++]
    }
    _setValue_array_setNeedsUpdate(e, t) {
        const n = this.resolvedProperty;
        for (let i = 0, s = n.length; i !== s; ++i)
            n[i] = e[t++];
        this.targetObject.needsUpdate = !0
    }
    _setValue_array_setMatrixWorldNeedsUpdate(e, t) {
        const n = this.resolvedProperty;
        for (let i = 0, s = n.length; i !== s; ++i)
            n[i] = e[t++];
        this.targetObject.matrixWorldNeedsUpdate = !0
    }
    _setValue_arrayElement(e, t) {
        this.resolvedProperty[this.propertyIndex] = e[t]
    }
    _setValue_arrayElement_setNeedsUpdate(e, t) {
        this.resolvedProperty[this.propertyIndex] = e[t],
        this.targetObject.needsUpdate = !0
    }
    _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) {
        this.resolvedProperty[this.propertyIndex] = e[t],
        this.targetObject.matrixWorldNeedsUpdate = !0
    }
    _setValue_fromArray(e, t) {
        this.resolvedProperty.fromArray(e, t)
    }
    _setValue_fromArray_setNeedsUpdate(e, t) {
        this.resolvedProperty.fromArray(e, t),
        this.targetObject.needsUpdate = !0
    }
    _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) {
        this.resolvedProperty.fromArray(e, t),
        this.targetObject.matrixWorldNeedsUpdate = !0
    }
    _getValue_unbound(e, t) {
        this.bind(),
        this.getValue(e, t)
    }
    _setValue_unbound(e, t) {
        this.bind(),
        this.setValue(e, t)
    }
    bind() {
        let e = this.node;
        const t = this.parsedPath
          , n = t.objectName
          , i = t.propertyName;
        let s = t.propertyIndex;
        if (e || (e = Pt.findNode(this.rootNode, t.nodeName),
        this.node = e),
        this.getValue = this._getValue_unavailable,
        this.setValue = this._setValue_unavailable,
        !e) {
            console.warn("THREE.PropertyBinding: No target node found for track: " + this.path + ".");
            return
        }
        if (n) {
            let h = t.objectIndex;
            switch (n) {
            case "materials":
                if (!e.material) {
                    console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                    return
                }
                if (!e.material.materials) {
                    console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                    return
                }
                e = e.material.materials;
                break;
            case "bones":
                if (!e.skeleton) {
                    console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                    return
                }
                e = e.skeleton.bones;
                for (let d = 0; d < e.length; d++)
                    if (e[d].name === h) {
                        h = d;
                        break
                    }
                break;
            case "map":
                if ("map"in e) {
                    e = e.map;
                    break
                }
                if (!e.material) {
                    console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                    return
                }
                if (!e.material.map) {
                    console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.", this);
                    return
                }
                e = e.material.map;
                break;
            default:
                if (e[n] === void 0) {
                    console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                    return
                }
                e = e[n]
            }
            if (h !== void 0) {
                if (e[h] === void 0) {
                    console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, e);
                    return
                }
                e = e[h]
            }
        }
        const o = e[i];
        if (o === void 0) {
            const h = t.nodeName;
            console.error("THREE.PropertyBinding: Trying to update property for track: " + h + "." + i + " but it wasn't found.", e);
            return
        }
        let a = this.Versioning.None;
        this.targetObject = e,
        e.needsUpdate !== void 0 ? a = this.Versioning.NeedsUpdate : e.matrixWorldNeedsUpdate !== void 0 && (a = this.Versioning.MatrixWorldNeedsUpdate);
        let c = this.BindingType.Direct;
        if (s !== void 0) {
            if (i === "morphTargetInfluences") {
                if (!e.geometry) {
                    console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                    return
                }
                if (!e.geometry.morphAttributes) {
                    console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                    return
                }
                e.morphTargetDictionary[s] !== void 0 && (s = e.morphTargetDictionary[s])
            }
            c = this.BindingType.ArrayElement,
            this.resolvedProperty = o,
            this.propertyIndex = s
        } else
            o.fromArray !== void 0 && o.toArray !== void 0 ? (c = this.BindingType.HasFromToArray,
            this.resolvedProperty = o) : Array.isArray(o) ? (c = this.BindingType.EntireArray,
            this.resolvedProperty = o) : this.propertyName = i;
        this.getValue = this.GetterByBindingType[c],
        this.setValue = this.SetterByBindingTypeAndVersioning[c][a]
    }
    unbind() {
        this.node = null,
        this.getValue = this._getValue_unbound,
        this.setValue = this._setValue_unbound
    }
}
Pt.Composite = J3;
Pt.prototype.BindingType = {
    Direct: 0,
    EntireArray: 1,
    ArrayElement: 2,
    HasFromToArray: 3
};
Pt.prototype.Versioning = {
    None: 0,
    NeedsUpdate: 1,
    MatrixWorldNeedsUpdate: 2
};
Pt.prototype.GetterByBindingType = [Pt.prototype._getValue_direct, Pt.prototype._getValue_array, Pt.prototype._getValue_arrayElement, Pt.prototype._getValue_toArray];
Pt.prototype.SetterByBindingTypeAndVersioning = [[Pt.prototype._setValue_direct, Pt.prototype._setValue_direct_setNeedsUpdate, Pt.prototype._setValue_direct_setMatrixWorldNeedsUpdate], [Pt.prototype._setValue_array, Pt.prototype._setValue_array_setNeedsUpdate, Pt.prototype._setValue_array_setMatrixWorldNeedsUpdate], [Pt.prototype._setValue_arrayElement, Pt.prototype._setValue_arrayElement_setNeedsUpdate, Pt.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate], [Pt.prototype._setValue_fromArray, Pt.prototype._setValue_fromArray_setNeedsUpdate, Pt.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];
class Q3 {
    constructor(e, t, n=null, i=t.blendMode) {
        this._mixer = e,
        this._clip = t,
        this._localRoot = n,
        this.blendMode = i;
        const s = t.tracks
          , o = s.length
          , a = new Array(o)
          , c = {
            endingStart: za,
            endingEnd: za
        };
        for (let h = 0; h !== o; ++h) {
            const d = s[h].createInterpolant(null);
            a[h] = d,
            d.settings = c
        }
        this._interpolantSettings = c,
        this._interpolants = a,
        this._propertyBindings = new Array(o),
        this._cacheIndex = null,
        this._byClipCacheIndex = null,
        this._timeScaleInterpolant = null,
        this._weightInterpolant = null,
        this.loop = VL,
        this._loopCount = -1,
        this._startTime = null,
        this.time = 0,
        this.timeScale = 1,
        this._effectiveTimeScale = 1,
        this.weight = 1,
        this._effectiveWeight = 1,
        this.repetitions = 1 / 0,
        this.paused = !1,
        this.enabled = !0,
        this.clampWhenFinished = !1,
        this.zeroSlopeAtStart = !0,
        this.zeroSlopeAtEnd = !0
    }
    play() {
        return this._mixer._activateAction(this),
        this
    }
    stop() {
        return this._mixer._deactivateAction(this),
        this.reset()
    }
    reset() {
        return this.paused = !1,
        this.enabled = !0,
        this.time = 0,
        this._loopCount = -1,
        this._startTime = null,
        this.stopFading().stopWarping()
    }
    isRunning() {
        return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this)
    }
    isScheduled() {
        return this._mixer._isActiveAction(this)
    }
    startAt(e) {
        return this._startTime = e,
        this
    }
    setLoop(e, t) {
        return this.loop = e,
        this.repetitions = t,
        this
    }
    setEffectiveWeight(e) {
        return this.weight = e,
        this._effectiveWeight = this.enabled ? e : 0,
        this.stopFading()
    }
    getEffectiveWeight() {
        return this._effectiveWeight
    }
    fadeIn(e) {
        return this._scheduleFading(e, 0, 1)
    }
    fadeOut(e) {
        return this._scheduleFading(e, 1, 0)
    }
    crossFadeFrom(e, t, n) {
        if (e.fadeOut(t),
        this.fadeIn(t),
        n) {
            const i = this._clip.duration
              , s = e._clip.duration
              , o = s / i
              , a = i / s;
            e.warp(1, o, t),
            this.warp(a, 1, t)
        }
        return this
    }
    crossFadeTo(e, t, n) {
        return e.crossFadeFrom(this, t, n)
    }
    stopFading() {
        const e = this._weightInterpolant;
        return e !== null && (this._weightInterpolant = null,
        this._mixer._takeBackControlInterpolant(e)),
        this
    }
    setEffectiveTimeScale(e) {
        return this.timeScale = e,
        this._effectiveTimeScale = this.paused ? 0 : e,
        this.stopWarping()
    }
    getEffectiveTimeScale() {
        return this._effectiveTimeScale
    }
    setDuration(e) {
        return this.timeScale = this._clip.duration / e,
        this.stopWarping()
    }
    syncWith(e) {
        return this.time = e.time,
        this.timeScale = e.timeScale,
        this.stopWarping()
    }
    halt(e) {
        return this.warp(this._effectiveTimeScale, 0, e)
    }
    warp(e, t, n) {
        const i = this._mixer
          , s = i.time
          , o = this.timeScale;
        let a = this._timeScaleInterpolant;
        a === null && (a = i._lendControlInterpolant(),
        this._timeScaleInterpolant = a);
        const c = a.parameterPositions
          , h = a.sampleValues;
        return c[0] = s,
        c[1] = s + n,
        h[0] = e / o,
        h[1] = t / o,
        this
    }
    stopWarping() {
        const e = this._timeScaleInterpolant;
        return e !== null && (this._timeScaleInterpolant = null,
        this._mixer._takeBackControlInterpolant(e)),
        this
    }
    getMixer() {
        return this._mixer
    }
    getClip() {
        return this._clip
    }
    getRoot() {
        return this._localRoot || this._mixer._root
    }
    _update(e, t, n, i) {
        if (!this.enabled) {
            this._updateWeight(e);
            return
        }
        const s = this._startTime;
        if (s !== null) {
            const c = (e - s) * n;
            c < 0 || n === 0 ? t = 0 : (this._startTime = null,
            t = n * c)
        }
        t *= this._updateTimeScale(e);
        const o = this._updateTime(t)
          , a = this._updateWeight(e);
        if (a > 0) {
            const c = this._interpolants
              , h = this._propertyBindings;
            switch (this.blendMode) {
            case WL:
                for (let d = 0, l = c.length; d !== l; ++d)
                    c[d].evaluate(o),
                    h[d].accumulateAdditive(a);
                break;
            case P_:
            default:
                for (let d = 0, l = c.length; d !== l; ++d)
                    c[d].evaluate(o),
                    h[d].accumulate(i, a)
            }
        }
    }
    _updateWeight(e) {
        let t = 0;
        if (this.enabled) {
            t = this.weight;
            const n = this._weightInterpolant;
            if (n !== null) {
                const i = n.evaluate(e)[0];
                t *= i,
                e > n.parameterPositions[1] && (this.stopFading(),
                i === 0 && (this.enabled = !1))
            }
        }
        return this._effectiveWeight = t,
        t
    }
    _updateTimeScale(e) {
        let t = 0;
        if (!this.paused) {
            t = this.timeScale;
            const n = this._timeScaleInterpolant;
            if (n !== null) {
                const i = n.evaluate(e)[0];
                t *= i,
                e > n.parameterPositions[1] && (this.stopWarping(),
                t === 0 ? this.paused = !0 : this.timeScale = t)
            }
        }
        return this._effectiveTimeScale = t,
        t
    }
    _updateTime(e) {
        const t = this._clip.duration
          , n = this.loop;
        let i = this.time + e
          , s = this._loopCount;
        const o = n === GL;
        if (e === 0)
            return s === -1 ? i : o && (s & 1) === 1 ? t - i : i;
        if (n === HL) {
            s === -1 && (this._loopCount = 0,
            this._setEndings(!0, !0, !1));
            e: {
                if (i >= t)
                    i = t;
                else if (i < 0)
                    i = 0;
                else {
                    this.time = i;
                    break e
                }
                this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                this.time = i,
                this._mixer.dispatchEvent({
                    type: "finished",
                    action: this,
                    direction: e < 0 ? -1 : 1
                })
            }
        } else {
            if (s === -1 && (e >= 0 ? (s = 0,
            this._setEndings(!0, this.repetitions === 0, o)) : this._setEndings(this.repetitions === 0, !0, o)),
            i >= t || i < 0) {
                const a = Math.floor(i / t);
                i -= t * a,
                s += Math.abs(a);
                const c = this.repetitions - s;
                if (c <= 0)
                    this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                    i = e > 0 ? t : 0,
                    this.time = i,
                    this._mixer.dispatchEvent({
                        type: "finished",
                        action: this,
                        direction: e > 0 ? 1 : -1
                    });
                else {
                    if (c === 1) {
                        const h = e < 0;
                        this._setEndings(h, !h, o)
                    } else
                        this._setEndings(!1, !1, o);
                    this._loopCount = s,
                    this.time = i,
                    this._mixer.dispatchEvent({
                        type: "loop",
                        action: this,
                        loopDelta: a
                    })
                }
            } else
                this.time = i;
            if (o && (s & 1) === 1)
                return t - i
        }
        return i
    }
    _setEndings(e, t, n) {
        const i = this._interpolantSettings;
        n ? (i.endingStart = Ha,
        i.endingEnd = Ha) : (e ? i.endingStart = this.zeroSlopeAtStart ? Ha : za : i.endingStart = Xh,
        t ? i.endingEnd = this.zeroSlopeAtEnd ? Ha : za : i.endingEnd = Xh)
    }
    _scheduleFading(e, t, n) {
        const i = this._mixer
          , s = i.time;
        let o = this._weightInterpolant;
        o === null && (o = i._lendControlInterpolant(),
        this._weightInterpolant = o);
        const a = o.parameterPositions
          , c = o.sampleValues;
        return a[0] = s,
        c[0] = t,
        a[1] = s + e,
        c[1] = n,
        this
    }
}
const eF = new Float32Array(1);
class tF extends Sr {
    constructor(e) {
        super(),
        this._root = e,
        this._initMemoryManager(),
        this._accuIndex = 0,
        this.time = 0,
        this.timeScale = 1
    }
    _bindAction(e, t) {
        const n = e._localRoot || this._root
          , i = e._clip.tracks
          , s = i.length
          , o = e._propertyBindings
          , a = e._interpolants
          , c = n.uuid
          , h = this._bindingsByRootAndName;
        let d = h[c];
        d === void 0 && (d = {},
        h[c] = d);
        for (let l = 0; l !== s; ++l) {
            const f = i[l]
              , p = f.name;
            let g = d[p];
            if (g !== void 0)
                ++g.referenceCount,
                o[l] = g;
            else {
                if (g = o[l],
                g !== void 0) {
                    g._cacheIndex === null && (++g.referenceCount,
                    this._addInactiveBinding(g, c, p));
                    continue
                }
                const y = t && t._propertyBindings[l].binding.parsedPath;
                g = new G3(Pt.create(n, p, y),f.ValueTypeName,f.getValueSize()),
                ++g.referenceCount,
                this._addInactiveBinding(g, c, p),
                o[l] = g
            }
            a[l].resultBuffer = g.buffer
        }
    }
    _activateAction(e) {
        if (!this._isActiveAction(e)) {
            if (e._cacheIndex === null) {
                const n = (e._localRoot || this._root).uuid
                  , i = e._clip.uuid
                  , s = this._actionsByClip[i];
                this._bindAction(e, s && s.knownActions[0]),
                this._addInactiveAction(e, i, n)
            }
            const t = e._propertyBindings;
            for (let n = 0, i = t.length; n !== i; ++n) {
                const s = t[n];
                s.useCount++ === 0 && (this._lendBinding(s),
                s.saveOriginalState())
            }
            this._lendAction(e)
        }
    }
    _deactivateAction(e) {
        if (this._isActiveAction(e)) {
            const t = e._propertyBindings;
            for (let n = 0, i = t.length; n !== i; ++n) {
                const s = t[n];
                --s.useCount === 0 && (s.restoreOriginalState(),
                this._takeBackBinding(s))
            }
            this._takeBackAction(e)
        }
    }
    _initMemoryManager() {
        this._actions = [],
        this._nActiveActions = 0,
        this._actionsByClip = {},
        this._bindings = [],
        this._nActiveBindings = 0,
        this._bindingsByRootAndName = {},
        this._controlInterpolants = [],
        this._nActiveControlInterpolants = 0;
        const e = this;
        this.stats = {
            actions: {
                get total() {
                    return e._actions.length
                },
                get inUse() {
                    return e._nActiveActions
                }
            },
            bindings: {
                get total() {
                    return e._bindings.length
                },
                get inUse() {
                    return e._nActiveBindings
                }
            },
            controlInterpolants: {
                get total() {
                    return e._controlInterpolants.length
                },
                get inUse() {
                    return e._nActiveControlInterpolants
                }
            }
        }
    }
    _isActiveAction(e) {
        const t = e._cacheIndex;
        return t !== null && t < this._nActiveActions
    }
    _addInactiveAction(e, t, n) {
        const i = this._actions
          , s = this._actionsByClip;
        let o = s[t];
        if (o === void 0)
            o = {
                knownActions: [e],
                actionByRoot: {}
            },
            e._byClipCacheIndex = 0,
            s[t] = o;
        else {
            const a = o.knownActions;
            e._byClipCacheIndex = a.length,
            a.push(e)
        }
        e._cacheIndex = i.length,
        i.push(e),
        o.actionByRoot[n] = e
    }
    _removeInactiveAction(e) {
        const t = this._actions
          , n = t[t.length - 1]
          , i = e._cacheIndex;
        n._cacheIndex = i,
        t[i] = n,
        t.pop(),
        e._cacheIndex = null;
        const s = e._clip.uuid
          , o = this._actionsByClip
          , a = o[s]
          , c = a.knownActions
          , h = c[c.length - 1]
          , d = e._byClipCacheIndex;
        h._byClipCacheIndex = d,
        c[d] = h,
        c.pop(),
        e._byClipCacheIndex = null;
        const l = a.actionByRoot
          , f = (e._localRoot || this._root).uuid;
        delete l[f],
        c.length === 0 && delete o[s],
        this._removeInactiveBindingsForAction(e)
    }
    _removeInactiveBindingsForAction(e) {
        const t = e._propertyBindings;
        for (let n = 0, i = t.length; n !== i; ++n) {
            const s = t[n];
            --s.referenceCount === 0 && this._removeInactiveBinding(s)
        }
    }
    _lendAction(e) {
        const t = this._actions
          , n = e._cacheIndex
          , i = this._nActiveActions++
          , s = t[i];
        e._cacheIndex = i,
        t[i] = e,
        s._cacheIndex = n,
        t[n] = s
    }
    _takeBackAction(e) {
        const t = this._actions
          , n = e._cacheIndex
          , i = --this._nActiveActions
          , s = t[i];
        e._cacheIndex = i,
        t[i] = e,
        s._cacheIndex = n,
        t[n] = s
    }
    _addInactiveBinding(e, t, n) {
        const i = this._bindingsByRootAndName
          , s = this._bindings;
        let o = i[t];
        o === void 0 && (o = {},
        i[t] = o),
        o[n] = e,
        e._cacheIndex = s.length,
        s.push(e)
    }
    _removeInactiveBinding(e) {
        const t = this._bindings
          , n = e.binding
          , i = n.rootNode.uuid
          , s = n.path
          , o = this._bindingsByRootAndName
          , a = o[i]
          , c = t[t.length - 1]
          , h = e._cacheIndex;
        c._cacheIndex = h,
        t[h] = c,
        t.pop(),
        delete a[s],
        Object.keys(a).length === 0 && delete o[i]
    }
    _lendBinding(e) {
        const t = this._bindings
          , n = e._cacheIndex
          , i = this._nActiveBindings++
          , s = t[i];
        e._cacheIndex = i,
        t[i] = e,
        s._cacheIndex = n,
        t[n] = s
    }
    _takeBackBinding(e) {
        const t = this._bindings
          , n = e._cacheIndex
          , i = --this._nActiveBindings
          , s = t[i];
        e._cacheIndex = i,
        t[i] = e,
        s._cacheIndex = n,
        t[n] = s
    }
    _lendControlInterpolant() {
        const e = this._controlInterpolants
          , t = this._nActiveControlInterpolants++;
        let n = e[t];
        return n === void 0 && (n = new Jh(new Float32Array(2),new Float32Array(2),1,eF),
        n.__cacheIndex = t,
        e[t] = n),
        n
    }
    _takeBackControlInterpolant(e) {
        const t = this._controlInterpolants
          , n = e.__cacheIndex
          , i = --this._nActiveControlInterpolants
          , s = t[i];
        e.__cacheIndex = i,
        t[i] = e,
        s.__cacheIndex = n,
        t[n] = s
    }
    clipAction(e, t, n) {
        const i = t || this._root
          , s = i.uuid;
        let o = typeof e == "string" ? qm.findByName(i, e) : e;
        const a = o !== null ? o.uuid : e
          , c = this._actionsByClip[a];
        let h = null;
        if (n === void 0 && (o !== null ? n = o.blendMode : n = P_),
        c !== void 0) {
            const l = c.actionByRoot[s];
            if (l !== void 0 && l.blendMode === n)
                return l;
            h = c.knownActions[0],
            o === null && (o = h._clip)
        }
        if (o === null)
            return null;
        const d = new Q3(this,o,t,n);
        return this._bindAction(d, h),
        this._addInactiveAction(d, a, s),
        d
    }
    existingAction(e, t) {
        const n = t || this._root
          , i = n.uuid
          , s = typeof e == "string" ? qm.findByName(n, e) : e
          , o = s ? s.uuid : e
          , a = this._actionsByClip[o];
        return a !== void 0 && a.actionByRoot[i] || null
    }
    stopAllAction() {
        const e = this._actions
          , t = this._nActiveActions;
        for (let n = t - 1; n >= 0; --n)
            e[n].stop();
        return this
    }
    update(e) {
        e *= this.timeScale;
        const t = this._actions
          , n = this._nActiveActions
          , i = this.time += e
          , s = Math.sign(e)
          , o = this._accuIndex ^= 1;
        for (let h = 0; h !== n; ++h)
            t[h]._update(i, e, s, o);
        const a = this._bindings
          , c = this._nActiveBindings;
        for (let h = 0; h !== c; ++h)
            a[h].apply(o);
        return this
    }
    setTime(e) {
        this.time = 0;
        for (let t = 0; t < this._actions.length; t++)
            this._actions[t].time = 0;
        return this.update(e)
    }
    getRoot() {
        return this._root
    }
    uncacheClip(e) {
        const t = this._actions
          , n = e.uuid
          , i = this._actionsByClip
          , s = i[n];
        if (s !== void 0) {
            const o = s.knownActions;
            for (let a = 0, c = o.length; a !== c; ++a) {
                const h = o[a];
                this._deactivateAction(h);
                const d = h._cacheIndex
                  , l = t[t.length - 1];
                h._cacheIndex = null,
                h._byClipCacheIndex = null,
                l._cacheIndex = d,
                t[d] = l,
                t.pop(),
                this._removeInactiveBindingsForAction(h)
            }
            delete i[n]
        }
    }
    uncacheRoot(e) {
        const t = e.uuid
          , n = this._actionsByClip;
        for (const o in n) {
            const a = n[o].actionByRoot
              , c = a[t];
            c !== void 0 && (this._deactivateAction(c),
            this._removeInactiveAction(c))
        }
        const i = this._bindingsByRootAndName
          , s = i[t];
        if (s !== void 0)
            for (const o in s) {
                const a = s[o];
                a.restoreOriginalState(),
                this._removeInactiveBinding(a)
            }
    }
    uncacheAction(e, t) {
        const n = this.existingAction(e, t);
        n !== null && (this._deactivateAction(n),
        this._removeInactiveAction(n))
    }
}
class bt {
    constructor(e) {
        this.value = e
    }
    clone() {
        return new bt(this.value.clone === void 0 ? this.value : this.value.clone())
    }
}
class nF {
    constructor(e, t, n=0, i=1 / 0) {
        this.ray = new Bo(e,t),
        this.near = n,
        this.far = i,
        this.camera = null,
        this.layers = new L_,
        this.params = {
            Mesh: {},
            Line: {
                threshold: 1
            },
            LOD: {},
            Points: {
                threshold: 1
            },
            Sprite: {}
        }
    }
    set(e, t) {
        this.ray.set(e, t)
    }
    setFromCamera(e, t) {
        t.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld),
        this.ray.direction.set(e.x, e.y, .5).unproject(t).sub(this.ray.origin).normalize(),
        this.camera = t) : t.isOrthographicCamera ? (this.ray.origin.set(e.x, e.y, (t.near + t.far) / (t.near - t.far)).unproject(t),
        this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld),
        this.camera = t) : console.error("THREE.Raycaster: Unsupported camera type: " + t.type)
    }
    intersectObject(e, t=!0, n=[]) {
        return Km(e, this, n, t),
        n.sort(tx),
        n
    }
    intersectObjects(e, t=!0, n=[]) {
        for (let i = 0, s = e.length; i < s; i++)
            Km(e[i], this, n, t);
        return n.sort(tx),
        n
    }
}
function tx(r, e) {
    return r.distance - e.distance
}
function Km(r, e, t, n) {
    if (r.layers.test(e.layers) && r.raycast(e, t),
    n === !0) {
        const i = r.children;
        for (let s = 0, o = i.length; s < o; s++)
            Km(i[s], e, t, !0)
    }
}
class nx {
    constructor(e=1, t=0, n=0) {
        return this.radius = e,
        this.phi = t,
        this.theta = n,
        this
    }
    set(e, t, n) {
        return this.radius = e,
        this.phi = t,
        this.theta = n,
        this
    }
    copy(e) {
        return this.radius = e.radius,
        this.phi = e.phi,
        this.theta = e.theta,
        this
    }
    makeSafe() {
        return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)),
        this
    }
    setFromVector3(e) {
        return this.setFromCartesianCoords(e.x, e.y, e.z)
    }
    setFromCartesianCoords(e, t, n) {
        return this.radius = Math.sqrt(e * e + t * t + n * n),
        this.radius === 0 ? (this.theta = 0,
        this.phi = 0) : (this.theta = Math.atan2(e, n),
        this.phi = Math.acos(Hn(t / this.radius, -1, 1))),
        this
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
const ix = new k
  , ah = new k;
class rs {
    constructor(e=new k, t=new k) {
        this.start = e,
        this.end = t
    }
    set(e, t) {
        return this.start.copy(e),
        this.end.copy(t),
        this
    }
    copy(e) {
        return this.start.copy(e.start),
        this.end.copy(e.end),
        this
    }
    getCenter(e) {
        return e.addVectors(this.start, this.end).multiplyScalar(.5)
    }
    delta(e) {
        return e.subVectors(this.end, this.start)
    }
    distanceSq() {
        return this.start.distanceToSquared(this.end)
    }
    distance() {
        return this.start.distanceTo(this.end)
    }
    at(e, t) {
        return this.delta(t).multiplyScalar(e).add(this.start)
    }
    closestPointToPointParameter(e, t) {
        ix.subVectors(e, this.start),
        ah.subVectors(this.end, this.start);
        const n = ah.dot(ah);
        let s = ah.dot(ix) / n;
        return t && (s = Hn(s, 0, 1)),
        s
    }
    closestPointToPoint(e, t, n) {
        const i = this.closestPointToPointParameter(e, t);
        return this.delta(n).multiplyScalar(i).add(this.start)
    }
    applyMatrix4(e) {
        return this.start.applyMatrix4(e),
        this.end.applyMatrix4(e),
        this
    }
    equals(e) {
        return e.start.equals(this.start) && e.end.equals(this.end)
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{
    detail: {
        revision: gl
    }
}));
typeof window < "u" && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = gl);
const rx = {
    type: "change"
}
  , Wp = {
    type: "start"
}
  , sx = {
    type: "end"
}
  , lh = new Bo
  , ox = new pr
  , iF = Math.cos(70 * Dn.DEG2RAD);
class rF extends Sr {
    constructor(e, t) {
        super(),
        this.object = e,
        this.domElement = t,
        this.domElement.style.touchAction = "none",
        this.enabled = !0,
        this.target = new k,
        this.cursor = new k,
        this.minDistance = 0,
        this.maxDistance = 1 / 0,
        this.minZoom = 0,
        this.maxZoom = 1 / 0,
        this.minTargetRadius = 0,
        this.maxTargetRadius = 1 / 0,
        this.minPolarAngle = 0,
        this.maxPolarAngle = Math.PI,
        this.minAzimuthAngle = -1 / 0,
        this.maxAzimuthAngle = 1 / 0,
        this.enableDamping = !1,
        this.dampingFactor = .05,
        this.enableZoom = !0,
        this.zoomSpeed = 1,
        this.enableRotate = !0,
        this.rotateSpeed = 1,
        this.enablePan = !0,
        this.panSpeed = 1,
        this.screenSpacePanning = !0,
        this.keyPanSpeed = 7,
        this.zoomToCursor = !1,
        this.autoRotate = !1,
        this.autoRotateSpeed = 2,
        this.keys = {
            LEFT: "ArrowLeft",
            UP: "ArrowUp",
            RIGHT: "ArrowRight",
            BOTTOM: "ArrowDown"
        },
        this.mouseButtons = {
            LEFT: ia.ROTATE,
            MIDDLE: ia.DOLLY,
            RIGHT: ia.PAN
        },
        this.touches = {
            ONE: ra.ROTATE,
            TWO: ra.DOLLY_PAN
        },
        this.target0 = this.target.clone(),
        this.position0 = this.object.position.clone(),
        this.zoom0 = this.object.zoom,
        this._domElementKeyEvents = null,
        this.getPolarAngle = function() {
            return a.phi
        }
        ,
        this.getAzimuthalAngle = function() {
            return a.theta
        }
        ,
        this.getDistance = function() {
            return this.object.position.distanceTo(this.target)
        }
        ,
        this.listenToKeyEvents = function(G) {
            G.addEventListener("keydown", L),
            this._domElementKeyEvents = G
        }
        ,
        this.stopListenToKeyEvents = function() {
            this._domElementKeyEvents.removeEventListener("keydown", L),
            this._domElementKeyEvents = null
        }
        ,
        this.saveState = function() {
            n.target0.copy(n.target),
            n.position0.copy(n.object.position),
            n.zoom0 = n.object.zoom
        }
        ,
        this.reset = function() {
            n.target.copy(n.target0),
            n.object.position.copy(n.position0),
            n.object.zoom = n.zoom0,
            n.object.updateProjectionMatrix(),
            n.dispatchEvent(rx),
            n.update(),
            s = i.NONE
        }
        ,
        this.update = function() {
            const G = new k
              , _e = new Hi().setFromUnitVectors(e.up, new k(0,1,0))
              , fe = _e.clone().invert()
              , je = new k
              , Fe = new Hi
              , Ge = new k
              , Oe = 2 * Math.PI;
            return function(rt=null) {
                const X = n.object.position;
                G.copy(X).sub(n.target),
                G.applyQuaternion(_e),
                a.setFromVector3(G),
                n.autoRotate && s === i.NONE && V(w(rt)),
                n.enableDamping ? (a.theta += c.theta * n.dampingFactor,
                a.phi += c.phi * n.dampingFactor) : (a.theta += c.theta,
                a.phi += c.phi);
                let we = n.minAzimuthAngle
                  , me = n.maxAzimuthAngle;
                isFinite(we) && isFinite(me) && (we < -Math.PI ? we += Oe : we > Math.PI && (we -= Oe),
                me < -Math.PI ? me += Oe : me > Math.PI && (me -= Oe),
                we <= me ? a.theta = Math.max(we, Math.min(me, a.theta)) : a.theta = a.theta > (we + me) / 2 ? Math.max(we, a.theta) : Math.min(me, a.theta)),
                a.phi = Math.max(n.minPolarAngle, Math.min(n.maxPolarAngle, a.phi)),
                a.makeSafe(),
                n.enableDamping === !0 ? n.target.addScaledVector(d, n.dampingFactor) : n.target.add(d),
                n.target.sub(n.cursor),
                n.target.clampLength(n.minTargetRadius, n.maxTargetRadius),
                n.target.add(n.cursor),
                n.zoomToCursor && P || n.object.isOrthographicCamera ? a.radius = ae(a.radius) : a.radius = ae(a.radius * h),
                G.setFromSpherical(a),
                G.applyQuaternion(fe),
                X.copy(n.target).add(G),
                n.object.lookAt(n.target),
                n.enableDamping === !0 ? (c.theta *= 1 - n.dampingFactor,
                c.phi *= 1 - n.dampingFactor,
                d.multiplyScalar(1 - n.dampingFactor)) : (c.set(0, 0, 0),
                d.set(0, 0, 0));
                let le = !1;
                if (n.zoomToCursor && P) {
                    let Se = null;
                    if (n.object.isPerspectiveCamera) {
                        const He = G.length();
                        Se = ae(He * h);
                        const ut = He - Se;
                        n.object.position.addScaledVector(S, ut),
                        n.object.updateMatrixWorld()
                    } else if (n.object.isOrthographicCamera) {
                        const He = new k(E.x,E.y,0);
                        He.unproject(n.object),
                        n.object.zoom = Math.max(n.minZoom, Math.min(n.maxZoom, n.object.zoom / h)),
                        n.object.updateProjectionMatrix(),
                        le = !0;
                        const ut = new k(E.x,E.y,0);
                        ut.unproject(n.object),
                        n.object.position.sub(ut).add(He),
                        n.object.updateMatrixWorld(),
                        Se = G.length()
                    } else
                        console.warn("WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled."),
                        n.zoomToCursor = !1;
                    Se !== null && (this.screenSpacePanning ? n.target.set(0, 0, -1).transformDirection(n.object.matrix).multiplyScalar(Se).add(n.object.position) : (lh.origin.copy(n.object.position),
                    lh.direction.set(0, 0, -1).transformDirection(n.object.matrix),
                    Math.abs(n.object.up.dot(lh.direction)) < iF ? e.lookAt(n.target) : (ox.setFromNormalAndCoplanarPoint(n.object.up, n.target),
                    lh.intersectPlane(ox, n.target))))
                } else
                    n.object.isOrthographicCamera && (n.object.zoom = Math.max(n.minZoom, Math.min(n.maxZoom, n.object.zoom / h)),
                    n.object.updateProjectionMatrix(),
                    le = !0);
                return h = 1,
                P = !1,
                le || je.distanceToSquared(n.object.position) > o || 8 * (1 - Fe.dot(n.object.quaternion)) > o || Ge.distanceToSquared(n.target) > 0 ? (n.dispatchEvent(rx),
                je.copy(n.object.position),
                Fe.copy(n.object.quaternion),
                Ge.copy(n.target),
                !0) : !1
            }
        }(),
        this.dispose = function() {
            n.domElement.removeEventListener("contextmenu", pe),
            n.domElement.removeEventListener("pointerdown", tt),
            n.domElement.removeEventListener("pointercancel", dt),
            n.domElement.removeEventListener("wheel", B),
            n.domElement.removeEventListener("pointermove", Ye),
            n.domElement.removeEventListener("pointerup", dt),
            n._domElementKeyEvents !== null && (n._domElementKeyEvents.removeEventListener("keydown", L),
            n._domElementKeyEvents = null)
        }
        ;
        const n = this
          , i = {
            NONE: -1,
            ROTATE: 0,
            DOLLY: 1,
            PAN: 2,
            TOUCH_ROTATE: 3,
            TOUCH_PAN: 4,
            TOUCH_DOLLY_PAN: 5,
            TOUCH_DOLLY_ROTATE: 6
        };
        let s = i.NONE;
        const o = 1e-6
          , a = new nx
          , c = new nx;
        let h = 1;
        const d = new k
          , l = new Ce
          , f = new Ce
          , p = new Ce
          , g = new Ce
          , y = new Ce
          , v = new Ce
          , _ = new Ce
          , b = new Ce
          , T = new Ce
          , S = new k
          , E = new Ce;
        let P = !1;
        const R = []
          , O = {};
        function w(G) {
            return G !== null ? 2 * Math.PI / 60 * n.autoRotateSpeed * G : 2 * Math.PI / 60 / 60 * n.autoRotateSpeed
        }
        function I() {
            return Math.pow(.95, n.zoomSpeed)
        }
        function V(G) {
            c.theta -= G
        }
        function z(G) {
            c.phi -= G
        }
        const q = function() {
            const G = new k;
            return function(fe, je) {
                G.setFromMatrixColumn(je, 0),
                G.multiplyScalar(-fe),
                d.add(G)
            }
        }()
          , F = function() {
            const G = new k;
            return function(fe, je) {
                n.screenSpacePanning === !0 ? G.setFromMatrixColumn(je, 1) : (G.setFromMatrixColumn(je, 0),
                G.crossVectors(n.object.up, G)),
                G.multiplyScalar(fe),
                d.add(G)
            }
        }()
          , j = function() {
            const G = new k;
            return function(fe, je) {
                const Fe = n.domElement;
                if (n.object.isPerspectiveCamera) {
                    const Ge = n.object.position;
                    G.copy(Ge).sub(n.target);
                    let Oe = G.length();
                    Oe *= Math.tan(n.object.fov / 2 * Math.PI / 180),
                    q(2 * fe * Oe / Fe.clientHeight, n.object.matrix),
                    F(2 * je * Oe / Fe.clientHeight, n.object.matrix)
                } else
                    n.object.isOrthographicCamera ? (q(fe * (n.object.right - n.object.left) / n.object.zoom / Fe.clientWidth, n.object.matrix),
                    F(je * (n.object.top - n.object.bottom) / n.object.zoom / Fe.clientHeight, n.object.matrix)) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."),
                    n.enablePan = !1)
            }
        }();
        function K(G) {
            n.object.isPerspectiveCamera || n.object.isOrthographicCamera ? h /= G : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),
            n.enableZoom = !1)
        }
        function J(G) {
            n.object.isPerspectiveCamera || n.object.isOrthographicCamera ? h *= G : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),
            n.enableZoom = !1)
        }
        function de(G) {
            if (!n.zoomToCursor)
                return;
            P = !0;
            const _e = n.domElement.getBoundingClientRect()
              , fe = G.clientX - _e.left
              , je = G.clientY - _e.top
              , Fe = _e.width
              , Ge = _e.height;
            E.x = fe / Fe * 2 - 1,
            E.y = -(je / Ge) * 2 + 1,
            S.set(E.x, E.y, 1).unproject(n.object).sub(n.object.position).normalize()
        }
        function ae(G) {
            return Math.max(n.minDistance, Math.min(n.maxDistance, G))
        }
        function ue(G) {
            l.set(G.clientX, G.clientY)
        }
        function ge(G) {
            de(G),
            _.set(G.clientX, G.clientY)
        }
        function Ee(G) {
            g.set(G.clientX, G.clientY)
        }
        function oe(G) {
            f.set(G.clientX, G.clientY),
            p.subVectors(f, l).multiplyScalar(n.rotateSpeed);
            const _e = n.domElement;
            V(2 * Math.PI * p.x / _e.clientHeight),
            z(2 * Math.PI * p.y / _e.clientHeight),
            l.copy(f),
            n.update()
        }
        function he(G) {
            b.set(G.clientX, G.clientY),
            T.subVectors(b, _),
            T.y > 0 ? K(I()) : T.y < 0 && J(I()),
            _.copy(b),
            n.update()
        }
        function xe(G) {
            y.set(G.clientX, G.clientY),
            v.subVectors(y, g).multiplyScalar(n.panSpeed),
            j(v.x, v.y),
            g.copy(y),
            n.update()
        }
        function Be(G) {
            de(G),
            G.deltaY < 0 ? J(I()) : G.deltaY > 0 && K(I()),
            n.update()
        }
        function De(G) {
            let _e = !1;
            switch (G.code) {
            case n.keys.UP:
                G.ctrlKey || G.metaKey || G.shiftKey ? z(2 * Math.PI * n.rotateSpeed / n.domElement.clientHeight) : j(0, n.keyPanSpeed),
                _e = !0;
                break;
            case n.keys.BOTTOM:
                G.ctrlKey || G.metaKey || G.shiftKey ? z(-2 * Math.PI * n.rotateSpeed / n.domElement.clientHeight) : j(0, -n.keyPanSpeed),
                _e = !0;
                break;
            case n.keys.LEFT:
                G.ctrlKey || G.metaKey || G.shiftKey ? V(2 * Math.PI * n.rotateSpeed / n.domElement.clientHeight) : j(n.keyPanSpeed, 0),
                _e = !0;
                break;
            case n.keys.RIGHT:
                G.ctrlKey || G.metaKey || G.shiftKey ? V(-2 * Math.PI * n.rotateSpeed / n.domElement.clientHeight) : j(-n.keyPanSpeed, 0),
                _e = !0;
                break
            }
            _e && (G.preventDefault(),
            n.update())
        }
        function et() {
            if (R.length === 1)
                l.set(R[0].pageX, R[0].pageY);
            else {
                const G = .5 * (R[0].pageX + R[1].pageX)
                  , _e = .5 * (R[0].pageY + R[1].pageY);
                l.set(G, _e)
            }
        }
        function Ze() {
            if (R.length === 1)
                g.set(R[0].pageX, R[0].pageY);
            else {
                const G = .5 * (R[0].pageX + R[1].pageX)
                  , _e = .5 * (R[0].pageY + R[1].pageY);
                g.set(G, _e)
            }
        }
        function We() {
            const G = R[0].pageX - R[1].pageX
              , _e = R[0].pageY - R[1].pageY
              , fe = Math.sqrt(G * G + _e * _e);
            _.set(0, fe)
        }
        function Je() {
            n.enableZoom && We(),
            n.enablePan && Ze()
        }
        function Q() {
            n.enableZoom && We(),
            n.enableRotate && et()
        }
        function hn(G) {
            if (R.length == 1)
                f.set(G.pageX, G.pageY);
            else {
                const fe = Ae(G)
                  , je = .5 * (G.pageX + fe.x)
                  , Fe = .5 * (G.pageY + fe.y);
                f.set(je, Fe)
            }
            p.subVectors(f, l).multiplyScalar(n.rotateSpeed);
            const _e = n.domElement;
            V(2 * Math.PI * p.x / _e.clientHeight),
            z(2 * Math.PI * p.y / _e.clientHeight),
            l.copy(f)
        }
        function ze(G) {
            if (R.length === 1)
                y.set(G.pageX, G.pageY);
            else {
                const _e = Ae(G)
                  , fe = .5 * (G.pageX + _e.x)
                  , je = .5 * (G.pageY + _e.y);
                y.set(fe, je)
            }
            v.subVectors(y, g).multiplyScalar(n.panSpeed),
            j(v.x, v.y),
            g.copy(y)
        }
        function at(G) {
            const _e = Ae(G)
              , fe = G.pageX - _e.x
              , je = G.pageY - _e.y
              , Fe = Math.sqrt(fe * fe + je * je);
            b.set(0, Fe),
            T.set(0, Math.pow(b.y / _.y, n.zoomSpeed)),
            K(T.y),
            _.copy(b)
        }
        function qe(G) {
            n.enableZoom && at(G),
            n.enablePan && ze(G)
        }
        function It(G) {
            n.enableZoom && at(G),
            n.enableRotate && hn(G)
        }
        function tt(G) {
            n.enabled !== !1 && (R.length === 0 && (n.domElement.setPointerCapture(G.pointerId),
            n.domElement.addEventListener("pointermove", Ye),
            n.domElement.addEventListener("pointerup", dt)),
            be(G),
            G.pointerType === "touch" ? ee(G) : on(G))
        }
        function Ye(G) {
            n.enabled !== !1 && (G.pointerType === "touch" ? Te(G) : Lt(G))
        }
        function dt(G) {
            Ne(G),
            R.length === 0 && (n.domElement.releasePointerCapture(G.pointerId),
            n.domElement.removeEventListener("pointermove", Ye),
            n.domElement.removeEventListener("pointerup", dt)),
            n.dispatchEvent(sx),
            s = i.NONE
        }
        function on(G) {
            let _e;
            switch (G.button) {
            case 0:
                _e = n.mouseButtons.LEFT;
                break;
            case 1:
                _e = n.mouseButtons.MIDDLE;
                break;
            case 2:
                _e = n.mouseButtons.RIGHT;
                break;
            default:
                _e = -1
            }
            switch (_e) {
            case ia.DOLLY:
                if (n.enableZoom === !1)
                    return;
                ge(G),
                s = i.DOLLY;
                break;
            case ia.ROTATE:
                if (G.ctrlKey || G.metaKey || G.shiftKey) {
                    if (n.enablePan === !1)
                        return;
                    Ee(G),
                    s = i.PAN
                } else {
                    if (n.enableRotate === !1)
                        return;
                    ue(G),
                    s = i.ROTATE
                }
                break;
            case ia.PAN:
                if (G.ctrlKey || G.metaKey || G.shiftKey) {
                    if (n.enableRotate === !1)
                        return;
                    ue(G),
                    s = i.ROTATE
                } else {
                    if (n.enablePan === !1)
                        return;
                    Ee(G),
                    s = i.PAN
                }
                break;
            default:
                s = i.NONE
            }
            s !== i.NONE && n.dispatchEvent(Wp)
        }
        function Lt(G) {
            switch (s) {
            case i.ROTATE:
                if (n.enableRotate === !1)
                    return;
                oe(G);
                break;
            case i.DOLLY:
                if (n.enableZoom === !1)
                    return;
                he(G);
                break;
            case i.PAN:
                if (n.enablePan === !1)
                    return;
                xe(G);
                break
            }
        }
        function B(G) {
            n.enabled === !1 || n.enableZoom === !1 || s !== i.NONE || (G.preventDefault(),
            n.dispatchEvent(Wp),
            Be(G),
            n.dispatchEvent(sx))
        }
        function L(G) {
            n.enabled === !1 || n.enablePan === !1 || De(G)
        }
        function ee(G) {
            switch (Me(G),
            R.length) {
            case 1:
                switch (n.touches.ONE) {
                case ra.ROTATE:
                    if (n.enableRotate === !1)
                        return;
                    et(),
                    s = i.TOUCH_ROTATE;
                    break;
                case ra.PAN:
                    if (n.enablePan === !1)
                        return;
                    Ze(),
                    s = i.TOUCH_PAN;
                    break;
                default:
                    s = i.NONE
                }
                break;
            case 2:
                switch (n.touches.TWO) {
                case ra.DOLLY_PAN:
                    if (n.enableZoom === !1 && n.enablePan === !1)
                        return;
                    Je(),
                    s = i.TOUCH_DOLLY_PAN;
                    break;
                case ra.DOLLY_ROTATE:
                    if (n.enableZoom === !1 && n.enableRotate === !1)
                        return;
                    Q(),
                    s = i.TOUCH_DOLLY_ROTATE;
                    break;
                default:
                    s = i.NONE
                }
                break;
            default:
                s = i.NONE
            }
            s !== i.NONE && n.dispatchEvent(Wp)
        }
        function Te(G) {
            switch (Me(G),
            s) {
            case i.TOUCH_ROTATE:
                if (n.enableRotate === !1)
                    return;
                hn(G),
                n.update();
                break;
            case i.TOUCH_PAN:
                if (n.enablePan === !1)
                    return;
                ze(G),
                n.update();
                break;
            case i.TOUCH_DOLLY_PAN:
                if (n.enableZoom === !1 && n.enablePan === !1)
                    return;
                qe(G),
                n.update();
                break;
            case i.TOUCH_DOLLY_ROTATE:
                if (n.enableZoom === !1 && n.enableRotate === !1)
                    return;
                It(G),
                n.update();
                break;
            default:
                s = i.NONE
            }
        }
        function pe(G) {
            n.enabled !== !1 && G.preventDefault()
        }
        function be(G) {
            R.push(G)
        }
        function Ne(G) {
            delete O[G.pointerId];
            for (let _e = 0; _e < R.length; _e++)
                if (R[_e].pointerId == G.pointerId) {
                    R.splice(_e, 1);
                    return
                }
        }
        function Me(G) {
            let _e = O[G.pointerId];
            _e === void 0 && (_e = new Ce,
            O[G.pointerId] = _e),
            _e.set(G.pageX, G.pageY)
        }
        function Ae(G) {
            const _e = G.pointerId === R[0].pointerId ? R[1] : R[0];
            return O[_e.pointerId]
        }
        n.domElement.addEventListener("contextmenu", pe),
        n.domElement.addEventListener("pointerdown", tt),
        n.domElement.addEventListener("pointercancel", dt),
        n.domElement.addEventListener("wheel", B, {
            passive: !1
        }),
        this.update()
    }
}
const Zb = 0
  , sF = 1
  , oF = 2
  , ax = 2
  , jp = 1.25
  , lx = 1
  , Uh = 6 * 4 + 4 + 4
  , vf = 65535
  , aF = Math.pow(2, -24)
  , Xp = Symbol("SKIP_GENERATION");
function lF(r) {
    return r.index ? r.index.count : r.attributes.position.count
}
function bl(r) {
    return lF(r) / 3
}
function cF(r, e=ArrayBuffer) {
    return r > 65535 ? new Uint32Array(new e(4 * r)) : new Uint16Array(new e(2 * r))
}
function uF(r, e) {
    if (!r.index) {
        const t = r.attributes.position.count
          , n = e.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer
          , i = cF(t, n);
        r.setIndex(new pt(i,1));
        for (let s = 0; s < t; s++)
            i[s] = s
    }
}
function Jb(r) {
    const e = bl(r)
      , t = r.drawRange
      , n = t.start / 3
      , i = (t.start + t.count) / 3
      , s = Math.max(0, n)
      , o = Math.min(e, i) - s;
    return [{
        offset: Math.floor(s),
        count: Math.floor(o)
    }]
}
function Qb(r) {
    if (!r.groups || !r.groups.length)
        return Jb(r);
    const e = []
      , t = new Set
      , n = r.drawRange
      , i = n.start / 3
      , s = (n.start + n.count) / 3;
    for (const a of r.groups) {
        const c = a.start / 3
          , h = (a.start + a.count) / 3;
        t.add(Math.max(i, c)),
        t.add(Math.min(s, h))
    }
    const o = Array.from(t.values()).sort((a,c)=>a - c);
    for (let a = 0; a < o.length - 1; a++) {
        const c = o[a]
          , h = o[a + 1];
        e.push({
            offset: Math.floor(c),
            count: Math.floor(h - c)
        })
    }
    return e
}
function hF(r) {
    if (r.groups.length === 0)
        return !1;
    const e = bl(r)
      , t = Qb(r).sort((s,o)=>s.offset - o.offset)
      , n = t[t.length - 1];
    n.count = Math.min(e - n.offset, n.count);
    let i = 0;
    return t.forEach(({count: s})=>i += s),
    e !== i
}
function rn(r, e, t) {
    return t.min.x = e[r],
    t.min.y = e[r + 1],
    t.min.z = e[r + 2],
    t.max.x = e[r + 3],
    t.max.y = e[r + 4],
    t.max.z = e[r + 5],
    t
}
function fF(r) {
    r[0] = r[1] = r[2] = 1 / 0,
    r[3] = r[4] = r[5] = -1 / 0
}
function cx(r) {
    let e = -1
      , t = -1 / 0;
    for (let n = 0; n < 3; n++) {
        const i = r[n + 3] - r[n];
        i > t && (t = i,
        e = n)
    }
    return e
}
function ux(r, e) {
    e.set(r)
}
function hx(r, e, t) {
    let n, i;
    for (let s = 0; s < 3; s++) {
        const o = s + 3;
        n = r[s],
        i = e[s],
        t[s] = n < i ? n : i,
        n = r[o],
        i = e[o],
        t[o] = n > i ? n : i
    }
}
function ch(r, e, t) {
    for (let n = 0; n < 3; n++) {
        const i = e[r + 2 * n]
          , s = e[r + 2 * n + 1]
          , o = i - s
          , a = i + s;
        o < t[n] && (t[n] = o),
        a > t[n + 3] && (t[n + 3] = a)
    }
}
function tc(r) {
    const e = r[3] - r[0]
      , t = r[4] - r[1]
      , n = r[5] - r[2];
    return 2 * (e * t + t * n + n * e)
}
function qp(r, e, t, n, i=null) {
    let s = 1 / 0
      , o = 1 / 0
      , a = 1 / 0
      , c = -1 / 0
      , h = -1 / 0
      , d = -1 / 0
      , l = 1 / 0
      , f = 1 / 0
      , p = 1 / 0
      , g = -1 / 0
      , y = -1 / 0
      , v = -1 / 0;
    const _ = i !== null;
    for (let b = e * 6, T = (e + t) * 6; b < T; b += 6) {
        const S = r[b + 0]
          , E = r[b + 1]
          , P = S - E
          , R = S + E;
        P < s && (s = P),
        R > c && (c = R),
        _ && S < l && (l = S),
        _ && S > g && (g = S);
        const O = r[b + 2]
          , w = r[b + 3]
          , I = O - w
          , V = O + w;
        I < o && (o = I),
        V > h && (h = V),
        _ && O < f && (f = O),
        _ && O > y && (y = O);
        const z = r[b + 4]
          , q = r[b + 5]
          , F = z - q
          , j = z + q;
        F < a && (a = F),
        j > d && (d = j),
        _ && z < p && (p = z),
        _ && z > v && (v = z)
    }
    n[0] = s,
    n[1] = o,
    n[2] = a,
    n[3] = c,
    n[4] = h,
    n[5] = d,
    _ && (i[0] = l,
    i[1] = f,
    i[2] = p,
    i[3] = g,
    i[4] = y,
    i[5] = v)
}
function dF(r, e, t, n) {
    let i = 1 / 0
      , s = 1 / 0
      , o = 1 / 0
      , a = -1 / 0
      , c = -1 / 0
      , h = -1 / 0;
    for (let d = e * 6, l = (e + t) * 6; d < l; d += 6) {
        const f = r[d + 0];
        f < i && (i = f),
        f > a && (a = f);
        const p = r[d + 2];
        p < s && (s = p),
        p > c && (c = p);
        const g = r[d + 4];
        g < o && (o = g),
        g > h && (h = g)
    }
    n[0] = i,
    n[1] = s,
    n[2] = o,
    n[3] = a,
    n[4] = c,
    n[5] = h
}
function pF(r, e) {
    fF(e);
    const t = r.attributes.position
      , n = r.index ? r.index.array : null
      , i = bl(r)
      , s = new Float32Array(i * 6)
      , o = t.normalized
      , a = t.array
      , c = t.offset || 0;
    let h = 3;
    t.isInterleavedBufferAttribute && (h = t.data.stride);
    const d = ["getX", "getY", "getZ"];
    for (let l = 0; l < i; l++) {
        const f = l * 3
          , p = l * 6;
        let g = f + 0
          , y = f + 1
          , v = f + 2;
        n && (g = n[g],
        y = n[y],
        v = n[v]),
        o || (g = g * h + c,
        y = y * h + c,
        v = v * h + c);
        for (let _ = 0; _ < 3; _++) {
            let b, T, S;
            o ? (b = t[d[_]](g),
            T = t[d[_]](y),
            S = t[d[_]](v)) : (b = a[g + _],
            T = a[y + _],
            S = a[v + _]);
            let E = b;
            T < E && (E = T),
            S < E && (E = S);
            let P = b;
            T > P && (P = T),
            S > P && (P = S);
            const R = (P - E) / 2
              , O = _ * 2;
            s[p + O + 0] = E + R,
            s[p + O + 1] = R + (Math.abs(E) + R) * aF,
            E < e[_] && (e[_] = E),
            P > e[_ + 3] && (e[_ + 3] = P)
        }
    }
    return s
}
const Qr = 32
  , mF = (r,e)=>r.candidate - e.candidate
  , bs = new Array(Qr).fill().map(()=>({
    count: 0,
    bounds: new Float32Array(6),
    rightCacheBounds: new Float32Array(6),
    leftCacheBounds: new Float32Array(6),
    candidate: 0
}))
  , uh = new Float32Array(6);
function _F(r, e, t, n, i, s) {
    let o = -1
      , a = 0;
    if (s === Zb)
        o = cx(e),
        o !== -1 && (a = (e[o] + e[o + 3]) / 2);
    else if (s === sF)
        o = cx(r),
        o !== -1 && (a = gF(t, n, i, o));
    else if (s === oF) {
        const c = tc(r);
        let h = jp * i;
        const d = n * 6
          , l = (n + i) * 6;
        for (let f = 0; f < 3; f++) {
            const p = e[f]
              , v = (e[f + 3] - p) / Qr;
            if (i < Qr / 4) {
                const _ = [...bs];
                _.length = i;
                let b = 0;
                for (let S = d; S < l; S += 6,
                b++) {
                    const E = _[b];
                    E.candidate = t[S + 2 * f],
                    E.count = 0;
                    const {bounds: P, leftCacheBounds: R, rightCacheBounds: O} = E;
                    for (let w = 0; w < 3; w++)
                        O[w] = 1 / 0,
                        O[w + 3] = -1 / 0,
                        R[w] = 1 / 0,
                        R[w + 3] = -1 / 0,
                        P[w] = 1 / 0,
                        P[w + 3] = -1 / 0;
                    ch(S, t, P)
                }
                _.sort(mF);
                let T = i;
                for (let S = 0; S < T; S++) {
                    const E = _[S];
                    for (; S + 1 < T && _[S + 1].candidate === E.candidate; )
                        _.splice(S + 1, 1),
                        T--
                }
                for (let S = d; S < l; S += 6) {
                    const E = t[S + 2 * f];
                    for (let P = 0; P < T; P++) {
                        const R = _[P];
                        E >= R.candidate ? ch(S, t, R.rightCacheBounds) : (ch(S, t, R.leftCacheBounds),
                        R.count++)
                    }
                }
                for (let S = 0; S < T; S++) {
                    const E = _[S]
                      , P = E.count
                      , R = i - E.count
                      , O = E.leftCacheBounds
                      , w = E.rightCacheBounds;
                    let I = 0;
                    P !== 0 && (I = tc(O) / c);
                    let V = 0;
                    R !== 0 && (V = tc(w) / c);
                    const z = lx + jp * (I * P + V * R);
                    z < h && (o = f,
                    h = z,
                    a = E.candidate)
                }
            } else {
                for (let T = 0; T < Qr; T++) {
                    const S = bs[T];
                    S.count = 0,
                    S.candidate = p + v + T * v;
                    const E = S.bounds;
                    for (let P = 0; P < 3; P++)
                        E[P] = 1 / 0,
                        E[P + 3] = -1 / 0
                }
                for (let T = d; T < l; T += 6) {
                    let P = ~~((t[T + 2 * f] - p) / v);
                    P >= Qr && (P = Qr - 1);
                    const R = bs[P];
                    R.count++,
                    ch(T, t, R.bounds)
                }
                const _ = bs[Qr - 1];
                ux(_.bounds, _.rightCacheBounds);
                for (let T = Qr - 2; T >= 0; T--) {
                    const S = bs[T]
                      , E = bs[T + 1];
                    hx(S.bounds, E.rightCacheBounds, S.rightCacheBounds)
                }
                let b = 0;
                for (let T = 0; T < Qr - 1; T++) {
                    const S = bs[T]
                      , E = S.count
                      , P = S.bounds
                      , O = bs[T + 1].rightCacheBounds;
                    E !== 0 && (b === 0 ? ux(P, uh) : hx(P, uh, uh)),
                    b += E;
                    let w = 0
                      , I = 0;
                    b !== 0 && (w = tc(uh) / c);
                    const V = i - b;
                    V !== 0 && (I = tc(O) / c);
                    const z = lx + jp * (w * b + I * V);
                    z < h && (o = f,
                    h = z,
                    a = S.candidate)
                }
            }
        }
    } else
        console.warn(`MeshBVH: Invalid build strategy value ${s} used.`);
    return {
        axis: o,
        pos: a
    }
}
function gF(r, e, t, n) {
    let i = 0;
    for (let s = e, o = e + t; s < o; s++)
        i += r[s * 6 + n * 2];
    return i / t
}
class hh {
    constructor() {}
}
function vF(r, e, t, n, i, s) {
    let o = n
      , a = n + i - 1;
    const c = s.pos
      , h = s.axis * 2;
    for (; ; ) {
        for (; o <= a && t[o * 6 + h] < c; )
            o++;
        for (; o <= a && t[a * 6 + h] >= c; )
            a--;
        if (o < a) {
            for (let d = 0; d < 3; d++) {
                let l = e[o * 3 + d];
                e[o * 3 + d] = e[a * 3 + d],
                e[a * 3 + d] = l
            }
            for (let d = 0; d < 6; d++) {
                let l = t[o * 6 + d];
                t[o * 6 + d] = t[a * 6 + d],
                t[a * 6 + d] = l
            }
            o++,
            a--
        } else
            return o
    }
}
function yF(r, e, t, n, i, s) {
    let o = n
      , a = n + i - 1;
    const c = s.pos
      , h = s.axis * 2;
    for (; ; ) {
        for (; o <= a && t[o * 6 + h] < c; )
            o++;
        for (; o <= a && t[a * 6 + h] >= c; )
            a--;
        if (o < a) {
            let d = r[o];
            r[o] = r[a],
            r[a] = d;
            for (let l = 0; l < 6; l++) {
                let f = t[o * 6 + l];
                t[o * 6 + l] = t[a * 6 + l],
                t[a * 6 + l] = f
            }
            o++,
            a--
        } else
            return o
    }
}
function xF(r, e) {
    const t = (r.index ? r.index.count : r.attributes.position.count) / 3
      , n = t > 2 ** 16
      , i = n ? 4 : 2
      , s = e ? new SharedArrayBuffer(t * i) : new ArrayBuffer(t * i)
      , o = n ? new Uint32Array(s) : new Uint16Array(s);
    for (let a = 0, c = o.length; a < c; a++)
        o[a] = a;
    return o
}
function TF(r, e) {
    const t = r.geometry
      , n = t.index ? t.index.array : null
      , i = e.maxDepth
      , s = e.verbose
      , o = e.maxLeafTris
      , a = e.strategy
      , c = e.onProgress
      , h = bl(t)
      , d = r._indirectBuffer;
    let l = !1;
    const f = new Float32Array(6)
      , p = new Float32Array(6)
      , g = pF(t, f)
      , y = e.indirect ? yF : vF
      , v = []
      , _ = e.indirect ? Jb(t) : Qb(t);
    if (_.length === 1) {
        const S = _[0]
          , E = new hh;
        E.boundingData = f,
        dF(g, S.offset, S.count, p),
        T(E, S.offset, S.count, p),
        v.push(E)
    } else
        for (let S of _) {
            const E = new hh;
            E.boundingData = new Float32Array(6),
            qp(g, S.offset, S.count, E.boundingData, p),
            T(E, S.offset, S.count, p),
            v.push(E)
        }
    return v;
    function b(S) {
        c && c(S / h)
    }
    function T(S, E, P, R=null, O=0) {
        if (!l && O >= i && (l = !0,
        s && (console.warn(`MeshBVH: Max depth of ${i} reached when generating BVH. Consider increasing maxDepth.`),
        console.warn(t))),
        P <= o || O >= i)
            return b(E + P),
            S.offset = E,
            S.count = P,
            S;
        const w = _F(S.boundingData, R, g, E, P, a);
        if (w.axis === -1)
            return b(E + P),
            S.offset = E,
            S.count = P,
            S;
        const I = y(d, n, g, E, P, w);
        if (I === E || I === E + P)
            b(E + P),
            S.offset = E,
            S.count = P;
        else {
            S.splitAxis = w.axis;
            const V = new hh
              , z = E
              , q = I - E;
            S.left = V,
            V.boundingData = new Float32Array(6),
            qp(g, z, q, V.boundingData, p),
            T(V, z, q, p, O + 1);
            const F = new hh
              , j = I
              , K = P - q;
            S.right = F,
            F.boundingData = new Float32Array(6),
            qp(g, j, K, F.boundingData, p),
            T(F, j, K, p, O + 1)
        }
        return S
    }
}
function bF(r, e) {
    const t = r.geometry;
    e.indirect && (r._indirectBuffer = xF(t, e.useSharedArrayBuffer),
    hF(t) && !e.verbose && console.warn('MeshBVH: Provided geometry contains groups that do not fully span the vertex contents while using the "indirect" option. BVH may incorrectly report intersections on unrendered portions of the geometry.')),
    r._indirectBuffer || uF(t, e);
    const n = TF(r, e);
    let i, s, o;
    const a = []
      , c = e.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer;
    for (let l = 0; l < n.length; l++) {
        const f = n[l];
        let p = h(f);
        const g = new c(Uh * p);
        i = new Float32Array(g),
        s = new Uint32Array(g),
        o = new Uint16Array(g),
        d(0, f),
        a.push(g)
    }
    r._roots = a;
    return;
    function h(l) {
        return l.count ? 1 : 1 + h(l.left) + h(l.right)
    }
    function d(l, f) {
        const p = l / 4
          , g = l / 2
          , y = !!f.count
          , v = f.boundingData;
        for (let _ = 0; _ < 6; _++)
            i[p + _] = v[_];
        if (y) {
            const _ = f.offset
              , b = f.count;
            return s[p + 6] = _,
            o[g + 14] = b,
            o[g + 15] = vf,
            l + Uh
        } else {
            const _ = f.left
              , b = f.right
              , T = f.splitAxis;
            let S;
            if (S = d(l + Uh, _),
            S / 4 > Math.pow(2, 32))
                throw new Error("MeshBVH: Cannot store child pointer greater than 32 bits.");
            return s[p + 6] = S / 4,
            S = d(S, b),
            s[p + 7] = T,
            S
        }
    }
}
class as {
    constructor() {
        this.min = 1 / 0,
        this.max = -1 / 0
    }
    setFromPointsField(e, t) {
        let n = 1 / 0
          , i = -1 / 0;
        for (let s = 0, o = e.length; s < o; s++) {
            const c = e[s][t];
            n = c < n ? c : n,
            i = c > i ? c : i
        }
        this.min = n,
        this.max = i
    }
    setFromPoints(e, t) {
        let n = 1 / 0
          , i = -1 / 0;
        for (let s = 0, o = t.length; s < o; s++) {
            const a = t[s]
              , c = e.dot(a);
            n = c < n ? c : n,
            i = c > i ? c : i
        }
        this.min = n,
        this.max = i
    }
    isSeparated(e) {
        return this.min > e.max || e.min > this.max
    }
}
as.prototype.setFromBox = function() {
    const r = new k;
    return function(t, n) {
        const i = n.min
          , s = n.max;
        let o = 1 / 0
          , a = -1 / 0;
        for (let c = 0; c <= 1; c++)
            for (let h = 0; h <= 1; h++)
                for (let d = 0; d <= 1; d++) {
                    r.x = i.x * c + s.x * (1 - c),
                    r.y = i.y * h + s.y * (1 - h),
                    r.z = i.z * d + s.z * (1 - d);
                    const l = t.dot(r);
                    o = Math.min(l, o),
                    a = Math.max(l, a)
                }
        this.min = o,
        this.max = a
    }
}();
const SF = function() {
    const r = new k
      , e = new k
      , t = new k;
    return function(i, s, o) {
        const a = i.start
          , c = r
          , h = s.start
          , d = e;
        t.subVectors(a, h),
        r.subVectors(i.end, i.start),
        e.subVectors(s.end, s.start);
        const l = t.dot(d)
          , f = d.dot(c)
          , p = d.dot(d)
          , g = t.dot(c)
          , v = c.dot(c) * p - f * f;
        let _, b;
        v !== 0 ? _ = (l * f - g * p) / v : _ = 0,
        b = (l + _ * f) / p,
        o.x = _,
        o.y = b
    }
}()
  , $_ = function() {
    const r = new Ce
      , e = new k
      , t = new k;
    return function(i, s, o, a) {
        SF(i, s, r);
        let c = r.x
          , h = r.y;
        if (c >= 0 && c <= 1 && h >= 0 && h <= 1) {
            i.at(c, o),
            s.at(h, a);
            return
        } else if (c >= 0 && c <= 1) {
            h < 0 ? s.at(0, a) : s.at(1, a),
            i.closestPointToPoint(a, !0, o);
            return
        } else if (h >= 0 && h <= 1) {
            c < 0 ? i.at(0, o) : i.at(1, o),
            s.closestPointToPoint(o, !0, a);
            return
        } else {
            let d;
            c < 0 ? d = i.start : d = i.end;
            let l;
            h < 0 ? l = s.start : l = s.end;
            const f = e
              , p = t;
            if (i.closestPointToPoint(l, !0, e),
            s.closestPointToPoint(d, !0, t),
            f.distanceToSquared(l) <= p.distanceToSquared(d)) {
                o.copy(f),
                a.copy(l);
                return
            } else {
                o.copy(d),
                a.copy(p);
                return
            }
        }
    }
}()
  , MF = function() {
    const r = new k
      , e = new k
      , t = new pr
      , n = new rs;
    return function(s, o) {
        const {radius: a, center: c} = s
          , {a: h, b: d, c: l} = o;
        if (n.start = h,
        n.end = d,
        n.closestPointToPoint(c, !0, r).distanceTo(c) <= a || (n.start = h,
        n.end = l,
        n.closestPointToPoint(c, !0, r).distanceTo(c) <= a) || (n.start = d,
        n.end = l,
        n.closestPointToPoint(c, !0, r).distanceTo(c) <= a))
            return !0;
        const y = o.getPlane(t);
        if (Math.abs(y.distanceToPoint(c)) <= a) {
            const _ = y.projectPoint(c, e);
            if (o.containsPoint(_))
                return !0
        }
        return !1
    }
}()
  , wF = 1e-15;
function Kp(r) {
    return Math.abs(r) < wF
}
class br extends ti {
    constructor(...e) {
        super(...e),
        this.isExtendedTriangle = !0,
        this.satAxes = new Array(4).fill().map(()=>new k),
        this.satBounds = new Array(4).fill().map(()=>new as),
        this.points = [this.a, this.b, this.c],
        this.sphere = new Mr,
        this.plane = new pr,
        this.needsUpdate = !0
    }
    intersectsSphere(e) {
        return MF(e, this)
    }
    update() {
        const e = this.a
          , t = this.b
          , n = this.c
          , i = this.points
          , s = this.satAxes
          , o = this.satBounds
          , a = s[0]
          , c = o[0];
        this.getNormal(a),
        c.setFromPoints(a, i);
        const h = s[1]
          , d = o[1];
        h.subVectors(e, t),
        d.setFromPoints(h, i);
        const l = s[2]
          , f = o[2];
        l.subVectors(t, n),
        f.setFromPoints(l, i);
        const p = s[3]
          , g = o[3];
        p.subVectors(n, e),
        g.setFromPoints(p, i),
        this.sphere.setFromPoints(this.points),
        this.plane.setFromNormalAndCoplanarPoint(a, e),
        this.needsUpdate = !1
    }
}
br.prototype.closestPointToSegment = function() {
    const r = new k
      , e = new k
      , t = new rs;
    return function(i, s=null, o=null) {
        const {start: a, end: c} = i
          , h = this.points;
        let d, l = 1 / 0;
        for (let f = 0; f < 3; f++) {
            const p = (f + 1) % 3;
            t.start.copy(h[f]),
            t.end.copy(h[p]),
            $_(t, i, r, e),
            d = r.distanceToSquared(e),
            d < l && (l = d,
            s && s.copy(r),
            o && o.copy(e))
        }
        return this.closestPointToPoint(a, r),
        d = a.distanceToSquared(r),
        d < l && (l = d,
        s && s.copy(r),
        o && o.copy(a)),
        this.closestPointToPoint(c, r),
        d = c.distanceToSquared(r),
        d < l && (l = d,
        s && s.copy(r),
        o && o.copy(c)),
        Math.sqrt(l)
    }
}();
br.prototype.intersectsTriangle = function() {
    const r = new br
      , e = new Array(3)
      , t = new Array(3)
      , n = new as
      , i = new as
      , s = new k
      , o = new k
      , a = new k
      , c = new k
      , h = new k
      , d = new rs
      , l = new rs
      , f = new rs
      , p = new k;
    function g(y, v, _) {
        const b = y.points;
        let T = 0
          , S = -1;
        for (let E = 0; E < 3; E++) {
            const {start: P, end: R} = d;
            P.copy(b[E]),
            R.copy(b[(E + 1) % 3]),
            d.delta(o);
            const O = Kp(v.distanceToPoint(P));
            if (Kp(v.normal.dot(o)) && O) {
                _.copy(d),
                T = 2;
                break
            }
            const w = v.intersectLine(d, p);
            if (!w && O && p.copy(P),
            (w || O) && !Kp(p.distanceTo(R))) {
                if (T <= 1)
                    (T === 1 ? _.start : _.end).copy(p),
                    O && (S = T);
                else if (T >= 2) {
                    (S === 1 ? _.start : _.end).copy(p),
                    T = 2;
                    break
                }
                if (T++,
                T === 2 && S === -1)
                    break
            }
        }
        return T
    }
    return function(v, _=null, b=!1) {
        this.needsUpdate && this.update(),
        v.isExtendedTriangle ? v.needsUpdate && v.update() : (r.copy(v),
        r.update(),
        v = r);
        const T = this.plane
          , S = v.plane;
        if (Math.abs(T.normal.dot(S.normal)) > 1 - 1e-10) {
            const E = this.satBounds
              , P = this.satAxes;
            t[0] = v.a,
            t[1] = v.b,
            t[2] = v.c;
            for (let w = 0; w < 4; w++) {
                const I = E[w]
                  , V = P[w];
                if (n.setFromPoints(V, t),
                I.isSeparated(n))
                    return !1
            }
            const R = v.satBounds
              , O = v.satAxes;
            e[0] = this.a,
            e[1] = this.b,
            e[2] = this.c;
            for (let w = 0; w < 4; w++) {
                const I = R[w]
                  , V = O[w];
                if (n.setFromPoints(V, e),
                I.isSeparated(n))
                    return !1
            }
            for (let w = 0; w < 4; w++) {
                const I = P[w];
                for (let V = 0; V < 4; V++) {
                    const z = O[V];
                    if (s.crossVectors(I, z),
                    n.setFromPoints(s, e),
                    i.setFromPoints(s, t),
                    n.isSeparated(i))
                        return !1
                }
            }
            return _ && (b || console.warn("ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0."),
            _.start.set(0, 0, 0),
            _.end.set(0, 0, 0)),
            !0
        } else {
            const E = g(this, S, l);
            if (E === 1 && v.containsPoint(l.end))
                return _ && (_.start.copy(l.end),
                _.end.copy(l.end)),
                !0;
            if (E !== 2)
                return !1;
            const P = g(v, T, f);
            if (P === 1 && this.containsPoint(f.end))
                return _ && (_.start.copy(f.end),
                _.end.copy(f.end)),
                !0;
            if (P !== 2)
                return !1;
            if (l.delta(a),
            f.delta(c),
            a.dot(c) < 0) {
                let q = f.start;
                f.start = f.end,
                f.end = q
            }
            const R = l.start.dot(a)
              , O = l.end.dot(a)
              , w = f.start.dot(a)
              , I = f.end.dot(a)
              , V = O < w
              , z = R < I;
            return R !== I && w !== O && V === z ? !1 : (_ && (h.subVectors(l.start, f.start),
            h.dot(a) > 0 ? _.start.copy(l.start) : _.start.copy(f.start),
            h.subVectors(l.end, f.end),
            h.dot(a) < 0 ? _.end.copy(l.end) : _.end.copy(f.end)),
            !0)
        }
    }
}();
br.prototype.distanceToPoint = function() {
    const r = new k;
    return function(t) {
        return this.closestPointToPoint(t, r),
        t.distanceTo(r)
    }
}();
br.prototype.distanceToTriangle = function() {
    const r = new k
      , e = new k
      , t = ["a", "b", "c"]
      , n = new rs
      , i = new rs;
    return function(o, a=null, c=null) {
        const h = a || c ? n : null;
        if (this.intersectsTriangle(o, h))
            return (a || c) && (a && h.getCenter(a),
            c && h.getCenter(c)),
            0;
        let d = 1 / 0;
        for (let l = 0; l < 3; l++) {
            let f;
            const p = t[l]
              , g = o[p];
            this.closestPointToPoint(g, r),
            f = g.distanceToSquared(r),
            f < d && (d = f,
            a && a.copy(r),
            c && c.copy(g));
            const y = this[p];
            o.closestPointToPoint(y, r),
            f = y.distanceToSquared(r),
            f < d && (d = f,
            a && a.copy(y),
            c && c.copy(r))
        }
        for (let l = 0; l < 3; l++) {
            const f = t[l]
              , p = t[(l + 1) % 3];
            n.set(this[f], this[p]);
            for (let g = 0; g < 3; g++) {
                const y = t[g]
                  , v = t[(g + 1) % 3];
                i.set(o[y], o[v]),
                $_(n, i, r, e);
                const _ = r.distanceToSquared(e);
                _ < d && (d = _,
                a && a.copy(r),
                c && c.copy(e))
            }
        }
        return Math.sqrt(d)
    }
}();
class pi {
    constructor(e, t, n) {
        this.isOrientedBox = !0,
        this.min = new k,
        this.max = new k,
        this.matrix = new it,
        this.invMatrix = new it,
        this.points = new Array(8).fill().map(()=>new k),
        this.satAxes = new Array(3).fill().map(()=>new k),
        this.satBounds = new Array(3).fill().map(()=>new as),
        this.alignedSatBounds = new Array(3).fill().map(()=>new as),
        this.needsUpdate = !1,
        e && this.min.copy(e),
        t && this.max.copy(t),
        n && this.matrix.copy(n)
    }
    set(e, t, n) {
        this.min.copy(e),
        this.max.copy(t),
        this.matrix.copy(n),
        this.needsUpdate = !0
    }
    copy(e) {
        this.min.copy(e.min),
        this.max.copy(e.max),
        this.matrix.copy(e.matrix),
        this.needsUpdate = !0
    }
}
pi.prototype.update = function() {
    return function() {
        const e = this.matrix
          , t = this.min
          , n = this.max
          , i = this.points;
        for (let h = 0; h <= 1; h++)
            for (let d = 0; d <= 1; d++)
                for (let l = 0; l <= 1; l++) {
                    const f = 1 * h | 2 * d | 4 * l
                      , p = i[f];
                    p.x = h ? n.x : t.x,
                    p.y = d ? n.y : t.y,
                    p.z = l ? n.z : t.z,
                    p.applyMatrix4(e)
                }
        const s = this.satBounds
          , o = this.satAxes
          , a = i[0];
        for (let h = 0; h < 3; h++) {
            const d = o[h]
              , l = s[h]
              , f = 1 << h
              , p = i[f];
            d.subVectors(a, p),
            l.setFromPoints(d, i)
        }
        const c = this.alignedSatBounds;
        c[0].setFromPointsField(i, "x"),
        c[1].setFromPointsField(i, "y"),
        c[2].setFromPointsField(i, "z"),
        this.invMatrix.copy(this.matrix).invert(),
        this.needsUpdate = !1
    }
}();
pi.prototype.intersectsBox = function() {
    const r = new as;
    return function(t) {
        this.needsUpdate && this.update();
        const n = t.min
          , i = t.max
          , s = this.satBounds
          , o = this.satAxes
          , a = this.alignedSatBounds;
        if (r.min = n.x,
        r.max = i.x,
        a[0].isSeparated(r) || (r.min = n.y,
        r.max = i.y,
        a[1].isSeparated(r)) || (r.min = n.z,
        r.max = i.z,
        a[2].isSeparated(r)))
            return !1;
        for (let c = 0; c < 3; c++) {
            const h = o[c]
              , d = s[c];
            if (r.setFromBox(h, t),
            d.isSeparated(r))
                return !1
        }
        return !0
    }
}();
pi.prototype.intersectsTriangle = function() {
    const r = new br
      , e = new Array(3)
      , t = new as
      , n = new as
      , i = new k;
    return function(o) {
        this.needsUpdate && this.update(),
        o.isExtendedTriangle ? o.needsUpdate && o.update() : (r.copy(o),
        r.update(),
        o = r);
        const a = this.satBounds
          , c = this.satAxes;
        e[0] = o.a,
        e[1] = o.b,
        e[2] = o.c;
        for (let f = 0; f < 3; f++) {
            const p = a[f]
              , g = c[f];
            if (t.setFromPoints(g, e),
            p.isSeparated(t))
                return !1
        }
        const h = o.satBounds
          , d = o.satAxes
          , l = this.points;
        for (let f = 0; f < 3; f++) {
            const p = h[f]
              , g = d[f];
            if (t.setFromPoints(g, l),
            p.isSeparated(t))
                return !1
        }
        for (let f = 0; f < 3; f++) {
            const p = c[f];
            for (let g = 0; g < 4; g++) {
                const y = d[g];
                if (i.crossVectors(p, y),
                t.setFromPoints(i, e),
                n.setFromPoints(i, l),
                t.isSeparated(n))
                    return !1
            }
        }
        return !0
    }
}();
pi.prototype.closestPointToPoint = function() {
    return function(e, t) {
        return this.needsUpdate && this.update(),
        t.copy(e).applyMatrix4(this.invMatrix).clamp(this.min, this.max).applyMatrix4(this.matrix),
        t
    }
}();
pi.prototype.distanceToPoint = function() {
    const r = new k;
    return function(t) {
        return this.closestPointToPoint(t, r),
        t.distanceTo(r)
    }
}();
pi.prototype.distanceToBox = function() {
    const r = ["x", "y", "z"]
      , e = new Array(12).fill().map(()=>new rs)
      , t = new Array(12).fill().map(()=>new rs)
      , n = new k
      , i = new k;
    return function(o, a=0, c=null, h=null) {
        if (this.needsUpdate && this.update(),
        this.intersectsBox(o))
            return (c || h) && (o.getCenter(i),
            this.closestPointToPoint(i, n),
            o.closestPointToPoint(n, i),
            c && c.copy(n),
            h && h.copy(i)),
            0;
        const d = a * a
          , l = o.min
          , f = o.max
          , p = this.points;
        let g = 1 / 0;
        for (let v = 0; v < 8; v++) {
            const _ = p[v];
            i.copy(_).clamp(l, f);
            const b = _.distanceToSquared(i);
            if (b < g && (g = b,
            c && c.copy(_),
            h && h.copy(i),
            b < d))
                return Math.sqrt(b)
        }
        let y = 0;
        for (let v = 0; v < 3; v++)
            for (let _ = 0; _ <= 1; _++)
                for (let b = 0; b <= 1; b++) {
                    const T = (v + 1) % 3
                      , S = (v + 2) % 3
                      , E = _ << T | b << S
                      , P = 1 << v | _ << T | b << S
                      , R = p[E]
                      , O = p[P];
                    e[y].set(R, O);
                    const I = r[v]
                      , V = r[T]
                      , z = r[S]
                      , q = t[y]
                      , F = q.start
                      , j = q.end;
                    F[I] = l[I],
                    F[V] = _ ? l[V] : f[V],
                    F[z] = b ? l[z] : f[V],
                    j[I] = f[I],
                    j[V] = _ ? l[V] : f[V],
                    j[z] = b ? l[z] : f[V],
                    y++
                }
        for (let v = 0; v <= 1; v++)
            for (let _ = 0; _ <= 1; _++)
                for (let b = 0; b <= 1; b++) {
                    i.x = v ? f.x : l.x,
                    i.y = _ ? f.y : l.y,
                    i.z = b ? f.z : l.z,
                    this.closestPointToPoint(i, n);
                    const T = i.distanceToSquared(n);
                    if (T < g && (g = T,
                    c && c.copy(n),
                    h && h.copy(i),
                    T < d))
                        return Math.sqrt(T)
                }
        for (let v = 0; v < 12; v++) {
            const _ = e[v];
            for (let b = 0; b < 12; b++) {
                const T = t[b];
                $_(_, T, n, i);
                const S = n.distanceToSquared(i);
                if (S < g && (g = S,
                c && c.copy(n),
                h && h.copy(i),
                S < d))
                    return Math.sqrt(S)
            }
        }
        return Math.sqrt(g)
    }
}();
class Z_ {
    constructor(e) {
        this._getNewPrimitive = e,
        this._primitives = []
    }
    getPrimitive() {
        const e = this._primitives;
        return e.length === 0 ? this._getNewPrimitive() : e.pop()
    }
    releasePrimitive(e) {
        this._primitives.push(e)
    }
}
class EF extends Z_ {
    constructor() {
        super(()=>new br)
    }
}
const Ji = new EF;
function Fi(r, e) {
    return e[r + 15] === 65535
}
function ki(r, e) {
    return e[r + 6]
}
function Qi(r, e) {
    return e[r + 14]
}
function er(r) {
    return r + 8
}
function tr(r, e) {
    return e[r + 6]
}
function eS(r, e) {
    return e[r + 7]
}
class AF {
    constructor() {
        this.float32Array = null,
        this.uint16Array = null,
        this.uint32Array = null;
        const e = [];
        let t = null;
        this.setBuffer = n=>{
            t && e.push(t),
            t = n,
            this.float32Array = new Float32Array(n),
            this.uint16Array = new Uint16Array(n),
            this.uint32Array = new Uint32Array(n)
        }
        ,
        this.clearBuffer = ()=>{
            t = null,
            this.float32Array = null,
            this.uint16Array = null,
            this.uint32Array = null,
            e.length !== 0 && this.setBuffer(e.pop())
        }
    }
}
const nn = new AF;
let Ds, Ga;
const ba = []
  , fh = new Z_(()=>new yn);
function PF(r, e, t, n, i, s) {
    Ds = fh.getPrimitive(),
    Ga = fh.getPrimitive(),
    ba.push(Ds, Ga),
    nn.setBuffer(r._roots[e]);
    const o = Ym(0, r.geometry, t, n, i, s);
    nn.clearBuffer(),
    fh.releasePrimitive(Ds),
    fh.releasePrimitive(Ga),
    ba.pop(),
    ba.pop();
    const a = ba.length;
    return a > 0 && (Ga = ba[a - 1],
    Ds = ba[a - 2]),
    o
}
function Ym(r, e, t, n, i=null, s=0, o=0) {
    const {float32Array: a, uint16Array: c, uint32Array: h} = nn;
    let d = r * 2;
    if (Fi(d, c)) {
        const f = ki(r, h)
          , p = Qi(d, c);
        return rn(r, a, Ds),
        n(f, p, !1, o, s + r, Ds)
    } else {
        let I = function(z) {
            const {uint16Array: q, uint32Array: F} = nn;
            let j = z * 2;
            for (; !Fi(j, q); )
                z = er(z),
                j = z * 2;
            return ki(z, F)
        }
          , V = function(z) {
            const {uint16Array: q, uint32Array: F} = nn;
            let j = z * 2;
            for (; !Fi(j, q); )
                z = tr(z, F),
                j = z * 2;
            return ki(z, F) + Qi(j, q)
        };
        const f = er(r)
          , p = tr(r, h);
        let g = f, y = p, v, _, b, T;
        if (i && (b = Ds,
        T = Ga,
        rn(g, a, b),
        rn(y, a, T),
        v = i(b),
        _ = i(T),
        _ < v)) {
            g = p,
            y = f;
            const z = v;
            v = _,
            _ = z,
            b = T
        }
        b || (b = Ds,
        rn(g, a, b));
        const S = Fi(g * 2, c)
          , E = t(b, S, v, o + 1, s + g);
        let P;
        if (E === ax) {
            const z = I(g)
              , F = V(g) - z;
            P = n(z, F, !0, o + 1, s + g, b)
        } else
            P = E && Ym(g, e, t, n, i, s, o + 1);
        if (P)
            return !0;
        T = Ga,
        rn(y, a, T);
        const R = Fi(y * 2, c)
          , O = t(T, R, _, o + 1, s + y);
        let w;
        if (O === ax) {
            const z = I(y)
              , F = V(y) - z;
            w = n(z, F, !0, o + 1, s + y, T)
        } else
            w = O && Ym(y, e, t, n, i, s, o + 1);
        return !!w
    }
}
const nc = new k
  , Yp = new k;
function RF(r, e, t={}, n=0, i=1 / 0) {
    const s = n * n
      , o = i * i;
    let a = 1 / 0
      , c = null;
    if (r.shapecast({
        boundsTraverseOrder: d=>(nc.copy(e).clamp(d.min, d.max),
        nc.distanceToSquared(e)),
        intersectsBounds: (d,l,f)=>f < a && f < o,
        intersectsTriangle: (d,l)=>{
            d.closestPointToPoint(e, nc);
            const f = e.distanceToSquared(nc);
            return f < a && (Yp.copy(nc),
            a = f,
            c = l),
            f < s
        }
    }),
    a === 1 / 0)
        return null;
    const h = Math.sqrt(a);
    return t.point ? t.point.copy(Yp) : t.point = Yp.clone(),
    t.distance = h,
    t.faceIndex = c,
    t
}
const Sa = new k
  , Ma = new k
  , wa = new k
  , dh = new Ce
  , ph = new Ce
  , mh = new Ce
  , fx = new k
  , dx = new k
  , px = new k
  , _h = new k;
function CF(r, e, t, n, i, s) {
    let o;
    return s === fi ? o = r.intersectTriangle(n, t, e, !0, i) : o = r.intersectTriangle(e, t, n, s !== mr, i),
    o === null ? null : {
        distance: r.origin.distanceTo(i),
        point: i.clone()
    }
}
function IF(r, e, t, n, i, s, o, a, c) {
    Sa.fromBufferAttribute(e, s),
    Ma.fromBufferAttribute(e, o),
    wa.fromBufferAttribute(e, a);
    const h = CF(r, Sa, Ma, wa, _h, c);
    if (h) {
        n && (dh.fromBufferAttribute(n, s),
        ph.fromBufferAttribute(n, o),
        mh.fromBufferAttribute(n, a),
        h.uv = ti.getInterpolation(_h, Sa, Ma, wa, dh, ph, mh, new Ce)),
        i && (dh.fromBufferAttribute(i, s),
        ph.fromBufferAttribute(i, o),
        mh.fromBufferAttribute(i, a),
        h.uv1 = ti.getInterpolation(_h, Sa, Ma, wa, dh, ph, mh, new Ce)),
        t && (fx.fromBufferAttribute(t, s),
        dx.fromBufferAttribute(t, o),
        px.fromBufferAttribute(t, a),
        h.normal = ti.getInterpolation(_h, Sa, Ma, wa, fx, dx, px, new k),
        h.normal.dot(r.direction) > 0 && h.normal.multiplyScalar(-1));
        const d = {
            a: s,
            b: o,
            c: a,
            normal: new k,
            materialIndex: 0
        };
        ti.getNormal(Sa, Ma, wa, d.normal),
        h.face = d,
        h.faceIndex = s
    }
    return h
}
function yf(r, e, t, n, i) {
    const s = n * 3;
    let o = s + 0
      , a = s + 1
      , c = s + 2;
    const h = r.index;
    r.index && (o = h.getX(o),
    a = h.getX(a),
    c = h.getX(c));
    const {position: d, normal: l, uv: f, uv1: p} = r.attributes
      , g = IF(t, d, l, f, p, o, a, c, e);
    return g ? (g.faceIndex = n,
    i && i.push(g),
    g) : null
}
function En(r, e, t, n) {
    const i = r.a
      , s = r.b
      , o = r.c;
    let a = e
      , c = e + 1
      , h = e + 2;
    t && (a = t.getX(a),
    c = t.getX(c),
    h = t.getX(h)),
    i.x = n.getX(a),
    i.y = n.getY(a),
    i.z = n.getZ(a),
    s.x = n.getX(c),
    s.y = n.getY(c),
    s.z = n.getZ(c),
    o.x = n.getX(h),
    o.y = n.getY(h),
    o.z = n.getZ(h)
}
function LF(r, e, t, n, i, s) {
    const {geometry: o, _indirectBuffer: a} = r;
    for (let c = n, h = n + i; c < h; c++)
        yf(o, e, t, c, s)
}
function DF(r, e, t, n, i) {
    const {geometry: s, _indirectBuffer: o} = r;
    let a = 1 / 0
      , c = null;
    for (let h = n, d = n + i; h < d; h++) {
        let l;
        l = yf(s, e, t, h),
        l && l.distance < a && (c = l,
        a = l.distance)
    }
    return c
}
function OF(r, e, t, n, i, s, o) {
    const {geometry: a} = t
      , {index: c} = a
      , h = a.attributes.position;
    for (let d = r, l = e + r; d < l; d++) {
        let f;
        if (f = d,
        En(o, f * 3, c, h),
        o.needsUpdate = !0,
        n(o, f, i, s))
            return !0
    }
    return !1
}
function UF(r, e=null) {
    e && Array.isArray(e) && (e = new Set(e));
    const t = r.geometry
      , n = t.index ? t.index.array : null
      , i = t.attributes.position;
    let s, o, a, c, h = 0;
    const d = r._roots;
    for (let f = 0, p = d.length; f < p; f++)
        s = d[f],
        o = new Uint32Array(s),
        a = new Uint16Array(s),
        c = new Float32Array(s),
        l(0, h),
        h += s.byteLength;
    function l(f, p, g=!1) {
        const y = f * 2;
        if (a[y + 15] === vf) {
            const _ = o[f + 6]
              , b = a[y + 14];
            let T = 1 / 0
              , S = 1 / 0
              , E = 1 / 0
              , P = -1 / 0
              , R = -1 / 0
              , O = -1 / 0;
            for (let w = 3 * _, I = 3 * (_ + b); w < I; w++) {
                let V = n[w];
                const z = i.getX(V)
                  , q = i.getY(V)
                  , F = i.getZ(V);
                z < T && (T = z),
                z > P && (P = z),
                q < S && (S = q),
                q > R && (R = q),
                F < E && (E = F),
                F > O && (O = F)
            }
            return c[f + 0] !== T || c[f + 1] !== S || c[f + 2] !== E || c[f + 3] !== P || c[f + 4] !== R || c[f + 5] !== O ? (c[f + 0] = T,
            c[f + 1] = S,
            c[f + 2] = E,
            c[f + 3] = P,
            c[f + 4] = R,
            c[f + 5] = O,
            !0) : !1
        } else {
            const _ = f + 8
              , b = o[f + 6]
              , T = _ + p
              , S = b + p;
            let E = g
              , P = !1
              , R = !1;
            e ? E || (P = e.has(T),
            R = e.has(S),
            E = !P && !R) : (P = !0,
            R = !0);
            const O = E || P
              , w = E || R;
            let I = !1;
            O && (I = l(_, p, E));
            let V = !1;
            w && (V = l(b, p, E));
            const z = I || V;
            if (z)
                for (let q = 0; q < 3; q++) {
                    const F = _ + q
                      , j = b + q
                      , K = c[F]
                      , J = c[F + 3]
                      , de = c[j]
                      , ae = c[j + 3];
                    c[f + q] = K < de ? K : de,
                    c[f + q + 3] = J > ae ? J : ae
                }
            return z
        }
    }
}
const mx = new yn;
function zs(r, e, t, n) {
    return rn(r, e, mx),
    t.intersectBox(mx, n)
}
function NF(r, e, t, n, i, s) {
    const {geometry: o, _indirectBuffer: a} = r;
    for (let c = n, h = n + i; c < h; c++) {
        let d = a ? a[c] : c;
        yf(o, e, t, d, s)
    }
}
function FF(r, e, t, n, i) {
    const {geometry: s, _indirectBuffer: o} = r;
    let a = 1 / 0
      , c = null;
    for (let h = n, d = n + i; h < d; h++) {
        let l;
        l = yf(s, e, t, o ? o[h] : h),
        l && l.distance < a && (c = l,
        a = l.distance)
    }
    return c
}
function BF(r, e, t, n, i, s, o) {
    const {geometry: a} = t
      , {index: c} = a
      , h = a.attributes.position;
    for (let d = r, l = e + r; d < l; d++) {
        let f;
        if (f = t.resolveTriangleIndex(d),
        En(o, f * 3, c, h),
        o.needsUpdate = !0,
        n(o, f, i, s))
            return !0
    }
    return !1
}
const _x = new k;
function kF(r, e, t, n, i) {
    nn.setBuffer(r._roots[e]),
    $m(0, r, t, n, i),
    nn.clearBuffer()
}
function $m(r, e, t, n, i) {
    const {float32Array: s, uint16Array: o, uint32Array: a} = nn
      , c = r * 2;
    if (Fi(c, o)) {
        const d = ki(r, a)
          , l = Qi(c, o);
        LF(e, t, n, d, l, i)
    } else {
        const d = er(r);
        zs(d, s, n, _x) && $m(d, e, t, n, i);
        const l = tr(r, a);
        zs(l, s, n, _x) && $m(l, e, t, n, i)
    }
}
const gx = new k
  , zF = ["x", "y", "z"];
function HF(r, e, t, n) {
    nn.setBuffer(r._roots[e]);
    const i = Zm(0, r, t, n);
    return nn.clearBuffer(),
    i
}
function Zm(r, e, t, n) {
    const {float32Array: i, uint16Array: s, uint32Array: o} = nn;
    let a = r * 2;
    if (Fi(a, s)) {
        const h = ki(r, o)
          , d = Qi(a, s);
        return DF(e, t, n, h, d)
    } else {
        const h = eS(r, o)
          , d = zF[h]
          , f = n.direction[d] >= 0;
        let p, g;
        f ? (p = er(r),
        g = tr(r, o)) : (p = tr(r, o),
        g = er(r));
        const v = zs(p, i, n, gx) ? Zm(p, e, t, n) : null;
        if (v) {
            const T = v.point[d];
            if (f ? T <= i[g + h] : T >= i[g + h + 3])
                return v
        }
        const b = zs(g, i, n, gx) ? Zm(g, e, t, n) : null;
        return v && b ? v.distance <= b.distance ? v : b : v || b || null
    }
}
const gh = new yn
  , Ea = new br
  , Aa = new br
  , ic = new it
  , vx = new pi
  , vh = new pi;
function VF(r, e, t, n) {
    nn.setBuffer(r._roots[e]);
    const i = Jm(0, r, t, n);
    return nn.clearBuffer(),
    i
}
function Jm(r, e, t, n, i=null) {
    const {float32Array: s, uint16Array: o, uint32Array: a} = nn;
    let c = r * 2;
    if (i === null && (t.boundingBox || t.computeBoundingBox(),
    vx.set(t.boundingBox.min, t.boundingBox.max, n),
    i = vx),
    Fi(c, o)) {
        const d = e.geometry
          , l = d.index
          , f = d.attributes.position
          , p = t.index
          , g = t.attributes.position
          , y = ki(r, a)
          , v = Qi(c, o);
        if (ic.copy(n).invert(),
        t.boundsTree)
            return rn(r, s, vh),
            vh.matrix.copy(ic),
            vh.needsUpdate = !0,
            t.boundsTree.shapecast({
                intersectsBounds: b=>vh.intersectsBox(b),
                intersectsTriangle: b=>{
                    b.a.applyMatrix4(n),
                    b.b.applyMatrix4(n),
                    b.c.applyMatrix4(n),
                    b.needsUpdate = !0;
                    for (let T = y * 3, S = (v + y) * 3; T < S; T += 3)
                        if (En(Aa, T, l, f),
                        Aa.needsUpdate = !0,
                        b.intersectsTriangle(Aa))
                            return !0;
                    return !1
                }
            });
        for (let _ = y * 3, b = (v + y) * 3; _ < b; _ += 3) {
            En(Ea, _, l, f),
            Ea.a.applyMatrix4(ic),
            Ea.b.applyMatrix4(ic),
            Ea.c.applyMatrix4(ic),
            Ea.needsUpdate = !0;
            for (let T = 0, S = p.count; T < S; T += 3)
                if (En(Aa, T, p, g),
                Aa.needsUpdate = !0,
                Ea.intersectsTriangle(Aa))
                    return !0
        }
    } else {
        const d = r + 8
          , l = a[r + 6];
        return rn(d, s, gh),
        !!(i.intersectsBox(gh) && Jm(d, e, t, n, i) || (rn(l, s, gh),
        i.intersectsBox(gh) && Jm(l, e, t, n, i)))
    }
}
const yh = new it
  , $p = new pi
  , rc = new pi
  , GF = new k
  , WF = new k
  , jF = new k
  , XF = new k;
function qF(r, e, t, n={}, i={}, s=0, o=1 / 0) {
    e.boundingBox || e.computeBoundingBox(),
    $p.set(e.boundingBox.min, e.boundingBox.max, t),
    $p.needsUpdate = !0;
    const a = r.geometry
      , c = a.attributes.position
      , h = a.index
      , d = e.attributes.position
      , l = e.index
      , f = Ji.getPrimitive()
      , p = Ji.getPrimitive();
    let g = GF
      , y = WF
      , v = null
      , _ = null;
    i && (v = jF,
    _ = XF);
    let b = 1 / 0
      , T = null
      , S = null;
    return yh.copy(t).invert(),
    rc.matrix.copy(yh),
    r.shapecast({
        boundsTraverseOrder: E=>$p.distanceToBox(E),
        intersectsBounds: (E,P,R)=>R < b && R < o ? (P && (rc.min.copy(E.min),
        rc.max.copy(E.max),
        rc.needsUpdate = !0),
        !0) : !1,
        intersectsRange: (E,P)=>{
            if (e.boundsTree)
                return e.boundsTree.shapecast({
                    boundsTraverseOrder: O=>rc.distanceToBox(O),
                    intersectsBounds: (O,w,I)=>I < b && I < o,
                    intersectsRange: (O,w)=>{
                        for (let I = O, V = O + w; I < V; I++) {
                            En(p, 3 * I, l, d),
                            p.a.applyMatrix4(t),
                            p.b.applyMatrix4(t),
                            p.c.applyMatrix4(t),
                            p.needsUpdate = !0;
                            for (let z = E, q = E + P; z < q; z++) {
                                En(f, 3 * z, h, c),
                                f.needsUpdate = !0;
                                const F = f.distanceToTriangle(p, g, v);
                                if (F < b && (y.copy(g),
                                _ && _.copy(v),
                                b = F,
                                T = z,
                                S = I),
                                F < s)
                                    return !0
                            }
                        }
                    }
                });
            {
                const R = bl(e);
                for (let O = 0, w = R; O < w; O++) {
                    En(p, 3 * O, l, d),
                    p.a.applyMatrix4(t),
                    p.b.applyMatrix4(t),
                    p.c.applyMatrix4(t),
                    p.needsUpdate = !0;
                    for (let I = E, V = E + P; I < V; I++) {
                        En(f, 3 * I, h, c),
                        f.needsUpdate = !0;
                        const z = f.distanceToTriangle(p, g, v);
                        if (z < b && (y.copy(g),
                        _ && _.copy(v),
                        b = z,
                        T = I,
                        S = O),
                        z < s)
                            return !0
                    }
                }
            }
        }
    }),
    Ji.releasePrimitive(f),
    Ji.releasePrimitive(p),
    b === 1 / 0 ? null : (n.point ? n.point.copy(y) : n.point = y.clone(),
    n.distance = b,
    n.faceIndex = T,
    i && (i.point ? i.point.copy(_) : i.point = _.clone(),
    i.point.applyMatrix4(yh),
    y.applyMatrix4(yh),
    i.distance = y.sub(i.point).length(),
    i.faceIndex = S),
    n)
}
function KF(r, e=null) {
    e && Array.isArray(e) && (e = new Set(e));
    const t = r.geometry
      , n = t.index ? t.index.array : null
      , i = t.attributes.position;
    let s, o, a, c, h = 0;
    const d = r._roots;
    for (let f = 0, p = d.length; f < p; f++)
        s = d[f],
        o = new Uint32Array(s),
        a = new Uint16Array(s),
        c = new Float32Array(s),
        l(0, h),
        h += s.byteLength;
    function l(f, p, g=!1) {
        const y = f * 2;
        if (a[y + 15] === vf) {
            const _ = o[f + 6]
              , b = a[y + 14];
            let T = 1 / 0
              , S = 1 / 0
              , E = 1 / 0
              , P = -1 / 0
              , R = -1 / 0
              , O = -1 / 0;
            for (let w = _, I = _ + b; w < I; w++) {
                const V = 3 * r.resolveTriangleIndex(w);
                for (let z = 0; z < 3; z++) {
                    let q = V + z;
                    q = n ? n[q] : q;
                    const F = i.getX(q)
                      , j = i.getY(q)
                      , K = i.getZ(q);
                    F < T && (T = F),
                    F > P && (P = F),
                    j < S && (S = j),
                    j > R && (R = j),
                    K < E && (E = K),
                    K > O && (O = K)
                }
            }
            return c[f + 0] !== T || c[f + 1] !== S || c[f + 2] !== E || c[f + 3] !== P || c[f + 4] !== R || c[f + 5] !== O ? (c[f + 0] = T,
            c[f + 1] = S,
            c[f + 2] = E,
            c[f + 3] = P,
            c[f + 4] = R,
            c[f + 5] = O,
            !0) : !1
        } else {
            const _ = f + 8
              , b = o[f + 6]
              , T = _ + p
              , S = b + p;
            let E = g
              , P = !1
              , R = !1;
            e ? E || (P = e.has(T),
            R = e.has(S),
            E = !P && !R) : (P = !0,
            R = !0);
            const O = E || P
              , w = E || R;
            let I = !1;
            O && (I = l(_, p, E));
            let V = !1;
            w && (V = l(b, p, E));
            const z = I || V;
            if (z)
                for (let q = 0; q < 3; q++) {
                    const F = _ + q
                      , j = b + q
                      , K = c[F]
                      , J = c[F + 3]
                      , de = c[j]
                      , ae = c[j + 3];
                    c[f + q] = K < de ? K : de,
                    c[f + q + 3] = J > ae ? J : ae
                }
            return z
        }
    }
}
const yx = new k;
function YF(r, e, t, n, i) {
    nn.setBuffer(r._roots[e]),
    Qm(0, r, t, n, i),
    nn.clearBuffer()
}
function Qm(r, e, t, n, i) {
    const {float32Array: s, uint16Array: o, uint32Array: a} = nn
      , c = r * 2;
    if (Fi(c, o)) {
        const d = ki(r, a)
          , l = Qi(c, o);
        NF(e, t, n, d, l, i)
    } else {
        const d = er(r);
        zs(d, s, n, yx) && Qm(d, e, t, n, i);
        const l = tr(r, a);
        zs(l, s, n, yx) && Qm(l, e, t, n, i)
    }
}
const xx = new k
  , $F = ["x", "y", "z"];
function ZF(r, e, t, n) {
    nn.setBuffer(r._roots[e]);
    const i = e_(0, r, t, n);
    return nn.clearBuffer(),
    i
}
function e_(r, e, t, n) {
    const {float32Array: i, uint16Array: s, uint32Array: o} = nn;
    let a = r * 2;
    if (Fi(a, s)) {
        const h = ki(r, o)
          , d = Qi(a, s);
        return FF(e, t, n, h, d)
    } else {
        const h = eS(r, o)
          , d = $F[h]
          , f = n.direction[d] >= 0;
        let p, g;
        f ? (p = er(r),
        g = tr(r, o)) : (p = tr(r, o),
        g = er(r));
        const v = zs(p, i, n, xx) ? e_(p, e, t, n) : null;
        if (v) {
            const T = v.point[d];
            if (f ? T <= i[g + h] : T >= i[g + h + 3])
                return v
        }
        const b = zs(g, i, n, xx) ? e_(g, e, t, n) : null;
        return v && b ? v.distance <= b.distance ? v : b : v || b || null
    }
}
const xh = new yn
  , Pa = new br
  , Ra = new br
  , sc = new it
  , Tx = new pi
  , Th = new pi;
function JF(r, e, t, n) {
    nn.setBuffer(r._roots[e]);
    const i = t_(0, r, t, n);
    return nn.clearBuffer(),
    i
}
function t_(r, e, t, n, i=null) {
    const {float32Array: s, uint16Array: o, uint32Array: a} = nn;
    let c = r * 2;
    if (i === null && (t.boundingBox || t.computeBoundingBox(),
    Tx.set(t.boundingBox.min, t.boundingBox.max, n),
    i = Tx),
    Fi(c, o)) {
        const d = e.geometry
          , l = d.index
          , f = d.attributes.position
          , p = t.index
          , g = t.attributes.position
          , y = ki(r, a)
          , v = Qi(c, o);
        if (sc.copy(n).invert(),
        t.boundsTree)
            return rn(r, s, Th),
            Th.matrix.copy(sc),
            Th.needsUpdate = !0,
            t.boundsTree.shapecast({
                intersectsBounds: b=>Th.intersectsBox(b),
                intersectsTriangle: b=>{
                    b.a.applyMatrix4(n),
                    b.b.applyMatrix4(n),
                    b.c.applyMatrix4(n),
                    b.needsUpdate = !0;
                    for (let T = y, S = v + y; T < S; T++)
                        if (En(Ra, 3 * e.resolveTriangleIndex(T), l, f),
                        Ra.needsUpdate = !0,
                        b.intersectsTriangle(Ra))
                            return !0;
                    return !1
                }
            });
        for (let _ = y, b = v + y; _ < b; _++) {
            const T = e.resolveTriangleIndex(_);
            En(Pa, 3 * T, l, f),
            Pa.a.applyMatrix4(sc),
            Pa.b.applyMatrix4(sc),
            Pa.c.applyMatrix4(sc),
            Pa.needsUpdate = !0;
            for (let S = 0, E = p.count; S < E; S += 3)
                if (En(Ra, S, p, g),
                Ra.needsUpdate = !0,
                Pa.intersectsTriangle(Ra))
                    return !0
        }
    } else {
        const d = r + 8
          , l = a[r + 6];
        return rn(d, s, xh),
        !!(i.intersectsBox(xh) && t_(d, e, t, n, i) || (rn(l, s, xh),
        i.intersectsBox(xh) && t_(l, e, t, n, i)))
    }
}
const bh = new it
  , Zp = new pi
  , oc = new pi
  , QF = new k
  , eB = new k
  , tB = new k
  , nB = new k;
function iB(r, e, t, n={}, i={}, s=0, o=1 / 0) {
    e.boundingBox || e.computeBoundingBox(),
    Zp.set(e.boundingBox.min, e.boundingBox.max, t),
    Zp.needsUpdate = !0;
    const a = r.geometry
      , c = a.attributes.position
      , h = a.index
      , d = e.attributes.position
      , l = e.index
      , f = Ji.getPrimitive()
      , p = Ji.getPrimitive();
    let g = QF
      , y = eB
      , v = null
      , _ = null;
    i && (v = tB,
    _ = nB);
    let b = 1 / 0
      , T = null
      , S = null;
    return bh.copy(t).invert(),
    oc.matrix.copy(bh),
    r.shapecast({
        boundsTraverseOrder: E=>Zp.distanceToBox(E),
        intersectsBounds: (E,P,R)=>R < b && R < o ? (P && (oc.min.copy(E.min),
        oc.max.copy(E.max),
        oc.needsUpdate = !0),
        !0) : !1,
        intersectsRange: (E,P)=>{
            if (e.boundsTree) {
                const R = e.boundsTree;
                return R.shapecast({
                    boundsTraverseOrder: O=>oc.distanceToBox(O),
                    intersectsBounds: (O,w,I)=>I < b && I < o,
                    intersectsRange: (O,w)=>{
                        for (let I = O, V = O + w; I < V; I++) {
                            const z = R.resolveTriangleIndex(I);
                            En(p, 3 * z, l, d),
                            p.a.applyMatrix4(t),
                            p.b.applyMatrix4(t),
                            p.c.applyMatrix4(t),
                            p.needsUpdate = !0;
                            for (let q = E, F = E + P; q < F; q++) {
                                const j = r.resolveTriangleIndex(q);
                                En(f, 3 * j, h, c),
                                f.needsUpdate = !0;
                                const K = f.distanceToTriangle(p, g, v);
                                if (K < b && (y.copy(g),
                                _ && _.copy(v),
                                b = K,
                                T = q,
                                S = I),
                                K < s)
                                    return !0
                            }
                        }
                    }
                })
            } else {
                const R = bl(e);
                for (let O = 0, w = R; O < w; O++) {
                    En(p, 3 * O, l, d),
                    p.a.applyMatrix4(t),
                    p.b.applyMatrix4(t),
                    p.c.applyMatrix4(t),
                    p.needsUpdate = !0;
                    for (let I = E, V = E + P; I < V; I++) {
                        const z = r.resolveTriangleIndex(I);
                        En(f, 3 * z, h, c),
                        f.needsUpdate = !0;
                        const q = f.distanceToTriangle(p, g, v);
                        if (q < b && (y.copy(g),
                        _ && _.copy(v),
                        b = q,
                        T = I,
                        S = O),
                        q < s)
                            return !0
                    }
                }
            }
        }
    }),
    Ji.releasePrimitive(f),
    Ji.releasePrimitive(p),
    b === 1 / 0 ? null : (n.point ? n.point.copy(y) : n.point = y.clone(),
    n.distance = b,
    n.faceIndex = T,
    i && (i.point ? i.point.copy(_) : i.point = _.clone(),
    i.point.applyMatrix4(bh),
    y.applyMatrix4(bh),
    i.distance = y.sub(i.point).length(),
    i.faceIndex = S),
    n)
}
function rB() {
    return typeof SharedArrayBuffer < "u"
}
const Sc = new nn.constructor
  , ef = new nn.constructor
  , Ps = new Z_(()=>new yn)
  , Ca = new yn
  , Ia = new yn
  , Jp = new yn
  , Qp = new yn;
let em = !1;
function sB(r, e, t, n) {
    if (em)
        throw new Error("MeshBVH: Recursive calls to bvhcast not supported.");
    em = !0;
    const i = r._roots
      , s = e._roots;
    let o, a = 0, c = 0;
    const h = new it().copy(t).invert();
    for (let d = 0, l = i.length; d < l; d++) {
        Sc.setBuffer(i[d]),
        c = 0;
        const f = Ps.getPrimitive();
        rn(0, Sc.float32Array, f),
        f.applyMatrix4(h);
        for (let p = 0, g = s.length; p < g && (ef.setBuffer(s[d]),
        o = dr(0, 0, t, h, n, a, c, 0, 0, f),
        ef.clearBuffer(),
        c += s[p].length,
        !o); p++)
            ;
        if (Ps.releasePrimitive(f),
        Sc.clearBuffer(),
        a += i[d].length,
        o)
            break
    }
    return em = !1,
    o
}
function dr(r, e, t, n, i, s=0, o=0, a=0, c=0, h=null, d=!1) {
    let l, f;
    d ? (l = ef,
    f = Sc) : (l = Sc,
    f = ef);
    const p = l.float32Array
      , g = l.uint32Array
      , y = l.uint16Array
      , v = f.float32Array
      , _ = f.uint32Array
      , b = f.uint16Array
      , T = r * 2
      , S = e * 2
      , E = Fi(T, y)
      , P = Fi(S, b);
    let R = !1;
    if (P && E)
        d ? R = i(ki(e, _), Qi(e * 2, b), ki(r, g), Qi(r * 2, y), c, o + e, a, s + r) : R = i(ki(r, g), Qi(r * 2, y), ki(e, _), Qi(e * 2, b), a, s + r, c, o + e);
    else if (P) {
        const O = Ps.getPrimitive();
        rn(e, v, O),
        O.applyMatrix4(t);
        const w = er(r)
          , I = tr(r, g);
        rn(w, p, Ca),
        rn(I, p, Ia);
        const V = O.intersectsBox(Ca)
          , z = O.intersectsBox(Ia);
        R = V && dr(e, w, n, t, i, o, s, c, a + 1, O, !d) || z && dr(e, I, n, t, i, o, s, c, a + 1, O, !d),
        Ps.releasePrimitive(O)
    } else {
        const O = er(e)
          , w = tr(e, _);
        rn(O, v, Jp),
        rn(w, v, Qp);
        const I = h.intersectsBox(Jp)
          , V = h.intersectsBox(Qp);
        if (I && V)
            R = dr(r, O, t, n, i, s, o, a, c + 1, h, d) || dr(r, w, t, n, i, s, o, a, c + 1, h, d);
        else if (I)
            if (E)
                R = dr(r, O, t, n, i, s, o, a, c + 1, h, d);
            else {
                const z = Ps.getPrimitive();
                z.copy(Jp).applyMatrix4(t);
                const q = er(r)
                  , F = tr(r, g);
                rn(q, p, Ca),
                rn(F, p, Ia);
                const j = z.intersectsBox(Ca)
                  , K = z.intersectsBox(Ia);
                R = j && dr(O, q, n, t, i, o, s, c, a + 1, z, !d) || K && dr(O, F, n, t, i, o, s, c, a + 1, z, !d),
                Ps.releasePrimitive(z)
            }
        else if (V)
            if (E)
                R = dr(r, w, t, n, i, s, o, a, c + 1, h, d);
            else {
                const z = Ps.getPrimitive();
                z.copy(Qp).applyMatrix4(t);
                const q = er(r)
                  , F = tr(r, g);
                rn(q, p, Ca),
                rn(F, p, Ia);
                const j = z.intersectsBox(Ca)
                  , K = z.intersectsBox(Ia);
                R = j && dr(w, q, n, t, i, o, s, c, a + 1, z, !d) || K && dr(w, F, n, t, i, o, s, c, a + 1, z, !d),
                Ps.releasePrimitive(z)
            }
    }
    return R
}
const Sh = new pi
  , bx = new yn;
class J_ {
    static serialize(e, t={}) {
        t = {
            cloneBuffers: !0,
            ...t
        };
        const n = e.geometry
          , i = e._roots
          , s = e._indirectBuffer
          , o = n.getIndex();
        let a;
        return t.cloneBuffers ? a = {
            roots: i.map(c=>c.slice()),
            index: o.array.slice(),
            indirectBuffer: s ? s.slice() : null
        } : a = {
            roots: i,
            index: o.array,
            indirectBuffer: s
        },
        a
    }
    static deserialize(e, t, n={}) {
        n = {
            setIndex: !0,
            indirect: !!e.indirectBuffer,
            ...n
        };
        const {index: i, roots: s, indirectBuffer: o} = e
          , a = new J_(t,{
            ...n,
            [Xp]: !0
        });
        if (a._roots = s,
        a._indirectBuffer = o || null,
        n.setIndex) {
            const c = t.getIndex();
            if (c === null) {
                const h = new pt(e.index,1,!1);
                t.setIndex(h)
            } else
                c.array !== i && (c.array.set(i),
                c.needsUpdate = !0)
        }
        return a
    }
    get indirect() {
        return !!this._indirectBuffer
    }
    constructor(e, t={}) {
        if (e.isBufferGeometry) {
            if (e.index && e.index.isInterleavedBufferAttribute)
                throw new Error("MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.")
        } else
            throw new Error("MeshBVH: Only BufferGeometries are supported.");
        if (t = Object.assign({
            strategy: Zb,
            maxDepth: 40,
            maxLeafTris: 10,
            verbose: !0,
            useSharedArrayBuffer: !1,
            setBoundingBox: !0,
            onProgress: null,
            indirect: !1,
            [Xp]: !1
        }, t),
        t.useSharedArrayBuffer && !rB())
            throw new Error("MeshBVH: SharedArrayBuffer is not available.");
        this.geometry = e,
        this._roots = null,
        this._indirectBuffer = null,
        t[Xp] || (bF(this, t),
        !e.boundingBox && t.setBoundingBox && (e.boundingBox = this.getBoundingBox(new yn)));
        const {_indirectBuffer: n} = this;
        this.resolveTriangleIndex = t.indirect ? i=>n[i] : i=>i
    }
    refit(e=null) {
        return (this.indirect ? KF : UF)(this, e)
    }
    traverse(e, t=0) {
        const n = this._roots[t]
          , i = new Uint32Array(n)
          , s = new Uint16Array(n);
        o(0);
        function o(a, c=0) {
            const h = a * 2
              , d = s[h + 15] === vf;
            if (d) {
                const l = i[a + 6]
                  , f = s[h + 14];
                e(c, d, new Float32Array(n,a * 4,6), l, f)
            } else {
                const l = a + Uh / 4
                  , f = i[a + 6]
                  , p = i[a + 7];
                e(c, d, new Float32Array(n,a * 4,6), p) || (o(l, c + 1),
                o(f, c + 1))
            }
        }
    }
    raycast(e, t=xr) {
        const n = this._roots
          , i = this.geometry
          , s = []
          , o = t.isMaterial
          , a = Array.isArray(t)
          , c = i.groups
          , h = o ? t.side : t
          , d = this.indirect ? YF : kF;
        for (let l = 0, f = n.length; l < f; l++) {
            const p = a ? t[c[l].materialIndex].side : h
              , g = s.length;
            if (d(this, l, p, e, s),
            a) {
                const y = c[l].materialIndex;
                for (let v = g, _ = s.length; v < _; v++)
                    s[v].face.materialIndex = y
            }
        }
        return s
    }
    raycastFirst(e, t=xr) {
        const n = this._roots
          , i = this.geometry
          , s = t.isMaterial
          , o = Array.isArray(t);
        let a = null;
        const c = i.groups
          , h = s ? t.side : t
          , d = this.indirect ? ZF : HF;
        for (let l = 0, f = n.length; l < f; l++) {
            const p = o ? t[c[l].materialIndex].side : h
              , g = d(this, l, p, e);
            g != null && (a == null || g.distance < a.distance) && (a = g,
            o && (g.face.materialIndex = c[l].materialIndex))
        }
        return a
    }
    intersectsGeometry(e, t) {
        let n = !1;
        const i = this._roots
          , s = this.indirect ? JF : VF;
        for (let o = 0, a = i.length; o < a && (n = s(this, o, e, t),
        !n); o++)
            ;
        return n
    }
    shapecast(e) {
        const t = Ji.getPrimitive()
          , n = this.indirect ? BF : OF;
        let {boundsTraverseOrder: i, intersectsBounds: s, intersectsRange: o, intersectsTriangle: a} = e;
        if (o && a) {
            const l = o;
            o = (f,p,g,y,v)=>l(f, p, g, y, v) ? !0 : n(f, p, this, a, g, y, t)
        } else
            o || (a ? o = (l,f,p,g)=>n(l, f, this, a, p, g, t) : o = (l,f,p)=>p);
        let c = !1
          , h = 0;
        const d = this._roots;
        for (let l = 0, f = d.length; l < f; l++) {
            const p = d[l];
            if (c = PF(this, l, s, o, i, h),
            c)
                break;
            h += p.byteLength
        }
        return Ji.releasePrimitive(t),
        c
    }
    bvhcast(e, t, n) {
        let {intersectsRanges: i, intersectsTriangles: s} = n;
        const o = Ji.getPrimitive()
          , a = this.geometry.index
          , c = this.geometry.attributes.position
          , h = this.indirect ? g=>{
            const y = this.resolveTriangleIndex(g);
            En(o, y * 3, a, c)
        }
        : g=>{
            En(o, g * 3, a, c)
        }
          , d = Ji.getPrimitive()
          , l = e.geometry.index
          , f = e.geometry.attributes.position
          , p = e.indirect ? g=>{
            const y = e.resolveTriangleIndex(g);
            En(d, y * 3, l, f)
        }
        : g=>{
            En(d, g * 3, l, f)
        }
        ;
        if (s) {
            const g = (y,v,_,b,T,S,E,P)=>{
                for (let R = _, O = _ + b; R < O; R++) {
                    p(R),
                    d.a.applyMatrix4(t),
                    d.b.applyMatrix4(t),
                    d.c.applyMatrix4(t),
                    d.needsUpdate = !0;
                    for (let w = y, I = y + v; w < I; w++)
                        if (h(w),
                        o.needsUpdate = !0,
                        s(o, d, w, R, T, S, E, P))
                            return !0
                }
                return !1
            }
            ;
            if (i) {
                const y = i;
                i = function(v, _, b, T, S, E, P, R) {
                    return y(v, _, b, T, S, E, P, R) ? !0 : g(v, _, b, T, S, E, P, R)
                }
            } else
                i = g
        }
        return sB(this, e, t, i)
    }
    intersectsBox(e, t) {
        return Sh.set(e.min, e.max, t),
        Sh.needsUpdate = !0,
        this.shapecast({
            intersectsBounds: n=>Sh.intersectsBox(n),
            intersectsTriangle: n=>Sh.intersectsTriangle(n)
        })
    }
    intersectsSphere(e) {
        return this.shapecast({
            intersectsBounds: t=>e.intersectsBox(t),
            intersectsTriangle: t=>t.intersectsSphere(e)
        })
    }
    closestPointToGeometry(e, t, n={}, i={}, s=0, o=1 / 0) {
        return (this.indirect ? iB : qF)(this, e, t, n, i, s, o)
    }
    closestPointToPoint(e, t={}, n=0, i=1 / 0) {
        return RF(this, e, t, n, i)
    }
    getBoundingBox(e) {
        return e.makeEmpty(),
        this._roots.forEach(n=>{
            rn(0, new Float32Array(n), bx),
            e.union(bx)
        }
        ),
        e
    }
}
const Sx = new yn;
class oB extends Yt {
    get isMesh() {
        return !this.displayEdges
    }
    get isLineSegments() {
        return this.displayEdges
    }
    get isLine() {
        return this.displayEdges
    }
    constructor(e, t, n=10, i=0) {
        super(),
        this.material = t,
        this.geometry = new mn,
        this.name = "MeshBVHRootVisualizer",
        this.depth = n,
        this.displayParents = !1,
        this.mesh = e,
        this.displayEdges = !0,
        this._group = i
    }
    raycast() {}
    update() {
        const e = this.geometry
          , t = this.mesh.geometry.boundsTree
          , n = this._group;
        if (e.dispose(),
        this.visible = !1,
        t) {
            const i = this.depth - 1
              , s = this.displayParents;
            let o = 0;
            t.traverse((f,p)=>{
                if (f === i || p)
                    return o++,
                    !0;
                s && o++
            }
            , n);
            let a = 0;
            const c = new Float32Array(8 * 3 * o);
            t.traverse((f,p,g)=>{
                const y = f === i || p;
                if (y || s) {
                    rn(0, g, Sx);
                    const {min: v, max: _} = Sx;
                    for (let b = -1; b <= 1; b += 2) {
                        const T = b < 0 ? v.x : _.x;
                        for (let S = -1; S <= 1; S += 2) {
                            const E = S < 0 ? v.y : _.y;
                            for (let P = -1; P <= 1; P += 2) {
                                const R = P < 0 ? v.z : _.z;
                                c[a + 0] = T,
                                c[a + 1] = E,
                                c[a + 2] = R,
                                a += 3
                            }
                        }
                    }
                    return y
                }
            }
            , n);
            let h, d;
            this.displayEdges ? d = new Uint8Array([0, 4, 1, 5, 2, 6, 3, 7, 0, 2, 1, 3, 4, 6, 5, 7, 0, 1, 2, 3, 4, 5, 6, 7]) : d = new Uint8Array([0, 1, 2, 2, 1, 3, 4, 6, 5, 6, 7, 5, 1, 4, 5, 0, 4, 1, 2, 3, 6, 3, 7, 6, 0, 2, 4, 2, 6, 4, 1, 5, 3, 3, 5, 7]),
            c.length > 65535 ? h = new Uint32Array(d.length * o) : h = new Uint16Array(d.length * o);
            const l = d.length;
            for (let f = 0; f < o; f++) {
                const p = f * 8
                  , g = f * l;
                for (let y = 0; y < l; y++)
                    h[g + y] = p + d[y]
            }
            e.setIndex(new pt(h,1,!1)),
            e.setAttribute("position", new pt(c,3,!1)),
            this.visible = !0
        }
    }
}
class Q_ extends gr {
    get color() {
        return this.edgeMaterial.color
    }
    get opacity() {
        return this.edgeMaterial.opacity
    }
    set opacity(e) {
        this.edgeMaterial.opacity = e,
        this.meshMaterial.opacity = e
    }
    constructor(e, t=10) {
        super(),
        this.name = "MeshBVHVisualizer",
        this.depth = t,
        this.mesh = e,
        this.displayParents = !1,
        this.displayEdges = !0,
        this._roots = [];
        const n = new H_({
            color: 65416,
            transparent: !0,
            opacity: .3,
            depthWrite: !1
        })
          , i = new _r({
            color: 65416,
            transparent: !0,
            opacity: .3,
            depthWrite: !1
        });
        i.color = n.color,
        this.edgeMaterial = n,
        this.meshMaterial = i,
        this.update()
    }
    update() {
        const e = this.mesh.geometry.boundsTree
          , t = e ? e._roots.length : 0;
        for (; this._roots.length > t; ) {
            const n = this._roots.pop();
            n.geometry.dispose(),
            this.remove(n)
        }
        for (let n = 0; n < t; n++) {
            if (n >= this._roots.length) {
                const s = new oB(this.mesh,this.edgeMaterial,this.depth,n);
                this.add(s),
                this._roots.push(s)
            }
            const i = this._roots[n];
            i.depth = this.depth,
            i.mesh = this.mesh,
            i.displayParents = this.displayParents,
            i.displayEdges = this.displayEdges,
            i.material = this.displayEdges ? this.edgeMaterial : this.meshMaterial,
            i.update()
        }
    }
    updateMatrixWorld(...e) {
        this.position.copy(this.mesh.position),
        this.rotation.copy(this.mesh.rotation),
        this.scale.copy(this.mesh.scale),
        super.updateMatrixWorld(...e)
    }
    copy(e) {
        this.depth = e.depth,
        this.mesh = e.mesh
    }
    clone() {
        return new Q_(this.mesh,this.depth)
    }
    dispose() {
        this.edgeMaterial.dispose(),
        this.meshMaterial.dispose();
        const e = this.children;
        for (let t = 0, n = e.length; t < n; t++)
            e[t].geometry.dispose()
    }
}
function Mx(r, e, t) {
    return r === null || (r.point.applyMatrix4(e.matrixWorld),
    r.distance = r.point.distanceTo(t.ray.origin),
    r.object = e,
    r.distance < t.near || r.distance > t.far) ? null : r
}
const tm = new Bo
  , wx = new it
  , aB = en.prototype.raycast;
function tS(r, e) {
    if (this.geometry.boundsTree) {
        if (this.material === void 0)
            return;
        wx.copy(this.matrixWorld).invert(),
        tm.copy(r.ray).applyMatrix4(wx);
        const t = this.geometry.boundsTree;
        if (r.firstHitOnly === !0) {
            const n = Mx(t.raycastFirst(tm, this.material), this, r);
            n && e.push(n)
        } else {
            const n = t.raycast(tm, this.material);
            for (let i = 0, s = n.length; i < s; i++) {
                const o = Mx(n[i], this, r);
                o && e.push(o)
            }
        }
    } else
        aB.call(this, r, e)
}
function lB(r) {
    return this.boundsTree = new J_(this,r),
    this.boundsTree
}
function cB() {
    this.boundsTree = null
}
new Ce;
new Ce;
var tf = function(e) {
    return 1 / (1 + e + .48 * e * e + .235 * e * e * e)
};
function No(r, e, t) {
    var n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : .25
      , i = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : .01
      , s = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : 1 / 0
      , o = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : tf
      , a = arguments.length > 7 && arguments[7] !== void 0 ? arguments[7] : .001
      , c = "velocity_" + e;
    if (r.__damp === void 0 && (r.__damp = {}),
    r.__damp[c] === void 0 && (r.__damp[c] = 0),
    Math.abs(r[e] - t) <= a)
        return r[e] = t,
        !1;
    n = Math.max(1e-4, n);
    var h = 2 / n
      , d = o(h * i)
      , l = r[e] - t
      , f = t
      , p = s * n;
    l = Math.min(Math.max(l, -p), p),
    t = r[e] - l;
    var g = (r.__damp[c] + h * l) * i;
    r.__damp[c] = (r.__damp[c] - h * g) * d;
    var y = t + (l + g) * d;
    return f - r[e] > 0 == y > f && (y = f,
    r.__damp[c] = (y - f) / i),
    r[e] = y,
    !0
}
function uB(r, e, t) {
    return Math.max(e, Math.min(r, t))
}
const tn = {
    toVector(r, e) {
        return r === void 0 && (r = e),
        Array.isArray(r) ? r : [r, r]
    },
    add(r, e) {
        return [r[0] + e[0], r[1] + e[1]]
    },
    sub(r, e) {
        return [r[0] - e[0], r[1] - e[1]]
    },
    addTo(r, e) {
        r[0] += e[0],
        r[1] += e[1]
    },
    subTo(r, e) {
        r[0] -= e[0],
        r[1] -= e[1]
    }
};
function Ex(r, e, t) {
    return e === 0 || Math.abs(e) === 1 / 0 ? Math.pow(r, t * 5) : r * e * t / (e + t * r)
}
function Ax(r, e, t, n=.15) {
    return n === 0 ? uB(r, e, t) : r < e ? -Ex(e - r, t - e, n) + e : r > t ? +Ex(r - t, t - e, n) + t : r
}
function hB(r, [e,t], [n,i]) {
    const [[s,o],[a,c]] = r;
    return [Ax(e, s, o, n), Ax(t, a, c, i)]
}
function fB(r, e) {
    if (typeof r != "object" || r === null)
        return r;
    var t = r[Symbol.toPrimitive];
    if (t !== void 0) {
        var n = t.call(r, e || "default");
        if (typeof n != "object")
            return n;
        throw new TypeError("@@toPrimitive must return a primitive value.")
    }
    return (e === "string" ? String : Number)(r)
}
function dB(r) {
    var e = fB(r, "string");
    return typeof e == "symbol" ? e : String(e)
}
function Sn(r, e, t) {
    return e = dB(e),
    e in r ? Object.defineProperty(r, e, {
        value: t,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : r[e] = t,
    r
}
function Px(r, e) {
    var t = Object.keys(r);
    if (Object.getOwnPropertySymbols) {
        var n = Object.getOwnPropertySymbols(r);
        e && (n = n.filter(function(i) {
            return Object.getOwnPropertyDescriptor(r, i).enumerable
        })),
        t.push.apply(t, n)
    }
    return t
}
function un(r) {
    for (var e = 1; e < arguments.length; e++) {
        var t = arguments[e] != null ? arguments[e] : {};
        e % 2 ? Px(Object(t), !0).forEach(function(n) {
            Sn(r, n, t[n])
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(r, Object.getOwnPropertyDescriptors(t)) : Px(Object(t)).forEach(function(n) {
            Object.defineProperty(r, n, Object.getOwnPropertyDescriptor(t, n))
        })
    }
    return r
}
const nS = {
    pointer: {
        start: "down",
        change: "move",
        end: "up"
    },
    mouse: {
        start: "down",
        change: "move",
        end: "up"
    },
    touch: {
        start: "start",
        change: "move",
        end: "end"
    },
    gesture: {
        start: "start",
        change: "change",
        end: "end"
    }
};
function Rx(r) {
    return r ? r[0].toUpperCase() + r.slice(1) : ""
}
const pB = ["enter", "leave"];
function mB(r=!1, e) {
    return r && !pB.includes(e)
}
function _B(r, e="", t=!1) {
    const n = nS[r]
      , i = n && n[e] || e;
    return "on" + Rx(r) + Rx(i) + (mB(t, i) ? "Capture" : "")
}
const gB = ["gotpointercapture", "lostpointercapture"];
function vB(r) {
    let e = r.substring(2).toLowerCase();
    const t = !!~e.indexOf("passive");
    t && (e = e.replace("passive", ""));
    const n = gB.includes(e) ? "capturecapture" : "capture"
      , i = !!~e.indexOf(n);
    return i && (e = e.replace("capture", "")),
    {
        device: e,
        capture: i,
        passive: t
    }
}
function yB(r, e="") {
    const t = nS[r]
      , n = t && t[e] || e;
    return r + n
}
function xf(r) {
    return "touches"in r
}
function iS(r) {
    return xf(r) ? "touch" : "pointerType"in r ? r.pointerType : "mouse"
}
function xB(r) {
    return Array.from(r.touches).filter(e=>{
        var t, n;
        return e.target === r.currentTarget || ((t = r.currentTarget) === null || t === void 0 || (n = t.contains) === null || n === void 0 ? void 0 : n.call(t, e.target))
    }
    )
}
function TB(r) {
    return r.type === "touchend" || r.type === "touchcancel" ? r.changedTouches : r.targetTouches
}
function rS(r) {
    return xf(r) ? TB(r)[0] : r
}
function n_(r, e) {
    try {
        const t = e.clientX - r.clientX
          , n = e.clientY - r.clientY
          , i = (e.clientX + r.clientX) / 2
          , s = (e.clientY + r.clientY) / 2
          , o = Math.hypot(t, n);
        return {
            angle: -(Math.atan2(t, n) * 180) / Math.PI,
            distance: o,
            origin: [i, s]
        }
    } catch {}
    return null
}
function bB(r) {
    return xB(r).map(e=>e.identifier)
}
function Cx(r, e) {
    const [t,n] = Array.from(r.touches).filter(i=>e.includes(i.identifier));
    return n_(t, n)
}
function nm(r) {
    const e = rS(r);
    return xf(r) ? e.identifier : e.pointerId
}
function dl(r) {
    const e = rS(r);
    return [e.clientX, e.clientY]
}
const Ix = 40
  , Lx = 800;
function sS(r) {
    let {deltaX: e, deltaY: t, deltaMode: n} = r;
    return n === 1 ? (e *= Ix,
    t *= Ix) : n === 2 && (e *= Lx,
    t *= Lx),
    [e, t]
}
function SB(r) {
    var e, t;
    const {scrollX: n, scrollY: i, scrollLeft: s, scrollTop: o} = r.currentTarget;
    return [(e = n ?? s) !== null && e !== void 0 ? e : 0, (t = i ?? o) !== null && t !== void 0 ? t : 0]
}
function MB(r) {
    const e = {};
    if ("buttons"in r && (e.buttons = r.buttons),
    "shiftKey"in r) {
        const {shiftKey: t, altKey: n, metaKey: i, ctrlKey: s} = r;
        Object.assign(e, {
            shiftKey: t,
            altKey: n,
            metaKey: i,
            ctrlKey: s
        })
    }
    return e
}
function nf(r, ...e) {
    return typeof r == "function" ? r(...e) : r
}
function wB() {}
function EB(...r) {
    return r.length === 0 ? wB : r.length === 1 ? r[0] : function() {
        let e;
        for (const t of r)
            e = t.apply(this, arguments) || e;
        return e
    }
}
function Dx(r, e) {
    return Object.assign({}, e, r || {})
}
const AB = 32;
class oS {
    constructor(e, t, n) {
        this.ctrl = e,
        this.args = t,
        this.key = n,
        this.state || (this.state = {},
        this.computeValues([0, 0]),
        this.computeInitial(),
        this.init && this.init(),
        this.reset())
    }
    get state() {
        return this.ctrl.state[this.key]
    }
    set state(e) {
        this.ctrl.state[this.key] = e
    }
    get shared() {
        return this.ctrl.state.shared
    }
    get eventStore() {
        return this.ctrl.gestureEventStores[this.key]
    }
    get timeoutStore() {
        return this.ctrl.gestureTimeoutStores[this.key]
    }
    get config() {
        return this.ctrl.config[this.key]
    }
    get sharedConfig() {
        return this.ctrl.config.shared
    }
    get handler() {
        return this.ctrl.handlers[this.key]
    }
    reset() {
        const {state: e, shared: t, ingKey: n, args: i} = this;
        t[n] = e._active = e.active = e._blocked = e._force = !1,
        e._step = [!1, !1],
        e.intentional = !1,
        e._movement = [0, 0],
        e._distance = [0, 0],
        e._direction = [0, 0],
        e._delta = [0, 0],
        e._bounds = [[-1 / 0, 1 / 0], [-1 / 0, 1 / 0]],
        e.args = i,
        e.axis = void 0,
        e.memo = void 0,
        e.elapsedTime = e.timeDelta = 0,
        e.direction = [0, 0],
        e.distance = [0, 0],
        e.overflow = [0, 0],
        e._movementBound = [!1, !1],
        e.velocity = [0, 0],
        e.movement = [0, 0],
        e.delta = [0, 0],
        e.timeStamp = 0
    }
    start(e) {
        const t = this.state
          , n = this.config;
        t._active || (this.reset(),
        this.computeInitial(),
        t._active = !0,
        t.target = e.target,
        t.currentTarget = e.currentTarget,
        t.lastOffset = n.from ? nf(n.from, t) : t.offset,
        t.offset = t.lastOffset,
        t.startTime = t.timeStamp = e.timeStamp)
    }
    computeValues(e) {
        const t = this.state;
        t._values = e,
        t.values = this.config.transform(e)
    }
    computeInitial() {
        const e = this.state;
        e._initial = e._values,
        e.initial = e.values
    }
    compute(e) {
        const {state: t, config: n, shared: i} = this;
        t.args = this.args;
        let s = 0;
        if (e && (t.event = e,
        n.preventDefault && e.cancelable && t.event.preventDefault(),
        t.type = e.type,
        i.touches = this.ctrl.pointerIds.size || this.ctrl.touchIds.size,
        i.locked = !!document.pointerLockElement,
        Object.assign(i, MB(e)),
        i.down = i.pressed = i.buttons % 2 === 1 || i.touches > 0,
        s = e.timeStamp - t.timeStamp,
        t.timeStamp = e.timeStamp,
        t.elapsedTime = t.timeStamp - t.startTime),
        t._active) {
            const P = t._delta.map(Math.abs);
            tn.addTo(t._distance, P)
        }
        this.axisIntent && this.axisIntent(e);
        const [o,a] = t._movement
          , [c,h] = n.threshold
          , {_step: d, values: l} = t;
        if (n.hasCustomTransform ? (d[0] === !1 && (d[0] = Math.abs(o) >= c && l[0]),
        d[1] === !1 && (d[1] = Math.abs(a) >= h && l[1])) : (d[0] === !1 && (d[0] = Math.abs(o) >= c && Math.sign(o) * c),
        d[1] === !1 && (d[1] = Math.abs(a) >= h && Math.sign(a) * h)),
        t.intentional = d[0] !== !1 || d[1] !== !1,
        !t.intentional)
            return;
        const f = [0, 0];
        if (n.hasCustomTransform) {
            const [P,R] = l;
            f[0] = d[0] !== !1 ? P - d[0] : 0,
            f[1] = d[1] !== !1 ? R - d[1] : 0
        } else
            f[0] = d[0] !== !1 ? o - d[0] : 0,
            f[1] = d[1] !== !1 ? a - d[1] : 0;
        this.restrictToAxis && !t._blocked && this.restrictToAxis(f);
        const p = t.offset
          , g = t._active && !t._blocked || t.active;
        g && (t.first = t._active && !t.active,
        t.last = !t._active && t.active,
        t.active = i[this.ingKey] = t._active,
        e && (t.first && ("bounds"in n && (t._bounds = nf(n.bounds, t)),
        this.setup && this.setup()),
        t.movement = f,
        this.computeOffset()));
        const [y,v] = t.offset
          , [[_,b],[T,S]] = t._bounds;
        t.overflow = [y < _ ? -1 : y > b ? 1 : 0, v < T ? -1 : v > S ? 1 : 0],
        t._movementBound[0] = t.overflow[0] ? t._movementBound[0] === !1 ? t._movement[0] : t._movementBound[0] : !1,
        t._movementBound[1] = t.overflow[1] ? t._movementBound[1] === !1 ? t._movement[1] : t._movementBound[1] : !1;
        const E = t._active ? n.rubberband || [0, 0] : [0, 0];
        if (t.offset = hB(t._bounds, t.offset, E),
        t.delta = tn.sub(t.offset, p),
        this.computeMovement(),
        g && (!t.last || s > AB)) {
            t.delta = tn.sub(t.offset, p);
            const P = t.delta.map(Math.abs);
            tn.addTo(t.distance, P),
            t.direction = t.delta.map(Math.sign),
            t._direction = t._delta.map(Math.sign),
            !t.first && s > 0 && (t.velocity = [P[0] / s, P[1] / s],
            t.timeDelta = s)
        }
    }
    emit() {
        const e = this.state
          , t = this.shared
          , n = this.config;
        if (e._active || this.clean(),
        (e._blocked || !e.intentional) && !e._force && !n.triggerAllEvents)
            return;
        const i = this.handler(un(un(un({}, t), e), {}, {
            [this.aliasKey]: e.values
        }));
        i !== void 0 && (e.memo = i)
    }
    clean() {
        this.eventStore.clean(),
        this.timeoutStore.clean()
    }
}
function PB([r,e], t) {
    const n = Math.abs(r)
      , i = Math.abs(e);
    if (n > i && n > t)
        return "x";
    if (i > n && i > t)
        return "y"
}
class zc extends oS {
    constructor(...e) {
        super(...e),
        Sn(this, "aliasKey", "xy")
    }
    reset() {
        super.reset(),
        this.state.axis = void 0
    }
    init() {
        this.state.offset = [0, 0],
        this.state.lastOffset = [0, 0]
    }
    computeOffset() {
        this.state.offset = tn.add(this.state.lastOffset, this.state.movement)
    }
    computeMovement() {
        this.state.movement = tn.sub(this.state.offset, this.state.lastOffset)
    }
    axisIntent(e) {
        const t = this.state
          , n = this.config;
        if (!t.axis && e) {
            const i = typeof n.axisThreshold == "object" ? n.axisThreshold[iS(e)] : n.axisThreshold;
            t.axis = PB(t._movement, i)
        }
        t._blocked = (n.lockDirection || !!n.axis) && !t.axis || !!n.axis && n.axis !== t.axis
    }
    restrictToAxis(e) {
        if (this.config.axis || this.config.lockDirection)
            switch (this.state.axis) {
            case "x":
                e[1] = 0;
                break;
            case "y":
                e[0] = 0;
                break
            }
    }
}
const RB = r=>r
  , Ox = .15
  , aS = {
    enabled(r=!0) {
        return r
    },
    eventOptions(r, e, t) {
        return un(un({}, t.shared.eventOptions), r)
    },
    preventDefault(r=!1) {
        return r
    },
    triggerAllEvents(r=!1) {
        return r
    },
    rubberband(r=0) {
        switch (r) {
        case !0:
            return [Ox, Ox];
        case !1:
            return [0, 0];
        default:
            return tn.toVector(r)
        }
    },
    from(r) {
        if (typeof r == "function")
            return r;
        if (r != null)
            return tn.toVector(r)
    },
    transform(r, e, t) {
        const n = r || t.shared.transform;
        return this.hasCustomTransform = !!n,
        n || RB
    },
    threshold(r) {
        return tn.toVector(r, 0)
    }
}
  , CB = 0
  , zo = un(un({}, aS), {}, {
    axis(r, e, {axis: t}) {
        if (this.lockDirection = t === "lock",
        !this.lockDirection)
            return t
    },
    axisThreshold(r=CB) {
        return r
    },
    bounds(r={}) {
        if (typeof r == "function")
            return s=>zo.bounds(r(s));
        if ("current"in r)
            return ()=>r.current;
        if (typeof HTMLElement == "function" && r instanceof HTMLElement)
            return r;
        const {left: e=-1 / 0, right: t=1 / 0, top: n=-1 / 0, bottom: i=1 / 0} = r;
        return [[e, t], [n, i]]
    }
})
  , Ux = {
    ArrowRight: (r,e=1)=>[r * e, 0],
    ArrowLeft: (r,e=1)=>[-1 * r * e, 0],
    ArrowUp: (r,e=1)=>[0, -1 * r * e],
    ArrowDown: (r,e=1)=>[0, r * e]
};
class IB extends zc {
    constructor(...e) {
        super(...e),
        Sn(this, "ingKey", "dragging")
    }
    reset() {
        super.reset();
        const e = this.state;
        e._pointerId = void 0,
        e._pointerActive = !1,
        e._keyboardActive = !1,
        e._preventScroll = !1,
        e._delayed = !1,
        e.swipe = [0, 0],
        e.tap = !1,
        e.canceled = !1,
        e.cancel = this.cancel.bind(this)
    }
    setup() {
        const e = this.state;
        if (e._bounds instanceof HTMLElement) {
            const t = e._bounds.getBoundingClientRect()
              , n = e.currentTarget.getBoundingClientRect()
              , i = {
                left: t.left - n.left + e.offset[0],
                right: t.right - n.right + e.offset[0],
                top: t.top - n.top + e.offset[1],
                bottom: t.bottom - n.bottom + e.offset[1]
            };
            e._bounds = zo.bounds(i)
        }
    }
    cancel() {
        const e = this.state;
        e.canceled || (e.canceled = !0,
        e._active = !1,
        setTimeout(()=>{
            this.compute(),
            this.emit()
        }
        , 0))
    }
    setActive() {
        this.state._active = this.state._pointerActive || this.state._keyboardActive
    }
    clean() {
        this.pointerClean(),
        this.state._pointerActive = !1,
        this.state._keyboardActive = !1,
        super.clean()
    }
    pointerDown(e) {
        const t = this.config
          , n = this.state;
        if (e.buttons != null && (Array.isArray(t.pointerButtons) ? !t.pointerButtons.includes(e.buttons) : t.pointerButtons !== -1 && t.pointerButtons !== e.buttons))
            return;
        const i = this.ctrl.setEventIds(e);
        t.pointerCapture && e.target.setPointerCapture(e.pointerId),
        !(i && i.size > 1 && n._pointerActive) && (this.start(e),
        this.setupPointer(e),
        n._pointerId = nm(e),
        n._pointerActive = !0,
        this.computeValues(dl(e)),
        this.computeInitial(),
        t.preventScrollAxis && iS(e) !== "mouse" ? (n._active = !1,
        this.setupScrollPrevention(e)) : t.delay > 0 ? (this.setupDelayTrigger(e),
        t.triggerAllEvents && (this.compute(e),
        this.emit())) : this.startPointerDrag(e))
    }
    startPointerDrag(e) {
        const t = this.state;
        t._active = !0,
        t._preventScroll = !0,
        t._delayed = !1,
        this.compute(e),
        this.emit()
    }
    pointerMove(e) {
        const t = this.state
          , n = this.config;
        if (!t._pointerActive)
            return;
        const i = nm(e);
        if (t._pointerId !== void 0 && i !== t._pointerId)
            return;
        const s = dl(e);
        if (document.pointerLockElement === e.target ? t._delta = [e.movementX, e.movementY] : (t._delta = tn.sub(s, t._values),
        this.computeValues(s)),
        tn.addTo(t._movement, t._delta),
        this.compute(e),
        t._delayed && t.intentional) {
            this.timeoutStore.remove("dragDelay"),
            t.active = !1,
            this.startPointerDrag(e);
            return
        }
        if (n.preventScrollAxis && !t._preventScroll)
            if (t.axis)
                if (t.axis === n.preventScrollAxis || n.preventScrollAxis === "xy") {
                    t._active = !1,
                    this.clean();
                    return
                } else {
                    this.timeoutStore.remove("startPointerDrag"),
                    this.startPointerDrag(e);
                    return
                }
            else
                return;
        this.emit()
    }
    pointerUp(e) {
        this.ctrl.setEventIds(e);
        try {
            this.config.pointerCapture && e.target.hasPointerCapture(e.pointerId) && e.target.releasePointerCapture(e.pointerId)
        } catch {}
        const t = this.state
          , n = this.config;
        if (!t._active || !t._pointerActive)
            return;
        const i = nm(e);
        if (t._pointerId !== void 0 && i !== t._pointerId)
            return;
        this.state._pointerActive = !1,
        this.setActive(),
        this.compute(e);
        const [s,o] = t._distance;
        if (t.tap = s <= n.tapsThreshold && o <= n.tapsThreshold,
        t.tap && n.filterTaps)
            t._force = !0;
        else {
            const [a,c] = t._delta
              , [h,d] = t._movement
              , [l,f] = n.swipe.velocity
              , [p,g] = n.swipe.distance
              , y = n.swipe.duration;
            if (t.elapsedTime < y) {
                const v = Math.abs(a / t.timeDelta)
                  , _ = Math.abs(c / t.timeDelta);
                v > l && Math.abs(h) > p && (t.swipe[0] = Math.sign(a)),
                _ > f && Math.abs(d) > g && (t.swipe[1] = Math.sign(c))
            }
        }
        this.emit()
    }
    pointerClick(e) {
        !this.state.tap && e.detail > 0 && (e.preventDefault(),
        e.stopPropagation())
    }
    setupPointer(e) {
        const t = this.config
          , n = t.device;
        t.pointerLock && e.currentTarget.requestPointerLock(),
        t.pointerCapture || (this.eventStore.add(this.sharedConfig.window, n, "change", this.pointerMove.bind(this)),
        this.eventStore.add(this.sharedConfig.window, n, "end", this.pointerUp.bind(this)),
        this.eventStore.add(this.sharedConfig.window, n, "cancel", this.pointerUp.bind(this)))
    }
    pointerClean() {
        this.config.pointerLock && document.pointerLockElement === this.state.currentTarget && document.exitPointerLock()
    }
    preventScroll(e) {
        this.state._preventScroll && e.cancelable && e.preventDefault()
    }
    setupScrollPrevention(e) {
        this.state._preventScroll = !1,
        LB(e);
        const t = this.eventStore.add(this.sharedConfig.window, "touch", "change", this.preventScroll.bind(this), {
            passive: !1
        });
        this.eventStore.add(this.sharedConfig.window, "touch", "end", t),
        this.eventStore.add(this.sharedConfig.window, "touch", "cancel", t),
        this.timeoutStore.add("startPointerDrag", this.startPointerDrag.bind(this), this.config.preventScrollDelay, e)
    }
    setupDelayTrigger(e) {
        this.state._delayed = !0,
        this.timeoutStore.add("dragDelay", ()=>{
            this.state._step = [0, 0],
            this.startPointerDrag(e)
        }
        , this.config.delay)
    }
    keyDown(e) {
        const t = Ux[e.key];
        if (t) {
            const n = this.state
              , i = e.shiftKey ? 10 : e.altKey ? .1 : 1;
            this.start(e),
            n._delta = t(this.config.keyboardDisplacement, i),
            n._keyboardActive = !0,
            tn.addTo(n._movement, n._delta),
            this.compute(e),
            this.emit()
        }
    }
    keyUp(e) {
        e.key in Ux && (this.state._keyboardActive = !1,
        this.setActive(),
        this.compute(e),
        this.emit())
    }
    bind(e) {
        const t = this.config.device;
        e(t, "start", this.pointerDown.bind(this)),
        this.config.pointerCapture && (e(t, "change", this.pointerMove.bind(this)),
        e(t, "end", this.pointerUp.bind(this)),
        e(t, "cancel", this.pointerUp.bind(this)),
        e("lostPointerCapture", "", this.pointerUp.bind(this))),
        this.config.keys && (e("key", "down", this.keyDown.bind(this)),
        e("key", "up", this.keyUp.bind(this))),
        this.config.filterTaps && e("click", "", this.pointerClick.bind(this), {
            capture: !0,
            passive: !1
        })
    }
}
function LB(r) {
    "persist"in r && typeof r.persist == "function" && r.persist()
}
const Hc = typeof window < "u" && window.document && window.document.createElement;
function lS() {
    return Hc && "ontouchstart"in window
}
function DB() {
    return lS() || Hc && window.navigator.maxTouchPoints > 1
}
function OB() {
    return Hc && "onpointerdown"in window
}
function UB() {
    return Hc && "exitPointerLock"in window.document
}
function NB() {
    try {
        return "constructor"in GestureEvent
    } catch {
        return !1
    }
}
const Yi = {
    isBrowser: Hc,
    gesture: NB(),
    touch: lS(),
    touchscreen: DB(),
    pointer: OB(),
    pointerLock: UB()
}
  , FB = 250
  , BB = 180
  , kB = .5
  , zB = 50
  , HB = 250
  , VB = 10
  , Nx = {
    mouse: 0,
    touch: 0,
    pen: 8
}
  , GB = un(un({}, zo), {}, {
    device(r, e, {pointer: {touch: t=!1, lock: n=!1, mouse: i=!1}={}}) {
        return this.pointerLock = n && Yi.pointerLock,
        Yi.touch && t ? "touch" : this.pointerLock ? "mouse" : Yi.pointer && !i ? "pointer" : Yi.touch ? "touch" : "mouse"
    },
    preventScrollAxis(r, e, {preventScroll: t}) {
        if (this.preventScrollDelay = typeof t == "number" ? t : t || t === void 0 && r ? FB : void 0,
        !(!Yi.touchscreen || t === !1))
            return r || (t !== void 0 ? "y" : void 0)
    },
    pointerCapture(r, e, {pointer: {capture: t=!0, buttons: n=1, keys: i=!0}={}}) {
        return this.pointerButtons = n,
        this.keys = i,
        !this.pointerLock && this.device === "pointer" && t
    },
    threshold(r, e, {filterTaps: t=!1, tapsThreshold: n=3, axis: i=void 0}) {
        const s = tn.toVector(r, t ? n : i ? 1 : 0);
        return this.filterTaps = t,
        this.tapsThreshold = n,
        s
    },
    swipe({velocity: r=kB, distance: e=zB, duration: t=HB}={}) {
        return {
            velocity: this.transform(tn.toVector(r)),
            distance: this.transform(tn.toVector(e)),
            duration: t
        }
    },
    delay(r=0) {
        switch (r) {
        case !0:
            return BB;
        case !1:
            return 0;
        default:
            return r
        }
    },
    axisThreshold(r) {
        return r ? un(un({}, Nx), r) : Nx
    },
    keyboardDisplacement(r=VB) {
        return r
    }
});
function cS(r) {
    const [e,t] = r.overflow
      , [n,i] = r._delta
      , [s,o] = r._direction;
    (e < 0 && n > 0 && s < 0 || e > 0 && n < 0 && s > 0) && (r._movement[0] = r._movementBound[0]),
    (t < 0 && i > 0 && o < 0 || t > 0 && i < 0 && o > 0) && (r._movement[1] = r._movementBound[1])
}
const WB = 30
  , jB = 100;
class XB extends oS {
    constructor(...e) {
        super(...e),
        Sn(this, "ingKey", "pinching"),
        Sn(this, "aliasKey", "da")
    }
    init() {
        this.state.offset = [1, 0],
        this.state.lastOffset = [1, 0],
        this.state._pointerEvents = new Map
    }
    reset() {
        super.reset();
        const e = this.state;
        e._touchIds = [],
        e.canceled = !1,
        e.cancel = this.cancel.bind(this),
        e.turns = 0
    }
    computeOffset() {
        const {type: e, movement: t, lastOffset: n} = this.state;
        e === "wheel" ? this.state.offset = tn.add(t, n) : this.state.offset = [(1 + t[0]) * n[0], t[1] + n[1]]
    }
    computeMovement() {
        const {offset: e, lastOffset: t} = this.state;
        this.state.movement = [e[0] / t[0], e[1] - t[1]]
    }
    axisIntent() {
        const e = this.state
          , [t,n] = e._movement;
        if (!e.axis) {
            const i = Math.abs(t) * WB - Math.abs(n);
            i < 0 ? e.axis = "angle" : i > 0 && (e.axis = "scale")
        }
    }
    restrictToAxis(e) {
        this.config.lockDirection && (this.state.axis === "scale" ? e[1] = 0 : this.state.axis === "angle" && (e[0] = 0))
    }
    cancel() {
        const e = this.state;
        e.canceled || setTimeout(()=>{
            e.canceled = !0,
            e._active = !1,
            this.compute(),
            this.emit()
        }
        , 0)
    }
    touchStart(e) {
        this.ctrl.setEventIds(e);
        const t = this.state
          , n = this.ctrl.touchIds;
        if (t._active && t._touchIds.every(s=>n.has(s)) || n.size < 2)
            return;
        this.start(e),
        t._touchIds = Array.from(n).slice(0, 2);
        const i = Cx(e, t._touchIds);
        i && this.pinchStart(e, i)
    }
    pointerStart(e) {
        if (e.buttons != null && e.buttons % 2 !== 1)
            return;
        this.ctrl.setEventIds(e),
        e.target.setPointerCapture(e.pointerId);
        const t = this.state
          , n = t._pointerEvents
          , i = this.ctrl.pointerIds;
        if (t._active && Array.from(n.keys()).every(o=>i.has(o)) || (n.size < 2 && n.set(e.pointerId, e),
        t._pointerEvents.size < 2))
            return;
        this.start(e);
        const s = n_(...Array.from(n.values()));
        s && this.pinchStart(e, s)
    }
    pinchStart(e, t) {
        const n = this.state;
        n.origin = t.origin,
        this.computeValues([t.distance, t.angle]),
        this.computeInitial(),
        this.compute(e),
        this.emit()
    }
    touchMove(e) {
        if (!this.state._active)
            return;
        const t = Cx(e, this.state._touchIds);
        t && this.pinchMove(e, t)
    }
    pointerMove(e) {
        const t = this.state._pointerEvents;
        if (t.has(e.pointerId) && t.set(e.pointerId, e),
        !this.state._active)
            return;
        const n = n_(...Array.from(t.values()));
        n && this.pinchMove(e, n)
    }
    pinchMove(e, t) {
        const n = this.state
          , i = n._values[1]
          , s = t.angle - i;
        let o = 0;
        Math.abs(s) > 270 && (o += Math.sign(s)),
        this.computeValues([t.distance, t.angle - 360 * o]),
        n.origin = t.origin,
        n.turns = o,
        n._movement = [n._values[0] / n._initial[0] - 1, n._values[1] - n._initial[1]],
        this.compute(e),
        this.emit()
    }
    touchEnd(e) {
        this.ctrl.setEventIds(e),
        this.state._active && this.state._touchIds.some(t=>!this.ctrl.touchIds.has(t)) && (this.state._active = !1,
        this.compute(e),
        this.emit())
    }
    pointerEnd(e) {
        const t = this.state;
        this.ctrl.setEventIds(e);
        try {
            e.target.releasePointerCapture(e.pointerId)
        } catch {}
        t._pointerEvents.has(e.pointerId) && t._pointerEvents.delete(e.pointerId),
        t._active && t._pointerEvents.size < 2 && (t._active = !1,
        this.compute(e),
        this.emit())
    }
    gestureStart(e) {
        e.cancelable && e.preventDefault();
        const t = this.state;
        t._active || (this.start(e),
        this.computeValues([e.scale, e.rotation]),
        t.origin = [e.clientX, e.clientY],
        this.compute(e),
        this.emit())
    }
    gestureMove(e) {
        if (e.cancelable && e.preventDefault(),
        !this.state._active)
            return;
        const t = this.state;
        this.computeValues([e.scale, e.rotation]),
        t.origin = [e.clientX, e.clientY];
        const n = t._movement;
        t._movement = [e.scale - 1, e.rotation],
        t._delta = tn.sub(t._movement, n),
        this.compute(e),
        this.emit()
    }
    gestureEnd(e) {
        this.state._active && (this.state._active = !1,
        this.compute(e),
        this.emit())
    }
    wheel(e) {
        const t = this.config.modifierKey;
        t && (Array.isArray(t) ? !t.find(n=>e[n]) : !e[t]) || (this.state._active ? this.wheelChange(e) : this.wheelStart(e),
        this.timeoutStore.add("wheelEnd", this.wheelEnd.bind(this)))
    }
    wheelStart(e) {
        this.start(e),
        this.wheelChange(e)
    }
    wheelChange(e) {
        "uv"in e || e.cancelable && e.preventDefault();
        const n = this.state;
        n._delta = [-sS(e)[1] / jB * n.offset[0], 0],
        tn.addTo(n._movement, n._delta),
        cS(n),
        this.state.origin = [e.clientX, e.clientY],
        this.compute(e),
        this.emit()
    }
    wheelEnd() {
        this.state._active && (this.state._active = !1,
        this.compute(),
        this.emit())
    }
    bind(e) {
        const t = this.config.device;
        t && (e(t, "start", this[t + "Start"].bind(this)),
        e(t, "change", this[t + "Move"].bind(this)),
        e(t, "end", this[t + "End"].bind(this)),
        e(t, "cancel", this[t + "End"].bind(this)),
        e("lostPointerCapture", "", this[t + "End"].bind(this))),
        this.config.pinchOnWheel && e("wheel", "", this.wheel.bind(this), {
            passive: !1
        })
    }
}
const qB = un(un({}, aS), {}, {
    device(r, e, {shared: t, pointer: {touch: n=!1}={}}) {
        if (t.target && !Yi.touch && Yi.gesture)
            return "gesture";
        if (Yi.touch && n)
            return "touch";
        if (Yi.touchscreen) {
            if (Yi.pointer)
                return "pointer";
            if (Yi.touch)
                return "touch"
        }
    },
    bounds(r, e, {scaleBounds: t={}, angleBounds: n={}}) {
        const i = o=>{
            const a = Dx(nf(t, o), {
                min: -1 / 0,
                max: 1 / 0
            });
            return [a.min, a.max]
        }
          , s = o=>{
            const a = Dx(nf(n, o), {
                min: -1 / 0,
                max: 1 / 0
            });
            return [a.min, a.max]
        }
        ;
        return typeof t != "function" && typeof n != "function" ? [i(), s()] : o=>[i(o), s(o)]
    },
    threshold(r, e, t) {
        return this.lockDirection = t.axis === "lock",
        tn.toVector(r, this.lockDirection ? [.1, 3] : 0)
    },
    modifierKey(r) {
        return r === void 0 ? "ctrlKey" : r
    },
    pinchOnWheel(r=!0) {
        return r
    }
});
class KB extends zc {
    constructor(...e) {
        super(...e),
        Sn(this, "ingKey", "moving")
    }
    move(e) {
        this.config.mouseOnly && e.pointerType !== "mouse" || (this.state._active ? this.moveChange(e) : this.moveStart(e),
        this.timeoutStore.add("moveEnd", this.moveEnd.bind(this)))
    }
    moveStart(e) {
        this.start(e),
        this.computeValues(dl(e)),
        this.compute(e),
        this.computeInitial(),
        this.emit()
    }
    moveChange(e) {
        if (!this.state._active)
            return;
        const t = dl(e)
          , n = this.state;
        n._delta = tn.sub(t, n._values),
        tn.addTo(n._movement, n._delta),
        this.computeValues(t),
        this.compute(e),
        this.emit()
    }
    moveEnd(e) {
        this.state._active && (this.state._active = !1,
        this.compute(e),
        this.emit())
    }
    bind(e) {
        e("pointer", "change", this.move.bind(this)),
        e("pointer", "leave", this.moveEnd.bind(this))
    }
}
const YB = un(un({}, zo), {}, {
    mouseOnly: (r=!0)=>r
});
class $B extends zc {
    constructor(...e) {
        super(...e),
        Sn(this, "ingKey", "scrolling")
    }
    scroll(e) {
        this.state._active || this.start(e),
        this.scrollChange(e),
        this.timeoutStore.add("scrollEnd", this.scrollEnd.bind(this))
    }
    scrollChange(e) {
        e.cancelable && e.preventDefault();
        const t = this.state
          , n = SB(e);
        t._delta = tn.sub(n, t._values),
        tn.addTo(t._movement, t._delta),
        this.computeValues(n),
        this.compute(e),
        this.emit()
    }
    scrollEnd() {
        this.state._active && (this.state._active = !1,
        this.compute(),
        this.emit())
    }
    bind(e) {
        e("scroll", "", this.scroll.bind(this))
    }
}
const ZB = zo;
class JB extends zc {
    constructor(...e) {
        super(...e),
        Sn(this, "ingKey", "wheeling")
    }
    wheel(e) {
        this.state._active || this.start(e),
        this.wheelChange(e),
        this.timeoutStore.add("wheelEnd", this.wheelEnd.bind(this))
    }
    wheelChange(e) {
        const t = this.state;
        t._delta = sS(e),
        tn.addTo(t._movement, t._delta),
        cS(t),
        this.compute(e),
        this.emit()
    }
    wheelEnd() {
        this.state._active && (this.state._active = !1,
        this.compute(),
        this.emit())
    }
    bind(e) {
        e("wheel", "", this.wheel.bind(this))
    }
}
const QB = zo;
class ek extends zc {
    constructor(...e) {
        super(...e),
        Sn(this, "ingKey", "hovering")
    }
    enter(e) {
        this.config.mouseOnly && e.pointerType !== "mouse" || (this.start(e),
        this.computeValues(dl(e)),
        this.compute(e),
        this.emit())
    }
    leave(e) {
        if (this.config.mouseOnly && e.pointerType !== "mouse")
            return;
        const t = this.state;
        if (!t._active)
            return;
        t._active = !1;
        const n = dl(e);
        t._movement = t._delta = tn.sub(n, t._values),
        this.computeValues(n),
        this.compute(e),
        t.delta = t.movement,
        this.emit()
    }
    bind(e) {
        e("pointer", "enter", this.enter.bind(this)),
        e("pointer", "leave", this.leave.bind(this))
    }
}
const tk = un(un({}, zo), {}, {
    mouseOnly: (r=!0)=>r
})
  , eg = new Map
  , i_ = new Map;
function nk(r) {
    eg.set(r.key, r.engine),
    i_.set(r.key, r.resolver)
}
const ik = {
    key: "drag",
    engine: IB,
    resolver: GB
}
  , rk = {
    key: "hover",
    engine: ek,
    resolver: tk
}
  , sk = {
    key: "move",
    engine: KB,
    resolver: YB
}
  , ok = {
    key: "pinch",
    engine: XB,
    resolver: qB
}
  , ak = {
    key: "scroll",
    engine: $B,
    resolver: ZB
}
  , lk = {
    key: "wheel",
    engine: JB,
    resolver: QB
};
function ck(r, e) {
    if (r == null)
        return {};
    var t = {}, n = Object.keys(r), i, s;
    for (s = 0; s < n.length; s++)
        i = n[s],
        !(e.indexOf(i) >= 0) && (t[i] = r[i]);
    return t
}
function uk(r, e) {
    if (r == null)
        return {};
    var t = ck(r, e), n, i;
    if (Object.getOwnPropertySymbols) {
        var s = Object.getOwnPropertySymbols(r);
        for (i = 0; i < s.length; i++)
            n = s[i],
            !(e.indexOf(n) >= 0) && Object.prototype.propertyIsEnumerable.call(r, n) && (t[n] = r[n])
    }
    return t
}
const hk = {
    target(r) {
        if (r)
            return ()=>"current"in r ? r.current : r
    },
    enabled(r=!0) {
        return r
    },
    window(r=Yi.isBrowser ? window : void 0) {
        return r
    },
    eventOptions({passive: r=!0, capture: e=!1}={}) {
        return {
            passive: r,
            capture: e
        }
    },
    transform(r) {
        return r
    }
}
  , fk = ["target", "eventOptions", "window", "enabled", "transform"];
function Nh(r={}, e) {
    const t = {};
    for (const [n,i] of Object.entries(e))
        switch (typeof i) {
        case "function":
            t[n] = i.call(t, r[n], n, r);
            break;
        case "object":
            t[n] = Nh(r[n], i);
            break;
        case "boolean":
            i && (t[n] = r[n]);
            break
        }
    return t
}
function dk(r, e, t={}) {
    const n = r
      , {target: i, eventOptions: s, window: o, enabled: a, transform: c} = n
      , h = uk(n, fk);
    if (t.shared = Nh({
        target: i,
        eventOptions: s,
        window: o,
        enabled: a,
        transform: c
    }, hk),
    e) {
        const d = i_.get(e);
        t[e] = Nh(un({
            shared: t.shared
        }, h), d)
    } else
        for (const d in h) {
            const l = i_.get(d);
            l && (t[d] = Nh(un({
                shared: t.shared
            }, h[d]), l))
        }
    return t
}
class uS {
    constructor(e, t) {
        Sn(this, "_listeners", new Set),
        this._ctrl = e,
        this._gestureKey = t
    }
    add(e, t, n, i, s) {
        const o = this._listeners
          , a = yB(t, n)
          , c = this._gestureKey ? this._ctrl.config[this._gestureKey].eventOptions : {}
          , h = un(un({}, c), s);
        e.addEventListener(a, i, h);
        const d = ()=>{
            e.removeEventListener(a, i, h),
            o.delete(d)
        }
        ;
        return o.add(d),
        d
    }
    clean() {
        this._listeners.forEach(e=>e()),
        this._listeners.clear()
    }
}
class pk {
    constructor() {
        Sn(this, "_timeouts", new Map)
    }
    add(e, t, n=140, ...i) {
        this.remove(e),
        this._timeouts.set(e, window.setTimeout(t, n, ...i))
    }
    remove(e) {
        const t = this._timeouts.get(e);
        t && window.clearTimeout(t)
    }
    clean() {
        this._timeouts.forEach(e=>void window.clearTimeout(e)),
        this._timeouts.clear()
    }
}
class mk {
    constructor(e) {
        Sn(this, "gestures", new Set),
        Sn(this, "_targetEventStore", new uS(this)),
        Sn(this, "gestureEventStores", {}),
        Sn(this, "gestureTimeoutStores", {}),
        Sn(this, "handlers", {}),
        Sn(this, "config", {}),
        Sn(this, "pointerIds", new Set),
        Sn(this, "touchIds", new Set),
        Sn(this, "state", {
            shared: {
                shiftKey: !1,
                metaKey: !1,
                ctrlKey: !1,
                altKey: !1
            }
        }),
        _k(this, e)
    }
    setEventIds(e) {
        if (xf(e))
            return this.touchIds = new Set(bB(e)),
            this.touchIds;
        if ("pointerId"in e)
            return e.type === "pointerup" || e.type === "pointercancel" ? this.pointerIds.delete(e.pointerId) : e.type === "pointerdown" && this.pointerIds.add(e.pointerId),
            this.pointerIds
    }
    applyHandlers(e, t) {
        this.handlers = e,
        this.nativeHandlers = t
    }
    applyConfig(e, t) {
        this.config = dk(e, t, this.config)
    }
    clean() {
        this._targetEventStore.clean();
        for (const e of this.gestures)
            this.gestureEventStores[e].clean(),
            this.gestureTimeoutStores[e].clean()
    }
    effect() {
        return this.config.shared.target && this.bind(),
        ()=>this._targetEventStore.clean()
    }
    bind(...e) {
        const t = this.config.shared
          , n = {};
        let i;
        if (!(t.target && (i = t.target(),
        !i))) {
            if (t.enabled) {
                for (const o of this.gestures) {
                    const a = this.config[o]
                      , c = Fx(n, a.eventOptions, !!i);
                    if (a.enabled) {
                        const h = eg.get(o);
                        new h(this,e,o).bind(c)
                    }
                }
                const s = Fx(n, t.eventOptions, !!i);
                for (const o in this.nativeHandlers)
                    s(o, "", a=>this.nativeHandlers[o](un(un({}, this.state.shared), {}, {
                        event: a,
                        args: e
                    })), void 0, !0)
            }
            for (const s in n)
                n[s] = EB(...n[s]);
            if (!i)
                return n;
            for (const s in n) {
                const {device: o, capture: a, passive: c} = vB(s);
                this._targetEventStore.add(i, o, "", n[s], {
                    capture: a,
                    passive: c
                })
            }
        }
    }
}
function La(r, e) {
    r.gestures.add(e),
    r.gestureEventStores[e] = new uS(r,e),
    r.gestureTimeoutStores[e] = new pk
}
function _k(r, e) {
    e.drag && La(r, "drag"),
    e.wheel && La(r, "wheel"),
    e.scroll && La(r, "scroll"),
    e.move && La(r, "move"),
    e.pinch && La(r, "pinch"),
    e.hover && La(r, "hover")
}
const Fx = (r,e,t)=>(n,i,s,o={},a=!1)=>{
    var c, h;
    const d = (c = o.capture) !== null && c !== void 0 ? c : e.capture
      , l = (h = o.passive) !== null && h !== void 0 ? h : e.passive;
    let f = a ? n : _B(n, i, d);
    t && l && (f += "Passive"),
    r[f] = r[f] || [],
    r[f].push(s)
}
  , gk = /^on(Drag|Wheel|Scroll|Move|Pinch|Hover)/;
function vk(r) {
    const e = {}
      , t = {}
      , n = new Set;
    for (let i in r)
        gk.test(i) ? (n.add(RegExp.lastMatch),
        t[i] = r[i]) : e[i] = r[i];
    return [t, e, n]
}
function Da(r, e, t, n, i, s) {
    if (!r.has(t) || !eg.has(n))
        return;
    const o = t + "Start"
      , a = t + "End"
      , c = h=>{
        let d;
        return h.first && o in e && e[o](h),
        t in e && (d = e[t](h)),
        h.last && a in e && e[a](h),
        d
    }
    ;
    i[n] = c,
    s[n] = s[n] || {}
}
function yk(r, e) {
    const [t,n,i] = vk(r)
      , s = {};
    return Da(i, t, "onDrag", "drag", s, e),
    Da(i, t, "onWheel", "wheel", s, e),
    Da(i, t, "onScroll", "scroll", s, e),
    Da(i, t, "onPinch", "pinch", s, e),
    Da(i, t, "onMove", "move", s, e),
    Da(i, t, "onHover", "hover", s, e),
    {
        handlers: s,
        config: e,
        nativeHandlers: n
    }
}
function xk(r, e) {
    if (typeof r != "object" || r === null)
        return r;
    var t = r[Symbol.toPrimitive];
    if (t !== void 0) {
        var n = t.call(r, e || "default");
        if (typeof n != "object")
            return n;
        throw new TypeError("@@toPrimitive must return a primitive value.")
    }
    return (e === "string" ? String : Number)(r)
}
function Tk(r) {
    var e = xk(r, "string");
    return typeof e == "symbol" ? e : String(e)
}
function bk(r, e, t) {
    return e = Tk(e),
    e in r ? Object.defineProperty(r, e, {
        value: t,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : r[e] = t,
    r
}
function Bx(r, e) {
    var t = Object.keys(r);
    if (Object.getOwnPropertySymbols) {
        var n = Object.getOwnPropertySymbols(r);
        e && (n = n.filter(function(i) {
            return Object.getOwnPropertyDescriptor(r, i).enumerable
        })),
        t.push.apply(t, n)
    }
    return t
}
function Mh(r) {
    for (var e = 1; e < arguments.length; e++) {
        var t = arguments[e] != null ? arguments[e] : {};
        e % 2 ? Bx(Object(t), !0).forEach(function(n) {
            bk(r, n, t[n])
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(r, Object.getOwnPropertyDescriptors(t)) : Bx(Object(t)).forEach(function(n) {
            Object.defineProperty(r, n, Object.getOwnPropertyDescriptor(t, n))
        })
    }
    return r
}
class Sk {
    constructor(e, t, n, i, s) {
        this._target = e,
        this._gestureKey = i,
        this._ctrl = new mk(t),
        this._ctrl.applyHandlers(t, s),
        this._ctrl.applyConfig(Mh(Mh({}, n), {}, {
            target: e
        }), i),
        this._ctrl.effect()
    }
    destroy() {
        this._ctrl.clean()
    }
    setConfig(e) {
        this._ctrl.clean(),
        this._ctrl.applyConfig(Mh(Mh({}, e), {}, {
            target: this._target
        }), this._gestureKey),
        this._ctrl.effect()
    }
}
function Mk(r) {
    return r.forEach(nk),
    function(e, t, n) {
        const {handlers: i, nativeHandlers: s, config: o} = yk(t, n || {});
        return new Sk(e,i,o,void 0,s)
    }
}
const wk = function(e, t, n) {
    return Mk([ik, ok, ak, lk, sk, rk])(e, t, n || {})
};
var ci = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function PV(r) {
    return r && r.__esModule && Object.prototype.hasOwnProperty.call(r, "default") ? r.default : r
}
var rf = {
    exports: {}
}
  , bn = {};
(function(r) {
    var e = Object.defineProperty
      , t = Object.defineProperties
      , n = Object.getOwnPropertyDescriptors
      , i = Object.getOwnPropertySymbols
      , s = Object.prototype.hasOwnProperty
      , o = Object.prototype.propertyIsEnumerable
      , a = (A,N,W)=>N in A ? e(A, N, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: W
    }) : A[N] = W
      , c = (A,N)=>{
        for (var W in N || (N = {}))
            s.call(N, W) && a(A, W, N[W]);
        if (i)
            for (var W of i(N))
                o.call(N, W) && a(A, W, N[W]);
        return A
    }
      , h = (A,N)=>t(A, n(N))
      , d = A=>e(A, "__esModule", {
        value: !0
    })
      , l = (A,N)=>{
        d(A);
        for (var W in N)
            e(A, W, {
                get: N[W],
                enumerable: !0
            })
    }
    ;
    l(r, {
        Atom: ()=>fu,
        PointerProxy: ()=>cd,
        Ticker: ()=>pu,
        getPointerParts: ()=>Ks,
        isPointer: ()=>kr,
        isPrism: ()=>Ko,
        iterateAndCountTicks: ()=>od,
        iterateOver: ()=>ld,
        pointer: ()=>Cl,
        pointerToPrism: ()=>$o,
        prism: ()=>Js,
        val: ()=>Nl
    });
    var f = Array.isArray
      , p = f
      , g = typeof ci == "object" && ci && ci.Object === Object && ci
      , y = g
      , v = typeof self == "object" && self && self.Object === Object && self
      , _ = y || v || Function("return this")()
      , b = _
      , T = b.Symbol
      , S = T
      , E = Object.prototype
      , P = E.hasOwnProperty
      , R = E.toString
      , O = S ? S.toStringTag : void 0;
    function w(A) {
        var N = P.call(A, O)
          , W = A[O];
        try {
            A[O] = void 0;
            var re = !0
        } catch {}
        var $e = R.call(A);
        return re && (N ? A[O] = W : delete A[O]),
        $e
    }
    var I = w
      , V = Object.prototype
      , z = V.toString;
    function q(A) {
        return z.call(A)
    }
    var F = q
      , j = "[object Null]"
      , K = "[object Undefined]"
      , J = S ? S.toStringTag : void 0;
    function de(A) {
        return A == null ? A === void 0 ? K : j : J && J in Object(A) ? I(A) : F(A)
    }
    var ae = de;
    function ue(A) {
        return A != null && typeof A == "object"
    }
    var ge = ue
      , Ee = "[object Symbol]";
    function oe(A) {
        return typeof A == "symbol" || ge(A) && ae(A) == Ee
    }
    var he = oe
      , xe = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/
      , Be = /^\w*$/;
    function De(A, N) {
        if (p(A))
            return !1;
        var W = typeof A;
        return W == "number" || W == "symbol" || W == "boolean" || A == null || he(A) ? !0 : Be.test(A) || !xe.test(A) || N != null && A in Object(N)
    }
    var et = De;
    function Ze(A) {
        var N = typeof A;
        return A != null && (N == "object" || N == "function")
    }
    var We = Ze
      , Je = "[object AsyncFunction]"
      , Q = "[object Function]"
      , hn = "[object GeneratorFunction]"
      , ze = "[object Proxy]";
    function at(A) {
        if (!We(A))
            return !1;
        var N = ae(A);
        return N == Q || N == hn || N == Je || N == ze
    }
    var qe = at
      , It = b["__core-js_shared__"]
      , tt = It
      , Ye = function() {
        var A = /[^.]+$/.exec(tt && tt.keys && tt.keys.IE_PROTO || "");
        return A ? "Symbol(src)_1." + A : ""
    }();
    function dt(A) {
        return !!Ye && Ye in A
    }
    var on = dt
      , Lt = Function.prototype
      , B = Lt.toString;
    function L(A) {
        if (A != null) {
            try {
                return B.call(A)
            } catch {}
            try {
                return A + ""
            } catch {}
        }
        return ""
    }
    var ee = L
      , Te = /[\\^$.*+?()[\]{}|]/g
      , pe = /^\[object .+?Constructor\]$/
      , be = Function.prototype
      , Ne = Object.prototype
      , Me = be.toString
      , Ae = Ne.hasOwnProperty
      , G = RegExp("^" + Me.call(Ae).replace(Te, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
    function _e(A) {
        if (!We(A) || on(A))
            return !1;
        var N = qe(A) ? G : pe;
        return N.test(ee(A))
    }
    var fe = _e;
    function je(A, N) {
        return A?.[N]
    }
    var Fe = je;
    function Ge(A, N) {
        var W = Fe(A, N);
        return fe(W) ? W : void 0
    }
    var Oe = Ge
      , Le = Oe(Object, "create")
      , rt = Le;
    function X() {
        this.__data__ = rt ? rt(null) : {},
        this.size = 0
    }
    var we = X;
    function me(A) {
        var N = this.has(A) && delete this.__data__[A];
        return this.size -= N ? 1 : 0,
        N
    }
    var le = me
      , Se = "__lodash_hash_undefined__"
      , He = Object.prototype
      , ut = He.hasOwnProperty;
    function Ut(A) {
        var N = this.__data__;
        if (rt) {
            var W = N[A];
            return W === Se ? void 0 : W
        }
        return ut.call(N, A) ? N[A] : void 0
    }
    var Rn = Ut
      , Et = Object.prototype
      , Cn = Et.hasOwnProperty;
    function _i(A) {
        var N = this.__data__;
        return rt ? N[A] !== void 0 : Cn.call(N, A)
    }
    var Ho = _i
      , Sl = "__lodash_hash_undefined__";
    function us(A, N) {
        var W = this.__data__;
        return this.size += this.has(A) ? 0 : 1,
        W[A] = rt && N === void 0 ? Sl : N,
        this
    }
    var Vo = us;
    function wi(A) {
        var N = -1
          , W = A == null ? 0 : A.length;
        for (this.clear(); ++N < W; ) {
            var re = A[N];
            this.set(re[0], re[1])
        }
    }
    wi.prototype.clear = we,
    wi.prototype.delete = le,
    wi.prototype.get = Rn,
    wi.prototype.has = Ho,
    wi.prototype.set = Vo;
    var Vs = wi;
    function Go() {
        this.__data__ = [],
        this.size = 0
    }
    var Ml = Go;
    function rr(A, N) {
        return A === N || A !== A && N !== N
    }
    var wl = rr;
    function U(A, N) {
        for (var W = A.length; W--; )
            if (wl(A[W][0], N))
                return W;
        return -1
    }
    var $ = U
      , ne = Array.prototype
      , ie = ne.splice;
    function te(A) {
        var N = this.__data__
          , W = $(N, A);
        if (W < 0)
            return !1;
        var re = N.length - 1;
        return W == re ? N.pop() : ie.call(N, W, 1),
        --this.size,
        !0
    }
    var Ie = te;
    function ke(A) {
        var N = this.__data__
          , W = $(N, A);
        return W < 0 ? void 0 : N[W][1]
    }
    var Xe = ke;
    function Qe(A) {
        return $(this.__data__, A) > -1
    }
    var lt = Qe;
    function st(A, N) {
        var W = this.__data__
          , re = $(W, A);
        return re < 0 ? (++this.size,
        W.push([A, N])) : W[re][1] = N,
        this
    }
    var ot = st;
    function At(A) {
        var N = -1
          , W = A == null ? 0 : A.length;
        for (this.clear(); ++N < W; ) {
            var re = A[N];
            this.set(re[0], re[1])
        }
    }
    At.prototype.clear = Ml,
    At.prototype.delete = Ie,
    At.prototype.get = Xe,
    At.prototype.has = lt,
    At.prototype.set = ot;
    var Wn = At
      , fn = Oe(b, "Map")
      , Ei = fn;
    function Bt() {
        this.size = 0,
        this.__data__ = {
            hash: new Vs,
            map: new (Ei || Wn),
            string: new Vs
        }
    }
    var nt = Bt;
    function hs(A) {
        var N = typeof A;
        return N == "string" || N == "number" || N == "symbol" || N == "boolean" ? A !== "__proto__" : A === null
    }
    var Gt = hs;
    function sr(A, N) {
        var W = A.__data__;
        return Gt(N) ? W[typeof N == "string" ? "string" : "hash"] : W.map
    }
    var Br = sr;
    function or(A) {
        var N = Br(this, A).delete(A);
        return this.size -= N ? 1 : 0,
        N
    }
    var Gs = or;
    function an(A) {
        return Br(this, A).get(A)
    }
    var ar = an;
    function Ws(A) {
        return Br(this, A).has(A)
    }
    var Yn = Ws;
    function js(A, N) {
        var W = Br(this, A)
          , re = W.size;
        return W.set(A, N),
        this.size += W.size == re ? 0 : 1,
        this
    }
    var El = js;
    function lr(A) {
        var N = -1
          , W = A == null ? 0 : A.length;
        for (this.clear(); ++N < W; ) {
            var re = A[N];
            this.set(re[0], re[1])
        }
    }
    lr.prototype.clear = nt,
    lr.prototype.delete = Gs,
    lr.prototype.get = ar,
    lr.prototype.has = Yn,
    lr.prototype.set = El;
    var Xc = lr
      , Tf = "Expected a function";
    function Al(A, N) {
        if (typeof A != "function" || N != null && typeof N != "function")
            throw new TypeError(Tf);
        var W = function() {
            var re = arguments
              , $e = N ? N.apply(this, re) : re[0]
              , St = W.cache;
            if (St.has($e))
                return St.get($e);
            var jn = A.apply(this, re);
            return W.cache = St.set($e, jn) || St,
            jn
        };
        return W.cache = new (Al.Cache || Xc),
        W
    }
    Al.Cache = Xc;
    var bf = Al
      , fs = 500;
    function Wo(A) {
        var N = bf(A, function(re) {
            return W.size === fs && W.clear(),
            re
        })
          , W = N.cache;
        return N
    }
    var Sf = Wo
      , Xs = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g
      , Mf = /\\(\\)?/g
      , wf = Sf(function(A) {
        var N = [];
        return A.charCodeAt(0) === 46 && N.push(""),
        A.replace(Xs, function(W, re, $e, St) {
            N.push($e ? St.replace(Mf, "$1") : re || W)
        }),
        N
    })
      , Ef = wf;
    function Af(A, N) {
        for (var W = -1, re = A == null ? 0 : A.length, $e = Array(re); ++W < re; )
            $e[W] = N(A[W], W, A);
        return $e
    }
    var Pf = Af
      , jo = 1 / 0
      , qc = S ? S.prototype : void 0
      , Kc = qc ? qc.toString : void 0;
    function Yc(A) {
        if (typeof A == "string")
            return A;
        if (p(A))
            return Pf(A, Yc) + "";
        if (he(A))
            return Kc ? Kc.call(A) : "";
        var N = A + "";
        return N == "0" && 1 / A == -jo ? "-0" : N
    }
    var Rf = Yc;
    function Cf(A) {
        return A == null ? "" : Rf(A)
    }
    var If = Cf;
    function Lf(A, N) {
        return p(A) ? A : et(A, N) ? [A] : Ef(If(A))
    }
    var Df = Lf
      , ds = 1 / 0;
    function Xo(A) {
        if (typeof A == "string" || he(A))
            return A;
        var N = A + "";
        return N == "0" && 1 / A == -ds ? "-0" : N
    }
    var Of = Xo;
    function Pl(A, N) {
        N = Df(N, A);
        for (var W = 0, re = N.length; A != null && W < re; )
            A = A[Of(N[W++])];
        return W && W == re ? A : void 0
    }
    var Uf = Pl;
    function Nf(A, N, W) {
        var re = A == null ? void 0 : Uf(A, N);
        return re === void 0 ? W : re
    }
    var Ff = Nf;
    function Bf(A, N) {
        return function(W) {
            return A(N(W))
        }
    }
    var kf = Bf
      , zf = kf(Object.getPrototypeOf, Object)
      , Hf = zf
      , Vf = "[object Object]"
      , Gf = Function.prototype
      , Wf = Object.prototype
      , $c = Gf.toString
      , Zc = Wf.hasOwnProperty
      , Jc = $c.call(Object);
    function Qc(A) {
        if (!ge(A) || ae(A) != Vf)
            return !1;
        var N = Hf(A);
        if (N === null)
            return !0;
        var W = Zc.call(N, "constructor") && N.constructor;
        return typeof W == "function" && W instanceof W && $c.call(W) == Jc
    }
    var eu = Qc;
    function jf(A) {
        var N = A == null ? 0 : A.length;
        return N ? A[N - 1] : void 0
    }
    var tu = jf
      , Rl = new WeakMap
      , qs = new WeakMap
      , nu = Symbol("pointerMeta")
      , Xf = {
        get(A, N) {
            if (N === nu)
                return Rl.get(A);
            let W = qs.get(A);
            W || (W = new Map,
            qs.set(A, W));
            const re = W.get(N);
            if (re !== void 0)
                return re;
            const $e = Rl.get(A)
              , St = qo({
                root: $e.root,
                path: [...$e.path, N]
            });
            return W.set(N, St),
            St
        }
    }
      , cr = A=>A[nu]
      , Ks = A=>{
        const {root: N, path: W} = cr(A);
        return {
            root: N,
            path: W
        }
    }
    ;
    function qo(A) {
        var N;
        const W = {
            root: A.root,
            path: (N = A.path) != null ? N : []
        }
          , re = {};
        return Rl.set(re, W),
        new Proxy(re,Xf)
    }
    var Cl = qo
      , kr = A=>A && !!cr(A);
    function iu(A, N, W) {
        return N.length === 0 ? W(A) : ps(A, N, W)
    }
    var ps = (A,N,W)=>{
        if (N.length === 0)
            return W(A);
        if (Array.isArray(A)) {
            let[re,...$e] = N;
            re = parseInt(String(re), 10),
            isNaN(re) && (re = 0);
            const St = A[re]
              , jn = ps(St, $e, W);
            if (St === jn)
                return A;
            const Gi = [...A];
            return Gi.splice(re, 1, jn),
            Gi
        } else if (typeof A == "object" && A !== null) {
            const [re,...$e] = N
              , St = A[re]
              , jn = ps(St, $e, W);
            return St === jn ? A : h(c({}, A), {
                [re]: jn
            })
        } else {
            const [re,...$e] = N;
            return {
                [re]: ps(void 0, $e, W)
            }
        }
    }
      , In = class {
        constructor() {
            this._head = void 0
        }
        peek() {
            return this._head && this._head.data
        }
        pop() {
            const A = this._head;
            if (A)
                return this._head = A.next,
                A.data
        }
        push(A) {
            const N = {
                next: this._head,
                data: A
            };
            this._head = N
        }
    }
    ;
    function Ko(A) {
        return !!(A && A.isPrism && A.isPrism === !0)
    }
    function Il() {
        const A = ()=>{}
          , N = new In
          , W = A;
        return {
            type: "Dataverse_discoveryMechanism",
            startIgnoringDependencies: ()=>{
                N.push(W)
            }
            ,
            stopIgnoringDependencies: ()=>{
                N.peek() !== W || N.pop()
            }
            ,
            reportResolutionStart: ms=>{
                const Qs = N.peek();
                Qs && Qs(ms),
                N.push(W)
            }
            ,
            reportResolutionEnd: ms=>{
                N.pop()
            }
            ,
            pushCollector: ms=>{
                N.push(ms)
            }
            ,
            popCollector: ms=>{
                if (N.peek() !== ms)
                    throw new Error("Popped collector is not on top of the stack");
                N.pop()
            }
        }
    }
    function qf() {
        const A = "__dataverse_discoveryMechanism_sharedStack"
          , N = typeof window < "u" ? window : typeof ci < "u" ? ci : {};
        if (N) {
            const W = N[A];
            if (W && typeof W == "object" && W.type === "Dataverse_discoveryMechanism")
                return W;
            {
                const re = Il();
                return N[A] = re,
                re
            }
        } else
            return Il()
    }
    var {startIgnoringDependencies: zr, stopIgnoringDependencies: Ys, reportResolutionEnd: Kf, reportResolutionStart: Yf, pushCollector: Ll, popCollector: $f} = qf()
      , ru = ()=>{}
      , Zf = class {
        constructor(A, N) {
            this._fn = A,
            this._prismInstance = N,
            this._didMarkDependentsAsStale = !1,
            this._isFresh = !1,
            this._cacheOfDendencyValues = new Map,
            this._dependents = new Set,
            this._dependencies = new Set,
            this._possiblyStaleDeps = new Set,
            this._scope = new su(this),
            this._lastValue = void 0,
            this._forciblySetToStale = !1,
            this._reactToDependencyGoingStale = W=>{
                this._possiblyStaleDeps.add(W),
                this._markAsStale()
            }
            ;
            for (const W of this._dependencies)
                W._addDependent(this._reactToDependencyGoingStale);
            zr(),
            this.getValue(),
            Ys()
        }
        get hasDependents() {
            return this._dependents.size > 0
        }
        removeDependent(A) {
            this._dependents.delete(A)
        }
        addDependent(A) {
            this._dependents.add(A)
        }
        destroy() {
            for (const A of this._dependencies)
                A._removeDependent(this._reactToDependencyGoingStale);
            ou(this._scope)
        }
        getValue() {
            if (!this._isFresh) {
                const A = this._recalculate();
                this._lastValue = A,
                this._isFresh = !0,
                this._didMarkDependentsAsStale = !1,
                this._forciblySetToStale = !1
            }
            return this._lastValue
        }
        _recalculate() {
            let A;
            if (!this._forciblySetToStale && this._possiblyStaleDeps.size > 0) {
                let re = !1;
                zr();
                for (const $e of this._possiblyStaleDeps)
                    if (this._cacheOfDendencyValues.get($e) !== $e.getValue()) {
                        re = !0;
                        break
                    }
                if (Ys(),
                this._possiblyStaleDeps.clear(),
                !re)
                    return this._lastValue
            }
            const N = new Set;
            this._cacheOfDendencyValues.clear();
            const W = re=>{
                N.add(re),
                this._addDependency(re)
            }
            ;
            Ll(W),
            Fn.push(this._scope);
            try {
                A = this._fn()
            } catch (re) {
                console.error(re)
            } finally {
                Fn.pop() !== this._scope && console.warn("The Prism hook stack has slipped. This is a bug.")
            }
            $f(W);
            for (const re of this._dependencies)
                N.has(re) || this._removeDependency(re);
            this._dependencies = N,
            zr();
            for (const re of N)
                this._cacheOfDendencyValues.set(re, re.getValue());
            return Ys(),
            A
        }
        forceStale() {
            this._forciblySetToStale = !0,
            this._markAsStale()
        }
        _markAsStale() {
            if (!this._didMarkDependentsAsStale) {
                this._didMarkDependentsAsStale = !0,
                this._isFresh = !1;
                for (const A of this._dependents)
                    A(this._prismInstance)
            }
        }
        _addDependency(A) {
            this._dependencies.has(A) || (this._dependencies.add(A),
            A._addDependent(this._reactToDependencyGoingStale))
        }
        _removeDependency(A) {
            this._dependencies.has(A) && (this._dependencies.delete(A),
            A._removeDependent(this._reactToDependencyGoingStale))
        }
    }
      , Dl = {}
      , Jf = class {
        constructor(A) {
            this._fn = A,
            this.isPrism = !0,
            this._state = {
                hot: !1,
                handle: void 0
            }
        }
        get isHot() {
            return this._state.hot
        }
        onChange(A, N, W=!1) {
            const re = ()=>{
                A.onThisOrNextTick(St)
            }
            ;
            let $e = Dl;
            const St = ()=>{
                const Gi = this.getValue();
                Gi !== $e && ($e = Gi,
                N(Gi))
            }
            ;
            return this._addDependent(re),
            W && ($e = this.getValue(),
            N($e)),
            ()=>{
                this._removeDependent(re),
                A.offThisOrNextTick(St),
                A.offNextTick(St)
            }
        }
        onStale(A) {
            const N = ()=>{
                this._removeDependent(W)
            }
              , W = ()=>A();
            return this._addDependent(W),
            N
        }
        keepHot() {
            return this.onStale(()=>{}
            )
        }
        _addDependent(A) {
            this._state.hot || this._goHot(),
            this._state.handle.addDependent(A)
        }
        _goHot() {
            const A = new Zf(this._fn,this);
            this._state = {
                hot: !0,
                handle: A
            }
        }
        _removeDependent(A) {
            const N = this._state;
            if (!N.hot)
                return;
            const W = N.handle;
            W.removeDependent(A),
            W.hasDependents || (this._state = {
                hot: !1,
                handle: void 0
            },
            W.destroy())
        }
        getValue() {
            Yf(this);
            const A = this._state;
            let N;
            return A.hot ? N = A.handle.getValue() : N = Zs(this._fn),
            Kf(this),
            N
        }
    }
      , su = class {
        constructor(A) {
            this._hotHandle = A,
            this._refs = new Map,
            this.isPrismScope = !0,
            this.subs = {},
            this.effects = new Map,
            this.memos = new Map
        }
        ref(A, N) {
            let W = this._refs.get(A);
            if (W !== void 0)
                return W;
            {
                const re = {
                    current: N
                };
                return this._refs.set(A, re),
                re
            }
        }
        effect(A, N, W) {
            let re = this.effects.get(A);
            re === void 0 && (re = {
                cleanup: ru,
                deps: void 0
            },
            this.effects.set(A, re)),
            au(re.deps, W) && (re.cleanup(),
            zr(),
            re.cleanup = Yo(N, ru).value,
            Ys(),
            re.deps = W)
        }
        memo(A, N, W) {
            let re = this.memos.get(A);
            return re === void 0 && (re = {
                cachedValue: null,
                deps: void 0
            },
            this.memos.set(A, re)),
            au(re.deps, W) && (zr(),
            re.cachedValue = Yo(N, void 0).value,
            Ys(),
            re.deps = W),
            re.cachedValue
        }
        state(A, N) {
            const {value: W, setValue: re} = this.memo("state/" + A, ()=>{
                const $e = {
                    current: N
                };
                return {
                    value: $e,
                    setValue: jn=>{
                        $e.current = jn,
                        this._hotHandle.forceStale()
                    }
                }
            }
            , []);
            return [W.current, re]
        }
        sub(A) {
            return this.subs[A] || (this.subs[A] = new su(this._hotHandle)),
            this.subs[A]
        }
        cleanupEffects() {
            for (const A of this.effects.values())
                Yo(A.cleanup, void 0);
            this.effects.clear()
        }
        source(A, N) {
            return this.effect("$$source/blah", ()=>A(()=>{
                this._hotHandle.forceStale()
            }
            ), [A]),
            N()
        }
    }
    ;
    function ou(A) {
        for (const N of Object.values(A.subs))
            ou(N);
        A.cleanupEffects()
    }
    function Yo(A, N) {
        try {
            return {
                value: A(),
                ok: !0
            }
        } catch (W) {
            return setTimeout(function() {
                throw W
            }),
            {
                value: N,
                ok: !1
            }
        }
    }
    var Fn = new In;
    function Qf(A, N) {
        const W = Fn.peek();
        if (!W)
            throw new Error("prism.ref() is called outside of a prism() call.");
        return W.ref(A, N)
    }
    function Ol(A, N, W) {
        const re = Fn.peek();
        if (!re)
            throw new Error("prism.effect() is called outside of a prism() call.");
        return re.effect(A, N, W)
    }
    function au(A, N) {
        if (A === void 0 || N === void 0)
            return !0;
        const W = A.length;
        if (W !== N.length)
            return !0;
        for (let re = 0; re < W; re++)
            if (A[re] !== N[re])
                return !0;
        return !1
    }
    function lu(A, N, W) {
        const re = Fn.peek();
        if (!re)
            throw new Error("prism.memo() is called outside of a prism() call.");
        return re.memo(A, N, W)
    }
    function oi(A, N) {
        const W = Fn.peek();
        if (!W)
            throw new Error("prism.state() is called outside of a prism() call.");
        return W.state(A, N)
    }
    function ed() {
        if (!Fn.peek())
            throw new Error("The parent function is called outside of a prism() call.")
    }
    function td(A, N) {
        const W = Fn.peek();
        if (!W)
            throw new Error("prism.scope() is called outside of a prism() call.");
        const re = W.sub(A);
        Fn.push(re);
        const $e = Yo(N, void 0).value;
        return Fn.pop(),
        $e
    }
    function nd(A, N, W) {
        return lu(A, ()=>Ln(N), W).getValue()
    }
    function cu() {
        return !!Fn.peek()
    }
    function id(A, N) {
        const W = Fn.peek();
        if (!W)
            throw new Error("prism.source() is called outside of a prism() call.");
        return W.source(A, N)
    }
    var Ln = A=>new Jf(A)
      , $s = class {
        effect(A, N, W) {
            console.warn("prism.effect() does not run in cold prisms")
        }
        memo(A, N, W) {
            return N()
        }
        state(A, N) {
            return [N, ()=>{}
            ]
        }
        ref(A, N) {
            return {
                current: N
            }
        }
        sub(A) {
            return new $s
        }
        source(A, N) {
            return N()
        }
    }
    ;
    function Zs(A) {
        const N = new $s;
        Fn.push(N);
        let W;
        try {
            W = A()
        } catch (re) {
            console.error(re)
        } finally {
            Fn.pop() !== N && console.warn("The Prism hook stack has slipped. This is a bug.")
        }
        return W
    }
    Ln.ref = Qf,
    Ln.effect = Ol,
    Ln.memo = lu,
    Ln.ensurePrism = ed,
    Ln.state = oi,
    Ln.scope = td,
    Ln.sub = nd,
    Ln.inPrism = cu,
    Ln.source = id;
    var Js = Ln, uu;
    (function(A) {
        A[A.Dict = 0] = "Dict",
        A[A.Array = 1] = "Array",
        A[A.Other = 2] = "Other"
    }
    )(uu || (uu = {}));
    var Dt = A=>Array.isArray(A) ? 1 : eu(A) ? 0 : 2
      , Ul = (A,N,W=Dt(A))=>W === 0 && typeof N == "string" || W === 1 && rd(N) ? A[N] : void 0
      , rd = A=>{
        const N = typeof A == "number" ? A : parseInt(A, 10);
        return !isNaN(N) && N >= 0 && N < 1 / 0 && (N | 0) === N
    }
      , hu = class {
        constructor(A, N) {
            this._parent = A,
            this._path = N,
            this.children = new Map,
            this.identityChangeListeners = new Set
        }
        addIdentityChangeListener(A) {
            this.identityChangeListeners.add(A)
        }
        removeIdentityChangeListener(A) {
            this.identityChangeListeners.delete(A),
            this._checkForGC()
        }
        removeChild(A) {
            this.children.delete(A),
            this._checkForGC()
        }
        getChild(A) {
            return this.children.get(A)
        }
        getOrCreateChild(A) {
            let N = this.children.get(A);
            return N || (N = N = new hu(this,this._path.concat([A])),
            this.children.set(A, N)),
            N
        }
        _checkForGC() {
            this.identityChangeListeners.size > 0 || this.children.size > 0 || this._parent && this._parent.removeChild(tu(this._path))
        }
    }
      , fu = class {
        constructor(A) {
            this.$$isPointerToPrismProvider = !0,
            this.pointer = Cl({
                root: this,
                path: []
            }),
            this.prism = this.pointerToPrism(this.pointer),
            this._onPointerValueChange = (N,W)=>{
                const {path: re} = Ks(N)
                  , $e = this._getOrCreateScopeForPath(re);
                return $e.identityChangeListeners.add(W),
                ()=>{
                    $e.identityChangeListeners.delete(W)
                }
            }
            ,
            this._currentState = A,
            this._rootScope = new hu(void 0,[])
        }
        set(A) {
            const N = this._currentState;
            this._currentState = A,
            this._checkUpdates(this._rootScope, N, A)
        }
        get() {
            return this._currentState
        }
        getByPointer(A) {
            const N = kr(A) ? A : A(this.pointer)
              , W = Ks(N).path;
            return this._getIn(W)
        }
        _getIn(A) {
            return A.length === 0 ? this.get() : Ff(this.get(), A)
        }
        reduce(A) {
            this.set(A(this.get()))
        }
        reduceByPointer(A, N) {
            const W = kr(A) ? A : A(this.pointer)
              , re = Ks(W).path
              , $e = iu(this.get(), re, N);
            this.set($e)
        }
        setByPointer(A, N) {
            this.reduceByPointer(A, ()=>N)
        }
        _checkUpdates(A, N, W) {
            if (N === W)
                return;
            for (const St of A.identityChangeListeners)
                St(W);
            if (A.children.size === 0)
                return;
            const re = Dt(N)
              , $e = Dt(W);
            if (!(re === 2 && re === $e))
                for (const [St,jn] of A.children) {
                    const Gi = Ul(N, St, re)
                      , mu = Ul(W, St, $e);
                    this._checkUpdates(jn, Gi, mu)
                }
        }
        _getOrCreateScopeForPath(A) {
            let N = this._rootScope;
            for (const W of A)
                N = N.getOrCreateChild(W);
            return N
        }
        pointerToPrism(A) {
            const {path: N} = Ks(A)
              , W = $e=>this._onPointerValueChange(A, $e)
              , re = ()=>this._getIn(N);
            return Js(()=>Js.source(W, re))
        }
    }
      , du = new WeakMap;
    function sd(A) {
        return typeof A == "object" && A !== null && A.$$isPointerToPrismProvider === !0
    }
    var $o = A=>{
        const N = cr(A);
        let W = du.get(N);
        if (!W) {
            const re = N.root;
            if (!sd(re))
                throw new Error("Cannot run pointerToPrism() on a pointer whose root is not an PointerToPrismProvider");
            W = re.pointerToPrism(A),
            du.set(N, W)
        }
        return W
    }
      , Nl = A=>kr(A) ? $o(A).getValue() : Ko(A) ? A.getValue() : A;
    function *od(A) {
        let N;
        if (kr(A))
            N = $o(A);
        else if (Ko(A))
            N = A;
        else
            throw new Error("Only pointers and prisms are supported");
        let W = 0;
        const re = N.onStale(()=>{
            W++
        }
        );
        try {
            for (; ; ) {
                const $e = W;
                W = 0,
                yield{
                    value: N.getValue(),
                    ticks: $e
                }
            }
        } finally {
            re()
        }
    }
    var ad = 60 * 3
      , pu = class {
        constructor(A) {
            this._conf = A,
            this._ticking = !1,
            this._dormant = !0,
            this._numberOfDormantTicks = 0,
            this.__ticks = 0,
            this._scheduledForThisOrNextTick = new Set,
            this._scheduledForNextTick = new Set,
            this._timeAtCurrentTick = 0
        }
        get dormant() {
            return this._dormant
        }
        onThisOrNextTick(A) {
            this._scheduledForThisOrNextTick.add(A),
            this._dormant && this._goActive()
        }
        onNextTick(A) {
            this._scheduledForNextTick.add(A),
            this._dormant && this._goActive()
        }
        offThisOrNextTick(A) {
            this._scheduledForThisOrNextTick.delete(A)
        }
        offNextTick(A) {
            this._scheduledForNextTick.delete(A)
        }
        get time() {
            return this._ticking ? this._timeAtCurrentTick : performance.now()
        }
        _goActive() {
            var A, N;
            this._dormant && (this._dormant = !1,
            (N = (A = this._conf) == null ? void 0 : A.onActive) == null || N.call(A))
        }
        _goDormant() {
            var A, N;
            this._dormant || (this._dormant = !0,
            this._numberOfDormantTicks = 0,
            (N = (A = this._conf) == null ? void 0 : A.onDormant) == null || N.call(A))
        }
        tick(A=performance.now()) {
            if (this.__ticks++,
            !this._dormant && this._scheduledForNextTick.size === 0 && this._scheduledForThisOrNextTick.size === 0 && (this._numberOfDormantTicks++,
            this._numberOfDormantTicks >= ad)) {
                this._goDormant();
                return
            }
            this._ticking = !0,
            this._timeAtCurrentTick = A;
            for (const N of this._scheduledForNextTick)
                this._scheduledForThisOrNextTick.add(N);
            this._scheduledForNextTick.clear(),
            this._tick(0),
            this._ticking = !1
        }
        _tick(A) {
            const N = this.time;
            if (A > 10 && console.warn("_tick() recursing for 10 times"),
            A > 100)
                throw new Error("Maximum recursion limit for _tick()");
            const W = this._scheduledForThisOrNextTick;
            this._scheduledForThisOrNextTick = new Set;
            for (const re of W)
                re(N);
            if (this._scheduledForThisOrNextTick.size > 0)
                return this._tick(A + 1)
        }
    }
    ;
    function *ld(A) {
        let N;
        if (kr(A))
            N = $o(A);
        else if (Ko(A))
            N = A;
        else
            throw new Error("Only pointers and prisms are supported");
        const W = new pu
          , re = N.onChange(W, $e=>{}
        );
        try {
            for (; ; )
                W.tick(),
                yield N.getValue()
        } finally {
            re()
        }
    }
    var cd = class {
        constructor(A) {
            this.$$isPointerToPrismProvider = !0,
            this._currentPointerBox = new fu(A),
            this.pointer = Cl({
                root: this,
                path: []
            })
        }
        setPointer(A) {
            this._currentPointerBox.set(A)
        }
        pointerToPrism(A) {
            const {path: N} = cr(A);
            return Js(()=>{
                const W = this._currentPointerBox.prism.getValue()
                  , re = N.reduce(($e,St)=>$e[St], W);
                return Nl(re)
            }
            )
        }
    }
}
)(bn);
rf.exports;
(function(r, e) {
    var t = Object.create
      , n = Object.defineProperty
      , i = Object.defineProperties
      , s = Object.getOwnPropertyDescriptor
      , o = Object.getOwnPropertyDescriptors
      , a = Object.getOwnPropertyNames
      , c = Object.getOwnPropertySymbols
      , h = Object.getPrototypeOf
      , d = Object.prototype.hasOwnProperty
      , l = Object.prototype.propertyIsEnumerable
      , f = (u,m,x)=>m in u ? n(u, m, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: x
    }) : u[m] = x
      , p = (u,m)=>{
        for (var x in m || (m = {}))
            d.call(m, x) && f(u, x, m[x]);
        if (c)
            for (var x of c(m))
                l.call(m, x) && f(u, x, m[x]);
        return u
    }
      , g = (u,m)=>i(u, o(m))
      , y = (u,m)=>function() {
        return m || (0,
        u[a(u)[0]])((m = {
            exports: {}
        }).exports, m),
        m.exports
    }
      , v = (u,m)=>{
        for (var x in m)
            n(u, x, {
                get: m[x],
                enumerable: !0
            })
    }
      , _ = (u,m,x,M)=>{
        if (m && typeof m == "object" || typeof m == "function")
            for (let C of a(m))
                !d.call(u, C) && C !== x && n(u, C, {
                    get: ()=>m[C],
                    enumerable: !(M = s(m, C)) || M.enumerable
                });
        return u
    }
      , b = (u,m,x)=>(x = u != null ? t(h(u)) : {},
    _(m || !u || !u.__esModule ? n(x, "default", {
        value: u,
        enumerable: !0
    }) : x, u))
      , T = u=>_(n({}, "__esModule", {
        value: !0
    }), u)
      , S = (u,m,x)=>(f(u, typeof m != "symbol" ? m + "" : m, x),
    x)
      , E = y({
        "../node_modules/timing-function/lib/UnitBezier.js"(u, m) {
            m.exports = function() {
                function x(M, C, D, H) {
                    this.set(M, C, D, H)
                }
                return x.prototype.set = function(M, C, D, H) {
                    this._cx = 3 * M,
                    this._bx = 3 * (D - M) - this._cx,
                    this._ax = 1 - this._cx - this._bx,
                    this._cy = 3 * C,
                    this._by = 3 * (H - C) - this._cy,
                    this._ay = 1 - this._cy - this._by
                }
                ,
                x.epsilon = 1e-6,
                x.prototype._sampleCurveX = function(M) {
                    return ((this._ax * M + this._bx) * M + this._cx) * M
                }
                ,
                x.prototype._sampleCurveY = function(M) {
                    return ((this._ay * M + this._by) * M + this._cy) * M
                }
                ,
                x.prototype._sampleCurveDerivativeX = function(M) {
                    return (3 * this._ax * M + 2 * this._bx) * M + this._cx
                }
                ,
                x.prototype._solveCurveX = function(M, C) {
                    var D, H, Y, Z, se, ve;
                    for (Y = void 0,
                    Z = void 0,
                    se = void 0,
                    ve = void 0,
                    D = void 0,
                    H = void 0,
                    se = M,
                    H = 0; H < 8; ) {
                        if (ve = this._sampleCurveX(se) - M,
                        Math.abs(ve) < C)
                            return se;
                        if (D = this._sampleCurveDerivativeX(se),
                        Math.abs(D) < C)
                            break;
                        se = se - ve / D,
                        H++
                    }
                    if (Y = 0,
                    Z = 1,
                    se = M,
                    se < Y)
                        return Y;
                    if (se > Z)
                        return Z;
                    for (; Y < Z; ) {
                        if (ve = this._sampleCurveX(se),
                        Math.abs(ve - M) < C)
                            return se;
                        M > ve ? Y = se : Z = se,
                        se = (Z - Y) * .5 + Y
                    }
                    return se
                }
                ,
                x.prototype.solve = function(M, C) {
                    return this._sampleCurveY(this._solveCurveX(M, C))
                }
                ,
                x.prototype.solveSimple = function(M) {
                    return this._sampleCurveY(this._solveCurveX(M, 1e-6))
                }
                ,
                x
            }()
        }
    })
      , P = y({
        "../node_modules/levenshtein-edit-distance/index.js"(u, m) {
            var x, M;
            x = [],
            M = [];
            function C(D, H, Y) {
                var Z, se, ve, ye, Re, Ve, Ue, ht;
                if (D === H)
                    return 0;
                if (Z = D.length,
                se = H.length,
                Z === 0)
                    return se;
                if (se === 0)
                    return Z;
                for (Y && (D = D.toLowerCase(),
                H = H.toLowerCase()),
                Ue = 0; Ue < Z; )
                    M[Ue] = D.charCodeAt(Ue),
                    x[Ue] = ++Ue;
                for (ht = 0; ht < se; )
                    for (ve = H.charCodeAt(ht),
                    ye = Re = ht++,
                    Ue = -1; ++Ue < Z; )
                        Ve = ve === M[Ue] ? Re : Re + 1,
                        Re = x[Ue],
                        x[Ue] = ye = Re > ye ? Ve > ye ? ye + 1 : Ve : Ve > Re ? Re + 1 : Ve;
                return ye
            }
            m.exports = C
        }
    })
      , R = y({
        "../node_modules/propose/propose.js"(u, m) {
            var x = P();
            function M() {
                var C, D, H, Y, Z, se = 0, ve = arguments[0], ye = arguments[1], Re = ye.length, Ve = arguments[2];
                Ve && (Y = Ve.threshold,
                Z = Ve.ignoreCase),
                Y === void 0 && (Y = 0);
                for (var Ue = 0; Ue < Re; ++Ue)
                    Z ? D = x(ve, ye[Ue], !0) : D = x(ve, ye[Ue]),
                    D > ve.length ? C = 1 - D / ye[Ue].length : C = 1 - D / ve.length,
                    C > se && (se = C,
                    H = ye[Ue]);
                return se >= Y ? H : null
            }
            m.exports = M
        }
    })
      , O = y({
        "../node_modules/fast-deep-equal/index.js"(u, m) {
            m.exports = function x(M, C) {
                if (M === C)
                    return !0;
                if (M && C && typeof M == "object" && typeof C == "object") {
                    if (M.constructor !== C.constructor)
                        return !1;
                    var D, H, Y;
                    if (Array.isArray(M)) {
                        if (D = M.length,
                        D != C.length)
                            return !1;
                        for (H = D; H-- !== 0; )
                            if (!x(M[H], C[H]))
                                return !1;
                        return !0
                    }
                    if (M.constructor === RegExp)
                        return M.source === C.source && M.flags === C.flags;
                    if (M.valueOf !== Object.prototype.valueOf)
                        return M.valueOf() === C.valueOf();
                    if (M.toString !== Object.prototype.toString)
                        return M.toString() === C.toString();
                    if (Y = Object.keys(M),
                    D = Y.length,
                    D !== Object.keys(C).length)
                        return !1;
                    for (H = D; H-- !== 0; )
                        if (!Object.prototype.hasOwnProperty.call(C, Y[H]))
                            return !1;
                    for (H = D; H-- !== 0; ) {
                        var Z = Y[H];
                        if (!x(M[Z], C[Z]))
                            return !1
                    }
                    return !0
                }
                return M !== M && C !== C
            }
        }
    })
      , w = {};
    v(w, {
        createRafDriver: ()=>Id,
        getProject: ()=>Zv,
        notify: ()=>Qo,
        onChange: ()=>ep,
        types: ()=>Ld,
        val: ()=>Jv
    }),
    r.exports = T(w);
    var I = {};
    v(I, {
        createRafDriver: ()=>Id,
        getProject: ()=>Zv,
        notify: ()=>Qo,
        onChange: ()=>ep,
        types: ()=>Ld,
        val: ()=>Jv
    });
    var V = bn
      , z = class {
        constructor() {
            S(this, "atom", new V.Atom({
                projects: {}
            }))
        }
        add(u, m) {
            this.atom.setByPointer(x=>x.projects[u], m)
        }
        get(u) {
            return this.atom.get().projects[u]
        }
        has(u) {
            return !!this.get(u)
        }
    }
      , q = new z
      , F = q
      , j = new WeakMap;
    function K(u) {
        return j.get(u)
    }
    function J(u, m) {
        j.set(u, m)
    }
    var de = []
      , ae = Array.isArray
      , ue = ae
      , ge = typeof ci == "object" && ci && ci.Object === Object && ci
      , Ee = ge
      , oe = typeof self == "object" && self && self.Object === Object && self
      , he = Ee || oe || Function("return this")()
      , xe = he
      , Be = xe.Symbol
      , De = Be
      , et = Object.prototype
      , Ze = et.hasOwnProperty
      , We = et.toString
      , Je = De ? De.toStringTag : void 0;
    function Q(u) {
        var m = Ze.call(u, Je)
          , x = u[Je];
        try {
            u[Je] = void 0;
            var M = !0
        } catch {}
        var C = We.call(u);
        return M && (m ? u[Je] = x : delete u[Je]),
        C
    }
    var hn = Q
      , ze = Object.prototype
      , at = ze.toString;
    function qe(u) {
        return at.call(u)
    }
    var It = qe
      , tt = "[object Null]"
      , Ye = "[object Undefined]"
      , dt = De ? De.toStringTag : void 0;
    function on(u) {
        return u == null ? u === void 0 ? Ye : tt : dt && dt in Object(u) ? hn(u) : It(u)
    }
    var Lt = on;
    function B(u) {
        return u != null && typeof u == "object"
    }
    var L = B
      , ee = "[object Symbol]";
    function Te(u) {
        return typeof u == "symbol" || L(u) && Lt(u) == ee
    }
    var pe = Te
      , be = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/
      , Ne = /^\w*$/;
    function Me(u, m) {
        if (ue(u))
            return !1;
        var x = typeof u;
        return x == "number" || x == "symbol" || x == "boolean" || u == null || pe(u) ? !0 : Ne.test(u) || !be.test(u) || m != null && u in Object(m)
    }
    var Ae = Me;
    function G(u) {
        var m = typeof u;
        return u != null && (m == "object" || m == "function")
    }
    var _e = G
      , fe = "[object AsyncFunction]"
      , je = "[object Function]"
      , Fe = "[object GeneratorFunction]"
      , Ge = "[object Proxy]";
    function Oe(u) {
        if (!_e(u))
            return !1;
        var m = Lt(u);
        return m == je || m == Fe || m == fe || m == Ge
    }
    var Le = Oe
      , rt = xe["__core-js_shared__"]
      , X = rt
      , we = function() {
        var u = /[^.]+$/.exec(X && X.keys && X.keys.IE_PROTO || "");
        return u ? "Symbol(src)_1." + u : ""
    }();
    function me(u) {
        return !!we && we in u
    }
    var le = me
      , Se = Function.prototype
      , He = Se.toString;
    function ut(u) {
        if (u != null) {
            try {
                return He.call(u)
            } catch {}
            try {
                return u + ""
            } catch {}
        }
        return ""
    }
    var Ut = ut
      , Rn = /[\\^$.*+?()[\]{}|]/g
      , Et = /^\[object .+?Constructor\]$/
      , Cn = Function.prototype
      , _i = Object.prototype
      , Ho = Cn.toString
      , Sl = _i.hasOwnProperty
      , us = RegExp("^" + Ho.call(Sl).replace(Rn, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
    function Vo(u) {
        if (!_e(u) || le(u))
            return !1;
        var m = Le(u) ? us : Et;
        return m.test(Ut(u))
    }
    var wi = Vo;
    function Vs(u, m) {
        return u?.[m]
    }
    var Go = Vs;
    function Ml(u, m) {
        var x = Go(u, m);
        return wi(x) ? x : void 0
    }
    var rr = Ml
      , wl = rr(Object, "create")
      , U = wl;
    function $() {
        this.__data__ = U ? U(null) : {},
        this.size = 0
    }
    var ne = $;
    function ie(u) {
        var m = this.has(u) && delete this.__data__[u];
        return this.size -= m ? 1 : 0,
        m
    }
    var te = ie
      , Ie = "__lodash_hash_undefined__"
      , ke = Object.prototype
      , Xe = ke.hasOwnProperty;
    function Qe(u) {
        var m = this.__data__;
        if (U) {
            var x = m[u];
            return x === Ie ? void 0 : x
        }
        return Xe.call(m, u) ? m[u] : void 0
    }
    var lt = Qe
      , st = Object.prototype
      , ot = st.hasOwnProperty;
    function At(u) {
        var m = this.__data__;
        return U ? m[u] !== void 0 : ot.call(m, u)
    }
    var Wn = At
      , fn = "__lodash_hash_undefined__";
    function Ei(u, m) {
        var x = this.__data__;
        return this.size += this.has(u) ? 0 : 1,
        x[u] = U && m === void 0 ? fn : m,
        this
    }
    var Bt = Ei;
    function nt(u) {
        var m = -1
          , x = u == null ? 0 : u.length;
        for (this.clear(); ++m < x; ) {
            var M = u[m];
            this.set(M[0], M[1])
        }
    }
    nt.prototype.clear = ne,
    nt.prototype.delete = te,
    nt.prototype.get = lt,
    nt.prototype.has = Wn,
    nt.prototype.set = Bt;
    var hs = nt;
    function Gt() {
        this.__data__ = [],
        this.size = 0
    }
    var sr = Gt;
    function Br(u, m) {
        return u === m || u !== u && m !== m
    }
    var or = Br;
    function Gs(u, m) {
        for (var x = u.length; x--; )
            if (or(u[x][0], m))
                return x;
        return -1
    }
    var an = Gs
      , ar = Array.prototype
      , Ws = ar.splice;
    function Yn(u) {
        var m = this.__data__
          , x = an(m, u);
        if (x < 0)
            return !1;
        var M = m.length - 1;
        return x == M ? m.pop() : Ws.call(m, x, 1),
        --this.size,
        !0
    }
    var js = Yn;
    function El(u) {
        var m = this.__data__
          , x = an(m, u);
        return x < 0 ? void 0 : m[x][1]
    }
    var lr = El;
    function Xc(u) {
        return an(this.__data__, u) > -1
    }
    var Tf = Xc;
    function Al(u, m) {
        var x = this.__data__
          , M = an(x, u);
        return M < 0 ? (++this.size,
        x.push([u, m])) : x[M][1] = m,
        this
    }
    var bf = Al;
    function fs(u) {
        var m = -1
          , x = u == null ? 0 : u.length;
        for (this.clear(); ++m < x; ) {
            var M = u[m];
            this.set(M[0], M[1])
        }
    }
    fs.prototype.clear = sr,
    fs.prototype.delete = js,
    fs.prototype.get = lr,
    fs.prototype.has = Tf,
    fs.prototype.set = bf;
    var Wo = fs
      , Sf = rr(xe, "Map")
      , Xs = Sf;
    function Mf() {
        this.size = 0,
        this.__data__ = {
            hash: new hs,
            map: new (Xs || Wo),
            string: new hs
        }
    }
    var wf = Mf;
    function Ef(u) {
        var m = typeof u;
        return m == "string" || m == "number" || m == "symbol" || m == "boolean" ? u !== "__proto__" : u === null
    }
    var Af = Ef;
    function Pf(u, m) {
        var x = u.__data__;
        return Af(m) ? x[typeof m == "string" ? "string" : "hash"] : x.map
    }
    var jo = Pf;
    function qc(u) {
        var m = jo(this, u).delete(u);
        return this.size -= m ? 1 : 0,
        m
    }
    var Kc = qc;
    function Yc(u) {
        return jo(this, u).get(u)
    }
    var Rf = Yc;
    function Cf(u) {
        return jo(this, u).has(u)
    }
    var If = Cf;
    function Lf(u, m) {
        var x = jo(this, u)
          , M = x.size;
        return x.set(u, m),
        this.size += x.size == M ? 0 : 1,
        this
    }
    var Df = Lf;
    function ds(u) {
        var m = -1
          , x = u == null ? 0 : u.length;
        for (this.clear(); ++m < x; ) {
            var M = u[m];
            this.set(M[0], M[1])
        }
    }
    ds.prototype.clear = wf,
    ds.prototype.delete = Kc,
    ds.prototype.get = Rf,
    ds.prototype.has = If,
    ds.prototype.set = Df;
    var Xo = ds
      , Of = "Expected a function";
    function Pl(u, m) {
        if (typeof u != "function" || m != null && typeof m != "function")
            throw new TypeError(Of);
        var x = function() {
            var M = arguments
              , C = m ? m.apply(this, M) : M[0]
              , D = x.cache;
            if (D.has(C))
                return D.get(C);
            var H = u.apply(this, M);
            return x.cache = D.set(C, H) || D,
            H
        };
        return x.cache = new (Pl.Cache || Xo),
        x
    }
    Pl.Cache = Xo;
    var Uf = Pl
      , Nf = 500;
    function Ff(u) {
        var m = Uf(u, function(M) {
            return x.size === Nf && x.clear(),
            M
        })
          , x = m.cache;
        return m
    }
    var Bf = Ff
      , kf = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g
      , zf = /\\(\\)?/g
      , Hf = Bf(function(u) {
        var m = [];
        return u.charCodeAt(0) === 46 && m.push(""),
        u.replace(kf, function(x, M, C, D) {
            m.push(C ? D.replace(zf, "$1") : M || x)
        }),
        m
    })
      , Vf = Hf;
    function Gf(u, m) {
        for (var x = -1, M = u == null ? 0 : u.length, C = Array(M); ++x < M; )
            C[x] = m(u[x], x, u);
        return C
    }
    var Wf = Gf
      , $c = 1 / 0
      , Zc = De ? De.prototype : void 0
      , Jc = Zc ? Zc.toString : void 0;
    function Qc(u) {
        if (typeof u == "string")
            return u;
        if (ue(u))
            return Wf(u, Qc) + "";
        if (pe(u))
            return Jc ? Jc.call(u) : "";
        var m = u + "";
        return m == "0" && 1 / u == -$c ? "-0" : m
    }
    var eu = Qc;
    function jf(u) {
        return u == null ? "" : eu(u)
    }
    var tu = jf;
    function Rl(u, m) {
        return ue(u) ? u : Ae(u, m) ? [u] : Vf(tu(u))
    }
    var qs = Rl
      , nu = 1 / 0;
    function Xf(u) {
        if (typeof u == "string" || pe(u))
            return u;
        var m = u + "";
        return m == "0" && 1 / u == -nu ? "-0" : m
    }
    var cr = Xf;
    function Ks(u, m) {
        m = qs(m, u);
        for (var x = 0, M = m.length; u != null && x < M; )
            u = u[cr(m[x++])];
        return x && x == M ? u : void 0
    }
    var qo = Ks;
    function Cl(u, m, x) {
        var M = u == null ? void 0 : qo(u, m);
        return M === void 0 ? x : M
    }
    var kr = Cl;
    function iu(u, m) {
        return m.length === 0 ? u : kr(u, m)
    }
    var ps = class {
        constructor() {
            S(this, "_values", {})
        }
        get(u, m) {
            if (this.has(u))
                return this._values[u];
            {
                const x = m();
                return this._values[u] = x,
                x
            }
        }
        has(u) {
            return this._values.hasOwnProperty(u)
        }
    }
      , In = bn
      , Ko = function() {
        try {
            var u = rr(Object, "defineProperty");
            return u({}, "", {}),
            u
        } catch {}
    }()
      , Il = Ko;
    function qf(u, m, x) {
        m == "__proto__" && Il ? Il(u, m, {
            configurable: !0,
            enumerable: !0,
            value: x,
            writable: !0
        }) : u[m] = x
    }
    var zr = qf
      , Ys = Object.prototype
      , Kf = Ys.hasOwnProperty;
    function Yf(u, m, x) {
        var M = u[m];
        (!(Kf.call(u, m) && or(M, x)) || x === void 0 && !(m in u)) && zr(u, m, x)
    }
    var Ll = Yf
      , $f = 9007199254740991
      , ru = /^(?:0|[1-9]\d*)$/;
    function Zf(u, m) {
        var x = typeof u;
        return m = m ?? $f,
        !!m && (x == "number" || x != "symbol" && ru.test(u)) && u > -1 && u % 1 == 0 && u < m
    }
    var Dl = Zf;
    function Jf(u, m, x, M) {
        if (!_e(u))
            return u;
        m = qs(m, u);
        for (var C = -1, D = m.length, H = D - 1, Y = u; Y != null && ++C < D; ) {
            var Z = cr(m[C])
              , se = x;
            if (Z === "__proto__" || Z === "constructor" || Z === "prototype")
                return u;
            if (C != H) {
                var ve = Y[Z];
                se = M ? M(ve, Z, Y) : void 0,
                se === void 0 && (se = _e(ve) ? ve : Dl(m[C + 1]) ? [] : {})
            }
            Ll(Y, Z, se),
            Y = Y[Z]
        }
        return u
    }
    var su = Jf;
    function ou(u, m, x) {
        return u == null ? u : su(u, m, x)
    }
    var Yo = ou
      , Fn = new WeakMap;
    function Qf(u) {
        return Ol(u)
    }
    function Ol(u) {
        if (Fn.has(u))
            return Fn.get(u);
        const m = u.type === "compound" ? lu(u) : u.type === "enum" ? au(u) : u.default;
        return Fn.set(u, m),
        m
    }
    function au(u) {
        const m = {
            $case: u.defaultCase
        };
        for (const [x,M] of Object.entries(u.cases))
            m[x] = Ol(M);
        return m
    }
    function lu(u) {
        const m = {};
        for (const [x,M] of Object.entries(u.props))
            m[x] = Ol(M);
        return m
    }
    var oi = bn
      , ed = b(E());
    function td(u, m, x) {
        return (0,
        oi.prism)(()=>{
            const M = (0,
            oi.val)(m);
            return oi.prism.memo("driver", ()=>M ? M.type === "BasicKeyframedTrack" ? nd(u, M, x) : (u.logger.error("Track type not yet supported."),
            (0,
            oi.prism)(()=>{}
            )) : (0,
            oi.prism)(()=>{}
            ), [M]).getValue()
        }
        )
    }
    function nd(u, m, x) {
        return (0,
        oi.prism)(()=>{
            let M = oi.prism.ref("state", {
                started: !1
            })
              , C = M.current;
            const D = x.getValue();
            return (!C.started || D < C.validFrom || C.validTo <= D) && (M.current = C = id(u, x, m)),
            C.der.getValue()
        }
        )
    }
    var cu = (0,
    oi.prism)(()=>{}
    );
    function id(u, m, x) {
        const M = m.getValue();
        if (x.keyframes.length === 0)
            return {
                started: !0,
                validFrom: -1 / 0,
                validTo: 1 / 0,
                der: cu
            };
        let C = 0;
        for (; ; ) {
            const D = x.keyframes[C];
            if (!D)
                return Ln.error;
            const H = C === x.keyframes.length - 1;
            if (M < D.position)
                return C === 0 ? Ln.beforeFirstKeyframe(D) : Ln.error;
            if (D.position === M)
                return H ? Ln.lastKeyframe(D) : Ln.between(D, x.keyframes[C + 1], m);
            if (C === x.keyframes.length - 1)
                return Ln.lastKeyframe(D);
            {
                const Y = C + 1;
                if (x.keyframes[Y].position <= M) {
                    C = Y;
                    continue
                } else
                    return Ln.between(D, x.keyframes[C + 1], m)
            }
        }
    }
    var Ln = {
        beforeFirstKeyframe(u) {
            return {
                started: !0,
                validFrom: -1 / 0,
                validTo: u.position,
                der: (0,
                oi.prism)(()=>({
                    left: u.value,
                    progression: 0
                }))
            }
        },
        lastKeyframe(u) {
            return {
                started: !0,
                validFrom: u.position,
                validTo: 1 / 0,
                der: (0,
                oi.prism)(()=>({
                    left: u.value,
                    progression: 0
                }))
            }
        },
        between(u, m, x) {
            if (!u.connectedRight)
                return {
                    started: !0,
                    validFrom: u.position,
                    validTo: m.position,
                    der: (0,
                    oi.prism)(()=>({
                        left: u.value,
                        progression: 0
                    }))
                };
            const M = D=>(D - u.position) / (m.position - u.position);
            if (!u.type || u.type === "bezier") {
                const D = new ed.default(u.handles[2],u.handles[3],m.handles[0],m.handles[1])
                  , H = (0,
                oi.prism)(()=>{
                    const Y = M(x.getValue())
                      , Z = D.solveSimple(Y);
                    return {
                        left: u.value,
                        right: m.value,
                        progression: Z
                    }
                }
                );
                return {
                    started: !0,
                    validFrom: u.position,
                    validTo: m.position,
                    der: H
                }
            }
            const C = (0,
            oi.prism)(()=>{
                const D = M(x.getValue())
                  , H = Math.floor(D);
                return {
                    left: u.value,
                    right: m.value,
                    progression: H
                }
            }
            );
            return {
                started: !0,
                validFrom: u.position,
                validTo: m.position,
                der: C
            }
        },
        error: {
            started: !0,
            validFrom: -1 / 0,
            validTo: 1 / 0,
            der: cu
        }
    };
    function $s(u, m, x) {
        const C = x.get(u);
        if (C && C.override === m)
            return C.merged;
        const D = p({}, u);
        for (const H of Object.keys(m)) {
            const Y = m[H]
              , Z = u[H];
            D[H] = typeof Y == "object" && typeof Z == "object" ? $s(Z, Y, x) : Y === void 0 ? Z : Y
        }
        return x.set(u, {
            override: m,
            merged: D
        }),
        D
    }
    function Zs(u, m) {
        let x = u;
        for (const M of m)
            x = x[M];
        return x
    }
    var Js = bn
      , uu = (u,m)=>{
        const x = Js.prism.memo(u, ()=>new Js.Atom(m), []);
        return x.set(m),
        x
    }
      , Dt = bn
      , Ul = bn
      , rd = /\s/;
    function hu(u) {
        for (var m = u.length; m-- && rd.test(u.charAt(m)); )
            ;
        return m
    }
    var fu = hu
      , du = /^\s+/;
    function sd(u) {
        return u && u.slice(0, fu(u) + 1).replace(du, "")
    }
    var $o = sd
      , Nl = NaN
      , od = /^[-+]0x[0-9a-f]+$/i
      , ad = /^0b[01]+$/i
      , pu = /^0o[0-7]+$/i
      , ld = parseInt;
    function cd(u) {
        if (typeof u == "number")
            return u;
        if (pe(u))
            return Nl;
        if (_e(u)) {
            var m = typeof u.valueOf == "function" ? u.valueOf() : u;
            u = _e(m) ? m + "" : m
        }
        if (typeof u != "string")
            return u === 0 ? u : +u;
        u = $o(u);
        var x = ad.test(u);
        return x || pu.test(u) ? ld(u.slice(2), x ? 2 : 8) : od.test(u) ? Nl : +u
    }
    var A = cd
      , N = 1 / 0
      , W = 17976931348623157e292;
    function re(u) {
        if (!u)
            return u === 0 ? u : 0;
        if (u = A(u),
        u === N || u === -N) {
            var m = u < 0 ? -1 : 1;
            return m * W
        }
        return u === u ? u : 0
    }
    var $e = re;
    function St(u) {
        var m = $e(u)
          , x = m % 1;
        return m === m ? x ? m - x : m : 0
    }
    var jn = St;
    function Gi(u) {
        return u
    }
    var mu = Gi
      , ms = rr(xe, "WeakMap")
      , Qs = ms
      , lg = Object.create
      , NS = function() {
        function u() {}
        return function(m) {
            if (!_e(m))
                return {};
            if (lg)
                return lg(m);
            u.prototype = m;
            var x = new u;
            return u.prototype = void 0,
            x
        }
    }()
      , FS = NS;
    function BS(u, m) {
        var x = -1
          , M = u.length;
        for (m || (m = Array(M)); ++x < M; )
            m[x] = u[x];
        return m
    }
    var kS = BS;
    function zS(u, m) {
        for (var x = -1, M = u == null ? 0 : u.length; ++x < M && m(u[x], x, u) !== !1; )
            ;
        return u
    }
    var HS = zS;
    function VS(u, m, x, M) {
        var C = !x;
        x || (x = {});
        for (var D = -1, H = m.length; ++D < H; ) {
            var Y = m[D]
              , Z = M ? M(x[Y], u[Y], Y, x, u) : void 0;
            Z === void 0 && (Z = u[Y]),
            C ? zr(x, Y, Z) : Ll(x, Y, Z)
        }
        return x
    }
    var _u = VS
      , GS = 9007199254740991;
    function WS(u) {
        return typeof u == "number" && u > -1 && u % 1 == 0 && u <= GS
    }
    var ud = WS;
    function jS(u) {
        return u != null && ud(u.length) && !Le(u)
    }
    var cg = jS
      , XS = Object.prototype;
    function qS(u) {
        var m = u && u.constructor
          , x = typeof m == "function" && m.prototype || XS;
        return u === x
    }
    var hd = qS;
    function KS(u, m) {
        for (var x = -1, M = Array(u); ++x < u; )
            M[x] = m(x);
        return M
    }
    var YS = KS
      , $S = "[object Arguments]";
    function ZS(u) {
        return L(u) && Lt(u) == $S
    }
    var ug = ZS
      , hg = Object.prototype
      , JS = hg.hasOwnProperty
      , QS = hg.propertyIsEnumerable
      , eM = ug(function() {
        return arguments
    }()) ? ug : function(u) {
        return L(u) && JS.call(u, "callee") && !QS.call(u, "callee")
    }
      , fg = eM;
    function tM() {
        return !1
    }
    var nM = tM
      , dg = e && !e.nodeType && e
      , pg = dg && !0 && r && !r.nodeType && r
      , iM = pg && pg.exports === dg
      , mg = iM ? xe.Buffer : void 0
      , rM = mg ? mg.isBuffer : void 0
      , sM = rM || nM
      , gu = sM
      , oM = "[object Arguments]"
      , aM = "[object Array]"
      , lM = "[object Boolean]"
      , cM = "[object Date]"
      , uM = "[object Error]"
      , hM = "[object Function]"
      , fM = "[object Map]"
      , dM = "[object Number]"
      , pM = "[object Object]"
      , mM = "[object RegExp]"
      , _M = "[object Set]"
      , gM = "[object String]"
      , vM = "[object WeakMap]"
      , yM = "[object ArrayBuffer]"
      , xM = "[object DataView]"
      , TM = "[object Float32Array]"
      , bM = "[object Float64Array]"
      , SM = "[object Int8Array]"
      , MM = "[object Int16Array]"
      , wM = "[object Int32Array]"
      , EM = "[object Uint8Array]"
      , AM = "[object Uint8ClampedArray]"
      , PM = "[object Uint16Array]"
      , RM = "[object Uint32Array]"
      , $t = {};
    $t[TM] = $t[bM] = $t[SM] = $t[MM] = $t[wM] = $t[EM] = $t[AM] = $t[PM] = $t[RM] = !0,
    $t[oM] = $t[aM] = $t[yM] = $t[lM] = $t[xM] = $t[cM] = $t[uM] = $t[hM] = $t[fM] = $t[dM] = $t[pM] = $t[mM] = $t[_M] = $t[gM] = $t[vM] = !1;
    function CM(u) {
        return L(u) && ud(u.length) && !!$t[Lt(u)]
    }
    var IM = CM;
    function LM(u) {
        return function(m) {
            return u(m)
        }
    }
    var fd = LM
      , _g = e && !e.nodeType && e
      , Fl = _g && !0 && r && !r.nodeType && r
      , DM = Fl && Fl.exports === _g
      , dd = DM && Ee.process
      , OM = function() {
        try {
            var u = Fl && Fl.require && Fl.require("util").types;
            return u || dd && dd.binding && dd.binding("util")
        } catch {}
    }()
      , Zo = OM
      , gg = Zo && Zo.isTypedArray
      , UM = gg ? fd(gg) : IM
      , vg = UM
      , NM = Object.prototype
      , FM = NM.hasOwnProperty;
    function BM(u, m) {
        var x = ue(u)
          , M = !x && fg(u)
          , C = !x && !M && gu(u)
          , D = !x && !M && !C && vg(u)
          , H = x || M || C || D
          , Y = H ? YS(u.length, String) : []
          , Z = Y.length;
        for (var se in u)
            (m || FM.call(u, se)) && !(H && (se == "length" || C && (se == "offset" || se == "parent") || D && (se == "buffer" || se == "byteLength" || se == "byteOffset") || Dl(se, Z))) && Y.push(se);
        return Y
    }
    var yg = BM;
    function kM(u, m) {
        return function(x) {
            return u(m(x))
        }
    }
    var xg = kM
      , zM = xg(Object.keys, Object)
      , HM = zM
      , VM = Object.prototype
      , GM = VM.hasOwnProperty;
    function WM(u) {
        if (!hd(u))
            return HM(u);
        var m = [];
        for (var x in Object(u))
            GM.call(u, x) && x != "constructor" && m.push(x);
        return m
    }
    var jM = WM;
    function XM(u) {
        return cg(u) ? yg(u) : jM(u)
    }
    var Bl = XM;
    function qM(u) {
        var m = [];
        if (u != null)
            for (var x in Object(u))
                m.push(x);
        return m
    }
    var KM = qM
      , YM = Object.prototype
      , $M = YM.hasOwnProperty;
    function ZM(u) {
        if (!_e(u))
            return KM(u);
        var m = hd(u)
          , x = [];
        for (var M in u)
            M == "constructor" && (m || !$M.call(u, M)) || x.push(M);
        return x
    }
    var JM = ZM;
    function QM(u) {
        return cg(u) ? yg(u, !0) : JM(u)
    }
    var pd = QM;
    function ew(u, m) {
        for (var x = -1, M = m.length, C = u.length; ++x < M; )
            u[C + x] = m[x];
        return u
    }
    var Tg = ew
      , tw = xg(Object.getPrototypeOf, Object)
      , md = tw
      , nw = "[object Object]"
      , iw = Function.prototype
      , rw = Object.prototype
      , bg = iw.toString
      , sw = rw.hasOwnProperty
      , ow = bg.call(Object);
    function aw(u) {
        if (!L(u) || Lt(u) != nw)
            return !1;
        var m = md(u);
        if (m === null)
            return !0;
        var x = sw.call(m, "constructor") && m.constructor;
        return typeof x == "function" && x instanceof x && bg.call(x) == ow
    }
    var lw = aw;
    function cw(u, m, x) {
        var M = -1
          , C = u.length;
        m < 0 && (m = -m > C ? 0 : C + m),
        x = x > C ? C : x,
        x < 0 && (x += C),
        C = m > x ? 0 : x - m >>> 0,
        m >>>= 0;
        for (var D = Array(C); ++M < C; )
            D[M] = u[M + m];
        return D
    }
    var Sg = cw;
    function uw(u, m, x) {
        var M = u.length;
        return x = x === void 0 ? M : x,
        !m && x >= M ? u : Sg(u, m, x)
    }
    var hw = uw
      , fw = "\\ud800-\\udfff"
      , dw = "\\u0300-\\u036f"
      , pw = "\\ufe20-\\ufe2f"
      , mw = "\\u20d0-\\u20ff"
      , _w = dw + pw + mw
      , gw = "\\ufe0e\\ufe0f"
      , vw = "\\u200d"
      , yw = RegExp("[" + vw + fw + _w + gw + "]");
    function xw(u) {
        return yw.test(u)
    }
    var _d = xw;
    function Tw(u) {
        return u.split("")
    }
    var bw = Tw
      , Mg = "\\ud800-\\udfff"
      , Sw = "\\u0300-\\u036f"
      , Mw = "\\ufe20-\\ufe2f"
      , ww = "\\u20d0-\\u20ff"
      , Ew = Sw + Mw + ww
      , Aw = "\\ufe0e\\ufe0f"
      , Pw = "[" + Mg + "]"
      , gd = "[" + Ew + "]"
      , vd = "\\ud83c[\\udffb-\\udfff]"
      , Rw = "(?:" + gd + "|" + vd + ")"
      , wg = "[^" + Mg + "]"
      , Eg = "(?:\\ud83c[\\udde6-\\uddff]){2}"
      , Ag = "[\\ud800-\\udbff][\\udc00-\\udfff]"
      , Cw = "\\u200d"
      , Pg = Rw + "?"
      , Rg = "[" + Aw + "]?"
      , Iw = "(?:" + Cw + "(?:" + [wg, Eg, Ag].join("|") + ")" + Rg + Pg + ")*"
      , Lw = Rg + Pg + Iw
      , Dw = "(?:" + [wg + gd + "?", gd, Eg, Ag, Pw].join("|") + ")"
      , Ow = RegExp(vd + "(?=" + vd + ")|" + Dw + Lw, "g");
    function Uw(u) {
        return u.match(Ow) || []
    }
    var Nw = Uw;
    function Fw(u) {
        return _d(u) ? Nw(u) : bw(u)
    }
    var Bw = Fw;
    function kw(u, m, x) {
        return u === u && (x !== void 0 && (u = u <= x ? u : x),
        m !== void 0 && (u = u >= m ? u : m)),
        u
    }
    var zw = kw;
    function Hw(u, m, x) {
        return x === void 0 && (x = m,
        m = void 0),
        x !== void 0 && (x = A(x),
        x = x === x ? x : 0),
        m !== void 0 && (m = A(m),
        m = m === m ? m : 0),
        zw(A(u), m, x)
    }
    var Cg = Hw;
    function Vw() {
        this.__data__ = new Wo,
        this.size = 0
    }
    var Gw = Vw;
    function Ww(u) {
        var m = this.__data__
          , x = m.delete(u);
        return this.size = m.size,
        x
    }
    var jw = Ww;
    function Xw(u) {
        return this.__data__.get(u)
    }
    var qw = Xw;
    function Kw(u) {
        return this.__data__.has(u)
    }
    var Yw = Kw
      , $w = 200;
    function Zw(u, m) {
        var x = this.__data__;
        if (x instanceof Wo) {
            var M = x.__data__;
            if (!Xs || M.length < $w - 1)
                return M.push([u, m]),
                this.size = ++x.size,
                this;
            x = this.__data__ = new Xo(M)
        }
        return x.set(u, m),
        this.size = x.size,
        this
    }
    var Jw = Zw;
    function Jo(u) {
        var m = this.__data__ = new Wo(u);
        this.size = m.size
    }
    Jo.prototype.clear = Gw,
    Jo.prototype.delete = jw,
    Jo.prototype.get = qw,
    Jo.prototype.has = Yw,
    Jo.prototype.set = Jw;
    var kl = Jo;
    function Qw(u, m) {
        return u && _u(m, Bl(m), u)
    }
    var eE = Qw;
    function tE(u, m) {
        return u && _u(m, pd(m), u)
    }
    var nE = tE
      , Ig = e && !e.nodeType && e
      , Lg = Ig && !0 && r && !r.nodeType && r
      , iE = Lg && Lg.exports === Ig
      , Dg = iE ? xe.Buffer : void 0
      , Og = Dg ? Dg.allocUnsafe : void 0;
    function rE(u, m) {
        if (m)
            return u.slice();
        var x = u.length
          , M = Og ? Og(x) : new u.constructor(x);
        return u.copy(M),
        M
    }
    var sE = rE;
    function oE(u, m) {
        for (var x = -1, M = u == null ? 0 : u.length, C = 0, D = []; ++x < M; ) {
            var H = u[x];
            m(H, x, u) && (D[C++] = H)
        }
        return D
    }
    var aE = oE;
    function lE() {
        return []
    }
    var Ug = lE
      , cE = Object.prototype
      , uE = cE.propertyIsEnumerable
      , Ng = Object.getOwnPropertySymbols
      , hE = Ng ? function(u) {
        return u == null ? [] : (u = Object(u),
        aE(Ng(u), function(m) {
            return uE.call(u, m)
        }))
    }
    : Ug
      , yd = hE;
    function fE(u, m) {
        return _u(u, yd(u), m)
    }
    var dE = fE
      , pE = Object.getOwnPropertySymbols
      , mE = pE ? function(u) {
        for (var m = []; u; )
            Tg(m, yd(u)),
            u = md(u);
        return m
    }
    : Ug
      , Fg = mE;
    function _E(u, m) {
        return _u(u, Fg(u), m)
    }
    var gE = _E;
    function vE(u, m, x) {
        var M = m(u);
        return ue(u) ? M : Tg(M, x(u))
    }
    var Bg = vE;
    function yE(u) {
        return Bg(u, Bl, yd)
    }
    var xd = yE;
    function xE(u) {
        return Bg(u, pd, Fg)
    }
    var TE = xE
      , bE = rr(xe, "DataView")
      , Td = bE
      , SE = rr(xe, "Promise")
      , bd = SE
      , ME = rr(xe, "Set")
      , Sd = ME
      , kg = "[object Map]"
      , wE = "[object Object]"
      , zg = "[object Promise]"
      , Hg = "[object Set]"
      , Vg = "[object WeakMap]"
      , Gg = "[object DataView]"
      , EE = Ut(Td)
      , AE = Ut(Xs)
      , PE = Ut(bd)
      , RE = Ut(Sd)
      , CE = Ut(Qs)
      , eo = Lt;
    (Td && eo(new Td(new ArrayBuffer(1))) != Gg || Xs && eo(new Xs) != kg || bd && eo(bd.resolve()) != zg || Sd && eo(new Sd) != Hg || Qs && eo(new Qs) != Vg) && (eo = function(u) {
        var m = Lt(u)
          , x = m == wE ? u.constructor : void 0
          , M = x ? Ut(x) : "";
        if (M)
            switch (M) {
            case EE:
                return Gg;
            case AE:
                return kg;
            case PE:
                return zg;
            case RE:
                return Hg;
            case CE:
                return Vg
            }
        return m
    }
    );
    var zl = eo
      , IE = Object.prototype
      , LE = IE.hasOwnProperty;
    function DE(u) {
        var m = u.length
          , x = new u.constructor(m);
        return m && typeof u[0] == "string" && LE.call(u, "index") && (x.index = u.index,
        x.input = u.input),
        x
    }
    var OE = DE
      , UE = xe.Uint8Array
      , vu = UE;
    function NE(u) {
        var m = new u.constructor(u.byteLength);
        return new vu(m).set(new vu(u)),
        m
    }
    var Md = NE;
    function FE(u, m) {
        var x = m ? Md(u.buffer) : u.buffer;
        return new u.constructor(x,u.byteOffset,u.byteLength)
    }
    var BE = FE
      , kE = /\w*$/;
    function zE(u) {
        var m = new u.constructor(u.source,kE.exec(u));
        return m.lastIndex = u.lastIndex,
        m
    }
    var HE = zE
      , Wg = De ? De.prototype : void 0
      , jg = Wg ? Wg.valueOf : void 0;
    function VE(u) {
        return jg ? Object(jg.call(u)) : {}
    }
    var GE = VE;
    function WE(u, m) {
        var x = m ? Md(u.buffer) : u.buffer;
        return new u.constructor(x,u.byteOffset,u.length)
    }
    var jE = WE
      , XE = "[object Boolean]"
      , qE = "[object Date]"
      , KE = "[object Map]"
      , YE = "[object Number]"
      , $E = "[object RegExp]"
      , ZE = "[object Set]"
      , JE = "[object String]"
      , QE = "[object Symbol]"
      , eA = "[object ArrayBuffer]"
      , tA = "[object DataView]"
      , nA = "[object Float32Array]"
      , iA = "[object Float64Array]"
      , rA = "[object Int8Array]"
      , sA = "[object Int16Array]"
      , oA = "[object Int32Array]"
      , aA = "[object Uint8Array]"
      , lA = "[object Uint8ClampedArray]"
      , cA = "[object Uint16Array]"
      , uA = "[object Uint32Array]";
    function hA(u, m, x) {
        var M = u.constructor;
        switch (m) {
        case eA:
            return Md(u);
        case XE:
        case qE:
            return new M(+u);
        case tA:
            return BE(u, x);
        case nA:
        case iA:
        case rA:
        case sA:
        case oA:
        case aA:
        case lA:
        case cA:
        case uA:
            return jE(u, x);
        case KE:
            return new M;
        case YE:
        case JE:
            return new M(u);
        case $E:
            return HE(u);
        case ZE:
            return new M;
        case QE:
            return GE(u)
        }
    }
    var fA = hA;
    function dA(u) {
        return typeof u.constructor == "function" && !hd(u) ? FS(md(u)) : {}
    }
    var pA = dA
      , mA = "[object Map]";
    function _A(u) {
        return L(u) && zl(u) == mA
    }
    var gA = _A
      , Xg = Zo && Zo.isMap
      , vA = Xg ? fd(Xg) : gA
      , yA = vA
      , xA = "[object Set]";
    function TA(u) {
        return L(u) && zl(u) == xA
    }
    var bA = TA
      , qg = Zo && Zo.isSet
      , SA = qg ? fd(qg) : bA
      , MA = SA
      , wA = 1
      , EA = 2
      , AA = 4
      , Kg = "[object Arguments]"
      , PA = "[object Array]"
      , RA = "[object Boolean]"
      , CA = "[object Date]"
      , IA = "[object Error]"
      , Yg = "[object Function]"
      , LA = "[object GeneratorFunction]"
      , DA = "[object Map]"
      , OA = "[object Number]"
      , $g = "[object Object]"
      , UA = "[object RegExp]"
      , NA = "[object Set]"
      , FA = "[object String]"
      , BA = "[object Symbol]"
      , kA = "[object WeakMap]"
      , zA = "[object ArrayBuffer]"
      , HA = "[object DataView]"
      , VA = "[object Float32Array]"
      , GA = "[object Float64Array]"
      , WA = "[object Int8Array]"
      , jA = "[object Int16Array]"
      , XA = "[object Int32Array]"
      , qA = "[object Uint8Array]"
      , KA = "[object Uint8ClampedArray]"
      , YA = "[object Uint16Array]"
      , $A = "[object Uint32Array]"
      , Wt = {};
    Wt[Kg] = Wt[PA] = Wt[zA] = Wt[HA] = Wt[RA] = Wt[CA] = Wt[VA] = Wt[GA] = Wt[WA] = Wt[jA] = Wt[XA] = Wt[DA] = Wt[OA] = Wt[$g] = Wt[UA] = Wt[NA] = Wt[FA] = Wt[BA] = Wt[qA] = Wt[KA] = Wt[YA] = Wt[$A] = !0,
    Wt[IA] = Wt[Yg] = Wt[kA] = !1;
    function yu(u, m, x, M, C, D) {
        var H, Y = m & wA, Z = m & EA, se = m & AA;
        if (x && (H = C ? x(u, M, C, D) : x(u)),
        H !== void 0)
            return H;
        if (!_e(u))
            return u;
        var ve = ue(u);
        if (ve) {
            if (H = OE(u),
            !Y)
                return kS(u, H)
        } else {
            var ye = zl(u)
              , Re = ye == Yg || ye == LA;
            if (gu(u))
                return sE(u, Y);
            if (ye == $g || ye == Kg || Re && !C) {
                if (H = Z || Re ? {} : pA(u),
                !Y)
                    return Z ? gE(u, nE(H, u)) : dE(u, eE(H, u))
            } else {
                if (!Wt[ye])
                    return C ? u : {};
                H = fA(u, ye, Y)
            }
        }
        D || (D = new kl);
        var Ve = D.get(u);
        if (Ve)
            return Ve;
        D.set(u, H),
        MA(u) ? u.forEach(function(mt) {
            H.add(yu(mt, m, x, mt, u, D))
        }) : yA(u) && u.forEach(function(mt, ct) {
            H.set(ct, yu(mt, m, x, ct, u, D))
        });
        var Ue = se ? Z ? TE : xd : Z ? pd : Bl
          , ht = ve ? void 0 : Ue(u);
        return HS(ht || u, function(mt, ct) {
            ht && (ct = mt,
            mt = u[ct]),
            Ll(H, ct, yu(mt, m, x, ct, u, D))
        }),
        H
    }
    var ZA = yu
      , JA = 1
      , QA = 4;
    function e1(u) {
        return ZA(u, JA | QA)
    }
    var t1 = e1
      , n1 = "__lodash_hash_undefined__";
    function i1(u) {
        return this.__data__.set(u, n1),
        this
    }
    var r1 = i1;
    function s1(u) {
        return this.__data__.has(u)
    }
    var o1 = s1;
    function xu(u) {
        var m = -1
          , x = u == null ? 0 : u.length;
        for (this.__data__ = new Xo; ++m < x; )
            this.add(u[m])
    }
    xu.prototype.add = xu.prototype.push = r1,
    xu.prototype.has = o1;
    var a1 = xu;
    function l1(u, m) {
        for (var x = -1, M = u == null ? 0 : u.length; ++x < M; )
            if (m(u[x], x, u))
                return !0;
        return !1
    }
    var c1 = l1;
    function u1(u, m) {
        return u.has(m)
    }
    var h1 = u1
      , f1 = 1
      , d1 = 2;
    function p1(u, m, x, M, C, D) {
        var H = x & f1
          , Y = u.length
          , Z = m.length;
        if (Y != Z && !(H && Z > Y))
            return !1;
        var se = D.get(u)
          , ve = D.get(m);
        if (se && ve)
            return se == m && ve == u;
        var ye = -1
          , Re = !0
          , Ve = x & d1 ? new a1 : void 0;
        for (D.set(u, m),
        D.set(m, u); ++ye < Y; ) {
            var Ue = u[ye]
              , ht = m[ye];
            if (M)
                var mt = H ? M(ht, Ue, ye, m, u, D) : M(Ue, ht, ye, u, m, D);
            if (mt !== void 0) {
                if (mt)
                    continue;
                Re = !1;
                break
            }
            if (Ve) {
                if (!c1(m, function(ct, wt) {
                    if (!h1(Ve, wt) && (Ue === ct || C(Ue, ct, x, M, D)))
                        return Ve.push(wt)
                })) {
                    Re = !1;
                    break
                }
            } else if (!(Ue === ht || C(Ue, ht, x, M, D))) {
                Re = !1;
                break
            }
        }
        return D.delete(u),
        D.delete(m),
        Re
    }
    var Zg = p1;
    function m1(u) {
        var m = -1
          , x = Array(u.size);
        return u.forEach(function(M, C) {
            x[++m] = [C, M]
        }),
        x
    }
    var _1 = m1;
    function g1(u) {
        var m = -1
          , x = Array(u.size);
        return u.forEach(function(M) {
            x[++m] = M
        }),
        x
    }
    var v1 = g1
      , y1 = 1
      , x1 = 2
      , T1 = "[object Boolean]"
      , b1 = "[object Date]"
      , S1 = "[object Error]"
      , M1 = "[object Map]"
      , w1 = "[object Number]"
      , E1 = "[object RegExp]"
      , A1 = "[object Set]"
      , P1 = "[object String]"
      , R1 = "[object Symbol]"
      , C1 = "[object ArrayBuffer]"
      , I1 = "[object DataView]"
      , Jg = De ? De.prototype : void 0
      , wd = Jg ? Jg.valueOf : void 0;
    function L1(u, m, x, M, C, D, H) {
        switch (x) {
        case I1:
            if (u.byteLength != m.byteLength || u.byteOffset != m.byteOffset)
                return !1;
            u = u.buffer,
            m = m.buffer;
        case C1:
            return !(u.byteLength != m.byteLength || !D(new vu(u), new vu(m)));
        case T1:
        case b1:
        case w1:
            return or(+u, +m);
        case S1:
            return u.name == m.name && u.message == m.message;
        case E1:
        case P1:
            return u == m + "";
        case M1:
            var Y = _1;
        case A1:
            var Z = M & y1;
            if (Y || (Y = v1),
            u.size != m.size && !Z)
                return !1;
            var se = H.get(u);
            if (se)
                return se == m;
            M |= x1,
            H.set(u, m);
            var ve = Zg(Y(u), Y(m), M, C, D, H);
            return H.delete(u),
            ve;
        case R1:
            if (wd)
                return wd.call(u) == wd.call(m)
        }
        return !1
    }
    var D1 = L1
      , O1 = 1
      , U1 = Object.prototype
      , N1 = U1.hasOwnProperty;
    function F1(u, m, x, M, C, D) {
        var H = x & O1
          , Y = xd(u)
          , Z = Y.length
          , se = xd(m)
          , ve = se.length;
        if (Z != ve && !H)
            return !1;
        for (var ye = Z; ye--; ) {
            var Re = Y[ye];
            if (!(H ? Re in m : N1.call(m, Re)))
                return !1
        }
        var Ve = D.get(u)
          , Ue = D.get(m);
        if (Ve && Ue)
            return Ve == m && Ue == u;
        var ht = !0;
        D.set(u, m),
        D.set(m, u);
        for (var mt = H; ++ye < Z; ) {
            Re = Y[ye];
            var ct = u[Re]
              , wt = m[Re];
            if (M)
                var $n = H ? M(wt, ct, Re, m, u, D) : M(ct, wt, Re, u, m, D);
            if (!($n === void 0 ? ct === wt || C(ct, wt, x, M, D) : $n)) {
                ht = !1;
                break
            }
            mt || (mt = Re == "constructor")
        }
        if (ht && !mt) {
            var vi = u.constructor
              , Zn = m.constructor;
            vi != Zn && "constructor"in u && "constructor"in m && !(typeof vi == "function" && vi instanceof vi && typeof Zn == "function" && Zn instanceof Zn) && (ht = !1)
        }
        return D.delete(u),
        D.delete(m),
        ht
    }
    var B1 = F1
      , k1 = 1
      , Qg = "[object Arguments]"
      , ev = "[object Array]"
      , Tu = "[object Object]"
      , z1 = Object.prototype
      , tv = z1.hasOwnProperty;
    function H1(u, m, x, M, C, D) {
        var H = ue(u)
          , Y = ue(m)
          , Z = H ? ev : zl(u)
          , se = Y ? ev : zl(m);
        Z = Z == Qg ? Tu : Z,
        se = se == Qg ? Tu : se;
        var ve = Z == Tu
          , ye = se == Tu
          , Re = Z == se;
        if (Re && gu(u)) {
            if (!gu(m))
                return !1;
            H = !0,
            ve = !1
        }
        if (Re && !ve)
            return D || (D = new kl),
            H || vg(u) ? Zg(u, m, x, M, C, D) : D1(u, m, Z, x, M, C, D);
        if (!(x & k1)) {
            var Ve = ve && tv.call(u, "__wrapped__")
              , Ue = ye && tv.call(m, "__wrapped__");
            if (Ve || Ue) {
                var ht = Ve ? u.value() : u
                  , mt = Ue ? m.value() : m;
                return D || (D = new kl),
                C(ht, mt, x, M, D)
            }
        }
        return Re ? (D || (D = new kl),
        B1(u, m, x, M, C, D)) : !1
    }
    var V1 = H1;
    function nv(u, m, x, M, C) {
        return u === m ? !0 : u == null || m == null || !L(u) && !L(m) ? u !== u && m !== m : V1(u, m, x, M, nv, C)
    }
    var iv = nv
      , G1 = 1
      , W1 = 2;
    function j1(u, m, x, M) {
        var C = x.length
          , D = C
          , H = !M;
        if (u == null)
            return !D;
        for (u = Object(u); C--; ) {
            var Y = x[C];
            if (H && Y[2] ? Y[1] !== u[Y[0]] : !(Y[0]in u))
                return !1
        }
        for (; ++C < D; ) {
            Y = x[C];
            var Z = Y[0]
              , se = u[Z]
              , ve = Y[1];
            if (H && Y[2]) {
                if (se === void 0 && !(Z in u))
                    return !1
            } else {
                var ye = new kl;
                if (M)
                    var Re = M(se, ve, Z, u, m, ye);
                if (!(Re === void 0 ? iv(ve, se, G1 | W1, M, ye) : Re))
                    return !1
            }
        }
        return !0
    }
    var X1 = j1;
    function q1(u) {
        return u === u && !_e(u)
    }
    var rv = q1;
    function K1(u) {
        for (var m = Bl(u), x = m.length; x--; ) {
            var M = m[x]
              , C = u[M];
            m[x] = [M, C, rv(C)]
        }
        return m
    }
    var Y1 = K1;
    function $1(u, m) {
        return function(x) {
            return x == null ? !1 : x[u] === m && (m !== void 0 || u in Object(x))
        }
    }
    var sv = $1;
    function Z1(u) {
        var m = Y1(u);
        return m.length == 1 && m[0][2] ? sv(m[0][0], m[0][1]) : function(x) {
            return x === u || X1(x, u, m)
        }
    }
    var J1 = Z1;
    function Q1(u, m) {
        return u != null && m in Object(u)
    }
    var eP = Q1;
    function tP(u, m, x) {
        m = qs(m, u);
        for (var M = -1, C = m.length, D = !1; ++M < C; ) {
            var H = cr(m[M]);
            if (!(D = u != null && x(u, H)))
                break;
            u = u[H]
        }
        return D || ++M != C ? D : (C = u == null ? 0 : u.length,
        !!C && ud(C) && Dl(H, C) && (ue(u) || fg(u)))
    }
    var nP = tP;
    function iP(u, m) {
        return u != null && nP(u, m, eP)
    }
    var rP = iP
      , sP = 1
      , oP = 2;
    function aP(u, m) {
        return Ae(u) && rv(m) ? sv(cr(u), m) : function(x) {
            var M = kr(x, u);
            return M === void 0 && M === m ? rP(x, u) : iv(m, M, sP | oP)
        }
    }
    var lP = aP;
    function cP(u) {
        return function(m) {
            return m?.[u]
        }
    }
    var ov = cP;
    function uP(u) {
        return function(m) {
            return qo(m, u)
        }
    }
    var hP = uP;
    function fP(u) {
        return Ae(u) ? ov(cr(u)) : hP(u)
    }
    var dP = fP;
    function pP(u) {
        return typeof u == "function" ? u : u == null ? mu : typeof u == "object" ? ue(u) ? lP(u[0], u[1]) : J1(u) : dP(u)
    }
    var mP = pP;
    function _P(u) {
        return function(m, x, M) {
            for (var C = -1, D = Object(m), H = M(m), Y = H.length; Y--; ) {
                var Z = H[u ? Y : ++C];
                if (x(D[Z], Z, D) === !1)
                    break
            }
            return m
        }
    }
    var gP = _P
      , vP = gP()
      , yP = vP;
    function xP(u, m) {
        return u && yP(u, m, Bl)
    }
    var TP = xP
      , bP = function() {
        return xe.Date.now()
    }
      , Ed = bP
      , SP = "Expected a function"
      , MP = Math.max
      , wP = Math.min;
    function EP(u, m, x) {
        var M, C, D, H, Y, Z, se = 0, ve = !1, ye = !1, Re = !0;
        if (typeof u != "function")
            throw new TypeError(SP);
        m = A(m) || 0,
        _e(x) && (ve = !!x.leading,
        ye = "maxWait"in x,
        D = ye ? MP(A(x.maxWait) || 0, m) : D,
        Re = "trailing"in x ? !!x.trailing : Re);
        function Ve(kt) {
            var Jn = M
              , Ci = C;
            return M = C = void 0,
            se = kt,
            H = u.apply(Ci, Jn),
            H
        }
        function Ue(kt) {
            return se = kt,
            Y = setTimeout(ct, m),
            ve ? Ve(kt) : H
        }
        function ht(kt) {
            var Jn = kt - Z
              , Ci = kt - se
              , wr = m - Jn;
            return ye ? wP(wr, D - Ci) : wr
        }
        function mt(kt) {
            var Jn = kt - Z
              , Ci = kt - se;
            return Z === void 0 || Jn >= m || Jn < 0 || ye && Ci >= D
        }
        function ct() {
            var kt = Ed();
            if (mt(kt))
                return wt(kt);
            Y = setTimeout(ct, ht(kt))
        }
        function wt(kt) {
            return Y = void 0,
            Re && M ? Ve(kt) : (M = C = void 0,
            H)
        }
        function $n() {
            Y !== void 0 && clearTimeout(Y),
            se = 0,
            M = Z = C = Y = void 0
        }
        function vi() {
            return Y === void 0 ? H : wt(Ed())
        }
        function Zn() {
            var kt = Ed()
              , Jn = mt(kt);
            if (M = arguments,
            C = this,
            Z = kt,
            Jn) {
                if (Y === void 0)
                    return Ue(Z);
                if (ye)
                    return clearTimeout(Y),
                    Y = setTimeout(ct, m),
                    Ve(Z)
            }
            return Y === void 0 && (Y = setTimeout(ct, m)),
            H
        }
        return Zn.cancel = $n,
        Zn.flush = vi,
        Zn
    }
    var AP = EP;
    function PP(u) {
        var m = u == null ? 0 : u.length;
        return m ? u[m - 1] : void 0
    }
    var RP = PP;
    function CP(u, m) {
        return m.length < 2 ? u : qo(u, Sg(m, 0, -1))
    }
    var IP = CP;
    function LP(u) {
        return typeof u == "number" && u == jn(u)
    }
    var DP = LP;
    function OP(u, m) {
        var x = {};
        return m = mP(m),
        TP(u, function(M, C, D) {
            zr(x, C, m(M, C, D))
        }),
        x
    }
    var UP = OP;
    function NP(u, m) {
        return m = qs(m, u),
        u = IP(u, m),
        u == null || delete u[cr(RP(m))]
    }
    var FP = NP
      , BP = 9007199254740991
      , kP = Math.floor;
    function zP(u, m) {
        var x = "";
        if (!u || m < 1 || m > BP)
            return x;
        do
            m % 2 && (x += u),
            m = kP(m / 2),
            m && (u += u);
        while (m);
        return x
    }
    var av = zP
      , HP = ov("length")
      , VP = HP
      , lv = "\\ud800-\\udfff"
      , GP = "\\u0300-\\u036f"
      , WP = "\\ufe20-\\ufe2f"
      , jP = "\\u20d0-\\u20ff"
      , XP = GP + WP + jP
      , qP = "\\ufe0e\\ufe0f"
      , KP = "[" + lv + "]"
      , Ad = "[" + XP + "]"
      , Pd = "\\ud83c[\\udffb-\\udfff]"
      , YP = "(?:" + Ad + "|" + Pd + ")"
      , cv = "[^" + lv + "]"
      , uv = "(?:\\ud83c[\\udde6-\\uddff]){2}"
      , hv = "[\\ud800-\\udbff][\\udc00-\\udfff]"
      , $P = "\\u200d"
      , fv = YP + "?"
      , dv = "[" + qP + "]?"
      , ZP = "(?:" + $P + "(?:" + [cv, uv, hv].join("|") + ")" + dv + fv + ")*"
      , JP = dv + fv + ZP
      , QP = "(?:" + [cv + Ad + "?", Ad, uv, hv, KP].join("|") + ")"
      , pv = RegExp(Pd + "(?=" + Pd + ")|" + QP + JP, "g");
    function eR(u) {
        for (var m = pv.lastIndex = 0; pv.test(u); )
            ++m;
        return m
    }
    var tR = eR;
    function nR(u) {
        return _d(u) ? tR(u) : VP(u)
    }
    var mv = nR
      , iR = Math.ceil;
    function rR(u, m) {
        m = m === void 0 ? " " : eu(m);
        var x = m.length;
        if (x < 2)
            return x ? av(m, u) : m;
        var M = av(m, iR(u / mv(m)));
        return _d(m) ? hw(Bw(M), 0, u).join("") : M.slice(0, u)
    }
    var sR = rR;
    function oR(u, m, x) {
        u = tu(u),
        m = jn(m);
        var M = m ? mv(u) : 0;
        return m && M < m ? sR(m - M, x) + u : u
    }
    var Hl = oR;
    function aR(u, m) {
        return u == null ? !0 : FP(u, m)
    }
    var _v = aR
      , lR = 5 * 1e3
      , cR = class {
        constructor(u) {
            S(this, "_cache", new ps),
            S(this, "_keepHotUntapDebounce"),
            J(this, u)
        }
        get type() {
            return "Theatre_SheetObject_PublicAPI"
        }
        get props() {
            return K(this).propsP
        }
        get sheet() {
            return K(this).sheet.publicApi
        }
        get project() {
            return K(this).sheet.project.publicApi
        }
        get address() {
            return p({}, K(this).address)
        }
        _valuesPrism() {
            return this._cache.get("_valuesPrism", ()=>{
                const u = K(this);
                return (0,
                Ul.prism)(()=>(0,
                Ul.val)(u.getValues().getValue()))
            }
            )
        }
        onValuesChange(u, m) {
            return ep(this._valuesPrism(), u, m)
        }
        get value() {
            const u = this._valuesPrism();
            {
                if (!u.isHot) {
                    this._keepHotUntapDebounce != null && this._keepHotUntapDebounce.flush();
                    const m = u.keepHot();
                    this._keepHotUntapDebounce = AP(()=>{
                        m(),
                        this._keepHotUntapDebounce = void 0
                    }
                    , lR)
                }
                this._keepHotUntapDebounce && this._keepHotUntapDebounce()
            }
            return u.getValue()
        }
        set initialValue(u) {
            K(this).setInitialValue(u)
        }
    }
    ;
    function uR(u) {
        const m = new WeakMap;
        return x=>(m.has(x) || m.set(x, u(x)),
        m.get(x))
    }
    function bu(u) {
        return u.type === "compound" || u.type === "enum"
    }
    function Rd(u, m) {
        if (!u)
            return;
        const [x,...M] = m;
        if (x === void 0)
            return u;
        if (!bu(u))
            return;
        const C = u.type === "enum" ? u.cases[x] : u.props[x];
        return Rd(C, M)
    }
    function hR(u) {
        return !bu(u)
    }
    var fR = class {
        constructor(u, m, x) {
            this.sheet = u,
            this.template = m,
            this.nativeObject = x,
            S(this, "$$isPointerToPrismProvider", !0),
            S(this, "address"),
            S(this, "publicApi"),
            S(this, "_initialValue", new Dt.Atom({})),
            S(this, "_cache", new ps),
            S(this, "_logger"),
            S(this, "_internalUtilCtx"),
            this._logger = u._logger.named("SheetObject", m.address.objectKey),
            this._logger._trace("creating object"),
            this._internalUtilCtx = {
                logger: this._logger.utilFor.internal()
            },
            this.address = g(p({}, m.address), {
                sheetInstanceId: u.address.sheetInstanceId
            }),
            this.publicApi = new cR(this)
        }
        get type() {
            return "Theatre_SheetObject"
        }
        getValues() {
            return this._cache.get("getValues()", ()=>(0,
            Dt.prism)(()=>{
                const u = (0,
                Dt.val)(this.template.getDefaultValues())
                  , m = (0,
                Dt.val)(this._initialValue.pointer)
                  , x = Dt.prism.memo("withInitialCache", ()=>new WeakMap, [])
                  , M = $s(u, m, x)
                  , C = (0,
                Dt.val)(this.template.getStaticValues())
                  , D = Dt.prism.memo("withStatics", ()=>new WeakMap, []);
                let Y = $s(M, C, D), Z;
                {
                    const ve = Dt.prism.memo("seq", ()=>this.getSequencedValues(), [])
                      , ye = Dt.prism.memo("withSeqsCache", ()=>new WeakMap, []);
                    Z = (0,
                    Dt.val)((0,
                    Dt.val)(ve)),
                    Y = $s(Y, Z, ye)
                }
                return uu("finalAtom", Y).pointer
            }
            ))
        }
        getValueByPointer(u) {
            const m = (0,
            Dt.val)(this.getValues())
              , {path: x} = (0,
            Dt.getPointerParts)(u);
            return (0,
            Dt.val)(Zs(m, x))
        }
        pointerToPrism(u) {
            const {path: m} = (0,
            Dt.getPointerParts)(u);
            return (0,
            Dt.prism)(()=>{
                const x = (0,
                Dt.val)(this.getValues());
                return (0,
                Dt.val)(Zs(x, m))
            }
            )
        }
        getSequencedValues() {
            return (0,
            Dt.prism)(()=>{
                const u = Dt.prism.memo("tracksToProcess", ()=>this.template.getArrayOfValidSequenceTracks(), [])
                  , m = (0,
                Dt.val)(u)
                  , x = new Dt.Atom({})
                  , M = (0,
                Dt.val)(this.template.configPointer);
                return Dt.prism.effect("processTracks", ()=>{
                    const C = [];
                    for (const {trackId: D, pathToProp: H} of m) {
                        const Y = this._trackIdToPrism(D)
                          , Z = Rd(M, H)
                          , se = Z.deserializeAndSanitize
                          , ve = Z.interpolate
                          , ye = ()=>{
                            const Ve = Y.getValue();
                            if (!Ve)
                                return x.setByPointer(wt=>Zs(wt, H), void 0);
                            const Ue = se(Ve.left)
                              , ht = Ue === void 0 ? Z.default : Ue;
                            if (Ve.right === void 0)
                                return x.setByPointer(wt=>Zs(wt, H), ht);
                            const mt = se(Ve.right)
                              , ct = mt === void 0 ? Z.default : mt;
                            return x.setByPointer(wt=>Zs(wt, H), ve(ht, ct, Ve.progression))
                        }
                          , Re = Y.onStale(ye);
                        ye(),
                        C.push(Re)
                    }
                    return ()=>{
                        for (const D of C)
                            D()
                    }
                }
                , [M, ...m]),
                x.pointer
            }
            )
        }
        _trackIdToPrism(u) {
            const m = this.template.project.pointers.historic.sheetsById[this.address.sheetId].sequence.tracksByObject[this.address.objectKey].trackData[u]
              , x = this.sheet.getSequence().positionPrism;
            return td(this._internalUtilCtx, m, x)
        }
        get propsP() {
            return this._cache.get("propsP", ()=>(0,
            Dt.pointer)({
                root: this,
                path: []
            }))
        }
        validateValue(u, m) {}
        setInitialValue(u) {
            this.validateValue(this.propsP, u),
            this._initialValue.set(u)
        }
    }
    ;
    function jt(u) {
        return function(x, M) {
            return u(x, M())
        }
    }
    var Ai = {
        _hmm: Pi(524),
        _todo: Pi(522),
        _error: Pi(521),
        errorDev: Pi(529),
        errorPublic: Pi(545),
        _kapow: Pi(268),
        _warn: Pi(265),
        warnDev: Pi(273),
        warnPublic: Pi(289),
        _debug: Pi(137),
        debugDev: Pi(145),
        _trace: Pi(73),
        traceDev: Pi(81)
    };
    function Pi(u) {
        return Object.freeze({
            audience: to(u, 8) ? "internal" : to(u, 16) ? "dev" : "public",
            category: to(u, 4) ? "troubleshooting" : to(u, 2) ? "todo" : "general",
            level: to(u, 512) ? 512 : to(u, 256) ? 256 : to(u, 128) ? 128 : 64
        })
    }
    function to(u, m) {
        return (u & m) === m
    }
    function Xt(u, m) {
        return ((m & 32) === 32 ? !0 : (m & 16) === 16 ? u.dev : (m & 8) === 8 ? u.internal : !1) && u.min <= m
    }
    var Hr = {
        loggingConsoleStyle: !0,
        loggerConsoleStyle: !0,
        includes: Object.freeze({
            internal: !1,
            dev: !1,
            min: 256
        }),
        filtered: function() {},
        include: function() {
            return {}
        },
        create: null,
        creatExt: null,
        named(u, m, x) {
            return this.create({
                names: [...u.names, {
                    name: m,
                    key: x
                }]
            })
        },
        style: {
            bold: void 0,
            italic: void 0,
            cssMemo: new Map([["", ""]]),
            collapseOnRE: /[a-z- ]+/g,
            color: void 0,
            collapsed(u) {
                if (u.length < 5)
                    return u;
                const m = u.replace(this.collapseOnRE, "");
                return this.cssMemo.has(m) || this.cssMemo.set(m, this.css(u)),
                m
            },
            css(u) {
                var m, x, M, C;
                const D = this.cssMemo.get(u);
                if (D)
                    return D;
                let H = "color:".concat((x = (m = this.color) == null ? void 0 : m.call(this, u)) != null ? x : "hsl(".concat((u.charCodeAt(0) + u.charCodeAt(u.length - 1)) % 360, ", 100%, 60%)"));
                return (M = this.bold) != null && M.test(u) && (H += ";font-weight:600"),
                (C = this.italic) != null && C.test(u) && (H += ";font-style:italic"),
                this.cssMemo.set(u, H),
                H
            }
        }
    };
    function gv(u=console, m={}) {
        const x = g(p({}, Hr), {
            includes: p({}, Hr.includes)
        })
          , M = {
            styled: mR.bind(x, u),
            noStyle: gR.bind(x, u)
        }
          , C = pR.bind(x);
        function D() {
            return x.loggingConsoleStyle && x.loggerConsoleStyle ? M.styled : M.noStyle
        }
        return x.create = D(),
        {
            configureLogger(H) {
                var Y;
                H === "console" ? (x.loggerConsoleStyle = Hr.loggerConsoleStyle,
                x.create = D()) : H.type === "console" ? (x.loggerConsoleStyle = (Y = H.style) != null ? Y : Hr.loggerConsoleStyle,
                x.create = D()) : H.type === "keyed" ? (x.creatExt = Z=>H.keyed(Z.names),
                x.create = C) : H.type === "named" && (x.creatExt = dR.bind(null, H.named),
                x.create = C)
            },
            configureLogging(H) {
                var Y, Z, se, ve, ye;
                x.includes.dev = (Y = H.dev) != null ? Y : Hr.includes.dev,
                x.includes.internal = (Z = H.internal) != null ? Z : Hr.includes.internal,
                x.includes.min = (se = H.min) != null ? se : Hr.includes.min,
                x.include = (ve = H.include) != null ? ve : Hr.include,
                x.loggingConsoleStyle = (ye = H.consoleStyle) != null ? ye : Hr.loggingConsoleStyle,
                x.create = D()
            },
            getLogger() {
                return x.create({
                    names: []
                })
            }
        }
    }
    function dR(u, m) {
        const x = [];
        for (let {name: M, key: C} of m.names)
            x.push(C == null ? M : "".concat(M, " (").concat(C, ")"));
        return u(x)
    }
    function pR(u) {
        const m = p(p({}, this.includes), this.include(u))
          , x = this.filtered
          , M = this.named.bind(this, u)
          , C = this.creatExt(u)
          , D = Xt(m, 524)
          , H = Xt(m, 522)
          , Y = Xt(m, 521)
          , Z = Xt(m, 529)
          , se = Xt(m, 545)
          , ve = Xt(m, 265)
          , ye = Xt(m, 268)
          , Re = Xt(m, 273)
          , Ve = Xt(m, 289)
          , Ue = Xt(m, 137)
          , ht = Xt(m, 145)
          , mt = Xt(m, 73)
          , ct = Xt(m, 81)
          , wt = D ? C.error.bind(C, Ai._hmm) : x.bind(u, 524)
          , $n = H ? C.error.bind(C, Ai._todo) : x.bind(u, 522)
          , vi = Y ? C.error.bind(C, Ai._error) : x.bind(u, 521)
          , Zn = Z ? C.error.bind(C, Ai.errorDev) : x.bind(u, 529)
          , kt = se ? C.error.bind(C, Ai.errorPublic) : x.bind(u, 545)
          , Jn = ye ? C.warn.bind(C, Ai._kapow) : x.bind(u, 268)
          , Ci = ve ? C.warn.bind(C, Ai._warn) : x.bind(u, 265)
          , wr = Re ? C.warn.bind(C, Ai.warnDev) : x.bind(u, 273)
          , ao = Ve ? C.warn.bind(C, Ai.warnPublic) : x.bind(u, 273)
          , lo = Ue ? C.debug.bind(C, Ai._debug) : x.bind(u, 137)
          , co = ht ? C.debug.bind(C, Ai.debugDev) : x.bind(u, 145)
          , uo = mt ? C.trace.bind(C, Ai._trace) : x.bind(u, 73)
          , ho = ct ? C.trace.bind(C, Ai.traceDev) : x.bind(u, 81)
          , xn = {
            _hmm: wt,
            _todo: $n,
            _error: vi,
            errorDev: Zn,
            errorPublic: kt,
            _kapow: Jn,
            _warn: Ci,
            warnDev: wr,
            warnPublic: ao,
            _debug: lo,
            debugDev: co,
            _trace: uo,
            traceDev: ho,
            lazy: {
                _hmm: D ? jt(wt) : wt,
                _todo: H ? jt($n) : $n,
                _error: Y ? jt(vi) : vi,
                errorDev: Z ? jt(Zn) : Zn,
                errorPublic: se ? jt(kt) : kt,
                _kapow: ye ? jt(Jn) : Jn,
                _warn: ve ? jt(Ci) : Ci,
                warnDev: Re ? jt(wr) : wr,
                warnPublic: Ve ? jt(ao) : ao,
                _debug: Ue ? jt(lo) : lo,
                debugDev: ht ? jt(co) : co,
                _trace: mt ? jt(uo) : uo,
                traceDev: ct ? jt(ho) : ho
            },
            named: M,
            utilFor: {
                internal() {
                    return {
                        debug: xn._debug,
                        error: xn._error,
                        warn: xn._warn,
                        trace: xn._trace,
                        named(Ii, qt) {
                            return xn.named(Ii, qt).utilFor.internal()
                        }
                    }
                },
                dev() {
                    return {
                        debug: xn.debugDev,
                        error: xn.errorDev,
                        warn: xn.warnDev,
                        trace: xn.traceDev,
                        named(Ii, qt) {
                            return xn.named(Ii, qt).utilFor.dev()
                        }
                    }
                },
                public() {
                    return {
                        error: xn.errorPublic,
                        warn: xn.warnPublic,
                        debug(Ii, qt) {
                            xn._warn('(public "debug" filtered out) '.concat(Ii), qt)
                        },
                        trace(Ii, qt) {
                            xn._warn('(public "trace" filtered out) '.concat(Ii), qt)
                        },
                        named(Ii, qt) {
                            return xn.named(Ii, qt).utilFor.public()
                        }
                    }
                }
            }
        };
        return xn
    }
    function mR(u, m) {
        const x = p(p({}, this.includes), this.include(m))
          , M = [];
        let C = "";
        for (let Z = 0; Z < m.names.length; Z++) {
            const {name: se, key: ve} = m.names[Z];
            if (C += " %c".concat(se),
            M.push(this.style.css(se)),
            ve != null) {
                const ye = "%c#".concat(ve);
                C += ye,
                M.push(this.style.css(ye))
            }
        }
        const D = this.filtered
          , H = this.named.bind(this, m)
          , Y = [C, ...M];
        return vv(D, m, x, u, Y, _R(Y), H)
    }
    function _R(u) {
        const m = u.slice(0);
        for (let x = 1; x < m.length; x++)
            m[x] += ";background-color:#e0005a;padding:2px;color:white";
        return m
    }
    function gR(u, m) {
        const x = p(p({}, this.includes), this.include(m));
        let M = "";
        for (let Y = 0; Y < m.names.length; Y++) {
            const {name: Z, key: se} = m.names[Y];
            M += " ".concat(Z),
            se != null && (M += "#".concat(se))
        }
        const C = this.filtered
          , D = this.named.bind(this, m)
          , H = [M];
        return vv(C, m, x, u, H, H, D)
    }
    function vv(u, m, x, M, C, D, H) {
        const Y = Xt(x, 524)
          , Z = Xt(x, 522)
          , se = Xt(x, 521)
          , ve = Xt(x, 529)
          , ye = Xt(x, 545)
          , Re = Xt(x, 265)
          , Ve = Xt(x, 268)
          , Ue = Xt(x, 273)
          , ht = Xt(x, 289)
          , mt = Xt(x, 137)
          , ct = Xt(x, 145)
          , wt = Xt(x, 73)
          , $n = Xt(x, 81)
          , vi = Y ? M.error.bind(M, ...C) : u.bind(m, 524)
          , Zn = Z ? M.error.bind(M, ...C) : u.bind(m, 522)
          , kt = se ? M.error.bind(M, ...C) : u.bind(m, 521)
          , Jn = ve ? M.error.bind(M, ...C) : u.bind(m, 529)
          , Ci = ye ? M.error.bind(M, ...C) : u.bind(m, 545)
          , wr = Ve ? M.warn.bind(M, ...D) : u.bind(m, 268)
          , ao = Re ? M.warn.bind(M, ...C) : u.bind(m, 265)
          , lo = Ue ? M.warn.bind(M, ...C) : u.bind(m, 273)
          , co = ht ? M.warn.bind(M, ...C) : u.bind(m, 273)
          , uo = mt ? M.info.bind(M, ...C) : u.bind(m, 137)
          , ho = ct ? M.info.bind(M, ...C) : u.bind(m, 145)
          , xn = wt ? M.debug.bind(M, ...C) : u.bind(m, 73)
          , Ii = $n ? M.debug.bind(M, ...C) : u.bind(m, 81)
          , qt = {
            _hmm: vi,
            _todo: Zn,
            _error: kt,
            errorDev: Jn,
            errorPublic: Ci,
            _kapow: wr,
            _warn: ao,
            warnDev: lo,
            warnPublic: co,
            _debug: uo,
            debugDev: ho,
            _trace: xn,
            traceDev: Ii,
            lazy: {
                _hmm: Y ? jt(vi) : vi,
                _todo: Z ? jt(Zn) : Zn,
                _error: se ? jt(kt) : kt,
                errorDev: ve ? jt(Jn) : Jn,
                errorPublic: ye ? jt(Ci) : Ci,
                _kapow: Ve ? jt(wr) : wr,
                _warn: Re ? jt(ao) : ao,
                warnDev: Ue ? jt(lo) : lo,
                warnPublic: ht ? jt(co) : co,
                _debug: mt ? jt(uo) : uo,
                debugDev: ct ? jt(ho) : ho,
                _trace: wt ? jt(xn) : xn,
                traceDev: $n ? jt(Ii) : Ii
            },
            named: H,
            utilFor: {
                internal() {
                    return {
                        debug: qt._debug,
                        error: qt._error,
                        warn: qt._warn,
                        trace: qt._trace,
                        named(Wr, jr) {
                            return qt.named(Wr, jr).utilFor.internal()
                        }
                    }
                },
                dev() {
                    return {
                        debug: qt.debugDev,
                        error: qt.errorDev,
                        warn: qt.warnDev,
                        trace: qt.traceDev,
                        named(Wr, jr) {
                            return qt.named(Wr, jr).utilFor.dev()
                        }
                    }
                },
                public() {
                    return {
                        error: qt.errorPublic,
                        warn: qt.warnPublic,
                        debug(Wr, jr) {
                            qt._warn('(public "debug" filtered out) '.concat(Wr), jr)
                        },
                        trace(Wr, jr) {
                            qt._warn('(public "trace" filtered out) '.concat(Wr), jr)
                        },
                        named(Wr, jr) {
                            return qt.named(Wr, jr).utilFor.public()
                        }
                    }
                }
            }
        };
        return qt
    }
    var yv = gv(console, {
        _debug: function() {},
        _error: function() {}
    });
    yv.configureLogging({
        dev: !0,
        min: 64
    });
    var Su = yv.getLogger().named("Theatre.js (default logger)").utilFor.dev()
      , xv = new WeakMap;
    function vR(u) {
        const m = xv.get(u);
        if (m)
            return m;
        const x = new Map;
        return xv.set(u, x),
        Tv([], u, x),
        x
    }
    function Tv(u, m, x) {
        for (const [M,C] of Object.entries(m.props))
            if (!bu(C)) {
                const D = [...u, M];
                x.set(JSON.stringify(D), x.size),
                bv(D, C, x)
            }
        for (const [M,C] of Object.entries(m.props))
            if (bu(C)) {
                const D = [...u, M];
                x.set(JSON.stringify(D), x.size),
                bv(D, C, x)
            }
    }
    function bv(u, m, x) {
        if (m.type === "compound")
            Tv(u, m, x);
        else {
            if (m.type === "enum")
                throw new Error("Enums aren't supported yet");
            x.set(JSON.stringify(u), x.size)
        }
    }
    function Sv(u) {
        return typeof u == "object" && u !== null && Object.keys(u).length === 0
    }
    var yR = class {
        constructor(u, m, x, M, C) {
            this.sheetTemplate = u,
            S(this, "address"),
            S(this, "type", "Theatre_SheetObjectTemplate"),
            S(this, "_config"),
            S(this, "_temp_actions_atom"),
            S(this, "_cache", new ps),
            S(this, "project"),
            S(this, "pointerToSheetState"),
            S(this, "pointerToStaticOverrides"),
            this.address = g(p({}, u.address), {
                objectKey: m
            }),
            this._config = new In.Atom(M),
            this._temp_actions_atom = new In.Atom(C),
            this.project = u.project,
            this.pointerToSheetState = this.sheetTemplate.project.pointers.historic.sheetsById[this.address.sheetId],
            this.pointerToStaticOverrides = this.pointerToSheetState.staticOverrides.byObject[this.address.objectKey]
        }
        get staticConfig() {
            return this._config.get()
        }
        get configPointer() {
            return this._config.pointer
        }
        get _temp_actions() {
            return this._temp_actions_atom.get()
        }
        get _temp_actionsPointer() {
            return this._temp_actions_atom.pointer
        }
        createInstance(u, m, x) {
            return this._config.set(x),
            new fR(u,this,m)
        }
        reconfigure(u) {
            this._config.set(u)
        }
        _temp_setActions(u) {
            this._temp_actions_atom.set(u)
        }
        getDefaultValues() {
            return this._cache.get("getDefaultValues()", ()=>(0,
            In.prism)(()=>{
                const u = (0,
                In.val)(this.configPointer);
                return Qf(u)
            }
            ))
        }
        getStaticValues() {
            return this._cache.get("getStaticValues", ()=>(0,
            In.prism)(()=>{
                var u;
                const m = (u = (0,
                In.val)(this.pointerToStaticOverrides)) != null ? u : {};
                return (0,
                In.val)(this.configPointer).deserializeAndSanitize(m) || {}
            }
            ))
        }
        getArrayOfValidSequenceTracks() {
            return this._cache.get("getArrayOfValidSequenceTracks", ()=>(0,
            In.prism)(()=>{
                const u = this.project.pointers.historic.sheetsById[this.address.sheetId]
                  , m = (0,
                In.val)(u.sequence.tracksByObject[this.address.objectKey].trackIdByPropPath);
                if (!m)
                    return de;
                const x = [];
                if (!m)
                    return de;
                const M = (0,
                In.val)(this.configPointer)
                  , C = Object.entries(m);
                for (const [H,Y] of C) {
                    const Z = xR(H);
                    if (!Z)
                        continue;
                    const se = Rd(M, Z);
                    se && hR(se) && x.push({
                        pathToProp: Z,
                        trackId: Y
                    })
                }
                const D = vR(M);
                return x.sort((H,Y)=>{
                    const Z = H.pathToProp
                      , se = Y.pathToProp
                      , ve = D.get(JSON.stringify(Z))
                      , ye = D.get(JSON.stringify(se));
                    return ve > ye ? 1 : -1
                }
                ),
                x.length === 0 ? de : x
            }
            ))
        }
        getMapOfValidSequenceTracks_forStudio() {
            return this._cache.get("getMapOfValidSequenceTracks_forStudio", ()=>(0,
            In.prism)(()=>{
                const u = (0,
                In.val)(this.getArrayOfValidSequenceTracks());
                let m = {};
                for (const {pathToProp: x, trackId: M} of u)
                    Yo(m, x, M);
                return m
            }
            ))
        }
        getStaticButNotSequencedOverrides() {
            return this._cache.get("getStaticButNotSequencedOverrides", ()=>(0,
            In.prism)(()=>{
                const u = (0,
                In.val)(this.getStaticValues())
                  , m = (0,
                In.val)(this.getArrayOfValidSequenceTracks())
                  , x = t1(u);
                for (const {pathToProp: M} of m) {
                    _v(x, M);
                    let C = M.slice(0, -1);
                    for (; C.length > 0; ) {
                        const D = iu(x, C);
                        if (!Sv(D))
                            break;
                        _v(x, C),
                        C = C.slice(0, -1)
                    }
                }
                if (!Sv(x))
                    return x
            }
            ))
        }
        getDefaultsAtPointer(u) {
            const {path: m} = (0,
            In.getPointerParts)(u)
              , x = this.getDefaultValues().getValue();
            return iu(x, m)
        }
    }
    ;
    function xR(u) {
        try {
            return JSON.parse(u)
        } catch {
            Su.warn("property ".concat(JSON.stringify(u), " cannot be parsed. Skipping."));
            return
        }
    }
    var Mv = bn
      , TR = uR(u=>JSON.stringify(u));
    b(R());
    var bR = class extends Error {
    }
      , Vl = class extends bR {
    }
      , wv = bn
      , SR = bn
      , MR = bn
      , Xn = bn;
    function _s() {
        let u, m;
        const x = new Promise((C,D)=>{
            u = H=>{
                C(H),
                M.status = "resolved"
            }
            ,
            m = H=>{
                D(H),
                M.status = "rejected"
            }
        }
        )
          , M = {
            resolve: u,
            reject: m,
            promise: x,
            status: "pending"
        };
        return M
    }
    var wR = ()=>{}
      , Mu = wR
      , ER = bn
      , AR = class {
        constructor() {
            S(this, "_stopPlayCallback", Mu),
            S(this, "_state", new ER.Atom({
                position: 0,
                playing: !1
            })),
            S(this, "statePointer"),
            this.statePointer = this._state.pointer
        }
        destroy() {}
        pause() {
            this._stopPlayCallback(),
            this.playing = !1,
            this._stopPlayCallback = Mu
        }
        gotoPosition(u) {
            this._updatePositionInState(u)
        }
        _updatePositionInState(u) {
            this._state.setByPointer(m=>m.position, u)
        }
        getCurrentPosition() {
            return this._state.get().position
        }
        get playing() {
            return this._state.get().playing
        }
        set playing(u) {
            this._state.setByPointer(m=>m.playing, u)
        }
        play(u, m, x, M, C) {
            this.playing && this.pause(),
            this.playing = !0;
            const D = m[1] - m[0];
            {
                const Re = this.getCurrentPosition();
                Re < m[0] || Re > m[1] ? M === "normal" || M === "alternate" ? this._updatePositionInState(m[0]) : (M === "reverse" || M === "alternateReverse") && this._updatePositionInState(m[1]) : M === "normal" || M === "alternate" ? Re === m[1] && this._updatePositionInState(m[0]) : Re === m[0] && this._updatePositionInState(m[1])
            }
            const H = _s()
              , Y = C.time
              , Z = D * u;
            let se = this.getCurrentPosition() - m[0];
            (M === "reverse" || M === "alternateReverse") && (se = m[1] - this.getCurrentPosition());
            const ve = Re=>{
                const Ue = Math.max(Re - Y, 0) / 1e3
                  , ht = Math.min(Ue * x + se, Z);
                if (ht !== Z) {
                    const mt = Math.floor(ht / D);
                    let ct = ht / D % 1 * D;
                    if (M !== "normal")
                        if (M === "reverse")
                            ct = D - ct;
                        else {
                            const wt = mt % 2 === 0;
                            M === "alternate" ? wt || (ct = D - ct) : wt && (ct = D - ct)
                        }
                    this._updatePositionInState(ct + m[0]),
                    ye()
                } else {
                    if (M === "normal")
                        this._updatePositionInState(m[1]);
                    else if (M === "reverse")
                        this._updatePositionInState(m[0]);
                    else {
                        const mt = (u - 1) % 2 === 0;
                        M === "alternate" ? mt ? this._updatePositionInState(m[1]) : this._updatePositionInState(m[0]) : mt ? this._updatePositionInState(m[0]) : this._updatePositionInState(m[1])
                    }
                    this.playing = !1,
                    H.resolve(!0)
                }
            }
            ;
            this._stopPlayCallback = ()=>{
                C.offThisOrNextTick(ve),
                C.offNextTick(ve),
                this.playing && H.resolve(!1)
            }
            ;
            const ye = ()=>C.onNextTick(ve);
            return C.onThisOrNextTick(ve),
            H.promise
        }
        playDynamicRange(u, m) {
            this.playing && this.pause(),
            this.playing = !0;
            const x = _s()
              , M = u.keepHot();
            x.promise.then(M, M);
            let C = m.time;
            const D = Y=>{
                const Z = Math.max(Y - C, 0);
                C = Y;
                const se = Z / 1e3
                  , ve = this.getCurrentPosition()
                  , ye = u.getValue();
                if (ve < ye[0] || ve > ye[1])
                    this.gotoPosition(ye[0]);
                else {
                    let Re = ve + se;
                    Re > ye[1] && (Re = ye[0] + (Re - ye[1])),
                    this.gotoPosition(Re)
                }
                H()
            }
            ;
            this._stopPlayCallback = ()=>{
                m.offThisOrNextTick(D),
                m.offNextTick(D),
                x.resolve(!1)
            }
            ;
            const H = ()=>m.onNextTick(D);
            return m.onThisOrNextTick(D),
            x.promise
        }
    }
      , PR = bn
      , RR = "__TheatreJS_StudioBundle"
      , Cd = "__TheatreJS_CoreBundle"
      , CR = "__TheatreJS_Notifications"
      , wu = u=>(...m)=>{
        var x;
        switch (u) {
        case "success":
            {
                Su.debug(m.slice(0, 2).join(`
`));
                break
            }
        case "info":
            {
                Su.debug(m.slice(0, 2).join(`
`));
                break
            }
        case "warning":
            {
                Su.warn(m.slice(0, 2).join(`
`));
                break
            }
        }
        return typeof window < "u" ? (x = window[CR]) == null ? void 0 : x.notify[u](...m) : void 0
    }
      , Qo = {
        warning: wu("warning"),
        success: wu("success"),
        info: wu("info"),
        error: wu("error")
    };
    typeof window < "u" && (window.addEventListener("error", u=>{
        Qo.error("An error occurred", "<pre>".concat(u.message, `</pre>

See **console** for details.`))
    }
    ),
    window.addEventListener("unhandledrejection", u=>{
        Qo.error("An error occurred", "<pre>".concat(u.reason, `</pre>

See **console** for details.`))
    }
    ));
    var IR = class {
        constructor(u, m, x) {
            this._decodedBuffer = u,
            this._audioContext = m,
            this._nodeDestination = x,
            S(this, "_mainGain"),
            S(this, "_state", new PR.Atom({
                position: 0,
                playing: !1
            })),
            S(this, "statePointer"),
            S(this, "_stopPlayCallback", Mu),
            this.statePointer = this._state.pointer,
            this._mainGain = this._audioContext.createGain(),
            this._mainGain.connect(this._nodeDestination)
        }
        playDynamicRange(u, m) {
            const x = _s();
            this._playing && this.pause(),
            this._playing = !0;
            let M;
            const C = ()=>{
                M?.(),
                M = this._loopInRange(u.getValue(), m).stop
            }
              , D = u.onStale(C);
            return C(),
            this._stopPlayCallback = ()=>{
                M?.(),
                D(),
                x.resolve(!1)
            }
            ,
            x.promise
        }
        _loopInRange(u, m) {
            let M = this.getCurrentPosition();
            const C = u[1] - u[0];
            M < u[0] || M > u[1] ? this._updatePositionInState(u[0]) : M === u[1] && this._updatePositionInState(u[0]),
            M = this.getCurrentPosition();
            const D = this._audioContext.createBufferSource();
            D.buffer = this._decodedBuffer,
            D.connect(this._mainGain),
            D.playbackRate.value = 1,
            D.loop = !0,
            D.loopStart = u[0],
            D.loopEnd = u[1];
            const H = m.time;
            let Y = M - u[0];
            D.start(0, M);
            const Z = ye=>{
                let ht = (Math.max(ye - H, 0) / 1e3 * 1 + Y) / C % 1 * C;
                this._updatePositionInState(ht + u[0]),
                se()
            }
              , se = ()=>m.onNextTick(Z);
            return m.onThisOrNextTick(Z),
            {
                stop: ()=>{
                    D.stop(),
                    D.disconnect(),
                    m.offThisOrNextTick(Z),
                    m.offNextTick(Z)
                }
            }
        }
        get _playing() {
            return this._state.get().playing
        }
        set _playing(u) {
            this._state.setByPointer(m=>m.playing, u)
        }
        destroy() {}
        pause() {
            this._stopPlayCallback(),
            this._playing = !1,
            this._stopPlayCallback = Mu
        }
        gotoPosition(u) {
            this._updatePositionInState(u)
        }
        _updatePositionInState(u) {
            this._state.reduce(m=>g(p({}, m), {
                position: u
            }))
        }
        getCurrentPosition() {
            return this._state.get().position
        }
        play(u, m, x, M, C) {
            this._playing && this.pause(),
            this._playing = !0;
            let D = this.getCurrentPosition();
            const H = m[1] - m[0];
            if (M !== "normal")
                throw new Vl('Audio-controlled sequences can only be played in the "normal" direction. ' + "'".concat(M, "' given."));
            D < m[0] || D > m[1] ? this._updatePositionInState(m[0]) : D === m[1] && this._updatePositionInState(m[0]),
            D = this.getCurrentPosition();
            const Y = _s()
              , Z = this._audioContext.createBufferSource();
            Z.buffer = this._decodedBuffer,
            Z.connect(this._mainGain),
            Z.playbackRate.value = x,
            u > 1e3 && (Qo.warning("Can't play sequences with audio more than 1000 times", "The sequence will still play, but only 1000 times. The `iterationCount: ".concat(u, "` provided to `sequence.play()`\nis too high for a sequence with audio.\n\nTo fix this, either set `iterationCount` to a lower value, or remove the audio from the sequence."), [{
                url: "https://www.theatrejs.com/docs/latest/manual/audio",
                title: "Using Audio"
            }, {
                url: "https://www.theatrejs.com/docs/latest/api/core#sequence.attachaudio",
                title: "Audio API"
            }]),
            u = 1e3),
            u > 1 && (Z.loop = !0,
            Z.loopStart = m[0],
            Z.loopEnd = m[1]);
            const se = C.time;
            let ve = D - m[0];
            const ye = H * u;
            Z.start(0, D, ye - ve);
            const Re = ht=>{
                const ct = Math.max(ht - se, 0) / 1e3
                  , wt = Math.min(ct * x + ve, ye);
                if (wt !== ye) {
                    let $n = wt / H % 1 * H;
                    this._updatePositionInState($n + m[0]),
                    Ue()
                } else
                    this._updatePositionInState(m[1]),
                    this._playing = !1,
                    Ve(),
                    Y.resolve(!0)
            }
              , Ve = ()=>{
                Z.stop(),
                Z.disconnect()
            }
            ;
            this._stopPlayCallback = ()=>{
                Ve(),
                C.offThisOrNextTick(Re),
                C.offNextTick(Re),
                this._playing && Y.resolve(!1)
            }
            ;
            const Ue = ()=>C.onNextTick(Re);
            return C.onThisOrNextTick(Re),
            Y.promise
        }
    }
      , LR = bn
      , Ev = 0;
    function Id(u) {
        var m;
        const x = H=>{
            M.tick(H)
        }
          , M = new LR.Ticker({
            onActive() {
                var H;
                (H = u?.start) == null || H.call(u)
            },
            onDormant() {
                var H;
                (H = u?.stop) == null || H.call(u)
            }
        })
          , C = {
            tick: x,
            id: Ev++,
            name: (m = u?.name) != null ? m : "CustomRafDriver-".concat(Ev),
            type: "Theatre_RafDriver_PublicAPI"
        }
          , D = {
            type: "Theatre_RafDriver_PrivateAPI",
            publicApi: C,
            ticker: M,
            start: u?.start,
            stop: u?.stop
        };
        return J(C, D),
        C
    }
    function DR() {
        let u = null;
        const M = Id({
            name: "DefaultCoreRafDriver",
            start: ()=>{
                if (typeof window < "u") {
                    const C = D=>{
                        M.tick(D),
                        u = window.requestAnimationFrame(C)
                    }
                    ;
                    u = window.requestAnimationFrame(C)
                } else
                    M.tick(0),
                    setTimeout(()=>M.tick(1), 0)
            }
            ,
            stop: ()=>{
                typeof window < "u" && u !== null && window.cancelAnimationFrame(u)
            }
        });
        return M
    }
    var Eu;
    function Av() {
        return Eu || OR(DR()),
        Eu
    }
    function Pv() {
        return Av().ticker
    }
    function OR(u) {
        if (Eu)
            throw new Error("`setCoreRafDriver()` is already called.");
        Eu = K(u)
    }
    var UR = class {
        get type() {
            return "Theatre_Sequence_PublicAPI"
        }
        constructor(u) {
            J(this, u)
        }
        play(u) {
            const m = K(this);
            if (m._project.isReady()) {
                const x = u?.rafDriver ? K(u.rafDriver).ticker : Pv();
                return m.play(u ?? {}, x)
            } else {
                const x = _s();
                return x.resolve(!0),
                x.promise
            }
        }
        pause() {
            K(this).pause()
        }
        get position() {
            return K(this).position
        }
        set position(u) {
            K(this).position = u
        }
        __experimental_getKeyframes(u) {
            return K(this).getKeyframesOfSimpleProp(u)
        }
        async attachAudio(u) {
            const {audioContext: m, destinationNode: x, decodedBuffer: M, gainNode: C} = await NR(u)
              , D = new IR(M,m,C);
            return K(this).replacePlaybackController(D),
            {
                audioContext: m,
                destinationNode: x,
                decodedBuffer: M,
                gainNode: C
            }
        }
        get pointer() {
            return K(this).pointer
        }
    }
    ;
    async function NR(u) {
        function m() {
            if (u.audioContext)
                return Promise.resolve(u.audioContext);
            const se = new AudioContext;
            return se.state === "running" || typeof window > "u" ? Promise.resolve(se) : new Promise(ve=>{
                const ye = ()=>{
                    se.resume().catch(Ue=>{
                        console.error(Ue)
                    }
                    )
                }
                  , Re = ["mousedown", "keydown", "touchstart"]
                  , Ve = {
                    capture: !0,
                    passive: !1
                };
                Re.forEach(Ue=>{
                    window.addEventListener(Ue, ye, Ve)
                }
                ),
                se.addEventListener("statechange", ()=>{
                    se.state === "running" && (Re.forEach(Ue=>{
                        window.removeEventListener(Ue, ye, Ve)
                    }
                    ),
                    ve(se))
                }
                )
            }
            )
        }
        async function x() {
            if (u.source instanceof AudioBuffer)
                return u.source;
            const se = _s();
            if (typeof u.source != "string")
                throw new Error("Error validating arguments to sequence.attachAudio(). args.source must either be a string or an instance of AudioBuffer.");
            let ve;
            try {
                ve = await fetch(u.source)
            } catch (Ue) {
                throw console.error(Ue),
                new Error("Could not fetch '".concat(u.source, "'. Network error logged above."))
            }
            let ye;
            try {
                ye = await ve.arrayBuffer()
            } catch (Ue) {
                throw console.error(Ue),
                new Error("Could not read '".concat(u.source, "' as an arrayBuffer."))
            }
            (await M).decodeAudioData(ye, se.resolve, se.reject);
            let Ve;
            try {
                Ve = await se.promise
            } catch (Ue) {
                throw console.error(Ue),
                new Error("Could not decode ".concat(u.source, " as an audio file."))
            }
            return Ve
        }
        const M = m()
          , C = x()
          , [D,H] = await Promise.all([M, C])
          , Y = u.destinationNode || D.destination
          , Z = D.createGain();
        return Z.connect(Y),
        {
            audioContext: D,
            decodedBuffer: H,
            gainNode: Z,
            destinationNode: Y
        }
    }
    var FR = BR("Theatre_SheetObject");
    function BR(u) {
        return m=>typeof m == "object" && !!m && m.type === u
    }
    var kR = class {
        constructor(u, m, x, M, C) {
            this._project = u,
            this._sheet = m,
            this._lengthD = x,
            this._subUnitsPerUnitD = M,
            S(this, "address"),
            S(this, "publicApi"),
            S(this, "_playbackControllerBox"),
            S(this, "_prismOfStatePointer"),
            S(this, "_positionD"),
            S(this, "_positionFormatterD"),
            S(this, "_playableRangeD"),
            S(this, "pointer", (0,
            MR.pointer)({
                root: this,
                path: []
            })),
            S(this, "$$isPointerToPrismProvider", !0),
            S(this, "_logger"),
            S(this, "closestGridPosition", D=>{
                const Y = 1 / this.subUnitsPerUnit;
                return parseFloat((Math.round(D / Y) * Y).toFixed(3))
            }
            ),
            this._logger = u._logger.named("Sheet", m.address.sheetId).named("Instance", m.address.sheetInstanceId),
            this.address = g(p({}, this._sheet.address), {
                sequenceName: "default"
            }),
            this.publicApi = new UR(this),
            this._playbackControllerBox = new SR.Atom(C ?? new AR),
            this._prismOfStatePointer = (0,
            Xn.prism)(()=>this._playbackControllerBox.prism.getValue().statePointer),
            this._positionD = (0,
            Xn.prism)(()=>{
                const D = this._prismOfStatePointer.getValue();
                return (0,
                Xn.val)(D.position)
            }
            ),
            this._positionFormatterD = (0,
            Xn.prism)(()=>{
                const D = (0,
                Xn.val)(this._subUnitsPerUnitD);
                return new zR(D)
            }
            )
        }
        pointerToPrism(u) {
            const {path: m} = (0,
            wv.getPointerParts)(u);
            if (m.length === 0)
                return (0,
                Xn.prism)(()=>({
                    length: (0,
                    Xn.val)(this.pointer.length),
                    playing: (0,
                    Xn.val)(this.pointer.playing),
                    position: (0,
                    Xn.val)(this.pointer.position)
                }));
            if (m.length > 1)
                return (0,
                Xn.prism)(()=>{}
                );
            const [x] = m;
            return x === "length" ? this._lengthD : x === "position" ? this._positionD : x === "playing" ? (0,
            Xn.prism)(()=>(0,
            Xn.val)(this._prismOfStatePointer.getValue().playing)) : (0,
            Xn.prism)(()=>{}
            )
        }
        getKeyframesOfSimpleProp(u) {
            const {path: m, root: x} = (0,
            wv.getPointerParts)(u);
            if (!FR(x))
                throw new Vl("Argument prop must be a pointer to a SheetObject property");
            const M = (0,
            Xn.val)(this._project.pointers.historic.sheetsById[this._sheet.address.sheetId].sequence.tracksByObject[x.address.objectKey]);
            if (!M)
                return [];
            const {trackData: C, trackIdByPropPath: D} = M
              , H = TR(m)
              , Y = D[H];
            if (!Y)
                return [];
            const Z = C[Y];
            return Z ? Z.keyframes : []
        }
        get positionFormatter() {
            return this._positionFormatterD.getValue()
        }
        get prismOfStatePointer() {
            return this._prismOfStatePointer
        }
        get length() {
            return this._lengthD.getValue()
        }
        get positionPrism() {
            return this._positionD
        }
        get position() {
            return this._playbackControllerBox.get().getCurrentPosition()
        }
        get subUnitsPerUnit() {
            return this._subUnitsPerUnitD.getValue()
        }
        get positionSnappedToGrid() {
            return this.closestGridPosition(this.position)
        }
        set position(u) {
            let m = u;
            this.pause(),
            m > this.length && (m = this.length);
            const x = this.length;
            this._playbackControllerBox.get().gotoPosition(m > x ? x : m)
        }
        getDurationCold() {
            return this._lengthD.getValue()
        }
        get playing() {
            return (0,
            Xn.val)(this._playbackControllerBox.get().statePointer.playing)
        }
        _makeRangeFromSequenceTemplate() {
            return (0,
            Xn.prism)(()=>[0, (0,
            Xn.val)(this._lengthD)])
        }
        playDynamicRange(u, m) {
            return this._playbackControllerBox.get().playDynamicRange(u, m)
        }
        async play(u, m) {
            const x = this.length
              , M = u && u.range ? u.range : [0, x]
              , C = u && typeof u.iterationCount == "number" ? u.iterationCount : 1
              , D = u && typeof u.rate < "u" ? u.rate : 1
              , H = u && u.direction ? u.direction : "normal";
            return await this._play(C, [M[0], M[1]], D, H, m)
        }
        _play(u, m, x, M, C) {
            return this._playbackControllerBox.get().play(u, m, x, M, C)
        }
        pause() {
            this._playbackControllerBox.get().pause()
        }
        replacePlaybackController(u) {
            this.pause();
            const m = this._playbackControllerBox.get();
            this._playbackControllerBox.set(u);
            const x = m.getCurrentPosition();
            m.destroy(),
            u.gotoPosition(x)
        }
    }
      , zR = class {
        constructor(u) {
            this._fps = u
        }
        formatSubUnitForGrid(u) {
            const m = u % 1
              , x = 1 / this._fps;
            return Math.round(m / x) + "f"
        }
        formatFullUnitForGrid(u) {
            let m = u
              , x = "";
            if (m >= ea) {
                const C = Math.floor(m / ea);
                x += C + "h",
                m = m % ea
            }
            if (m >= io) {
                const C = Math.floor(m / io);
                x += C + "m",
                m = m % io
            }
            if (m >= no) {
                const C = Math.floor(m / no);
                x += C + "s",
                m = m % no
            }
            const M = 1 / this._fps;
            if (m >= M) {
                const C = Math.floor(m / M);
                x += C + "f",
                m = m % M
            }
            return x.length === 0 ? "0s" : x
        }
        formatForPlayhead(u) {
            let m = u
              , x = "";
            if (m >= ea) {
                const C = Math.floor(m / ea);
                x += Hl(C.toString(), 2, "0") + "h",
                m = m % ea
            }
            if (m >= io) {
                const C = Math.floor(m / io);
                x += Hl(C.toString(), 2, "0") + "m",
                m = m % io
            } else
                x.length > 0 && (x += "00m");
            if (m >= no) {
                const C = Math.floor(m / no);
                x += Hl(C.toString(), 2, "0") + "s",
                m = m % no
            } else
                x += "00s";
            const M = 1 / this._fps;
            if (m >= M) {
                const C = Math.round(m / M);
                x += Hl(C.toString(), 2, "0") + "f",
                m = m % M
            } else
                m / M > .98 ? (x += Hl("1", 2, "0") + "f",
                m = m % M) : x += "00f";
            return x.length === 0 ? "00s00f" : x
        }
        formatBasic(u) {
            return u.toFixed(2) + "s"
        }
    }
      , no = 1
      , io = no * 60
      , ea = io * 60
      , Ld = {};
    v(Ld, {
        boolean: ()=>Uv,
        compound: ()=>Od,
        file: ()=>KR,
        image: ()=>$R,
        number: ()=>Ov,
        rgba: ()=>tC,
        string: ()=>Nv,
        stringLiteral: ()=>oC
    });
    function Rv(u, m) {
        return u.length <= m ? u : u.substr(0, m - 3) + "..."
    }
    var HR = u=>typeof u == "string" ? 'string("'.concat(Rv(u, 10), '")') : typeof u == "number" ? "number(".concat(Rv(String(u), 10), ")") : u === null ? "null" : u === void 0 ? "undefined" : typeof u == "boolean" ? String(u) : Array.isArray(u) ? "array" : typeof u == "object" ? "object" : "unknown"
      , Cv = HR;
    function VR(u, {removeAlphaIfOpaque: m=!1}={}) {
        const x = (u.a * 255 | 256).toString(16).slice(1)
          , M = (u.r * 255 | 256).toString(16).slice(1) + (u.g * 255 | 256).toString(16).slice(1) + (u.b * 255 | 256).toString(16).slice(1) + (m && x === "ff" ? "" : x);
        return "#".concat(M)
    }
    function Dd(u) {
        return g(p({}, u), {
            toString() {
                return VR(this, {
                    removeAlphaIfOpaque: !0
                })
            }
        })
    }
    function GR(u) {
        return Object.fromEntries(Object.entries(u).map(([m,x])=>[m, Cg(x, 0, 1)]))
    }
    function WR(u) {
        function m(x) {
            return x >= .0031308 ? 1.055 * x ** (1 / 2.4) - .055 : 12.92 * x
        }
        return GR({
            r: m(u.r),
            g: m(u.g),
            b: m(u.b),
            a: u.a
        })
    }
    function Iv(u) {
        function m(x) {
            return x >= .04045 ? ((x + .055) / (1 + .055)) ** 2.4 : x / 12.92
        }
        return {
            r: m(u.r),
            g: m(u.g),
            b: m(u.b),
            a: u.a
        }
    }
    function Lv(u) {
        let m = .4122214708 * u.r + .5363325363 * u.g + .0514459929 * u.b
          , x = .2119034982 * u.r + .6806995451 * u.g + .1073969566 * u.b
          , M = .0883024619 * u.r + .2817188376 * u.g + .6299787005 * u.b
          , C = Math.cbrt(m)
          , D = Math.cbrt(x)
          , H = Math.cbrt(M);
        return {
            L: .2104542553 * C + .793617785 * D - .0040720468 * H,
            a: 1.9779984951 * C - 2.428592205 * D + .4505937099 * H,
            b: .0259040371 * C + .7827717662 * D - .808675766 * H,
            alpha: u.a
        }
    }
    function jR(u) {
        let m = u.L + .3963377774 * u.a + .2158037573 * u.b
          , x = u.L - .1055613458 * u.a - .0638541728 * u.b
          , M = u.L - .0894841775 * u.a - 1.291485548 * u.b
          , C = m * m * m
          , D = x * x * x
          , H = M * M * M;
        return {
            r: 4.0767416621 * C - 3.3077115913 * D + .2309699292 * H,
            g: -1.2684380046 * C + 2.6097574011 * D - .3413193965 * H,
            b: -.0041960863 * C - .7034186147 * D + 1.707614701 * H,
            a: u.alpha
        }
    }
    var Vr = Symbol("TheatrePropType_Basic");
    function Dv(u) {
        return typeof u == "object" && !!u && u[Vr] === "TheatrePropType"
    }
    function XR(u) {
        if (typeof u == "number")
            return Ov(u);
        if (typeof u == "boolean")
            return Uv(u);
        if (typeof u == "string")
            return Nv(u);
        if (typeof u == "object" && u) {
            if (Dv(u))
                return u;
            if (lw(u))
                return Od(u);
            throw new Vl("This value is not a valid prop type: ".concat(Cv(u)))
        } else
            throw new Vl("This value is not a valid prop type: ".concat(Cv(u)))
    }
    function qR(u) {
        const m = {};
        for (const x of Object.keys(u)) {
            const M = u[x];
            Dv(M) ? m[x] = M : m[x] = XR(M)
        }
        return m
    }
    var Od = (u,m={})=>{
        const x = qR(u)
          , M = new WeakMap;
        return {
            type: "compound",
            props: x,
            valueType: null,
            [Vr]: "TheatrePropType",
            label: m.label,
            default: UP(x, D=>D.default),
            deserializeAndSanitize: D=>{
                if (typeof D != "object" || !D)
                    return;
                if (M.has(D))
                    return M.get(D);
                const H = {};
                let Y = !1;
                for (const [Z,se] of Object.entries(x))
                    if (Object.prototype.hasOwnProperty.call(D, Z)) {
                        const ve = se.deserializeAndSanitize(D[Z]);
                        ve != null && (Y = !0,
                        H[Z] = ve)
                    }
                if (M.set(D, H),
                Y)
                    return H
            }
        }
    }
      , KR = (u,m={})=>{
        const x = (M,C,D)=>{
            var H;
            return {
                type: "file",
                id: ((H = m.interpolate) != null ? H : Gl)(M.id, C.id, D)
            }
        }
        ;
        return {
            type: "file",
            default: {
                type: "file",
                id: u
            },
            valueType: null,
            [Vr]: "TheatrePropType",
            label: m.label,
            interpolate: x,
            deserializeAndSanitize: YR
        }
    }
      , YR = u=>{
        if (!u)
            return;
        let m = !0;
        if (typeof u.id != "string" && ![null, void 0].includes(u.id) && (m = !1),
        u.type !== "file" && (m = !1),
        !!m)
            return u
    }
      , $R = (u,m={})=>{
        const x = (M,C,D)=>{
            var H;
            return {
                type: "image",
                id: ((H = m.interpolate) != null ? H : Gl)(M.id, C.id, D)
            }
        }
        ;
        return {
            type: "image",
            default: {
                type: "image",
                id: u
            },
            valueType: null,
            [Vr]: "TheatrePropType",
            label: m.label,
            interpolate: x,
            deserializeAndSanitize: ZR
        }
    }
      , ZR = u=>{
        if (!u)
            return;
        let m = !0;
        if (typeof u.id != "string" && ![null, void 0].includes(u.id) && (m = !1),
        u.type !== "image" && (m = !1),
        !!m)
            return u
    }
      , Ov = (u,m={})=>{
        var x;
        return g(p({
            type: "number",
            valueType: 0,
            default: u,
            [Vr]: "TheatrePropType"
        }, m || {}), {
            label: m.label,
            nudgeFn: (x = m.nudgeFn) != null ? x : aC,
            nudgeMultiplier: typeof m.nudgeMultiplier == "number" ? m.nudgeMultiplier : void 0,
            interpolate: eC,
            deserializeAndSanitize: JR(m.range)
        })
    }
      , JR = u=>u ? m=>{
        if (typeof m == "number" && isFinite(m))
            return Cg(m, u[0], u[1])
    }
    : QR
      , QR = u=>typeof u == "number" && isFinite(u) ? u : void 0
      , eC = (u,m,x)=>u + x * (m - u)
      , tC = (u={
        r: 0,
        g: 0,
        b: 0,
        a: 1
    },m={})=>{
        const x = {};
        for (const M of ["r", "g", "b", "a"])
            x[M] = Math.min(Math.max(u[M], 0), 1);
        return {
            type: "rgba",
            valueType: null,
            default: Dd(x),
            [Vr]: "TheatrePropType",
            label: m.label,
            interpolate: iC,
            deserializeAndSanitize: nC
        }
    }
      , nC = u=>{
        if (!u)
            return;
        let m = !0;
        for (const M of ["r", "g", "b", "a"])
            (!Object.prototype.hasOwnProperty.call(u, M) || typeof u[M] != "number") && (m = !1);
        if (!m)
            return;
        const x = {};
        for (const M of ["r", "g", "b", "a"])
            x[M] = Math.min(Math.max(u[M], 0), 1);
        return Dd(x)
    }
      , iC = (u,m,x)=>{
        const M = Lv(Iv(u))
          , C = Lv(Iv(m))
          , D = {
            L: (1 - x) * M.L + x * C.L,
            a: (1 - x) * M.a + x * C.a,
            b: (1 - x) * M.b + x * C.b,
            alpha: (1 - x) * M.alpha + x * C.alpha
        }
          , H = WR(jR(D));
        return Dd(H)
    }
      , Uv = (u,m={})=>{
        var x;
        return {
            type: "boolean",
            default: u,
            valueType: null,
            [Vr]: "TheatrePropType",
            label: m.label,
            interpolate: (x = m.interpolate) != null ? x : Gl,
            deserializeAndSanitize: rC
        }
    }
      , rC = u=>typeof u == "boolean" ? u : void 0;
    function Gl(u) {
        return u
    }
    var Nv = (u,m={})=>{
        var x;
        return {
            type: "string",
            default: u,
            valueType: null,
            [Vr]: "TheatrePropType",
            label: m.label,
            interpolate: (x = m.interpolate) != null ? x : Gl,
            deserializeAndSanitize: sC
        }
    }
    ;
    function sC(u) {
        return typeof u == "string" ? u : void 0
    }
    function oC(u, m, x={}) {
        var M, C;
        return {
            type: "stringLiteral",
            default: u,
            valuesAndLabels: p({}, m),
            [Vr]: "TheatrePropType",
            valueType: null,
            as: (M = x.as) != null ? M : "menu",
            label: x.label,
            interpolate: (C = x.interpolate) != null ? C : Gl,
            deserializeAndSanitize(D) {
                if (typeof D == "string" && Object.prototype.hasOwnProperty.call(m, D))
                    return D
            }
        }
    }
    var aC = ({config: u, deltaX: m, deltaFraction: x, magnitude: M})=>{
        var C;
        const {range: D} = u;
        return !u.nudgeMultiplier && D && !D.includes(1 / 0) && !D.includes(-1 / 0) ? x * (D[1] - D[0]) * M : m * M * ((C = u.nudgeMultiplier) != null ? C : 1)
    }
      , lC = u=>u.replace(/^[\s\/]*/, "").replace(/[\s\/]*$/, "").replace(/\s*\/\s*/g, " / ");
    function Ud(u, m) {
        return lC(u)
    }
    b(O());
    var cC = class {
        get type() {
            return "Theatre_Sheet_PublicAPI"
        }
        constructor(u) {
            J(this, u)
        }
        object(u, m, x) {
            const M = K(this)
              , C = Ud(u)
              , D = M.getObject(C)
              , H = null
              , Y = x?.__actions__THIS_API_IS_UNSTABLE_AND_WILL_CHANGE_IN_THE_NEXT_VERSION;
            if (D)
                return Y && D.template._temp_setActions(Y),
                D.publicApi;
            {
                const Z = Od(m);
                return M.createObject(C, H, Z, Y).publicApi
            }
        }
        get sequence() {
            return K(this).getSequence().publicApi
        }
        get project() {
            return K(this).project.publicApi
        }
        get address() {
            return p({}, K(this).address)
        }
        detachObject(u) {
            const m = K(this)
              , x = Ud(u);
            if (!m.getObject(x)) {
                Qo.warning(`Couldn't delete object "`.concat(x, '"'), 'There is no object with key "'.concat(x, `".

To fix this, make sure you are calling \`sheet.deleteObject("`).concat(x, '")` with the correct key.')),
                console.warn('Object key "'.concat(x, '" does not exist.'));
                return
            }
            m.deleteObject(x)
        }
    }
      , Wl = bn
      , uC = class {
        constructor(u, m) {
            this.template = u,
            this.instanceId = m,
            S(this, "_objects", new Wl.Atom({})),
            S(this, "_sequence"),
            S(this, "address"),
            S(this, "publicApi"),
            S(this, "project"),
            S(this, "objectsP", this._objects.pointer),
            S(this, "type", "Theatre_Sheet"),
            S(this, "_logger"),
            this._logger = u.project._logger.named("Sheet", m),
            this._logger._trace("creating sheet"),
            this.project = u.project,
            this.address = g(p({}, u.address), {
                sheetInstanceId: this.instanceId
            }),
            this.publicApi = new cC(this)
        }
        createObject(u, m, x, M={}) {
            const D = this.template.getObjectTemplate(u, m, x, M).createInstance(this, m, x);
            return this._objects.setByPointer(H=>H[u], D),
            D
        }
        getObject(u) {
            return this._objects.get()[u]
        }
        deleteObject(u) {
            this._objects.reduce(m=>{
                const x = p({}, m);
                return delete x[u],
                x
            }
            )
        }
        getSequence() {
            if (!this._sequence) {
                const u = (0,
                Wl.prism)(()=>{
                    const x = (0,
                    Wl.val)(this.project.pointers.historic.sheetsById[this.address.sheetId].sequence.length);
                    return hC(x)
                }
                )
                  , m = (0,
                Wl.prism)(()=>{
                    const x = (0,
                    Wl.val)(this.project.pointers.historic.sheetsById[this.address.sheetId].sequence.subUnitsPerUnit);
                    return fC(x)
                }
                );
                this._sequence = new kR(this.template.project,this,u,m)
            }
            return this._sequence
        }
    }
      , hC = u=>typeof u == "number" && isFinite(u) && u > 0 ? u : 10
      , fC = u=>typeof u == "number" && DP(u) && u >= 1 && u <= 1e3 ? u : 30
      , dC = class {
        constructor(u, m) {
            this.project = u,
            S(this, "type", "Theatre_SheetTemplate"),
            S(this, "address"),
            S(this, "_instances", new Mv.Atom({})),
            S(this, "instancesP", this._instances.pointer),
            S(this, "_objectTemplates", new Mv.Atom({})),
            S(this, "objectTemplatesP", this._objectTemplates.pointer),
            this.address = g(p({}, u.address), {
                sheetId: m
            })
        }
        getInstance(u) {
            let m = this._instances.get()[u];
            return m || (m = new uC(this,u),
            this._instances.setByPointer(x=>x[u], m)),
            m
        }
        getObjectTemplate(u, m, x, M) {
            let C = this._objectTemplates.get()[u];
            return C || (C = new yR(this,u,m,x,M),
            this._objectTemplates.setByPointer(D=>D[u], C)),
            C
        }
    }
      , Nd = bn
      , Fv = bn
      , pC = u=>new Promise(m=>setTimeout(m, u))
      , mC = pC;
    function Wi(u) {
        for (var m = arguments.length, x = Array(m > 1 ? m - 1 : 0), M = 1; M < m; M++)
            x[M - 1] = arguments[M];
        throw Error("[Immer] minified error nr: " + u + (x.length ? " " + x.map(function(C) {
            return "'" + C + "'"
        }).join(",") : "") + ". Find the full error at: https://bit.ly/3cXEKWf")
    }
    function ro(u) {
        return !!u && !!u[gi]
    }
    function so(u) {
        return !!u && (function(m) {
            if (!m || typeof m != "object")
                return !1;
            var x = Object.getPrototypeOf(m);
            if (x === null)
                return !0;
            var M = Object.hasOwnProperty.call(x, "constructor") && x.constructor;
            return M === Object || typeof M == "function" && Function.toString.call(M) === MC
        }(u) || Array.isArray(u) || !!u[qv] || !!u.constructor[qv] || Bd(u) || kd(u))
    }
    function _C(u) {
        return ro(u) || Wi(23, u),
        u[gi].t
    }
    function jl(u, m, x) {
        x === void 0 && (x = !1),
        ta(u) === 0 ? (x ? Object.keys : Zd)(u).forEach(function(M) {
            x && typeof M == "symbol" || m(M, u[M], u)
        }) : u.forEach(function(M, C) {
            return m(C, M, u)
        })
    }
    function ta(u) {
        var m = u[gi];
        return m ? m.i > 3 ? m.i - 4 : m.i : Array.isArray(u) ? 1 : Bd(u) ? 2 : kd(u) ? 3 : 0
    }
    function Fd(u, m) {
        return ta(u) === 2 ? u.has(m) : Object.prototype.hasOwnProperty.call(u, m)
    }
    function gC(u, m) {
        return ta(u) === 2 ? u.get(m) : u[m]
    }
    function Bv(u, m, x) {
        var M = ta(u);
        M === 2 ? u.set(m, x) : M === 3 ? (u.delete(m),
        u.add(x)) : u[m] = x
    }
    function vC(u, m) {
        return u === m ? u !== 0 || 1 / u == 1 / m : u != u && m != m
    }
    function Bd(u) {
        return bC && u instanceof Map
    }
    function kd(u) {
        return SC && u instanceof Set
    }
    function oo(u) {
        return u.o || u.t
    }
    function zd(u) {
        if (Array.isArray(u))
            return Array.prototype.slice.call(u);
        var m = wC(u);
        delete m[gi];
        for (var x = Zd(m), M = 0; M < x.length; M++) {
            var C = x[M]
              , D = m[C];
            D.writable === !1 && (D.writable = !0,
            D.configurable = !0),
            (D.get || D.set) && (m[C] = {
                configurable: !0,
                writable: !0,
                enumerable: D.enumerable,
                value: u[C]
            })
        }
        return Object.create(Object.getPrototypeOf(u), m)
    }
    function Hd(u, m) {
        return m === void 0 && (m = !1),
        Vd(u) || ro(u) || !so(u) || (ta(u) > 1 && (u.set = u.add = u.clear = u.delete = yC),
        Object.freeze(u),
        m && jl(u, function(x, M) {
            return Hd(M, !0)
        }, !0)),
        u
    }
    function yC() {
        Wi(2)
    }
    function Vd(u) {
        return u == null || typeof u != "object" || Object.isFrozen(u)
    }
    function Gr(u) {
        var m = EC[u];
        return m || Wi(18, u),
        m
    }
    function kv() {
        return Xl
    }
    function Gd(u, m) {
        m && (Gr("Patches"),
        u.u = [],
        u.s = [],
        u.v = m)
    }
    function Au(u) {
        Wd(u),
        u.p.forEach(xC),
        u.p = null
    }
    function Wd(u) {
        u === Xl && (Xl = u.l)
    }
    function zv(u) {
        return Xl = {
            p: [],
            l: Xl,
            h: u,
            m: !0,
            _: 0
        }
    }
    function xC(u) {
        var m = u[gi];
        m.i === 0 || m.i === 1 ? m.j() : m.O = !0
    }
    function jd(u, m) {
        m._ = m.p.length;
        var x = m.p[0]
          , M = u !== void 0 && u !== x;
        return m.h.g || Gr("ES5").S(m, u, M),
        M ? (x[gi].P && (Au(m),
        Wi(4)),
        so(u) && (u = Pu(m, u),
        m.l || Ru(m, u)),
        m.u && Gr("Patches").M(x[gi], u, m.u, m.s)) : u = Pu(m, x, []),
        Au(m),
        m.u && m.v(m.u, m.s),
        u !== Xv ? u : void 0
    }
    function Pu(u, m, x) {
        if (Vd(m))
            return m;
        var M = m[gi];
        if (!M)
            return jl(m, function(D, H) {
                return Hv(u, M, m, D, H, x)
            }, !0),
            m;
        if (M.A !== u)
            return m;
        if (!M.P)
            return Ru(u, M.t, !0),
            M.t;
        if (!M.I) {
            M.I = !0,
            M.A._--;
            var C = M.i === 4 || M.i === 5 ? M.o = zd(M.k) : M.o;
            jl(M.i === 3 ? new Set(C) : C, function(D, H) {
                return Hv(u, M, C, D, H, x)
            }),
            Ru(u, C, !1),
            x && u.u && Gr("Patches").R(M, x, u.u, u.s)
        }
        return M.o
    }
    function Hv(u, m, x, M, C, D) {
        if (ro(C)) {
            var H = Pu(u, C, D && m && m.i !== 3 && !Fd(m.D, M) ? D.concat(M) : void 0);
            if (Bv(x, M, H),
            !ro(H))
                return;
            u.m = !1
        }
        if (so(C) && !Vd(C)) {
            if (!u.h.F && u._ < 1)
                return;
            Pu(u, C),
            m && m.A.l || Ru(u, C)
        }
    }
    function Ru(u, m, x) {
        x === void 0 && (x = !1),
        u.h.F && u.m && Hd(m, x)
    }
    function Xd(u, m) {
        var x = u[gi];
        return (x ? oo(x) : u)[m]
    }
    function Vv(u, m) {
        if (m in u)
            for (var x = Object.getPrototypeOf(u); x; ) {
                var M = Object.getOwnPropertyDescriptor(x, m);
                if (M)
                    return M;
                x = Object.getPrototypeOf(x)
            }
    }
    function qd(u) {
        u.P || (u.P = !0,
        u.l && qd(u.l))
    }
    function Kd(u) {
        u.o || (u.o = zd(u.t))
    }
    function Yd(u, m, x) {
        var M = Bd(m) ? Gr("MapSet").N(m, x) : kd(m) ? Gr("MapSet").T(m, x) : u.g ? function(C, D) {
            var H = Array.isArray(C)
              , Y = {
                i: H ? 1 : 0,
                A: D ? D.A : kv(),
                P: !1,
                I: !1,
                D: {},
                l: D,
                t: C,
                k: null,
                o: null,
                j: null,
                C: !1
            }
              , Z = Y
              , se = Cu;
            H && (Z = [Y],
            se = Iu);
            var ve = Proxy.revocable(Z, se)
              , ye = ve.revoke
              , Re = ve.proxy;
            return Y.k = Re,
            Y.j = ye,
            Re
        }(m, x) : Gr("ES5").J(m, x);
        return (x ? x.A : kv()).p.push(M),
        M
    }
    function TC(u) {
        return ro(u) || Wi(22, u),
        function m(x) {
            if (!so(x))
                return x;
            var M, C = x[gi], D = ta(x);
            if (C) {
                if (!C.P && (C.i < 4 || !Gr("ES5").K(C)))
                    return C.t;
                C.I = !0,
                M = Gv(x, D),
                C.I = !1
            } else
                M = Gv(x, D);
            return jl(M, function(H, Y) {
                C && gC(C.t, H) === Y || Bv(M, H, m(Y))
            }),
            D === 3 ? new Set(M) : M
        }(u)
    }
    function Gv(u, m) {
        switch (m) {
        case 2:
            return new Map(u);
        case 3:
            return Array.from(u)
        }
        return zd(u)
    }
    var Wv, Xl, $d = typeof Symbol < "u" && typeof Symbol("x") == "symbol", bC = typeof Map < "u", SC = typeof Set < "u", jv = typeof Proxy < "u" && Proxy.revocable !== void 0 && typeof Reflect < "u", Xv = $d ? Symbol.for("immer-nothing") : ((Wv = {})["immer-nothing"] = !0,
    Wv), qv = $d ? Symbol.for("immer-draftable") : "__$immer_draftable", gi = $d ? Symbol.for("immer-state") : "__$immer_state", MC = "" + Object.prototype.constructor, Zd = typeof Reflect < "u" && Reflect.ownKeys ? Reflect.ownKeys : Object.getOwnPropertySymbols !== void 0 ? function(u) {
        return Object.getOwnPropertyNames(u).concat(Object.getOwnPropertySymbols(u))
    }
    : Object.getOwnPropertyNames, wC = Object.getOwnPropertyDescriptors || function(u) {
        var m = {};
        return Zd(u).forEach(function(x) {
            m[x] = Object.getOwnPropertyDescriptor(u, x)
        }),
        m
    }
    , EC = {}, Cu = {
        get: function(u, m) {
            if (m === gi)
                return u;
            var x = oo(u);
            if (!Fd(x, m))
                return function(C, D, H) {
                    var Y, Z = Vv(D, H);
                    return Z ? "value"in Z ? Z.value : (Y = Z.get) === null || Y === void 0 ? void 0 : Y.call(C.k) : void 0
                }(u, x, m);
            var M = x[m];
            return u.I || !so(M) ? M : M === Xd(u.t, m) ? (Kd(u),
            u.o[m] = Yd(u.A.h, M, u)) : M
        },
        has: function(u, m) {
            return m in oo(u)
        },
        ownKeys: function(u) {
            return Reflect.ownKeys(oo(u))
        },
        set: function(u, m, x) {
            var M = Vv(oo(u), m);
            if (M?.set)
                return M.set.call(u.k, x),
                !0;
            if (!u.P) {
                var C = Xd(oo(u), m)
                  , D = C?.[gi];
                if (D && D.t === x)
                    return u.o[m] = x,
                    u.D[m] = !1,
                    !0;
                if (vC(x, C) && (x !== void 0 || Fd(u.t, m)))
                    return !0;
                Kd(u),
                qd(u)
            }
            return u.o[m] === x && typeof x != "number" && (x !== void 0 || m in u.o) || (u.o[m] = x,
            u.D[m] = !0,
            !0)
        },
        deleteProperty: function(u, m) {
            return Xd(u.t, m) !== void 0 || m in u.t ? (u.D[m] = !1,
            Kd(u),
            qd(u)) : delete u.D[m],
            u.o && delete u.o[m],
            !0
        },
        getOwnPropertyDescriptor: function(u, m) {
            var x = oo(u)
              , M = Reflect.getOwnPropertyDescriptor(x, m);
            return M && {
                writable: !0,
                configurable: u.i !== 1 || m !== "length",
                enumerable: M.enumerable,
                value: x[m]
            }
        },
        defineProperty: function() {
            Wi(11)
        },
        getPrototypeOf: function(u) {
            return Object.getPrototypeOf(u.t)
        },
        setPrototypeOf: function() {
            Wi(12)
        }
    }, Iu = {};
    jl(Cu, function(u, m) {
        Iu[u] = function() {
            return arguments[0] = arguments[0][0],
            m.apply(this, arguments)
        }
    }),
    Iu.deleteProperty = function(u, m) {
        return Cu.deleteProperty.call(this, u[0], m)
    }
    ,
    Iu.set = function(u, m, x) {
        return Cu.set.call(this, u[0], m, x, u[0])
    }
    ;
    var AC = function() {
        function u(x) {
            var M = this;
            this.g = jv,
            this.F = !0,
            this.produce = function(C, D, H) {
                if (typeof C == "function" && typeof D != "function") {
                    var Y = D;
                    D = C;
                    var Z = M;
                    return function(Ve) {
                        var Ue = this;
                        Ve === void 0 && (Ve = Y);
                        for (var ht = arguments.length, mt = Array(ht > 1 ? ht - 1 : 0), ct = 1; ct < ht; ct++)
                            mt[ct - 1] = arguments[ct];
                        return Z.produce(Ve, function(wt) {
                            var $n;
                            return ($n = D).call.apply($n, [Ue, wt].concat(mt))
                        })
                    }
                }
                var se;
                if (typeof D != "function" && Wi(6),
                H !== void 0 && typeof H != "function" && Wi(7),
                so(C)) {
                    var ve = zv(M)
                      , ye = Yd(M, C, void 0)
                      , Re = !0;
                    try {
                        se = D(ye),
                        Re = !1
                    } finally {
                        Re ? Au(ve) : Wd(ve)
                    }
                    return typeof Promise < "u" && se instanceof Promise ? se.then(function(Ve) {
                        return Gd(ve, H),
                        jd(Ve, ve)
                    }, function(Ve) {
                        throw Au(ve),
                        Ve
                    }) : (Gd(ve, H),
                    jd(se, ve))
                }
                if (!C || typeof C != "object")
                    return (se = D(C)) === Xv ? void 0 : (se === void 0 && (se = C),
                    M.F && Hd(se, !0),
                    se);
                Wi(21, C)
            }
            ,
            this.produceWithPatches = function(C, D) {
                return typeof C == "function" ? function(Z) {
                    for (var se = arguments.length, ve = Array(se > 1 ? se - 1 : 0), ye = 1; ye < se; ye++)
                        ve[ye - 1] = arguments[ye];
                    return M.produceWithPatches(Z, function(Re) {
                        return C.apply(void 0, [Re].concat(ve))
                    })
                }
                : [M.produce(C, D, function(Z, se) {
                    H = Z,
                    Y = se
                }), H, Y];
                var H, Y
            }
            ,
            typeof x?.useProxies == "boolean" && this.setUseProxies(x.useProxies),
            typeof x?.autoFreeze == "boolean" && this.setAutoFreeze(x.autoFreeze)
        }
        var m = u.prototype;
        return m.createDraft = function(x) {
            so(x) || Wi(8),
            ro(x) && (x = TC(x));
            var M = zv(this)
              , C = Yd(this, x, void 0);
            return C[gi].C = !0,
            Wd(M),
            C
        }
        ,
        m.finishDraft = function(x, M) {
            var C = x && x[gi]
              , D = C.A;
            return Gd(D, M),
            jd(void 0, D)
        }
        ,
        m.setAutoFreeze = function(x) {
            this.F = x
        }
        ,
        m.setUseProxies = function(x) {
            x && !jv && Wi(20),
            this.g = x
        }
        ,
        m.applyPatches = function(x, M) {
            var C;
            for (C = M.length - 1; C >= 0; C--) {
                var D = M[C];
                if (D.path.length === 0 && D.op === "replace") {
                    x = D.value;
                    break
                }
            }
            var H = Gr("Patches").$;
            return ro(x) ? H(x, M) : this.produce(x, function(Y) {
                return H(Y, M.slice(C + 1))
            })
        }
        ,
        u
    }()
      , Ri = new AC;
    Ri.produce,
    Ri.produceWithPatches.bind(Ri),
    Ri.setAutoFreeze.bind(Ri),
    Ri.setUseProxies.bind(Ri),
    Ri.applyPatches.bind(Ri),
    Ri.createDraft.bind(Ri),
    Ri.finishDraft.bind(Ri);
    var PC = {
        currentProjectStateDefinitionVersion: "0.4.0"
    }
      , Jd = PC;
    async function RC(u, m, x) {
        await mC(0),
        u.transaction(({drafts: M})=>{
            var C;
            const D = m.address.projectId;
            M.ephemeral.coreByProject[D] = {
                lastExportedObject: null,
                loadingState: {
                    type: "loading"
                }
            },
            M.ahistoric.coreByProject[D] = {
                ahistoricStuff: ""
            };
            function H() {
                M.ephemeral.coreByProject[D].loadingState = {
                    type: "loaded"
                },
                M.historic.coreByProject[D] = {
                    sheetsById: {},
                    definitionVersion: Jd.currentProjectStateDefinitionVersion,
                    revisionHistory: []
                }
            }
            function Y(ye) {
                M.ephemeral.coreByProject[D].loadingState = {
                    type: "loaded"
                },
                M.historic.coreByProject[D] = ye
            }
            function Z() {
                M.ephemeral.coreByProject[D].loadingState = {
                    type: "loaded"
                }
            }
            function se(ye) {
                M.ephemeral.coreByProject[D].loadingState = {
                    type: "browserStateIsNotBasedOnDiskState",
                    onDiskState: ye
                }
            }
            const ve = (C = _C(M.historic)) == null ? void 0 : C.coreByProject[m.address.projectId];
            ve ? x && ve.revisionHistory.indexOf(x.revisionHistory[0]) == -1 ? se(x) : Z() : x ? Y(x) : H()
        }
        )
    }
    function Kv() {}
    function Yv(u) {
        var m, x;
        const M = (m = u?.logging) != null && m.internal ? (x = u.logging.min) != null ? x : 256 : 1 / 0
          , C = M <= 128
          , D = M <= 512
          , H = gv(void 0, {
            _debug: C ? console.debug.bind(console, "_coreLogger(TheatreInternalLogger) debug") : Kv,
            _error: D ? console.error.bind(console, "_coreLogger(TheatreInternalLogger) error") : Kv
        });
        if (u) {
            const {logger: Y, logging: Z} = u;
            Y && H.configureLogger(Y),
            Z ? H.configureLogging(Z) : H.configureLogging({
                dev: !1
            })
        }
        return H.getLogger().named("Theatre")
    }
    var CC = class {
        constructor(u, m={}, x) {
            this.config = m,
            this.publicApi = x,
            S(this, "pointers"),
            S(this, "_pointerProxies"),
            S(this, "address"),
            S(this, "_studioReadyDeferred"),
            S(this, "_assetStorageReadyDeferred"),
            S(this, "_readyPromise"),
            S(this, "_sheetTemplates", new Fv.Atom({})),
            S(this, "sheetTemplatesP", this._sheetTemplates.pointer),
            S(this, "_studio"),
            S(this, "assetStorage"),
            S(this, "type", "Theatre_Project"),
            S(this, "_logger");
            var M;
            this._logger = Yv({
                logging: {
                    dev: !0
                }
            }).named("Project", u),
            this._logger.traceDev("creating project"),
            this.address = {
                projectId: u
            };
            const C = new Fv.Atom({
                ahistoric: {
                    ahistoricStuff: ""
                },
                historic: (M = m.state) != null ? M : {
                    sheetsById: {},
                    definitionVersion: Jd.currentProjectStateDefinitionVersion,
                    revisionHistory: []
                },
                ephemeral: {
                    loadingState: {
                        type: "loaded"
                    },
                    lastExportedObject: null
                }
            });
            this._assetStorageReadyDeferred = _s(),
            this.assetStorage = {
                getAssetUrl: D=>{
                    var H;
                    return "".concat((H = m.assets) == null ? void 0 : H.baseUrl, "/").concat(D)
                }
                ,
                createAsset: ()=>{
                    throw new Error("Please wait for Project.ready to use assets.")
                }
            },
            this._pointerProxies = {
                historic: new Nd.PointerProxy(C.pointer.historic),
                ahistoric: new Nd.PointerProxy(C.pointer.ahistoric),
                ephemeral: new Nd.PointerProxy(C.pointer.ephemeral)
            },
            this.pointers = {
                historic: this._pointerProxies.historic.pointer,
                ahistoric: this._pointerProxies.ahistoric.pointer,
                ephemeral: this._pointerProxies.ephemeral.pointer
            },
            F.add(u, this),
            this._studioReadyDeferred = _s(),
            this._readyPromise = Promise.all([this._studioReadyDeferred.promise, this._assetStorageReadyDeferred.promise]).then(()=>{}
            ),
            m.state ? setTimeout(()=>{
                this._studio || (this._studioReadyDeferred.resolve(void 0),
                this._assetStorageReadyDeferred.resolve(void 0),
                this._logger._trace("ready deferred resolved with no state"))
            }
            , 0) : typeof window > "u" ? console.error('Argument config.state in Theatre.getProject("'.concat(u, '", config) is empty. ') + "You can safely ignore this message if you're developing a Next.js/Remix project in development mode. But if you are shipping to your end-users, then you need to set config.state, otherwise your project's state will be empty and nothing will animate. Learn more at https://www.theatrejs.com/docs/latest/manual/projects#state") : setTimeout(()=>{
                if (!this._studio)
                    throw new Error('Argument config.state in Theatre.getProject("'.concat(u, '", config) is empty. This is fine ') + "while you are using @theatre/core along with @theatre/studio. But since @theatre/studio " + 'is not loaded, the state of project "'.concat(u, `" will be empty.

`) + `To fix this, you need to add @theatre/studio into the bundle and export the project's state. Learn how to do that at https://www.theatrejs.com/docs/latest/manual/projects#state
`)
            }
            , 1e3)
        }
        attachToStudio(u) {
            if (this._studio) {
                if (this._studio !== u)
                    throw new Error("Project ".concat(this.address.projectId, " is already attached to studio ").concat(this._studio.address.studioId));
                console.warn("Project ".concat(this.address.projectId, " is already attached to studio ").concat(this._studio.address.studioId));
                return
            }
            this._studio = u,
            u.initialized.then(async()=>{
                var m;
                await RC(u, this, this.config.state),
                this._pointerProxies.historic.setPointer(u.atomP.historic.coreByProject[this.address.projectId]),
                this._pointerProxies.ahistoric.setPointer(u.atomP.ahistoric.coreByProject[this.address.projectId]),
                this._pointerProxies.ephemeral.setPointer(u.atomP.ephemeral.coreByProject[this.address.projectId]),
                await u.createAssetStorage(this, (m = this.config.assets) == null ? void 0 : m.baseUrl).then(x=>{
                    this.assetStorage = x,
                    this._assetStorageReadyDeferred.resolve(void 0)
                }
                ),
                this._studioReadyDeferred.resolve(void 0)
            }
            ).catch(m=>{
                throw console.error(m),
                m
            }
            )
        }
        get isAttachedToStudio() {
            return !!this._studio
        }
        get ready() {
            return this._readyPromise
        }
        isReady() {
            return this._studioReadyDeferred.status === "resolved" && this._assetStorageReadyDeferred.status === "resolved"
        }
        getOrCreateSheet(u, m="default") {
            let x = this._sheetTemplates.get()[u];
            return x || (x = new dC(this,u),
            this._sheetTemplates.reduce(M=>g(p({}, M), {
                [u]: x
            }))),
            x.getInstance(m)
        }
    }
      , IC = class {
        get type() {
            return "Theatre_Project_PublicAPI"
        }
        constructor(u, m={}) {
            J(this, new CC(u,m,this))
        }
        get ready() {
            return K(this).ready
        }
        get isReady() {
            return K(this).isReady()
        }
        get address() {
            return p({}, K(this).address)
        }
        getAssetUrl(u) {
            if (!this.isReady) {
                console.error("Calling `project.getAssetUrl()` before `project.ready` is resolved, will always return `undefined`. Either use `project.ready.then(() => project.getAssetUrl())` or `await project.ready` before calling `project.getAssetUrl()`.");
                return
            }
            return u.id ? K(this).assetStorage.getAssetUrl(u.id) : void 0
        }
        sheet(u, m="default") {
            const x = Ud(u);
            return K(this).getOrCreateSheet(x, m).publicApi
        }
    }
    ;
    b(O());
    var $v = bn
      , Qd = bn;
    function Zv(u, m={}) {
        const x = F.get(u);
        if (x)
            return x.publicApi;
        const C = Yv().named("Project", u);
        return m.state ? (DC(u, m.state),
        C._debug("deep validated config.state on disk")) : C._debug("no config.state"),
        new IC(u,m)
    }
    var LC = (u,m)=>{
        if (Array.isArray(m) || m == null || m.definitionVersion !== Jd.currentProjectStateDefinitionVersion)
            throw new Vl("Error validating conf.state in Theatre.getProject(".concat(JSON.stringify(u), ", conf). The state seems to be formatted in a way that is unreadable to Theatre.js. Read more at https://www.theatrejs.com/docs/latest/manual/projects#state"))
    }
      , DC = (u,m)=>{
        LC(u, m)
    }
    ;
    function ep(u, m, x) {
        const M = x ? K(x).ticker : Pv();
        if ((0,
        $v.isPointer)(u))
            return (0,
            Qd.pointerToPrism)(u).onChange(M, m, !0);
        if ((0,
        Qd.isPrism)(u))
            return u.onChange(M, m, !0);
        throw new Error("Called onChange(p) where p is neither a pointer nor a prism.")
    }
    function Jv(u) {
        if ((0,
        $v.isPointer)(u))
            return (0,
            Qd.pointerToPrism)(u).getValue();
        throw new Error("Called val(p) where p is not a pointer.")
    }
    var OC = class {
        constructor() {
            S(this, "_studio")
        }
        get type() {
            return "Theatre_CoreBundle"
        }
        get version() {
            return "0.7.0"
        }
        getBitsForStudio(u, m) {
            if (this._studio)
                throw new Error("@theatre/core is already attached to @theatre/studio");
            this._studio = u;
            const x = {
                projectsP: F.atom.pointer.projects,
                privateAPI: K,
                coreExports: I,
                getCoreRafDriver: Av
            };
            m(x)
        }
    }
    ;
    UC();
    function UC() {
        if (typeof window > "u")
            return;
        const u = window[Cd];
        if (typeof u < "u")
            throw typeof u == "object" && u && typeof u.version == "string" ? new Error(`It seems that the module '@theatre/core' is loaded more than once. This could have two possible causes:
1. You might have two separate versions of Theatre.js in node_modules.
2. Or this might be a bundling misconfiguration, in case you're using a bundler like Webpack/ESBuild/Rollup.

Note that it **is okay** to import '@theatre/core' multiple times. But those imports should point to the same module.`) : new Error("The variable window.".concat(Cd, " seems to be already set by a module other than @theatre/core."));
        const m = new OC;
        window[Cd] = m;
        const x = window[RR];
        x && x !== null && x.type === "Theatre_StudioBundle" && x.registerCoreBundle(m)
    }
    /*! Bundled license information:

	lodash-es/lodash.js:
	  (**
	   * @license
	   * Lodash (Custom Build) <https://lodash.com/>
	   * Build: `lodash modularize exports="es" -o ./`
	   * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
	   * Released under MIT license <https://lodash.com/license>
	   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
	   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	   *)
	*/
}
)(rf, rf.exports);
var Xi = rf.exports;
const ce = {
    gl: void 0,
    scene: void 0,
    camera: void 0,
    raycaster: void 0,
    frames: 0,
    clock: void 0,
    time: {
        elapsed: 0,
        delta: 0,
        scale: 1
    },
    composer: void 0,
    isDebug: !1,
    isKonami: !1,
    size: {
        width: 0,
        height: 0,
        isMobile: !1
    },
    mouse: {
        static: new Ce(-2,-2),
        smooth: new Ce(-2,-2),
        world: new k(-100,-100,-100),
        isDragging: !1
    }
}
  , sf = {
    projectName: "GPGPU",
    sheets: {
        config: "Config"
    }
}
  , Ek = {
    Config: {
        staticOverrides: {
            byObject: {
                Composer: {
                    intensity: 3.4000000000000012,
                    radius: .4800000000000002,
                    smoothing: .69,
                    levels: 5
                }
            }
        }
    }
}
  , Ak = "0.4.0"
  , Pk = ["3YNOU8OwDU1OI7eM", "ajFl5jZH1VVLXu5D"]
  , hS = {
    sheetsById: Ek,
    definitionVersion: Ak,
    revisionHistory: Pk
};
function wh(r, e, t) {
    const a = r * .005
      , c = e * .005
      , h = t * 1
      , d = r * .02
      , l = e * .02
      , f = t * .5
      , p = Math.sin(a + h) * Math.cos(c + h)
      , g = Math.sin(d + f) * Math.cos(l + f);
    return (p * .6 + g * .4) * .5 + .5
}
class Rk {
    constructor() {
        this.enabled = !1,
        this.k = [38, 38, 40, 40, 37, 39, 37, 39, 66, 65],
        this.n = 0,
        typeof window < "u" && document.addEventListener("keydown", this.onKeyDown),
        this.callbacks = []
    }
    add(e) {
        this.callbacks.push(e)
    }
    onKeyDown = e=>{
        if (e.keyCode === this.k[this.n++]) {
            if (this.n === this.k.length)
                return this.enabled = !0,
                this.trigger(),
                !1
        } else
            this.n = 0
    }
    ;
    trigger = ()=>{
        this.callbacks.forEach(e=>e())
    }
}
const Ck = new Rk;
var Ik = typeof global == "object" && global && global.Object === Object && global
  , Lk = typeof self == "object" && self && self.Object === Object && self
  , fS = Ik || Lk || Function("return this")()
  , of = fS.Symbol
  , dS = Object.prototype
  , Dk = dS.hasOwnProperty
  , Ok = dS.toString
  , ac = of ? of.toStringTag : void 0;
function Uk(r) {
    var e = Dk.call(r, ac)
      , t = r[ac];
    try {
        r[ac] = void 0;
        var n = !0
    } catch {}
    var i = Ok.call(r);
    return n && (e ? r[ac] = t : delete r[ac]),
    i
}
var Nk = Object.prototype
  , Fk = Nk.toString;
function Bk(r) {
    return Fk.call(r)
}
var kk = "[object Null]"
  , zk = "[object Undefined]"
  , kx = of ? of.toStringTag : void 0;
function Hk(r) {
    return r == null ? r === void 0 ? zk : kk : kx && kx in Object(r) ? Uk(r) : Bk(r)
}
function Vk(r) {
    return r != null && typeof r == "object"
}
var Gk = "[object Symbol]";
function Wk(r) {
    return typeof r == "symbol" || Vk(r) && Hk(r) == Gk
}
var jk = /\s/;
function Xk(r) {
    for (var e = r.length; e-- && jk.test(r.charAt(e)); )
        ;
    return e
}
var qk = /^\s+/;
function Kk(r) {
    return r && r.slice(0, Xk(r) + 1).replace(qk, "")
}
function r_(r) {
    var e = typeof r;
    return r != null && (e == "object" || e == "function")
}
var zx = NaN
  , Yk = /^[-+]0x[0-9a-f]+$/i
  , $k = /^0b[01]+$/i
  , Zk = /^0o[0-7]+$/i
  , Jk = parseInt;
function Hx(r) {
    if (typeof r == "number")
        return r;
    if (Wk(r))
        return zx;
    if (r_(r)) {
        var e = typeof r.valueOf == "function" ? r.valueOf() : r;
        r = r_(e) ? e + "" : e
    }
    if (typeof r != "string")
        return r === 0 ? r : +r;
    r = Kk(r);
    var t = $k.test(r);
    return t || Zk.test(r) ? Jk(r.slice(2), t ? 2 : 8) : Yk.test(r) ? zx : +r
}
var im = function() {
    return fS.Date.now()
}
  , Qk = "Expected a function"
  , ez = Math.max
  , tz = Math.min;
function nz(r, e, t) {
    var n, i, s, o, a, c, h = 0, d = !1, l = !1, f = !0;
    if (typeof r != "function")
        throw new TypeError(Qk);
    e = Hx(e) || 0,
    r_(t) && (d = !!t.leading,
    l = "maxWait"in t,
    s = l ? ez(Hx(t.maxWait) || 0, e) : s,
    f = "trailing"in t ? !!t.trailing : f);
    function p(P) {
        var R = n
          , O = i;
        return n = i = void 0,
        h = P,
        o = r.apply(O, R),
        o
    }
    function g(P) {
        return h = P,
        a = setTimeout(_, e),
        d ? p(P) : o
    }
    function y(P) {
        var R = P - c
          , O = P - h
          , w = e - R;
        return l ? tz(w, s - O) : w
    }
    function v(P) {
        var R = P - c
          , O = P - h;
        return c === void 0 || R >= e || R < 0 || l && O >= s
    }
    function _() {
        var P = im();
        if (v(P))
            return b(P);
        a = setTimeout(_, y(P))
    }
    function b(P) {
        return a = void 0,
        f && n ? p(P) : (n = i = void 0,
        o)
    }
    function T() {
        a !== void 0 && clearTimeout(a),
        h = 0,
        n = c = i = a = void 0
    }
    function S() {
        return a === void 0 ? o : b(im())
    }
    function E() {
        var P = im()
          , R = v(P);
        if (n = arguments,
        i = this,
        c = P,
        R) {
            if (a === void 0)
                return g(c);
            if (l)
                return clearTimeout(a),
                a = setTimeout(_, e),
                p(c)
        }
        return a === void 0 && (a = setTimeout(_, e)),
        o
    }
    return E.cancel = T,
    E.flush = S,
    E
}
function Vx(r, e) {
    if (e === jL)
        return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."),
        r;
    if (e === km || e === wb) {
        let t = r.getIndex();
        if (t === null) {
            const o = []
              , a = r.getAttribute("position");
            if (a !== void 0) {
                for (let c = 0; c < a.count; c++)
                    o.push(c);
                r.setIndex(o),
                t = r.getIndex()
            } else
                return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),
                r
        }
        const n = t.count - 2
          , i = [];
        if (e === km)
            for (let o = 1; o <= n; o++)
                i.push(t.getX(0)),
                i.push(t.getX(o)),
                i.push(t.getX(o + 1));
        else
            for (let o = 0; o < n; o++)
                o % 2 === 0 ? (i.push(t.getX(o)),
                i.push(t.getX(o + 1)),
                i.push(t.getX(o + 2))) : (i.push(t.getX(o + 2)),
                i.push(t.getX(o + 1)),
                i.push(t.getX(o)));
        i.length / 3 !== n && console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
        const s = r.clone();
        return s.setIndex(i),
        s.clearGroups(),
        s
    } else
        return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:", e),
        r
}
class iz extends ko {
    constructor(e) {
        super(e),
        this.dracoLoader = null,
        this.ktx2Loader = null,
        this.meshoptDecoder = null,
        this.pluginCallbacks = [],
        this.register(function(t) {
            return new lz(t)
        }),
        this.register(function(t) {
            return new gz(t)
        }),
        this.register(function(t) {
            return new vz(t)
        }),
        this.register(function(t) {
            return new yz(t)
        }),
        this.register(function(t) {
            return new uz(t)
        }),
        this.register(function(t) {
            return new hz(t)
        }),
        this.register(function(t) {
            return new fz(t)
        }),
        this.register(function(t) {
            return new dz(t)
        }),
        this.register(function(t) {
            return new az(t)
        }),
        this.register(function(t) {
            return new pz(t)
        }),
        this.register(function(t) {
            return new cz(t)
        }),
        this.register(function(t) {
            return new _z(t)
        }),
        this.register(function(t) {
            return new mz(t)
        }),
        this.register(function(t) {
            return new sz(t)
        }),
        this.register(function(t) {
            return new xz(t)
        }),
        this.register(function(t) {
            return new Tz(t)
        })
    }
    load(e, t, n, i) {
        const s = this;
        let o;
        if (this.resourcePath !== "")
            o = this.resourcePath;
        else if (this.path !== "") {
            const h = bc.extractUrlBase(e);
            o = bc.resolveURL(h, this.path)
        } else
            o = bc.extractUrlBase(e);
        this.manager.itemStart(e);
        const a = function(h) {
            i ? i(h) : console.error(h),
            s.manager.itemError(e),
            s.manager.itemEnd(e)
        }
          , c = new Qh(this.manager);
        c.setPath(this.path),
        c.setResponseType("arraybuffer"),
        c.setRequestHeader(this.requestHeader),
        c.setWithCredentials(this.withCredentials),
        c.load(e, function(h) {
            try {
                s.parse(h, o, function(d) {
                    t(d),
                    s.manager.itemEnd(e)
                }, a)
            } catch (d) {
                a(d)
            }
        }, n, a)
    }
    setDRACOLoader(e) {
        return this.dracoLoader = e,
        this
    }
    setDDSLoader() {
        throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".')
    }
    setKTX2Loader(e) {
        return this.ktx2Loader = e,
        this
    }
    setMeshoptDecoder(e) {
        return this.meshoptDecoder = e,
        this
    }
    register(e) {
        return this.pluginCallbacks.indexOf(e) === -1 && this.pluginCallbacks.push(e),
        this
    }
    unregister(e) {
        return this.pluginCallbacks.indexOf(e) !== -1 && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1),
        this
    }
    parse(e, t, n, i) {
        let s;
        const o = {}
          , a = {}
          , c = new TextDecoder;
        if (typeof e == "string")
            s = JSON.parse(e);
        else if (e instanceof ArrayBuffer)
            if (c.decode(new Uint8Array(e,0,4)) === pS) {
                try {
                    o[vt.KHR_BINARY_GLTF] = new bz(e)
                } catch (l) {
                    i && i(l);
                    return
                }
                s = JSON.parse(o[vt.KHR_BINARY_GLTF].content)
            } else
                s = JSON.parse(c.decode(e));
        else
            s = e;
        if (s.asset === void 0 || s.asset.version[0] < 2) {
            i && i(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));
            return
        }
        const h = new Uz(s,{
            path: t || this.resourcePath || "",
            crossOrigin: this.crossOrigin,
            requestHeader: this.requestHeader,
            manager: this.manager,
            ktx2Loader: this.ktx2Loader,
            meshoptDecoder: this.meshoptDecoder
        });
        h.fileLoader.setRequestHeader(this.requestHeader);
        for (let d = 0; d < this.pluginCallbacks.length; d++) {
            const l = this.pluginCallbacks[d](h);
            l.name || console.error("THREE.GLTFLoader: Invalid plugin found: missing name"),
            a[l.name] = l,
            o[l.name] = !0
        }
        if (s.extensionsUsed)
            for (let d = 0; d < s.extensionsUsed.length; ++d) {
                const l = s.extensionsUsed[d]
                  , f = s.extensionsRequired || [];
                switch (l) {
                case vt.KHR_MATERIALS_UNLIT:
                    o[l] = new oz;
                    break;
                case vt.KHR_DRACO_MESH_COMPRESSION:
                    o[l] = new Sz(s,this.dracoLoader);
                    break;
                case vt.KHR_TEXTURE_TRANSFORM:
                    o[l] = new Mz;
                    break;
                case vt.KHR_MESH_QUANTIZATION:
                    o[l] = new wz;
                    break;
                default:
                    f.indexOf(l) >= 0 && a[l] === void 0 && console.warn('THREE.GLTFLoader: Unknown extension "' + l + '".')
                }
            }
        h.setExtensions(o),
        h.setPlugins(a),
        h.parse(n, i)
    }
    parseAsync(e, t) {
        const n = this;
        return new Promise(function(i, s) {
            n.parse(e, t, i, s)
        }
        )
    }
}
function rz() {
    let r = {};
    return {
        get: function(e) {
            return r[e]
        },
        add: function(e, t) {
            r[e] = t
        },
        remove: function(e) {
            delete r[e]
        },
        removeAll: function() {
            r = {}
        }
    }
}
const vt = {
    KHR_BINARY_GLTF: "KHR_binary_glTF",
    KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
    KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
    KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
    KHR_MATERIALS_IOR: "KHR_materials_ior",
    KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
    KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
    KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
    KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence",
    KHR_MATERIALS_ANISOTROPY: "KHR_materials_anisotropy",
    KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
    KHR_MATERIALS_VOLUME: "KHR_materials_volume",
    KHR_TEXTURE_BASISU: "KHR_texture_basisu",
    KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
    KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
    KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength",
    EXT_MATERIALS_BUMP: "EXT_materials_bump",
    EXT_TEXTURE_WEBP: "EXT_texture_webp",
    EXT_TEXTURE_AVIF: "EXT_texture_avif",
    EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression",
    EXT_MESH_GPU_INSTANCING: "EXT_mesh_gpu_instancing"
};
class sz {
    constructor(e) {
        this.parser = e,
        this.name = vt.KHR_LIGHTS_PUNCTUAL,
        this.cache = {
            refs: {},
            uses: {}
        }
    }
    _markDefs() {
        const e = this.parser
          , t = this.parser.json.nodes || [];
        for (let n = 0, i = t.length; n < i; n++) {
            const s = t[n];
            s.extensions && s.extensions[this.name] && s.extensions[this.name].light !== void 0 && e._addNodeRef(this.cache, s.extensions[this.name].light)
        }
    }
    _loadLight(e) {
        const t = this.parser
          , n = "light:" + e;
        let i = t.cache.get(n);
        if (i)
            return i;
        const s = t.json
          , c = ((s.extensions && s.extensions[this.name] || {}).lights || [])[e];
        let h;
        const d = new Ke(16777215);
        c.color !== void 0 && d.setRGB(c.color[0], c.color[1], c.color[2], gn);
        const l = c.range !== void 0 ? c.range : 0;
        switch (c.type) {
        case "directional":
            h = new z3(d),
            h.target.position.set(0, 0, -1),
            h.add(h.target);
            break;
        case "point":
            h = new B3(d),
            h.distance = l;
            break;
        case "spot":
            h = new N3(d),
            h.distance = l,
            c.spot = c.spot || {},
            c.spot.innerConeAngle = c.spot.innerConeAngle !== void 0 ? c.spot.innerConeAngle : 0,
            c.spot.outerConeAngle = c.spot.outerConeAngle !== void 0 ? c.spot.outerConeAngle : Math.PI / 4,
            h.angle = c.spot.outerConeAngle,
            h.penumbra = 1 - c.spot.innerConeAngle / c.spot.outerConeAngle,
            h.target.position.set(0, 0, -1),
            h.add(h.target);
            break;
        default:
            throw new Error("THREE.GLTFLoader: Unexpected light type: " + c.type)
        }
        return h.position.set(0, 0, 0),
        h.decay = 2,
        Rs(h, c),
        c.intensity !== void 0 && (h.intensity = c.intensity),
        h.name = t.createUniqueName(c.name || "light_" + e),
        i = Promise.resolve(h),
        t.cache.add(n, i),
        i
    }
    getDependency(e, t) {
        if (e === "light")
            return this._loadLight(t)
    }
    createNodeAttachment(e) {
        const t = this
          , n = this.parser
          , s = n.json.nodes[e]
          , a = (s.extensions && s.extensions[this.name] || {}).light;
        return a === void 0 ? null : this._loadLight(a).then(function(c) {
            return n._getNodeRef(t.cache, a, c)
        })
    }
}
class oz {
    constructor() {
        this.name = vt.KHR_MATERIALS_UNLIT
    }
    getMaterialType() {
        return _r
    }
    extendParams(e, t, n) {
        const i = [];
        e.color = new Ke(1,1,1),
        e.opacity = 1;
        const s = t.pbrMetallicRoughness;
        if (s) {
            if (Array.isArray(s.baseColorFactor)) {
                const o = s.baseColorFactor;
                e.color.setRGB(o[0], o[1], o[2], gn),
                e.opacity = o[3]
            }
            s.baseColorTexture !== void 0 && i.push(n.assignTexture(e, "map", s.baseColorTexture, Ft))
        }
        return Promise.all(i)
    }
}
class az {
    constructor(e) {
        this.parser = e,
        this.name = vt.KHR_MATERIALS_EMISSIVE_STRENGTH
    }
    extendMaterialParams(e, t) {
        const i = this.parser.json.materials[e];
        if (!i.extensions || !i.extensions[this.name])
            return Promise.resolve();
        const s = i.extensions[this.name].emissiveStrength;
        return s !== void 0 && (t.emissiveIntensity = s),
        Promise.resolve()
    }
}
class lz {
    constructor(e) {
        this.parser = e,
        this.name = vt.KHR_MATERIALS_CLEARCOAT
    }
    getMaterialType(e) {
        const n = this.parser.json.materials[e];
        return !n.extensions || !n.extensions[this.name] ? null : cs
    }
    extendMaterialParams(e, t) {
        const n = this.parser
          , i = n.json.materials[e];
        if (!i.extensions || !i.extensions[this.name])
            return Promise.resolve();
        const s = []
          , o = i.extensions[this.name];
        if (o.clearcoatFactor !== void 0 && (t.clearcoat = o.clearcoatFactor),
        o.clearcoatTexture !== void 0 && s.push(n.assignTexture(t, "clearcoatMap", o.clearcoatTexture)),
        o.clearcoatRoughnessFactor !== void 0 && (t.clearcoatRoughness = o.clearcoatRoughnessFactor),
        o.clearcoatRoughnessTexture !== void 0 && s.push(n.assignTexture(t, "clearcoatRoughnessMap", o.clearcoatRoughnessTexture)),
        o.clearcoatNormalTexture !== void 0 && (s.push(n.assignTexture(t, "clearcoatNormalMap", o.clearcoatNormalTexture)),
        o.clearcoatNormalTexture.scale !== void 0)) {
            const a = o.clearcoatNormalTexture.scale;
            t.clearcoatNormalScale = new Ce(a,a)
        }
        return Promise.all(s)
    }
}
class cz {
    constructor(e) {
        this.parser = e,
        this.name = vt.KHR_MATERIALS_IRIDESCENCE
    }
    getMaterialType(e) {
        const n = this.parser.json.materials[e];
        return !n.extensions || !n.extensions[this.name] ? null : cs
    }
    extendMaterialParams(e, t) {
        const n = this.parser
          , i = n.json.materials[e];
        if (!i.extensions || !i.extensions[this.name])
            return Promise.resolve();
        const s = []
          , o = i.extensions[this.name];
        return o.iridescenceFactor !== void 0 && (t.iridescence = o.iridescenceFactor),
        o.iridescenceTexture !== void 0 && s.push(n.assignTexture(t, "iridescenceMap", o.iridescenceTexture)),
        o.iridescenceIor !== void 0 && (t.iridescenceIOR = o.iridescenceIor),
        t.iridescenceThicknessRange === void 0 && (t.iridescenceThicknessRange = [100, 400]),
        o.iridescenceThicknessMinimum !== void 0 && (t.iridescenceThicknessRange[0] = o.iridescenceThicknessMinimum),
        o.iridescenceThicknessMaximum !== void 0 && (t.iridescenceThicknessRange[1] = o.iridescenceThicknessMaximum),
        o.iridescenceThicknessTexture !== void 0 && s.push(n.assignTexture(t, "iridescenceThicknessMap", o.iridescenceThicknessTexture)),
        Promise.all(s)
    }
}
class uz {
    constructor(e) {
        this.parser = e,
        this.name = vt.KHR_MATERIALS_SHEEN
    }
    getMaterialType(e) {
        const n = this.parser.json.materials[e];
        return !n.extensions || !n.extensions[this.name] ? null : cs
    }
    extendMaterialParams(e, t) {
        const n = this.parser
          , i = n.json.materials[e];
        if (!i.extensions || !i.extensions[this.name])
            return Promise.resolve();
        const s = [];
        t.sheenColor = new Ke(0,0,0),
        t.sheenRoughness = 0,
        t.sheen = 1;
        const o = i.extensions[this.name];
        if (o.sheenColorFactor !== void 0) {
            const a = o.sheenColorFactor;
            t.sheenColor.setRGB(a[0], a[1], a[2], gn)
        }
        return o.sheenRoughnessFactor !== void 0 && (t.sheenRoughness = o.sheenRoughnessFactor),
        o.sheenColorTexture !== void 0 && s.push(n.assignTexture(t, "sheenColorMap", o.sheenColorTexture, Ft)),
        o.sheenRoughnessTexture !== void 0 && s.push(n.assignTexture(t, "sheenRoughnessMap", o.sheenRoughnessTexture)),
        Promise.all(s)
    }
}
class hz {
    constructor(e) {
        this.parser = e,
        this.name = vt.KHR_MATERIALS_TRANSMISSION
    }
    getMaterialType(e) {
        const n = this.parser.json.materials[e];
        return !n.extensions || !n.extensions[this.name] ? null : cs
    }
    extendMaterialParams(e, t) {
        const n = this.parser
          , i = n.json.materials[e];
        if (!i.extensions || !i.extensions[this.name])
            return Promise.resolve();
        const s = []
          , o = i.extensions[this.name];
        return o.transmissionFactor !== void 0 && (t.transmission = o.transmissionFactor),
        o.transmissionTexture !== void 0 && s.push(n.assignTexture(t, "transmissionMap", o.transmissionTexture)),
        Promise.all(s)
    }
}
class fz {
    constructor(e) {
        this.parser = e,
        this.name = vt.KHR_MATERIALS_VOLUME
    }
    getMaterialType(e) {
        const n = this.parser.json.materials[e];
        return !n.extensions || !n.extensions[this.name] ? null : cs
    }
    extendMaterialParams(e, t) {
        const n = this.parser
          , i = n.json.materials[e];
        if (!i.extensions || !i.extensions[this.name])
            return Promise.resolve();
        const s = []
          , o = i.extensions[this.name];
        t.thickness = o.thicknessFactor !== void 0 ? o.thicknessFactor : 0,
        o.thicknessTexture !== void 0 && s.push(n.assignTexture(t, "thicknessMap", o.thicknessTexture)),
        t.attenuationDistance = o.attenuationDistance || 1 / 0;
        const a = o.attenuationColor || [1, 1, 1];
        return t.attenuationColor = new Ke().setRGB(a[0], a[1], a[2], gn),
        Promise.all(s)
    }
}
class dz {
    constructor(e) {
        this.parser = e,
        this.name = vt.KHR_MATERIALS_IOR
    }
    getMaterialType(e) {
        const n = this.parser.json.materials[e];
        return !n.extensions || !n.extensions[this.name] ? null : cs
    }
    extendMaterialParams(e, t) {
        const i = this.parser.json.materials[e];
        if (!i.extensions || !i.extensions[this.name])
            return Promise.resolve();
        const s = i.extensions[this.name];
        return t.ior = s.ior !== void 0 ? s.ior : 1.5,
        Promise.resolve()
    }
}
class pz {
    constructor(e) {
        this.parser = e,
        this.name = vt.KHR_MATERIALS_SPECULAR
    }
    getMaterialType(e) {
        const n = this.parser.json.materials[e];
        return !n.extensions || !n.extensions[this.name] ? null : cs
    }
    extendMaterialParams(e, t) {
        const n = this.parser
          , i = n.json.materials[e];
        if (!i.extensions || !i.extensions[this.name])
            return Promise.resolve();
        const s = []
          , o = i.extensions[this.name];
        t.specularIntensity = o.specularFactor !== void 0 ? o.specularFactor : 1,
        o.specularTexture !== void 0 && s.push(n.assignTexture(t, "specularIntensityMap", o.specularTexture));
        const a = o.specularColorFactor || [1, 1, 1];
        return t.specularColor = new Ke().setRGB(a[0], a[1], a[2], gn),
        o.specularColorTexture !== void 0 && s.push(n.assignTexture(t, "specularColorMap", o.specularColorTexture, Ft)),
        Promise.all(s)
    }
}
class mz {
    constructor(e) {
        this.parser = e,
        this.name = vt.EXT_MATERIALS_BUMP
    }
    getMaterialType(e) {
        const n = this.parser.json.materials[e];
        return !n.extensions || !n.extensions[this.name] ? null : cs
    }
    extendMaterialParams(e, t) {
        const n = this.parser
          , i = n.json.materials[e];
        if (!i.extensions || !i.extensions[this.name])
            return Promise.resolve();
        const s = []
          , o = i.extensions[this.name];
        return t.bumpScale = o.bumpFactor !== void 0 ? o.bumpFactor : 1,
        o.bumpTexture !== void 0 && s.push(n.assignTexture(t, "bumpMap", o.bumpTexture)),
        Promise.all(s)
    }
}
class _z {
    constructor(e) {
        this.parser = e,
        this.name = vt.KHR_MATERIALS_ANISOTROPY
    }
    getMaterialType(e) {
        const n = this.parser.json.materials[e];
        return !n.extensions || !n.extensions[this.name] ? null : cs
    }
    extendMaterialParams(e, t) {
        const n = this.parser
          , i = n.json.materials[e];
        if (!i.extensions || !i.extensions[this.name])
            return Promise.resolve();
        const s = []
          , o = i.extensions[this.name];
        return o.anisotropyStrength !== void 0 && (t.anisotropy = o.anisotropyStrength),
        o.anisotropyRotation !== void 0 && (t.anisotropyRotation = o.anisotropyRotation),
        o.anisotropyTexture !== void 0 && s.push(n.assignTexture(t, "anisotropyMap", o.anisotropyTexture)),
        Promise.all(s)
    }
}
class gz {
    constructor(e) {
        this.parser = e,
        this.name = vt.KHR_TEXTURE_BASISU
    }
    loadTexture(e) {
        const t = this.parser
          , n = t.json
          , i = n.textures[e];
        if (!i.extensions || !i.extensions[this.name])
            return null;
        const s = i.extensions[this.name]
          , o = t.options.ktx2Loader;
        if (!o) {
            if (n.extensionsRequired && n.extensionsRequired.indexOf(this.name) >= 0)
                throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
            return null
        }
        return t.loadTextureImage(e, s.source, o)
    }
}
class vz {
    constructor(e) {
        this.parser = e,
        this.name = vt.EXT_TEXTURE_WEBP,
        this.isSupported = null
    }
    loadTexture(e) {
        const t = this.name
          , n = this.parser
          , i = n.json
          , s = i.textures[e];
        if (!s.extensions || !s.extensions[t])
            return null;
        const o = s.extensions[t]
          , a = i.images[o.source];
        let c = n.textureLoader;
        if (a.uri) {
            const h = n.options.manager.getHandler(a.uri);
            h !== null && (c = h)
        }
        return this.detectSupport().then(function(h) {
            if (h)
                return n.loadTextureImage(e, o.source, c);
            if (i.extensionsRequired && i.extensionsRequired.indexOf(t) >= 0)
                throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");
            return n.loadTexture(e)
        })
    }
    detectSupport() {
        return this.isSupported || (this.isSupported = new Promise(function(e) {
            const t = new Image;
            t.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA",
            t.onload = t.onerror = function() {
                e(t.height === 1)
            }
        }
        )),
        this.isSupported
    }
}
class yz {
    constructor(e) {
        this.parser = e,
        this.name = vt.EXT_TEXTURE_AVIF,
        this.isSupported = null
    }
    loadTexture(e) {
        const t = this.name
          , n = this.parser
          , i = n.json
          , s = i.textures[e];
        if (!s.extensions || !s.extensions[t])
            return null;
        const o = s.extensions[t]
          , a = i.images[o.source];
        let c = n.textureLoader;
        if (a.uri) {
            const h = n.options.manager.getHandler(a.uri);
            h !== null && (c = h)
        }
        return this.detectSupport().then(function(h) {
            if (h)
                return n.loadTextureImage(e, o.source, c);
            if (i.extensionsRequired && i.extensionsRequired.indexOf(t) >= 0)
                throw new Error("THREE.GLTFLoader: AVIF required by asset but unsupported.");
            return n.loadTexture(e)
        })
    }
    detectSupport() {
        return this.isSupported || (this.isSupported = new Promise(function(e) {
            const t = new Image;
            t.src = "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=",
            t.onload = t.onerror = function() {
                e(t.height === 1)
            }
        }
        )),
        this.isSupported
    }
}
class xz {
    constructor(e) {
        this.name = vt.EXT_MESHOPT_COMPRESSION,
        this.parser = e
    }
    loadBufferView(e) {
        const t = this.parser.json
          , n = t.bufferViews[e];
        if (n.extensions && n.extensions[this.name]) {
            const i = n.extensions[this.name]
              , s = this.parser.getDependency("buffer", i.buffer)
              , o = this.parser.options.meshoptDecoder;
            if (!o || !o.supported) {
                if (t.extensionsRequired && t.extensionsRequired.indexOf(this.name) >= 0)
                    throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
                return null
            }
            return s.then(function(a) {
                const c = i.byteOffset || 0
                  , h = i.byteLength || 0
                  , d = i.count
                  , l = i.byteStride
                  , f = new Uint8Array(a,c,h);
                return o.decodeGltfBufferAsync ? o.decodeGltfBufferAsync(d, l, f, i.mode, i.filter).then(function(p) {
                    return p.buffer
                }) : o.ready.then(function() {
                    const p = new ArrayBuffer(d * l);
                    return o.decodeGltfBuffer(new Uint8Array(p), d, l, f, i.mode, i.filter),
                    p
                })
            })
        } else
            return null
    }
}
class Tz {
    constructor(e) {
        this.name = vt.EXT_MESH_GPU_INSTANCING,
        this.parser = e
    }
    createNodeMesh(e) {
        const t = this.parser.json
          , n = t.nodes[e];
        if (!n.extensions || !n.extensions[this.name] || n.mesh === void 0)
            return null;
        const i = t.meshes[n.mesh];
        for (const h of i.primitives)
            if (h.mode !== Ki.TRIANGLES && h.mode !== Ki.TRIANGLE_STRIP && h.mode !== Ki.TRIANGLE_FAN && h.mode !== void 0)
                return null;
        const o = n.extensions[this.name].attributes
          , a = []
          , c = {};
        for (const h in o)
            a.push(this.parser.getDependency("accessor", o[h]).then(d=>(c[h] = d,
            c[h])));
        return a.length < 1 ? null : (a.push(this.parser.createNodeMesh(e)),
        Promise.all(a).then(h=>{
            const d = h.pop()
              , l = d.isGroup ? d.children : [d]
              , f = h[0].count
              , p = [];
            for (const g of l) {
                const y = new it
                  , v = new k
                  , _ = new Hi
                  , b = new k(1,1,1)
                  , T = new z_(g.geometry,g.material,f);
                for (let S = 0; S < f; S++)
                    c.TRANSLATION && v.fromBufferAttribute(c.TRANSLATION, S),
                    c.ROTATION && _.fromBufferAttribute(c.ROTATION, S),
                    c.SCALE && b.fromBufferAttribute(c.SCALE, S),
                    T.setMatrixAt(S, y.compose(v, _, b));
                for (const S in c)
                    if (S === "_COLOR_0") {
                        const E = c[S];
                        T.instanceColor = new cl(E.array,E.itemSize,E.normalized)
                    } else
                        S !== "TRANSLATION" && S !== "ROTATION" && S !== "SCALE" && g.geometry.setAttribute(S, c[S]);
                Yt.prototype.copy.call(T, g),
                this.parser.assignFinalMaterial(T),
                p.push(T)
            }
            return d.isGroup ? (d.clear(),
            d.add(...p),
            d) : p[0]
        }
        ))
    }
}
const pS = "glTF"
  , lc = 12
  , Gx = {
    JSON: 1313821514,
    BIN: 5130562
};
class bz {
    constructor(e) {
        this.name = vt.KHR_BINARY_GLTF,
        this.content = null,
        this.body = null;
        const t = new DataView(e,0,lc)
          , n = new TextDecoder;
        if (this.header = {
            magic: n.decode(new Uint8Array(e.slice(0, 4))),
            version: t.getUint32(4, !0),
            length: t.getUint32(8, !0)
        },
        this.header.magic !== pS)
            throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
        if (this.header.version < 2)
            throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
        const i = this.header.length - lc
          , s = new DataView(e,lc);
        let o = 0;
        for (; o < i; ) {
            const a = s.getUint32(o, !0);
            o += 4;
            const c = s.getUint32(o, !0);
            if (o += 4,
            c === Gx.JSON) {
                const h = new Uint8Array(e,lc + o,a);
                this.content = n.decode(h)
            } else if (c === Gx.BIN) {
                const h = lc + o;
                this.body = e.slice(h, h + a)
            }
            o += a
        }
        if (this.content === null)
            throw new Error("THREE.GLTFLoader: JSON content not found.")
    }
}
class Sz {
    constructor(e, t) {
        if (!t)
            throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
        this.name = vt.KHR_DRACO_MESH_COMPRESSION,
        this.json = e,
        this.dracoLoader = t,
        this.dracoLoader.preload()
    }
    decodePrimitive(e, t) {
        const n = this.json
          , i = this.dracoLoader
          , s = e.extensions[this.name].bufferView
          , o = e.extensions[this.name].attributes
          , a = {}
          , c = {}
          , h = {};
        for (const d in o) {
            const l = s_[d] || d.toLowerCase();
            a[l] = o[d]
        }
        for (const d in e.attributes) {
            const l = s_[d] || d.toLowerCase();
            if (o[d] !== void 0) {
                const f = n.accessors[e.attributes[d]]
                  , p = Ya[f.componentType];
                h[l] = p.name,
                c[l] = f.normalized === !0
            }
        }
        return t.getDependency("bufferView", s).then(function(d) {
            return new Promise(function(l) {
                i.decodeDracoFile(d, function(f) {
                    for (const p in f.attributes) {
                        const g = f.attributes[p]
                          , y = c[p];
                        y !== void 0 && (g.normalized = y)
                    }
                    l(f)
                }, a, h)
            }
            )
        })
    }
}
class Mz {
    constructor() {
        this.name = vt.KHR_TEXTURE_TRANSFORM
    }
    extendTexture(e, t) {
        return (t.texCoord === void 0 || t.texCoord === e.channel) && t.offset === void 0 && t.rotation === void 0 && t.scale === void 0 || (e = e.clone(),
        t.texCoord !== void 0 && (e.channel = t.texCoord),
        t.offset !== void 0 && e.offset.fromArray(t.offset),
        t.rotation !== void 0 && (e.rotation = t.rotation),
        t.scale !== void 0 && e.repeat.fromArray(t.scale),
        e.needsUpdate = !0),
        e
    }
}
class wz {
    constructor() {
        this.name = vt.KHR_MESH_QUANTIZATION
    }
}
class mS extends kc {
    constructor(e, t, n, i) {
        super(e, t, n, i)
    }
    copySampleValue_(e) {
        const t = this.resultBuffer
          , n = this.sampleValues
          , i = this.valueSize
          , s = e * i * 3 + i;
        for (let o = 0; o !== i; o++)
            t[o] = n[s + o];
        return t
    }
    interpolate_(e, t, n, i) {
        const s = this.resultBuffer
          , o = this.sampleValues
          , a = this.valueSize
          , c = a * 2
          , h = a * 3
          , d = i - t
          , l = (n - t) / d
          , f = l * l
          , p = f * l
          , g = e * h
          , y = g - h
          , v = -2 * p + 3 * f
          , _ = p - f
          , b = 1 - v
          , T = _ - f + l;
        for (let S = 0; S !== a; S++) {
            const E = o[y + S + a]
              , P = o[y + S + c] * d
              , R = o[g + S + a]
              , O = o[g + S] * d;
            s[S] = b * E + T * P + v * R + _ * O
        }
        return s
    }
}
const Ez = new Hi;
class Az extends mS {
    interpolate_(e, t, n, i) {
        const s = super.interpolate_(e, t, n, i);
        return Ez.fromArray(s).normalize().toArray(s),
        s
    }
}
const Ki = {
    FLOAT: 5126,
    FLOAT_MAT3: 35675,
    FLOAT_MAT4: 35676,
    FLOAT_VEC2: 35664,
    FLOAT_VEC3: 35665,
    FLOAT_VEC4: 35666,
    LINEAR: 9729,
    REPEAT: 10497,
    SAMPLER_2D: 35678,
    POINTS: 0,
    LINES: 1,
    LINE_LOOP: 2,
    LINE_STRIP: 3,
    TRIANGLES: 4,
    TRIANGLE_STRIP: 5,
    TRIANGLE_FAN: 6,
    UNSIGNED_BYTE: 5121,
    UNSIGNED_SHORT: 5123
}
  , Ya = {
    5120: Int8Array,
    5121: Uint8Array,
    5122: Int16Array,
    5123: Uint16Array,
    5125: Uint32Array,
    5126: Float32Array
}
  , Wx = {
    9728: Jt,
    9729: Ot,
    9984: Bm,
    9985: gb,
    9986: Lh,
    9987: Do
}
  , jx = {
    33071: hi,
    33648: sl,
    10497: ii
}
  , rm = {
    SCALAR: 1,
    VEC2: 2,
    VEC3: 3,
    VEC4: 4,
    MAT2: 4,
    MAT3: 9,
    MAT4: 16
}
  , s_ = {
    POSITION: "position",
    NORMAL: "normal",
    TANGENT: "tangent",
    TEXCOORD_0: "uv",
    TEXCOORD_1: "uv1",
    TEXCOORD_2: "uv2",
    TEXCOORD_3: "uv3",
    COLOR_0: "color",
    WEIGHTS_0: "skinWeight",
    JOINTS_0: "skinIndex"
}
  , Ss = {
    scale: "scale",
    translation: "position",
    rotation: "quaternion",
    weights: "morphTargetInfluences"
}
  , Pz = {
    CUBICSPLINE: void 0,
    LINEAR: ol,
    STEP: Oc
}
  , sm = {
    OPAQUE: "OPAQUE",
    MASK: "MASK",
    BLEND: "BLEND"
};
function Rz(r) {
    return r.DefaultMaterial === void 0 && (r.DefaultMaterial = new j_({
        color: 16777215,
        emissive: 0,
        metalness: 1,
        roughness: 1,
        transparent: !1,
        depthTest: !0,
        side: xr
    })),
    r.DefaultMaterial
}
function yo(r, e, t) {
    for (const n in t.extensions)
        r[n] === void 0 && (e.userData.gltfExtensions = e.userData.gltfExtensions || {},
        e.userData.gltfExtensions[n] = t.extensions[n])
}
function Rs(r, e) {
    e.extras !== void 0 && (typeof e.extras == "object" ? Object.assign(r.userData, e.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + e.extras))
}
function Cz(r, e, t) {
    let n = !1
      , i = !1
      , s = !1;
    for (let h = 0, d = e.length; h < d; h++) {
        const l = e[h];
        if (l.POSITION !== void 0 && (n = !0),
        l.NORMAL !== void 0 && (i = !0),
        l.COLOR_0 !== void 0 && (s = !0),
        n && i && s)
            break
    }
    if (!n && !i && !s)
        return Promise.resolve(r);
    const o = []
      , a = []
      , c = [];
    for (let h = 0, d = e.length; h < d; h++) {
        const l = e[h];
        if (n) {
            const f = l.POSITION !== void 0 ? t.getDependency("accessor", l.POSITION) : r.attributes.position;
            o.push(f)
        }
        if (i) {
            const f = l.NORMAL !== void 0 ? t.getDependency("accessor", l.NORMAL) : r.attributes.normal;
            a.push(f)
        }
        if (s) {
            const f = l.COLOR_0 !== void 0 ? t.getDependency("accessor", l.COLOR_0) : r.attributes.color;
            c.push(f)
        }
    }
    return Promise.all([Promise.all(o), Promise.all(a), Promise.all(c)]).then(function(h) {
        const d = h[0]
          , l = h[1]
          , f = h[2];
        return n && (r.morphAttributes.position = d),
        i && (r.morphAttributes.normal = l),
        s && (r.morphAttributes.color = f),
        r.morphTargetsRelative = !0,
        r
    })
}
function Iz(r, e) {
    if (r.updateMorphTargets(),
    e.weights !== void 0)
        for (let t = 0, n = e.weights.length; t < n; t++)
            r.morphTargetInfluences[t] = e.weights[t];
    if (e.extras && Array.isArray(e.extras.targetNames)) {
        const t = e.extras.targetNames;
        if (r.morphTargetInfluences.length === t.length) {
            r.morphTargetDictionary = {};
            for (let n = 0, i = t.length; n < i; n++)
                r.morphTargetDictionary[t[n]] = n
        } else
            console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")
    }
}
function Lz(r) {
    let e;
    const t = r.extensions && r.extensions[vt.KHR_DRACO_MESH_COMPRESSION];
    if (t ? e = "draco:" + t.bufferView + ":" + t.indices + ":" + om(t.attributes) : e = r.indices + ":" + om(r.attributes) + ":" + r.mode,
    r.targets !== void 0)
        for (let n = 0, i = r.targets.length; n < i; n++)
            e += ":" + om(r.targets[n]);
    return e
}
function om(r) {
    let e = "";
    const t = Object.keys(r).sort();
    for (let n = 0, i = t.length; n < i; n++)
        e += t[n] + ":" + r[t[n]] + ";";
    return e
}
function o_(r) {
    switch (r) {
    case Int8Array:
        return 1 / 127;
    case Uint8Array:
        return 1 / 255;
    case Int16Array:
        return 1 / 32767;
    case Uint16Array:
        return 1 / 65535;
    default:
        throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")
    }
}
function Dz(r) {
    return r.search(/\.jpe?g($|\?)/i) > 0 || r.search(/^data\:image\/jpeg/) === 0 ? "image/jpeg" : r.search(/\.webp($|\?)/i) > 0 || r.search(/^data\:image\/webp/) === 0 ? "image/webp" : "image/png"
}
const Oz = new it;
class Uz {
    constructor(e={}, t={}) {
        this.json = e,
        this.extensions = {},
        this.plugins = {},
        this.options = t,
        this.cache = new rz,
        this.associations = new Map,
        this.primitiveCache = {},
        this.nodeCache = {},
        this.meshCache = {
            refs: {},
            uses: {}
        },
        this.cameraCache = {
            refs: {},
            uses: {}
        },
        this.lightCache = {
            refs: {},
            uses: {}
        },
        this.sourceCache = {},
        this.textureCache = {},
        this.nodeNamesUsed = {};
        let n = !1
          , i = !1
          , s = -1;
        typeof navigator < "u" && (n = /^((?!chrome|android).)*safari/i.test(navigator.userAgent) === !0,
        i = navigator.userAgent.indexOf("Firefox") > -1,
        s = i ? navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1] : -1),
        typeof createImageBitmap > "u" || n || i && s < 98 ? this.textureLoader = new $b(this.options.manager) : this.textureLoader = new H3(this.options.manager),
        this.textureLoader.setCrossOrigin(this.options.crossOrigin),
        this.textureLoader.setRequestHeader(this.options.requestHeader),
        this.fileLoader = new Qh(this.options.manager),
        this.fileLoader.setResponseType("arraybuffer"),
        this.options.crossOrigin === "use-credentials" && this.fileLoader.setWithCredentials(!0)
    }
    setExtensions(e) {
        this.extensions = e
    }
    setPlugins(e) {
        this.plugins = e
    }
    parse(e, t) {
        const n = this
          , i = this.json
          , s = this.extensions;
        this.cache.removeAll(),
        this.nodeCache = {},
        this._invokeAll(function(o) {
            return o._markDefs && o._markDefs()
        }),
        Promise.all(this._invokeAll(function(o) {
            return o.beforeRoot && o.beforeRoot()
        })).then(function() {
            return Promise.all([n.getDependencies("scene"), n.getDependencies("animation"), n.getDependencies("camera")])
        }).then(function(o) {
            const a = {
                scene: o[0][i.scene || 0],
                scenes: o[0],
                animations: o[1],
                cameras: o[2],
                asset: i.asset,
                parser: n,
                userData: {}
            };
            return yo(s, a, i),
            Rs(a, i),
            Promise.all(n._invokeAll(function(c) {
                return c.afterRoot && c.afterRoot(a)
            })).then(function() {
                e(a)
            })
        }).catch(t)
    }
    _markDefs() {
        const e = this.json.nodes || []
          , t = this.json.skins || []
          , n = this.json.meshes || [];
        for (let i = 0, s = t.length; i < s; i++) {
            const o = t[i].joints;
            for (let a = 0, c = o.length; a < c; a++)
                e[o[a]].isBone = !0
        }
        for (let i = 0, s = e.length; i < s; i++) {
            const o = e[i];
            o.mesh !== void 0 && (this._addNodeRef(this.meshCache, o.mesh),
            o.skin !== void 0 && (n[o.mesh].isSkinnedMesh = !0)),
            o.camera !== void 0 && this._addNodeRef(this.cameraCache, o.camera)
        }
    }
    _addNodeRef(e, t) {
        t !== void 0 && (e.refs[t] === void 0 && (e.refs[t] = e.uses[t] = 0),
        e.refs[t]++)
    }
    _getNodeRef(e, t, n) {
        if (e.refs[t] <= 1)
            return n;
        const i = n.clone()
          , s = (o,a)=>{
            const c = this.associations.get(o);
            c != null && this.associations.set(a, c);
            for (const [h,d] of o.children.entries())
                s(d, a.children[h])
        }
        ;
        return s(n, i),
        i.name += "_instance_" + e.uses[t]++,
        i
    }
    _invokeOne(e) {
        const t = Object.values(this.plugins);
        t.push(this);
        for (let n = 0; n < t.length; n++) {
            const i = e(t[n]);
            if (i)
                return i
        }
        return null
    }
    _invokeAll(e) {
        const t = Object.values(this.plugins);
        t.unshift(this);
        const n = [];
        for (let i = 0; i < t.length; i++) {
            const s = e(t[i]);
            s && n.push(s)
        }
        return n
    }
    getDependency(e, t) {
        const n = e + ":" + t;
        let i = this.cache.get(n);
        if (!i) {
            switch (e) {
            case "scene":
                i = this.loadScene(t);
                break;
            case "node":
                i = this._invokeOne(function(s) {
                    return s.loadNode && s.loadNode(t)
                });
                break;
            case "mesh":
                i = this._invokeOne(function(s) {
                    return s.loadMesh && s.loadMesh(t)
                });
                break;
            case "accessor":
                i = this.loadAccessor(t);
                break;
            case "bufferView":
                i = this._invokeOne(function(s) {
                    return s.loadBufferView && s.loadBufferView(t)
                });
                break;
            case "buffer":
                i = this.loadBuffer(t);
                break;
            case "material":
                i = this._invokeOne(function(s) {
                    return s.loadMaterial && s.loadMaterial(t)
                });
                break;
            case "texture":
                i = this._invokeOne(function(s) {
                    return s.loadTexture && s.loadTexture(t)
                });
                break;
            case "skin":
                i = this.loadSkin(t);
                break;
            case "animation":
                i = this._invokeOne(function(s) {
                    return s.loadAnimation && s.loadAnimation(t)
                });
                break;
            case "camera":
                i = this.loadCamera(t);
                break;
            default:
                if (i = this._invokeOne(function(s) {
                    return s != this && s.getDependency && s.getDependency(e, t)
                }),
                !i)
                    throw new Error("Unknown type: " + e);
                break
            }
            this.cache.add(n, i)
        }
        return i
    }
    getDependencies(e) {
        let t = this.cache.get(e);
        if (!t) {
            const n = this
              , i = this.json[e + (e === "mesh" ? "es" : "s")] || [];
            t = Promise.all(i.map(function(s, o) {
                return n.getDependency(e, o)
            })),
            this.cache.add(e, t)
        }
        return t
    }
    loadBuffer(e) {
        const t = this.json.buffers[e]
          , n = this.fileLoader;
        if (t.type && t.type !== "arraybuffer")
            throw new Error("THREE.GLTFLoader: " + t.type + " buffer type is not supported.");
        if (t.uri === void 0 && e === 0)
            return Promise.resolve(this.extensions[vt.KHR_BINARY_GLTF].body);
        const i = this.options;
        return new Promise(function(s, o) {
            n.load(bc.resolveURL(t.uri, i.path), s, void 0, function() {
                o(new Error('THREE.GLTFLoader: Failed to load buffer "' + t.uri + '".'))
            })
        }
        )
    }
    loadBufferView(e) {
        const t = this.json.bufferViews[e];
        return this.getDependency("buffer", t.buffer).then(function(n) {
            const i = t.byteLength || 0
              , s = t.byteOffset || 0;
            return n.slice(s, s + i)
        })
    }
    loadAccessor(e) {
        const t = this
          , n = this.json
          , i = this.json.accessors[e];
        if (i.bufferView === void 0 && i.sparse === void 0) {
            const o = rm[i.type]
              , a = Ya[i.componentType]
              , c = i.normalized === !0
              , h = new a(i.count * o);
            return Promise.resolve(new pt(h,o,c))
        }
        const s = [];
        return i.bufferView !== void 0 ? s.push(this.getDependency("bufferView", i.bufferView)) : s.push(null),
        i.sparse !== void 0 && (s.push(this.getDependency("bufferView", i.sparse.indices.bufferView)),
        s.push(this.getDependency("bufferView", i.sparse.values.bufferView))),
        Promise.all(s).then(function(o) {
            const a = o[0]
              , c = rm[i.type]
              , h = Ya[i.componentType]
              , d = h.BYTES_PER_ELEMENT
              , l = d * c
              , f = i.byteOffset || 0
              , p = i.bufferView !== void 0 ? n.bufferViews[i.bufferView].byteStride : void 0
              , g = i.normalized === !0;
            let y, v;
            if (p && p !== l) {
                const _ = Math.floor(f / p)
                  , b = "InterleavedBuffer:" + i.bufferView + ":" + i.componentType + ":" + _ + ":" + i.count;
                let T = t.cache.get(b);
                T || (y = new h(a,_ * p,i.count * p / d),
                T = new g3(y,p / d),
                t.cache.add(b, T)),
                v = new B_(T,c,f % p / d,g)
            } else
                a === null ? y = new h(i.count * c) : y = new h(a,f,i.count * c),
                v = new pt(y,c,g);
            if (i.sparse !== void 0) {
                const _ = rm.SCALAR
                  , b = Ya[i.sparse.indices.componentType]
                  , T = i.sparse.indices.byteOffset || 0
                  , S = i.sparse.values.byteOffset || 0
                  , E = new b(o[1],T,i.sparse.count * _)
                  , P = new h(o[2],S,i.sparse.count * c);
                a !== null && (v = new pt(v.array.slice(),v.itemSize,v.normalized));
                for (let R = 0, O = E.length; R < O; R++) {
                    const w = E[R];
                    if (v.setX(w, P[R * c]),
                    c >= 2 && v.setY(w, P[R * c + 1]),
                    c >= 3 && v.setZ(w, P[R * c + 2]),
                    c >= 4 && v.setW(w, P[R * c + 3]),
                    c >= 5)
                        throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")
                }
            }
            return v
        })
    }
    loadTexture(e) {
        const t = this.json
          , n = this.options
          , s = t.textures[e].source
          , o = t.images[s];
        let a = this.textureLoader;
        if (o.uri) {
            const c = n.manager.getHandler(o.uri);
            c !== null && (a = c)
        }
        return this.loadTextureImage(e, s, a)
    }
    loadTextureImage(e, t, n) {
        const i = this
          , s = this.json
          , o = s.textures[e]
          , a = s.images[t]
          , c = (a.uri || a.bufferView) + ":" + o.sampler;
        if (this.textureCache[c])
            return this.textureCache[c];
        const h = this.loadImageSource(t, n).then(function(d) {
            d.flipY = !1,
            d.name = o.name || a.name || "",
            d.name === "" && typeof a.uri == "string" && a.uri.startsWith("data:image/") === !1 && (d.name = a.uri);
            const f = (s.samplers || {})[o.sampler] || {};
            return d.magFilter = Wx[f.magFilter] || Ot,
            d.minFilter = Wx[f.minFilter] || Do,
            d.wrapS = jx[f.wrapS] || ii,
            d.wrapT = jx[f.wrapT] || ii,
            i.associations.set(d, {
                textures: e
            }),
            d
        }).catch(function() {
            return null
        });
        return this.textureCache[c] = h,
        h
    }
    loadImageSource(e, t) {
        const n = this
          , i = this.json
          , s = this.options;
        if (this.sourceCache[e] !== void 0)
            return this.sourceCache[e].then(l=>l.clone());
        const o = i.images[e]
          , a = self.URL || self.webkitURL;
        let c = o.uri || ""
          , h = !1;
        if (o.bufferView !== void 0)
            c = n.getDependency("bufferView", o.bufferView).then(function(l) {
                h = !0;
                const f = new Blob([l],{
                    type: o.mimeType
                });
                return c = a.createObjectURL(f),
                c
            });
        else if (o.uri === void 0)
            throw new Error("THREE.GLTFLoader: Image " + e + " is missing URI and bufferView");
        const d = Promise.resolve(c).then(function(l) {
            return new Promise(function(f, p) {
                let g = f;
                t.isImageBitmapLoader === !0 && (g = function(y) {
                    const v = new Pn(y);
                    v.needsUpdate = !0,
                    f(v)
                }
                ),
                t.load(bc.resolveURL(l, s.path), g, void 0, p)
            }
            )
        }).then(function(l) {
            return h === !0 && a.revokeObjectURL(c),
            l.userData.mimeType = o.mimeType || Dz(o.uri),
            l
        }).catch(function(l) {
            throw console.error("THREE.GLTFLoader: Couldn't load texture", c),
            l
        });
        return this.sourceCache[e] = d,
        d
    }
    assignTexture(e, t, n, i) {
        const s = this;
        return this.getDependency("texture", n.index).then(function(o) {
            if (!o)
                return null;
            if (n.texCoord !== void 0 && n.texCoord > 0 && (o = o.clone(),
            o.channel = n.texCoord),
            s.extensions[vt.KHR_TEXTURE_TRANSFORM]) {
                const a = n.extensions !== void 0 ? n.extensions[vt.KHR_TEXTURE_TRANSFORM] : void 0;
                if (a) {
                    const c = s.associations.get(o);
                    o = s.extensions[vt.KHR_TEXTURE_TRANSFORM].extendTexture(o, a),
                    s.associations.set(o, c)
                }
            }
            return i !== void 0 && (o.colorSpace = i),
            e[t] = o,
            o
        })
    }
    assignFinalMaterial(e) {
        const t = e.geometry;
        let n = e.material;
        const i = t.attributes.tangent === void 0
          , s = t.attributes.color !== void 0
          , o = t.attributes.normal === void 0;
        if (e.isPoints) {
            const a = "PointsMaterial:" + n.uuid;
            let c = this.cache.get(a);
            c || (c = new qb,
            nr.prototype.copy.call(c, n),
            c.color.copy(n.color),
            c.map = n.map,
            c.sizeAttenuation = !1,
            this.cache.add(a, c)),
            n = c
        } else if (e.isLine) {
            const a = "LineBasicMaterial:" + n.uuid;
            let c = this.cache.get(a);
            c || (c = new H_,
            nr.prototype.copy.call(c, n),
            c.color.copy(n.color),
            c.map = n.map,
            this.cache.add(a, c)),
            n = c
        }
        if (i || s || o) {
            let a = "ClonedMaterial:" + n.uuid + ":";
            i && (a += "derivative-tangents:"),
            s && (a += "vertex-colors:"),
            o && (a += "flat-shading:");
            let c = this.cache.get(a);
            c || (c = n.clone(),
            s && (c.vertexColors = !0),
            o && (c.flatShading = !0),
            i && (c.normalScale && (c.normalScale.y *= -1),
            c.clearcoatNormalScale && (c.clearcoatNormalScale.y *= -1)),
            this.cache.add(a, c),
            this.associations.set(c, this.associations.get(n))),
            n = c
        }
        e.material = n
    }
    getMaterialType() {
        return j_
    }
    loadMaterial(e) {
        const t = this
          , n = this.json
          , i = this.extensions
          , s = n.materials[e];
        let o;
        const a = {}
          , c = s.extensions || {}
          , h = [];
        if (c[vt.KHR_MATERIALS_UNLIT]) {
            const l = i[vt.KHR_MATERIALS_UNLIT];
            o = l.getMaterialType(),
            h.push(l.extendParams(a, s, t))
        } else {
            const l = s.pbrMetallicRoughness || {};
            if (a.color = new Ke(1,1,1),
            a.opacity = 1,
            Array.isArray(l.baseColorFactor)) {
                const f = l.baseColorFactor;
                a.color.setRGB(f[0], f[1], f[2], gn),
                a.opacity = f[3]
            }
            l.baseColorTexture !== void 0 && h.push(t.assignTexture(a, "map", l.baseColorTexture, Ft)),
            a.metalness = l.metallicFactor !== void 0 ? l.metallicFactor : 1,
            a.roughness = l.roughnessFactor !== void 0 ? l.roughnessFactor : 1,
            l.metallicRoughnessTexture !== void 0 && (h.push(t.assignTexture(a, "metalnessMap", l.metallicRoughnessTexture)),
            h.push(t.assignTexture(a, "roughnessMap", l.metallicRoughnessTexture))),
            o = this._invokeOne(function(f) {
                return f.getMaterialType && f.getMaterialType(e)
            }),
            h.push(Promise.all(this._invokeAll(function(f) {
                return f.extendMaterialParams && f.extendMaterialParams(e, a)
            })))
        }
        s.doubleSided === !0 && (a.side = mr);
        const d = s.alphaMode || sm.OPAQUE;
        if (d === sm.BLEND ? (a.transparent = !0,
        a.depthWrite = !1) : (a.transparent = !1,
        d === sm.MASK && (a.alphaTest = s.alphaCutoff !== void 0 ? s.alphaCutoff : .5)),
        s.normalTexture !== void 0 && o !== _r && (h.push(t.assignTexture(a, "normalMap", s.normalTexture)),
        a.normalScale = new Ce(1,1),
        s.normalTexture.scale !== void 0)) {
            const l = s.normalTexture.scale;
            a.normalScale.set(l, l)
        }
        if (s.occlusionTexture !== void 0 && o !== _r && (h.push(t.assignTexture(a, "aoMap", s.occlusionTexture)),
        s.occlusionTexture.strength !== void 0 && (a.aoMapIntensity = s.occlusionTexture.strength)),
        s.emissiveFactor !== void 0 && o !== _r) {
            const l = s.emissiveFactor;
            a.emissive = new Ke().setRGB(l[0], l[1], l[2], gn)
        }
        return s.emissiveTexture !== void 0 && o !== _r && h.push(t.assignTexture(a, "emissiveMap", s.emissiveTexture, Ft)),
        Promise.all(h).then(function() {
            const l = new o(a);
            return s.name && (l.name = s.name),
            Rs(l, s),
            t.associations.set(l, {
                materials: e
            }),
            s.extensions && yo(i, l, s),
            l
        })
    }
    createUniqueName(e) {
        const t = Pt.sanitizeNodeName(e || "");
        return t in this.nodeNamesUsed ? t + "_" + ++this.nodeNamesUsed[t] : (this.nodeNamesUsed[t] = 0,
        t)
    }
    loadGeometries(e) {
        const t = this
          , n = this.extensions
          , i = this.primitiveCache;
        function s(a) {
            return n[vt.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(a, t).then(function(c) {
                return Xx(c, a, t)
            })
        }
        const o = [];
        for (let a = 0, c = e.length; a < c; a++) {
            const h = e[a]
              , d = Lz(h)
              , l = i[d];
            if (l)
                o.push(l.promise);
            else {
                let f;
                h.extensions && h.extensions[vt.KHR_DRACO_MESH_COMPRESSION] ? f = s(h) : f = Xx(new mn, h, t),
                i[d] = {
                    primitive: h,
                    promise: f
                },
                o.push(f)
            }
        }
        return Promise.all(o)
    }
    loadMesh(e) {
        const t = this
          , n = this.json
          , i = this.extensions
          , s = n.meshes[e]
          , o = s.primitives
          , a = [];
        for (let c = 0, h = o.length; c < h; c++) {
            const d = o[c].material === void 0 ? Rz(this.cache) : this.getDependency("material", o[c].material);
            a.push(d)
        }
        return a.push(t.loadGeometries(o)),
        Promise.all(a).then(function(c) {
            const h = c.slice(0, c.length - 1)
              , d = c[c.length - 1]
              , l = [];
            for (let p = 0, g = d.length; p < g; p++) {
                const y = d[p]
                  , v = o[p];
                let _;
                const b = h[p];
                if (v.mode === Ki.TRIANGLES || v.mode === Ki.TRIANGLE_STRIP || v.mode === Ki.TRIANGLE_FAN || v.mode === void 0)
                    _ = s.isSkinnedMesh === !0 ? new Wb(y,b) : new en(y,b),
                    _.isSkinnedMesh === !0 && _.normalizeSkinWeights(),
                    v.mode === Ki.TRIANGLE_STRIP ? _.geometry = Vx(_.geometry, wb) : v.mode === Ki.TRIANGLE_FAN && (_.geometry = Vx(_.geometry, km));
                else if (v.mode === Ki.LINES)
                    _ = new T3(y,b);
                else if (v.mode === Ki.LINE_STRIP)
                    _ = new V_(y,b);
                else if (v.mode === Ki.LINE_LOOP)
                    _ = new b3(y,b);
                else if (v.mode === Ki.POINTS)
                    _ = new gf(y,b);
                else
                    throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + v.mode);
                Object.keys(_.geometry.morphAttributes).length > 0 && Iz(_, s),
                _.name = t.createUniqueName(s.name || "mesh_" + e),
                Rs(_, s),
                v.extensions && yo(i, _, v),
                t.assignFinalMaterial(_),
                l.push(_)
            }
            for (let p = 0, g = l.length; p < g; p++)
                t.associations.set(l[p], {
                    meshes: e,
                    primitives: p
                });
            if (l.length === 1)
                return s.extensions && yo(i, l[0], s),
                l[0];
            const f = new gr;
            s.extensions && yo(i, f, s),
            t.associations.set(f, {
                meshes: e
            });
            for (let p = 0, g = l.length; p < g; p++)
                f.add(l[p]);
            return f
        })
    }
    loadCamera(e) {
        let t;
        const n = this.json.cameras[e]
          , i = n[n.type];
        if (!i) {
            console.warn("THREE.GLTFLoader: Missing camera parameters.");
            return
        }
        return n.type === "perspective" ? t = new qn(Dn.radToDeg(i.yfov),i.aspectRatio || 1,i.znear || 1,i.zfar || 2e6) : n.type === "orthographic" && (t = new vl(-i.xmag,i.xmag,i.ymag,-i.ymag,i.znear,i.zfar)),
        n.name && (t.name = this.createUniqueName(n.name)),
        Rs(t, n),
        Promise.resolve(t)
    }
    loadSkin(e) {
        const t = this.json.skins[e]
          , n = [];
        for (let i = 0, s = t.joints.length; i < s; i++)
            n.push(this._loadNodeShallow(t.joints[i]));
        return t.inverseBindMatrices !== void 0 ? n.push(this.getDependency("accessor", t.inverseBindMatrices)) : n.push(null),
        Promise.all(n).then(function(i) {
            const s = i.pop()
              , o = i
              , a = []
              , c = [];
            for (let h = 0, d = o.length; h < d; h++) {
                const l = o[h];
                if (l) {
                    a.push(l);
                    const f = new it;
                    s !== null && f.fromArray(s.array, h * 16),
                    c.push(f)
                } else
                    console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', t.joints[h])
            }
            return new k_(a,c)
        })
    }
    loadAnimation(e) {
        const t = this.json
          , n = this
          , i = t.animations[e]
          , s = i.name ? i.name : "animation_" + e
          , o = []
          , a = []
          , c = []
          , h = []
          , d = [];
        for (let l = 0, f = i.channels.length; l < f; l++) {
            const p = i.channels[l]
              , g = i.samplers[p.sampler]
              , y = p.target
              , v = y.node
              , _ = i.parameters !== void 0 ? i.parameters[g.input] : g.input
              , b = i.parameters !== void 0 ? i.parameters[g.output] : g.output;
            y.node !== void 0 && (o.push(this.getDependency("node", v)),
            a.push(this.getDependency("accessor", _)),
            c.push(this.getDependency("accessor", b)),
            h.push(g),
            d.push(y))
        }
        return Promise.all([Promise.all(o), Promise.all(a), Promise.all(c), Promise.all(h), Promise.all(d)]).then(function(l) {
            const f = l[0]
              , p = l[1]
              , g = l[2]
              , y = l[3]
              , v = l[4]
              , _ = [];
            for (let b = 0, T = f.length; b < T; b++) {
                const S = f[b]
                  , E = p[b]
                  , P = g[b]
                  , R = y[b]
                  , O = v[b];
                if (S === void 0)
                    continue;
                S.updateMatrix && S.updateMatrix();
                const w = n._createAnimationTracks(S, E, P, R, O);
                if (w)
                    for (let I = 0; I < w.length; I++)
                        _.push(w[I])
            }
            return new qm(s,void 0,_)
        })
    }
    createNodeMesh(e) {
        const t = this.json
          , n = this
          , i = t.nodes[e];
        return i.mesh === void 0 ? null : n.getDependency("mesh", i.mesh).then(function(s) {
            const o = n._getNodeRef(n.meshCache, i.mesh, s);
            return i.weights !== void 0 && o.traverse(function(a) {
                if (a.isMesh)
                    for (let c = 0, h = i.weights.length; c < h; c++)
                        a.morphTargetInfluences[c] = i.weights[c]
            }),
            o
        })
    }
    loadNode(e) {
        const t = this.json
          , n = this
          , i = t.nodes[e]
          , s = n._loadNodeShallow(e)
          , o = []
          , a = i.children || [];
        for (let h = 0, d = a.length; h < d; h++)
            o.push(n.getDependency("node", a[h]));
        const c = i.skin === void 0 ? Promise.resolve(null) : n.getDependency("skin", i.skin);
        return Promise.all([s, Promise.all(o), c]).then(function(h) {
            const d = h[0]
              , l = h[1]
              , f = h[2];
            f !== null && d.traverse(function(p) {
                p.isSkinnedMesh && p.bind(f, Oz)
            });
            for (let p = 0, g = l.length; p < g; p++)
                d.add(l[p]);
            return d
        })
    }
    _loadNodeShallow(e) {
        const t = this.json
          , n = this.extensions
          , i = this;
        if (this.nodeCache[e] !== void 0)
            return this.nodeCache[e];
        const s = t.nodes[e]
          , o = s.name ? i.createUniqueName(s.name) : ""
          , a = []
          , c = i._invokeOne(function(h) {
            return h.createNodeMesh && h.createNodeMesh(e)
        });
        return c && a.push(c),
        s.camera !== void 0 && a.push(i.getDependency("camera", s.camera).then(function(h) {
            return i._getNodeRef(i.cameraCache, s.camera, h)
        })),
        i._invokeAll(function(h) {
            return h.createNodeAttachment && h.createNodeAttachment(e)
        }).forEach(function(h) {
            a.push(h)
        }),
        this.nodeCache[e] = Promise.all(a).then(function(h) {
            let d;
            if (s.isBone === !0 ? d = new jb : h.length > 1 ? d = new gr : h.length === 1 ? d = h[0] : d = new Yt,
            d !== h[0])
                for (let l = 0, f = h.length; l < f; l++)
                    d.add(h[l]);
            if (s.name && (d.userData.name = s.name,
            d.name = o),
            Rs(d, s),
            s.extensions && yo(n, d, s),
            s.matrix !== void 0) {
                const l = new it;
                l.fromArray(s.matrix),
                d.applyMatrix4(l)
            } else
                s.translation !== void 0 && d.position.fromArray(s.translation),
                s.rotation !== void 0 && d.quaternion.fromArray(s.rotation),
                s.scale !== void 0 && d.scale.fromArray(s.scale);
            return i.associations.has(d) || i.associations.set(d, {}),
            i.associations.get(d).nodes = e,
            d
        }),
        this.nodeCache[e]
    }
    loadScene(e) {
        const t = this.extensions
          , n = this.json.scenes[e]
          , i = this
          , s = new gr;
        n.name && (s.name = i.createUniqueName(n.name)),
        Rs(s, n),
        n.extensions && yo(t, s, n);
        const o = n.nodes || []
          , a = [];
        for (let c = 0, h = o.length; c < h; c++)
            a.push(i.getDependency("node", o[c]));
        return Promise.all(a).then(function(c) {
            for (let d = 0, l = c.length; d < l; d++)
                s.add(c[d]);
            const h = d=>{
                const l = new Map;
                for (const [f,p] of i.associations)
                    (f instanceof nr || f instanceof Pn) && l.set(f, p);
                return d.traverse(f=>{
                    const p = i.associations.get(f);
                    p != null && l.set(f, p)
                }
                ),
                l
            }
            ;
            return i.associations = h(s),
            s
        })
    }
    _createAnimationTracks(e, t, n, i, s) {
        const o = []
          , a = e.name ? e.name : e.uuid
          , c = [];
        Ss[s.path] === Ss.weights ? e.traverse(function(f) {
            f.morphTargetInfluences && c.push(f.name ? f.name : f.uuid)
        }) : c.push(a);
        let h;
        switch (Ss[s.path]) {
        case Ss.weights:
            h = ul;
            break;
        case Ss.rotation:
            h = Uo;
            break;
        case Ss.position:
        case Ss.scale:
            h = hl;
            break;
        default:
            switch (n.itemSize) {
            case 1:
                h = ul;
                break;
            case 2:
            case 3:
            default:
                h = hl;
                break
            }
            break
        }
        const d = i.interpolation !== void 0 ? Pz[i.interpolation] : ol
          , l = this._getArrayFromAccessor(n);
        for (let f = 0, p = c.length; f < p; f++) {
            const g = new h(c[f] + "." + Ss[s.path],t.array,l,d);
            i.interpolation === "CUBICSPLINE" && this._createCubicSplineTrackInterpolant(g),
            o.push(g)
        }
        return o
    }
    _getArrayFromAccessor(e) {
        let t = e.array;
        if (e.normalized) {
            const n = o_(t.constructor)
              , i = new Float32Array(t.length);
            for (let s = 0, o = t.length; s < o; s++)
                i[s] = t[s] * n;
            t = i
        }
        return t
    }
    _createCubicSplineTrackInterpolant(e) {
        e.createInterpolant = function(n) {
            const i = this instanceof Uo ? Az : mS;
            return new i(this.times,this.values,this.getValueSize() / 3,n)
        }
        ,
        e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0
    }
}
function Nz(r, e, t) {
    const n = e.attributes
      , i = new yn;
    if (n.POSITION !== void 0) {
        const a = t.json.accessors[n.POSITION]
          , c = a.min
          , h = a.max;
        if (c !== void 0 && h !== void 0) {
            if (i.set(new k(c[0],c[1],c[2]), new k(h[0],h[1],h[2])),
            a.normalized) {
                const d = o_(Ya[a.componentType]);
                i.min.multiplyScalar(d),
                i.max.multiplyScalar(d)
            }
        } else {
            console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
            return
        }
    } else
        return;
    const s = e.targets;
    if (s !== void 0) {
        const a = new k
          , c = new k;
        for (let h = 0, d = s.length; h < d; h++) {
            const l = s[h];
            if (l.POSITION !== void 0) {
                const f = t.json.accessors[l.POSITION]
                  , p = f.min
                  , g = f.max;
                if (p !== void 0 && g !== void 0) {
                    if (c.setX(Math.max(Math.abs(p[0]), Math.abs(g[0]))),
                    c.setY(Math.max(Math.abs(p[1]), Math.abs(g[1]))),
                    c.setZ(Math.max(Math.abs(p[2]), Math.abs(g[2]))),
                    f.normalized) {
                        const y = o_(Ya[f.componentType]);
                        c.multiplyScalar(y)
                    }
                    a.max(c)
                } else
                    console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")
            }
        }
        i.expandByVector(a)
    }
    r.boundingBox = i;
    const o = new Mr;
    i.getCenter(o.center),
    o.radius = i.min.distanceTo(i.max) / 2,
    r.boundingSphere = o
}
function Xx(r, e, t) {
    const n = e.attributes
      , i = [];
    function s(o, a) {
        return t.getDependency("accessor", o).then(function(c) {
            r.setAttribute(a, c)
        })
    }
    for (const o in n) {
        const a = s_[o] || o.toLowerCase();
        a in r.attributes || i.push(s(n[o], a))
    }
    if (e.indices !== void 0 && !r.index) {
        const o = t.getDependency("accessor", e.indices).then(function(a) {
            r.setIndex(a)
        });
        i.push(o)
    }
    return Rt.workingColorSpace !== gn && "COLOR_0"in n && console.warn(`THREE.GLTFLoader: Converting vertex colors from "srgb-linear" to "${Rt.workingColorSpace}" not supported.`),
    Rs(r, e),
    Nz(r, e, t),
    Promise.all(i).then(function() {
        return e.targets !== void 0 ? Cz(r, e.targets, t) : r
    })
}
const am = new WeakMap;
class Fz extends ko {
    constructor(e) {
        super(e),
        this.decoderPath = "",
        this.decoderConfig = {},
        this.decoderBinary = null,
        this.decoderPending = null,
        this.workerLimit = 4,
        this.workerPool = [],
        this.workerNextTaskID = 1,
        this.workerSourceURL = "",
        this.defaultAttributeIDs = {
            position: "POSITION",
            normal: "NORMAL",
            color: "COLOR",
            uv: "TEX_COORD"
        },
        this.defaultAttributeTypes = {
            position: "Float32Array",
            normal: "Float32Array",
            color: "Float32Array",
            uv: "Float32Array"
        }
    }
    setDecoderPath(e) {
        return this.decoderPath = e,
        this
    }
    setDecoderConfig(e) {
        return this.decoderConfig = e,
        this
    }
    setWorkerLimit(e) {
        return this.workerLimit = e,
        this
    }
    load(e, t, n, i) {
        const s = new Qh(this.manager);
        s.setPath(this.path),
        s.setResponseType("arraybuffer"),
        s.setRequestHeader(this.requestHeader),
        s.setWithCredentials(this.withCredentials),
        s.load(e, o=>{
            this.parse(o, t, i)
        }
        , n, i)
    }
    parse(e, t, n) {
        this.decodeDracoFile(e, t, null, null, Ft).catch(n)
    }
    decodeDracoFile(e, t, n, i, s=gn) {
        const o = {
            attributeIDs: n || this.defaultAttributeIDs,
            attributeTypes: i || this.defaultAttributeTypes,
            useUniqueIDs: !!n,
            vertexColorSpace: s
        };
        return this.decodeGeometry(e, o).then(t)
    }
    decodeGeometry(e, t) {
        const n = JSON.stringify(t);
        if (am.has(e)) {
            const c = am.get(e);
            if (c.key === n)
                return c.promise;
            if (e.byteLength === 0)
                throw new Error("THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.")
        }
        let i;
        const s = this.workerNextTaskID++
          , o = e.byteLength
          , a = this._getWorker(s, o).then(c=>(i = c,
        new Promise((h,d)=>{
            i._callbacks[s] = {
                resolve: h,
                reject: d
            },
            i.postMessage({
                type: "decode",
                id: s,
                taskConfig: t,
                buffer: e
            }, [e])
        }
        ))).then(c=>this._createGeometry(c.geometry));
        return a.catch(()=>!0).then(()=>{
            i && s && this._releaseTask(i, s)
        }
        ),
        am.set(e, {
            key: n,
            promise: a
        }),
        a
    }
    _createGeometry(e) {
        const t = new mn;
        e.index && t.setIndex(new pt(e.index.array,1));
        for (let n = 0; n < e.attributes.length; n++) {
            const i = e.attributes[n]
              , s = i.name
              , o = i.array
              , a = i.itemSize
              , c = new pt(o,a);
            s === "color" && (this._assignVertexColorSpace(c, i.vertexColorSpace),
            c.normalized = !(o instanceof Float32Array)),
            t.setAttribute(s, c)
        }
        return t
    }
    _assignVertexColorSpace(e, t) {
        if (t !== Ft)
            return;
        const n = new Ke;
        for (let i = 0, s = e.count; i < s; i++)
            n.fromBufferAttribute(e, i).convertSRGBToLinear(),
            e.setXYZ(i, n.r, n.g, n.b)
    }
    _loadLibrary(e, t) {
        const n = new Qh(this.manager);
        return n.setPath(this.decoderPath),
        n.setResponseType(t),
        n.setWithCredentials(this.withCredentials),
        new Promise((i,s)=>{
            n.load(e, i, void 0, s)
        }
        )
    }
    preload() {
        return this._initDecoder(),
        this
    }
    _initDecoder() {
        if (this.decoderPending)
            return this.decoderPending;
        const e = typeof WebAssembly != "object" || this.decoderConfig.type === "js"
          , t = [];
        return e ? t.push(this._loadLibrary("draco_decoder.js", "text")) : (t.push(this._loadLibrary("draco_wasm_wrapper.js", "text")),
        t.push(this._loadLibrary("draco_decoder.wasm", "arraybuffer"))),
        this.decoderPending = Promise.all(t).then(n=>{
            const i = n[0];
            e || (this.decoderConfig.wasmBinary = n[1]);
            const s = Bz.toString()
              , o = ["/* draco decoder */", i, "", "/* worker */", s.substring(s.indexOf("{") + 1, s.lastIndexOf("}"))].join(`
`);
            this.workerSourceURL = URL.createObjectURL(new Blob([o]))
        }
        ),
        this.decoderPending
    }
    _getWorker(e, t) {
        return this._initDecoder().then(()=>{
            if (this.workerPool.length < this.workerLimit) {
                const i = new Worker(this.workerSourceURL);
                i._callbacks = {},
                i._taskCosts = {},
                i._taskLoad = 0,
                i.postMessage({
                    type: "init",
                    decoderConfig: this.decoderConfig
                }),
                i.onmessage = function(s) {
                    const o = s.data;
                    switch (o.type) {
                    case "decode":
                        i._callbacks[o.id].resolve(o);
                        break;
                    case "error":
                        i._callbacks[o.id].reject(o);
                        break;
                    default:
                        console.error('THREE.DRACOLoader: Unexpected message, "' + o.type + '"')
                    }
                }
                ,
                this.workerPool.push(i)
            } else
                this.workerPool.sort(function(i, s) {
                    return i._taskLoad > s._taskLoad ? -1 : 1
                });
            const n = this.workerPool[this.workerPool.length - 1];
            return n._taskCosts[e] = t,
            n._taskLoad += t,
            n
        }
        )
    }
    _releaseTask(e, t) {
        e._taskLoad -= e._taskCosts[t],
        delete e._callbacks[t],
        delete e._taskCosts[t]
    }
    debug() {
        console.log("Task load: ", this.workerPool.map(e=>e._taskLoad))
    }
    dispose() {
        for (let e = 0; e < this.workerPool.length; ++e)
            this.workerPool[e].terminate();
        return this.workerPool.length = 0,
        this.workerSourceURL !== "" && URL.revokeObjectURL(this.workerSourceURL),
        this
    }
}
function Bz() {
    let r, e;
    onmessage = function(o) {
        const a = o.data;
        switch (a.type) {
        case "init":
            r = a.decoderConfig,
            e = new Promise(function(d) {
                r.onModuleLoaded = function(l) {
                    d({
                        draco: l
                    })
                }
                ,
                DracoDecoderModule(r)
            }
            );
            break;
        case "decode":
            const c = a.buffer
              , h = a.taskConfig;
            e.then(d=>{
                const l = d.draco
                  , f = new l.Decoder;
                try {
                    const p = t(l, f, new Int8Array(c), h)
                      , g = p.attributes.map(y=>y.array.buffer);
                    p.index && g.push(p.index.array.buffer),
                    self.postMessage({
                        type: "decode",
                        id: a.id,
                        geometry: p
                    }, g)
                } catch (p) {
                    console.error(p),
                    self.postMessage({
                        type: "error",
                        id: a.id,
                        error: p.message
                    })
                } finally {
                    l.destroy(f)
                }
            }
            );
            break
        }
    }
    ;
    function t(o, a, c, h) {
        const d = h.attributeIDs
          , l = h.attributeTypes;
        let f, p;
        const g = a.GetEncodedGeometryType(c);
        if (g === o.TRIANGULAR_MESH)
            f = new o.Mesh,
            p = a.DecodeArrayToMesh(c, c.byteLength, f);
        else if (g === o.POINT_CLOUD)
            f = new o.PointCloud,
            p = a.DecodeArrayToPointCloud(c, c.byteLength, f);
        else
            throw new Error("THREE.DRACOLoader: Unexpected geometry type.");
        if (!p.ok() || f.ptr === 0)
            throw new Error("THREE.DRACOLoader: Decoding failed: " + p.error_msg());
        const y = {
            index: null,
            attributes: []
        };
        for (const v in d) {
            const _ = self[l[v]];
            let b, T;
            if (h.useUniqueIDs)
                T = d[v],
                b = a.GetAttributeByUniqueId(f, T);
            else {
                if (T = a.GetAttributeId(f, o[d[v]]),
                T === -1)
                    continue;
                b = a.GetAttribute(f, T)
            }
            const S = i(o, a, f, v, _, b);
            v === "color" && (S.vertexColorSpace = h.vertexColorSpace),
            y.attributes.push(S)
        }
        return g === o.TRIANGULAR_MESH && (y.index = n(o, a, f)),
        o.destroy(f),
        y
    }
    function n(o, a, c) {
        const d = c.num_faces() * 3
          , l = d * 4
          , f = o._malloc(l);
        a.GetTrianglesUInt32Array(c, l, f);
        const p = new Uint32Array(o.HEAPF32.buffer,f,d).slice();
        return o._free(f),
        {
            array: p,
            itemSize: 1
        }
    }
    function i(o, a, c, h, d, l) {
        const f = l.num_components()
          , g = c.num_points() * f
          , y = g * d.BYTES_PER_ELEMENT
          , v = s(o, d)
          , _ = o._malloc(y);
        a.GetAttributeDataArrayForAllPoints(c, l, v, y, _);
        const b = new d(o.HEAPF32.buffer,_,g).slice();
        return o._free(_),
        {
            name: h,
            array: b,
            itemSize: f
        }
    }
    function s(o, a) {
        switch (a) {
        case Float32Array:
            return o.DT_FLOAT32;
        case Int8Array:
            return o.DT_INT8;
        case Int16Array:
            return o.DT_INT16;
        case Int32Array:
            return o.DT_INT32;
        case Uint8Array:
            return o.DT_UINT8;
        case Uint16Array:
            return o.DT_UINT16;
        case Uint32Array:
            return o.DT_UINT32
        }
    }
}
const kz = [{
    key: "radial",
    type: "texture",
    path: "/gl/images/radial.jpg"
}, {
    key: "ice-diffuse-3",
    type: "texture",
    path: "/gl/images/ice-diffuse-3.jpg"
}, {
    key: "ice-normal-4",
    type: "texture",
    path: "/gl/images/ice-normal-4.png"
}, {
    key: "ice-density-4",
    type: "texture",
    path: "/gl/images/ice-density-4.jpg"
}, {
    key: "water-normal-1",
    type: "texture",
    path: "/gl/images/water-normal-1.jpg"
}, {
    key: "water-normal-2",
    type: "texture",
    path: "/gl/images/water-normal-3.png"
}, {
    key: "perlin",
    type: "texture",
    path: "/gl/images/perlin.png"
}, {
    key: "perlin-3",
    type: "texture",
    path: "/gl/images/perlin3.png"
}, {
    key: "fog-noise",
    type: "texture",
    path: "/gl/images/fognoise.jpg"
}, {
    key: "fog-smoke",
    type: "texture",
    path: "/gl/images/smoke.png"
}, {
    key: "strike-map",
    type: "texture",
    path: "/gl/images/strike.jpg"
}, {
    key: "rays-map",
    type: "texture",
    path: "/gl/images/noise-fbm.png"
}, {
    key: "logo",
    type: "texture",
    path: "/gl/images/logo_n.png"
}, {
    key: "logo2",
    type: "texture",
    path: "/gl/images/logo_p.png"
}, {
    key: "lut",
    type: "texture",
    path: "/gl/images/lut.png"
}, {
    key: "dragon",
    type: "gltfModel",
    path: "/gl/models/dragon-fly-flames-bb.glb"
}, {
    key: "strike-model",
    type: "gltfModel",
    path: "/gl/models/strike.glb"
}, {
    key: "awww",
    type: "gltfModel",
    path: "/gl/models/awww.glb"
}, {
    key: "fwa",
    type: "gltfModel",
    path: "/gl/models/fwa.glb"
}]
  , zz = 800;
class Hz {
    constructor() {
        this._loaders = {
            gltfLoader: new iz,
            textureLoader: new $b
        };
        const e = new Fz;
        e.setDecoderPath("three/draco/"),
        this._loaders.gltfLoader.setDRACOLoader(e),
        this._loaded = 0,
        this._promises = [],
        this._resources = new Map,
        this._promisesMap = new Map,
        this._onLoadCb = void 0,
        this._time = !1,
        this._debouncedLoadComplete = nz(this._internalComplete, zz)
    }
    get(e) {
        return this._resources.get(e)
    }
    getLoadPromise() {
        return Promise.all(this._promises)
    }
    startLoad(e=()=>{}
    , t=[], n) {
        this._onLoadCb = e,
        this._gl = n,
        this._pmremGenerator = new Gm(this._gl),
        this._time = performance.now(),
        [...t || [], ...kz || []].forEach(s=>{
            this.startSingleLoad(s)
        }
        )
    }
    startSingleLoad(e) {
        if (this._resources.has(e.key))
            return this._promisesMap.get(e.key);
        const t = new Promise(n=>{
            if (this._resources.set(e.key, !1),
            e.type === "gltfModel")
                this._loaders.gltfLoader.load(e.path, i=>{
                    this.onSingleLoad(e.key, i, n)
                }
                );
            else if (e.type === "texture")
                this._loaders.textureLoader.load(e.path, i=>{
                    i.colorSpace = Ft,
                    i.needsUpdate = !0,
                    i.minFilter = i.magFilter = Ot,
                    this.onSingleLoad(e.key, i, n, e)
                }
                );
            else if (e.type === "video") {
                const i = document.createElement("video");
                i.width = 0,
                i.height = 0,
                i.loop = !0,
                i.muted = !0,
                i.playsInline = !0,
                i.preload = "auto",
                i.crossOrigin = "anonymous",
                i.style.display = "none",
                i.src = e.path,
                i.type = "video/mp4",
                document.body.appendChild(i),
                i.addEventListener("loadedmetadata", ()=>{
                    const s = new S3(i);
                    s.userData.video = i,
                    s.colorSpace = Ft,
                    s.needsUpdate = !0,
                    this.onSingleLoad(e.key, s, n, e)
                }
                ),
                i.load()
            } else
                e.type === "fbo" ? this._loaders.exrLoader.load(e.path, i=>{
                    i.minFilter = i.magFilter = Jt,
                    i.generateMipmaps = !1,
                    i.needsUpdate = !0,
                    this.onSingleLoad(e.key, i, n, e)
                }
                ) : e.type === "envmap" && (this._pmremGenerator.compileEquirectangularShader(),
                this._loaders.textureLoader.load(e.path, i=>{
                    i.colorSpace = Ft,
                    i.needsUpdate = !0;
                    const s = this._pmremGenerator.fromEquirectangular(i).texture;
                    this.onSingleLoad(e.key, s, n)
                }
                ))
        }
        );
        return this._promises.push(t),
        this._promisesMap.set(e.key, t),
        t
    }
    load(e) {
        return this.startSingleLoad(e)
    }
    onSingleLoad(e, t, n) {
        console.log(`--- LOADED [${this._loaded} : ${this._resources.size - 1}]:`, e),
        this._loaded += 1,
        this._resources.set(e, t),
        n(t),
        this._debouncedLoadComplete()
    }
    _internalComplete() {
        [...this._resources.values()].includes(!1) || (console.log("--- LOADED:{{  COMPLETE }}}"),
        this._onLoadCb(),
        yt.emit(xt.WEBGL_LOADED))
    }
}
const a_ = new Hz
  , dn = r=>a_.get(r)
  , An = {
    vat: {
        texture: {
            size: 512
        }
    },
    timeScale: {
        max: 1,
        min: .2
    },
    environment: {
        plane: {
            size: 29
        }
    },
    renderOrder: {
        particleMesh: 101,
        reflector: 1,
        terrainBlock: 1,
        fog: 2,
        flames: 101,
        strikes: 3,
        rays: 1e5
    },
    composer: {
        responsive: [{
            size: 1400,
            radius: .48,
            intensity: 1.75,
            levels: 5,
            luminanceThreshold: 1.2,
            luminanceSmoothing: .7
        }, {
            size: 1800,
            radius: .3,
            intensity: 3,
            levels: 6,
            luminanceThreshold: 1.1,
            luminanceSmoothing: .9
        }]
    }
};
var Vz = `uniform mat4 uTextureMatrix;

varying vec2 vUv;
varying vec2 vUv2;
varying vec4 vProjectorUv;

void main(){
  vProjectorUv = uTextureMatrix * vec4( position, 1.0 );
  vUv = uv * 2.0;
  vUv2 = uv;
  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
}`
  , Gz = `uniform float uTime;
uniform sampler2D uDiffuse;
uniform sampler2D uFluidTexture;
uniform sampler2D uNormal1;
uniform sampler2D uNormal2;
uniform sampler2D uPerlin;

varying vec2 vUv;
varying vec2 vUv2;
varying vec4 vProjectorUv;

float w0( float a ) {
    return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
}

float w1( float a ) {
    return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
}

float w2( float a ){
    return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
}

float w3( float a ) {
    return ( 1.0 / 6.0 ) * ( a * a * a );
}

float g0( float a ) {
    return w0( a ) + w1( a );
}

float g1( float a ) {
    return w2( a ) + w3( a );
}

float h0( float a ) {
    return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
}

float h1( float a ) {
    return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
}

vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
    uv = uv * texelSize.zw + 0.5;

    vec2 iuv = floor( uv );
    vec2 fuv = fract( uv );

    float g0x = g0( fuv.x );
    float g1x = g1( fuv.x );
    float h0x = h0( fuv.x );
    float h1x = h1( fuv.x );
    float h0y = h0( fuv.y );
    float h1y = h1( fuv.y );

    vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
    vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
    vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
    vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;

    return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) )
        + g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );

}

vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
    vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
    vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
    vec2 fLodSizeInv = 1.0 / fLodSize;
    vec2 cLodSizeInv = 1.0 / cLodSize;
    vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
    vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
    return mix( fSample, cSample, fract( lod ) );
}

void main(){
  float t = uTime;
  vec2 reflectionUv = vProjectorUv.xy / vProjectorUv.w;

  vec2 normal1 = texture2D(uNormal2, reflectionUv.xy * 0.6 + vec2(0.0, -t * 1.5)).xy;
  vec2 normal2 = texture2D(uNormal2, reflectionUv.xy * 0.5 + vec2(t * 0.2, -t * 0.8)).xy;
  vec2 normal = mix(normal1, normal2, 0.5) * 2.0;

  float f= 0.9;
  vec4 perlin1 = texture2D(uPerlin, f * vUv.xy + vec2(0.0 * t, f * - 1.9 * t));
  vec4 perlin2 = texture2D(uPerlin, 2.0 * f * vUv.xy + vec2(-0.0 * t, - 1.9 * t));
  vec4 perlin = mix(perlin1, perlin2, 0.5) * 2.0;
  float mp = smoothstep(0.20, 0.80, perlin.r);
  mp = pow(mp * 2.0, 1.2);

  vec4 ft = texture2D(uFluidTexture, vUv2);

  float WIDTH = float(FLUID_SIZE);
  vec2 cellSize = vec2( 1.0 / WIDTH, 1.0 / WIDTH );
  vec3 fluidNormal = vec3(
					( texture2D( uFluidTexture, vUv2 + vec2( - cellSize.x, 0 ) ).x - texture2D( uFluidTexture, vUv2 + vec2( cellSize.x, 0 ) ).x ) * WIDTH / 1.0,
					( texture2D( uFluidTexture, vUv2 + vec2( 0, - cellSize.y ) ).x - texture2D( uFluidTexture, vUv2 + vec2( 0, cellSize.y ) ).x ) * WIDTH / 1.0,
					1.0 );
  fluidNormal = normalize(fluidNormal);
  normal = mix(normal.xy, fluidNormal.xy, 0.5) * 2.0;

  float highlight = dot(normalize(vec3(normal, 1.0)), normalize(vec3(1.0, 1.2, 0.0)));
  highlight = max(0.0, highlight);
  highlight = smoothstep(0.65, 0.95, highlight);
  highlight = pow(highlight, 2.5);

  vec4 base = textureBicubic(uDiffuse, reflectionUv + normal.xy * 0.022, mp);
  base.rgb +=  highlight * 0.63;

  
  vec3 edges = vec3(0.0);
  float falloff = smoothstep(0.5, 0.4, distance(vUv2, vec2(0.5)));

  base.rgb = mix(edges, base.rgb, falloff);

  gl_FragColor = base;
}`;
class Wz extends Vt {
    constructor({map: e, textureMatrix: t, fluidTexture: n, fluidTextureSize: i}) {
        super(),
        this.name = "reflector",
        this._map = {
            value: e
        },
        this._fluidTexture = {
            value: n
        },
        this._textureMatrix = {
            value: t
        },
        this._normalMap1 = {
            value: dn("water-normal-1")
        },
        this._normalMap2 = {
            value: dn("water-normal-2")
        },
        this._perlinNoise = {
            value: dn("perlin")
        },
        this._time = {
            value: 0
        },
        this._fluidTextureSize = i,
        this._init()
    }
    _init() {
        this._normalMap1.value.wrapS = this._normalMap1.value.wrapT = ii,
        this._normalMap2.value.wrapS = this._normalMap2.value.wrapT = ii,
        this._perlinNoise.value.wrapS = this._perlinNoise.value.wrapT = sl,
        this.vertexShader = Vz,
        this.fragmentShader = Gz,
        this.uniforms = {
            uDiffuse: this._map,
            uNormal1: this._normalMap1,
            uNormal2: this._normalMap2,
            uPerlin: this._perlinNoise,
            uTextureMatrix: this._textureMatrix,
            uFluidTexture: this._fluidTexture,
            uTime: this._time
        },
        this.defines = {
            FLUID_SIZE: this._fluidTextureSize
        },
        this.depthTest = !0,
        this.depthWrite = !0
    }
}
var jz = `varying vec2 vUv;

void main(){
    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    vUv = uv;
}`
  , Xz = `#include <common>

uniform sampler2D uCurrentTexture;
uniform vec2 uMousePosition;
uniform vec2 uResolution;
uniform float uMouseSize;
uniform float uMouseIntensity;
uniform float uMouseProgress;
uniform float uViscosityConstant;

varying vec2 vUv;

void main()	{

  vec2 cellSize = 1.0 / (uResolution);
  vec2 uv = vUv;

  vec4 heightmapValue = texture2D( uCurrentTexture, uv );

  
  vec4 north = texture2D( uCurrentTexture, vUv + vec2( 0.0, cellSize.y ) );
  vec4 south = texture2D( uCurrentTexture, vUv + vec2( 0.0, - cellSize.y ) );
  vec4 east = texture2D( uCurrentTexture, vUv + vec2( cellSize.x, 0.0 ) );
  vec4 west = texture2D( uCurrentTexture, vUv + vec2( - cellSize.x, 0.0 ) );

  
  float newHeight = ((north.x + south.x + east.x + west.x) * 0.5 - heightmapValue.y) * uViscosityConstant;

  
  float mousePhase = clamp( length( ( vUv - vec2( 0.5 ) ) * 1.0 - vec2( uMousePosition.x, - uMousePosition.y ) ) * PI / uMouseSize, 0.0, PI );
  newHeight += ( cos( mousePhase ) + 1.0 ) * uMouseIntensity * uMouseProgress;

  heightmapValue.y = heightmapValue.x;
  heightmapValue.x = newHeight;

  gl_FragColor = heightmapValue;
  gl_FragColor = vec4(heightmapValue.rgb, 1.0);

}`;
const $a = 512
  , qz = $a
  , Oa = 1
  , qx = ()=>new vn($a,qz,{
    type: ce.gl.capabilities.isWebGL2 ? Ur : wn,
    generateMipmaps: !1,
    depthBuffer: !1,
    stencilBuffer: !1,
    minFilter: Ot,
    magFilter: Ot,
    samples: 0
});
class Kz {
    constructor(e) {
        this._props = e,
        this._camera = new vl(-Oa * .5,Oa * .5,Oa * .5,-Oa * .5,1,100),
        this._camera.position.z = 2,
        this._fbos = {
            read: qx(),
            write: qx()
        },
        this._mouseUv = new Ce(100,100),
        this._raycasterMesh = e.raycasterMesh || void 0,
        this._simulationMesh = void 0,
        this._debugMouseMesh = void 0,
        this._mouseActive = !1,
        this._mouseProgressDest = 0,
        this._onClickCb = void 0,
        this._init(),
        this._initEvents()
    }
    get raycasterMesh() {
        return this._raycasterMesh
    }
    get texture() {
        return this._fbos.read.texture
    }
    getSimulationTexture() {
        return this._fbos.read.texture
    }
    _init() {
        this._simulationMaterial = new Vt({
            name: "water-sim",
            vertexShader: jz,
            fragmentShader: Xz,
            uniforms: {
                uMousePosition: {
                    value: [0, 0]
                },
                uResolution: {
                    value: [$a, $a]
                },
                uMouseSize: {
                    value: .0045
                },
                uMouseIntensity: {
                    value: .04
                },
                uMouseProgress: {
                    value: 0
                },
                uViscosityConstant: {
                    value: .89
                },
                uCurrentTexture: {
                    value: this._fbos.read.texture
                }
            },
            defines: {
                BOUNDS: $a * 2
            }
        }),
        this._simulationMesh = new en(new Tr(Oa,Oa,1,1),this._simulationMaterial),
        this._raycasterMesh || (this._raycasterMesh = new en(new Tr(1,1,1,1),new _r({
            color: 2080458
        })),
        this._raycasterMesh.scale.setScalar(this._props.planeSize),
        this._raycasterMesh.rotation.x = -Math.PI * .5,
        this._raycasterMesh.position.y += 1)
    }
    _initEvents() {
        yt.on(xt.MOUSE_MOVE, this._onMouseMove.bind(this)),
        yt.on(xt.MOUSE_CLICK_NEXT, this._onMouseClick.bind(this))
    }
    _onMouseMove() {
        this._onClickCb?.kill(),
        ce.raycaster.setFromCamera(ce.mouse.static, ce.camera);
        const e = ce.raycaster.intersectObject(this._raycasterMesh);
        if (e.length > 0) {
            this._mouseActive = !0;
            const {uv: t} = e[0];
            this._mouseUv.copy(t)
        } else
            this._mouseUv.set(100, 100),
            this._mouseActive = !1
    }
    _onMouseClick() {
        this._onMouseMove(),
        this._simulationMaterial.uniforms.uMouseProgress.value = Math.random() * .1 + .05,
        this._onClickCb = Qt.delayedCall(.02, ()=>{
            this._simulationMaterial.uniforms.uMouseProgress.value = 0
        }
        )
    }
    render() {
        const e = this._mouseActive;
        this._mouseProgressDest = e ? 1 : 0,
        No(this._simulationMaterial.uniforms.uMouseProgress, "value", this._mouseProgressDest, e ? .3 : .1, ce.time.delta, e ? .75 : .95),
        this._simulationMaterial.uniforms.uMousePosition.value[0] = this._mouseUv.x - .5,
        this._simulationMaterial.uniforms.uMousePosition.value[1] = 1 - this._mouseUv.y - .5;
        const t = this._fbos.write;
        this._fbos.write = this._fbos.read,
        this._fbos.read = t,
        this._simulationMaterial.uniforms.uCurrentTexture.value = this._fbos.read.texture,
        ce.gl.setRenderTarget(this._fbos.write),
        ce.gl.autoClear = !1,
        ce.gl.render(this._simulationMesh, this._camera),
        ce.gl.setRenderTarget(null),
        this._mouseActive = !1
    }
    _addTheatre() {}
}
const Ua = new k
  , Kx = new Ct
  , Yx = new it
  , lm = An.environment.plane.size;
class Yz extends en {
    constructor({camera: e, scene: t, gl: n}) {
        super(),
        this._camera = e,
        this._gl = n,
        this._scene = t,
        this._waterSimulation,
        this._reflectionMesh = this,
        this._reflectorPlane = new pr,
        this._virtualCamera = new qn,
        this._normal = Ua.clone(),
        this._reflectorWorldPosition = Ua.clone(),
        this._cameraWorldPosition = Ua.clone(),
        this._rotationMatrix = Yx.clone(),
        this._textureMatrix = Yx.clone(),
        this._view = Ua.clone(),
        this._lookAtPosition = Ua.clone(),
        this._target = Ua.clone(),
        this._clipPlane = Kx.clone(),
        this._q = Kx.clone(),
        this._fbo = new vn(2048,2048,{
            generateMipmaps: !0,
            minFilter: S0,
            magFilter: S0,
            type: Ur,
            depth: !1,
            stencil: !1
        }),
        this._init()
    }
    _init() {
        this._initWaterSimulation(),
        this._initReflector()
    }
    _initReflector() {
        this.renderOrder = An.renderOrder.reflector,
        this.geometry = new Tr(lm,lm,1,1),
        this.material = new Wz({
            map: this._fbo.texture,
            textureMatrix: this._textureMatrix,
            fluidTexture: this._waterSimulation.texture,
            fluidTextureSize: $a
        }),
        this.material.onBeforeRender = ()=>{
            if (ce.frames % 2 !== 0 && !ce.mouse.isDragging || (this._reflectorWorldPosition.setFromMatrixPosition(this._reflectionMesh.matrixWorld),
            this._cameraWorldPosition.setFromMatrixPosition(this._camera.matrixWorld),
            this._rotationMatrix.extractRotation(this._reflectionMesh.matrixWorld),
            this._normal.set(0, 0, 1),
            this._normal.applyMatrix4(this._rotationMatrix),
            this._view.subVectors(this._reflectorWorldPosition, this._cameraWorldPosition),
            this._view.dot(this._normal) > 0))
                return;
            this._view.reflect(this._normal).negate(),
            this._view.add(this._reflectorWorldPosition),
            this._rotationMatrix.extractRotation(this._camera.matrixWorld),
            this._lookAtPosition.set(0, 0, -1),
            this._lookAtPosition.applyMatrix4(this._rotationMatrix),
            this._lookAtPosition.add(this._cameraWorldPosition),
            this._target.subVectors(this._reflectorWorldPosition, this._lookAtPosition),
            this._target.reflect(this._normal).negate(),
            this._target.add(this._reflectorWorldPosition),
            this._virtualCamera.position.copy(this._view),
            this._virtualCamera.up.set(0, 1, 0),
            this._virtualCamera.up.applyMatrix4(this._rotationMatrix),
            this._virtualCamera.up.reflect(this._normal),
            this._virtualCamera.lookAt(this._target),
            this._virtualCamera.far = this._camera.far,
            this._virtualCamera.updateMatrixWorld(),
            this._virtualCamera.projectionMatrix.copy(this._camera.projectionMatrix),
            this._textureMatrix.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1),
            this._textureMatrix.multiply(this._virtualCamera.projectionMatrix),
            this._textureMatrix.multiply(this._virtualCamera.matrixWorldInverse),
            this._textureMatrix.multiply(this._reflectionMesh.matrixWorld),
            this._reflectorPlane.setFromNormalAndCoplanarPoint(this._normal, this._reflectorWorldPosition),
            this._reflectorPlane.applyMatrix4(this._virtualCamera.matrixWorldInverse),
            this._clipPlane.set(this._reflectorPlane.normal.x, this._reflectorPlane.normal.y, this._reflectorPlane.normal.z, this._reflectorPlane.constant);
            const {projectionMatrix: e} = this._virtualCamera;
            this._q.x = (Math.sign(this._clipPlane.x) + e.elements[8]) / e.elements[0],
            this._q.y = (Math.sign(this._clipPlane.y) + e.elements[9]) / e.elements[5],
            this._q.z = -1,
            this._q.w = (1 + e.elements[10]) / e.elements[14],
            this._clipPlane.multiplyScalar(2 / this._clipPlane.dot(this._q)),
            e.elements[2] = this._clipPlane.x,
            e.elements[6] = this._clipPlane.y,
            e.elements[10] = this._clipPlane.z + 1,
            e.elements[14] = this._clipPlane.w,
            this._render()
        }
    }
    _initWaterSimulation() {
        this._waterSimulation = new Kz({
            planeSize: lm,
            raycasterMesh: this
        })
    }
    _render() {
        yt.emit(xt.RENDER_REFLECTOR, !0),
        this.material.uniforms.uTime.value += ce.time.delta * .2,
        this.visible = !1;
        const e = this._gl.getRenderTarget() || null;
        this._gl.setRenderTarget(this._fbo),
        this._gl.render(this._scene, this._virtualCamera),
        this._gl.setRenderTarget(e),
        this.visible = !0,
        yt.emit(xt.RENDER_REFLECTOR, !1)
    }
    update(e) {
        this._waterSimulation.render(),
        this.material.uniforms.uFluidTexture.value = this._waterSimulation.texture
    }
}
var $z = `uniform float uTime;

attribute vec2 aProps;

varying float vRandom;
varying float vLife;

void main(){
  float speed = aProps.x;
  float scale = aProps.y;
  float life = mod(uTime + aProps.y * 3.0, 1.0);
  float time = (uTime + aProps.y) * 4.0;

  vec3 newPos = position;
  newPos.z -= life * speed * 12.0;
  newPos.y += sin(0.6 * time + cos(0.2 * time + 9.5 + sin(3.3 * time))) * 0.1;
  newPos.x += sin(0.4 * time + cos(0.3 * time + 2.5 + sin(2.3 * time))) * 0.1;

  vec4 mvPosition = modelViewMatrix * vec4(newPos, 1.0);
  gl_PointSize = 15.0 + scale * 15.0;
  gl_PointSize *= ( 1.0 / - mvPosition.z );
  gl_Position = projectionMatrix * mvPosition;

  vRandom = scale;
  vLife = sin(life * 3.14);
}`
  , Zz = `varying float vRandom;
varying float vLife;

void main() {
 float a = smoothstep(0.7, 0.0, length(gl_PointCoord.xy - vec2(0.5)));
 a *= vRandom * vLife;

 vec3 color = mix(vec3(1.0), vec3(0.309, 0.976, 1.0), vRandom);
 color *= 1.0 + step(0.9, vRandom) * 4.0;
 gl_FragColor = vec4(color, a);
}`;
class Jz extends gf {
    constructor({amount: e=300}={}) {
        super(),
        this._amount = e,
        this._init()
    }
    _init() {
        const e = new mn
          , t = []
          , n = [];
        for (let i = 0; i < this._amount; i++)
            t.push(Dn.randFloat(-14, 14), Dn.randFloat(-1, 8), Dn.randFloat(0, 16)),
            n.push(Dn.randFloat(.4, 2), Dn.randFloat(.2, 1));
        e.setAttribute("position", new pt(new Float32Array(t),3)),
        e.setAttribute("aProps", new pt(new Float32Array(n),2)),
        this.geometry = e,
        this.material = new Vt({
            vertexShader: $z,
            fragmentShader: Zz,
            uniforms: {
                uTime: {
                    value: 0
                }
            },
            transparent: !0,
            depthWrite: !1,
            depthTest: !1
        })
    }
    update(e) {
        this.material.uniforms.uTime.value += e * .5
    }
}
var Qz = `float remap(float value, float min, float max, float newMin, float newMax) {
  return newMin + (newMax - newMin) * (value - min) / (max - min);
}

vec3 terrainDisplacement(sampler2D txt, vec2 uv, vec2 uvShift, float time){
    float h = texture2D(txt, uv * 1.6 + uvShift).r;
    h = smoothstep(0.1, 0.7, h);
    vec3 pos = position;
    pos.y += h * 2.0 - 1.0;
    
    pos.z -= remap(mod(time * 6.4, 40.0), 0.0, 40.0,  -30.0, 30.0);

    return pos;
}

uniform float uTime;
uniform float uRandom;
uniform vec2 uUvShift;
uniform sampler2D uNoise;

varying float vAlpha;
varying float vDepth;
varying vec3 vPosition;
varying vec3 vViewDir;

void main(){
  vec3 pos = terrainDisplacement(uNoise, uv, uUvShift, uTime + uRandom * 40.0);

  #ifdef IS_POINTS
    gl_PointSize = 3.0;
  #endif

  vec4 mvp = modelMatrix * vec4(pos, 1.0);
  float alpha = smoothstep(0.0, 15.0, length((mvp.xz) * vec2(1.0, 0.8) - vec2(0.0)));
  alpha = 1.0 - (alpha * alpha * alpha * alpha);

  gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);

  vViewDir = normalize(cameraPosition - pos);
  vDepth = pos.y;
  vPosition = pos;
  vAlpha = alpha;
}`
  , eH = `uniform vec3 uColor;

varying float vAlpha;
varying float vDepth;
varying vec3 vPosition;
varying vec3 vViewDir;

void main(){
    if(vDepth < -0.0) discard;

    vec3 final = uColor;
    float alpha = vAlpha;

    #ifdef IS_MESH
      vec3 dx = dFdx(vPosition);
      vec3 dy = dFdy(vPosition);
      vec3 normal = normalize(cross(dx, dy));
      vec3 light = normalize(vec3(2.0, 2.0, 2.0));

      
      float dir = max(0.0, dot(normal, light));
      dir = pow(dir, 4.0);

      float fresnel = dot(vViewDir, normal);
      fresnel = 1.0 - max(0.0, dot(vViewDir, normal));
      fresnel = pow(fresnel, 8.0);

      final += (dir * 0.15) + (fresnel * 0.05);
    #endif

    #ifdef IS_POINTS
      final *= 6.0;
      alpha *= smoothstep(0.5, 0.0, length(gl_PointCoord.xy - vec2(0.5)));
    #endif

    
    float foam = smoothstep(0.06, 0.0, vDepth);
    final = mix(final, final * 1.5, foam);

    gl_FragColor = vec4(final, alpha);
}`;
class tH extends F_ {
    constructor({depthPacking: e, uvShift: t=[0, 0], map: n, random: i}) {
        super(e),
        this._time = {
            value: 0
        },
        this._noiseTxT = {
            value: n
        },
        this._uvShift = {
            value: t
        },
        this._random = {
            value: i
        }
    }
    onBeforeCompile(e) {
        e.uniforms.uTime = this._time,
        e.uniforms.uNoise = this._noiseTxT,
        e.uniforms.uUvShift = this._uvShift,
        e.uniforms.uRandom = this._random,
        e.vertexShader = e.vertexShader.replace("#include <common>", `
        #include <common>
        uniform float uRandom;
        uniform float uTime;
        uniform vec2 uUvShift;
        uniform sampler2D uNoise;
      `),
        e.vertexShader = e.vertexShader.replace("#include <project_vertex>", `
        gl_Position = terrainDisplacement(uNoise, uv, uUvShift, uTime + uRandom * 40.0);
      `)
    }
    update(e) {
        this._time.value += e
    }
}
class nH extends en {
    constructor({type: e, uvShift: t=[0, 0], random: n=0}) {
        super(),
        this._type = e,
        this._uvShift = {
            value: t
        },
        this._random = {
            value: n
        },
        this._init()
    }
    _init() {
        const e = dn("perlin-3");
        e.wrapS = e.wrapT = ii;
        const t = An.environment.plane.size;
        this.geometry = new Tr(t,t,40,40),
        this.geometry.rotateX(-Math.PI * .5),
        this.material = new Vt({
            vertexShader: Qz,
            fragmentShader: eH,
            uniforms: {
                uNoise: {
                    value: e
                },
                uTime: {
                    value: 0
                },
                uRandom: this._random,
                uColor: {
                    value: new Ke
                },
                uUvShift: this._uvShift
            },
            defines: {
                IS_POINTS: this._type === "points",
                IS_MESH: this._type === "mesh",
                IS_WIREFRAME: this._type === "wireframe"
            },
            depthTest: !0,
            transparent: !0
        }),
        this._type === "wireframe" ? (this.material.wireframe = !0,
        this.isMesh = !0,
        this.isPoints = !1) : this._type === "points" ? (this.material.wireframe = !1,
        this.isMesh = !1,
        this.isPoints = !0) : this._type === "mesh" && (this.material.wireframe = !1,
        this.isMesh = !0,
        this.isPoints = !1),
        this.renderOrder = An.renderOrder.terrainBlock,
        this.matrixAutoUpdate = !1,
        this.updateMatrix(),
        this.customDepthMaterial = new tH({
            depthPacking: R_,
            uvShift: this._uvShift.value,
            map: this.material.uniforms.uNoise.value,
            random: this._random.value
        })
    }
    update(e) {
        this.material.uniforms.uTime.value += e
    }
}
const {size: Ms} = An.environment.plane
  , iH = [{
    type: "wireframe",
    color: 3355446,
    uvShift: [0, 0],
    position: [0, 0, 0],
    random: .2,
    convertColor: !0
}, {
    type: "points",
    color: 913663,
    uvShift: [0, 0],
    position: [0, 0, 0],
    random: .2,
    convertColor: !0
}, {
    type: "wireframe",
    color: 4473929,
    uvShift: [.7, .34],
    position: [0, 0, -Ms * 0],
    random: .4,
    convertColor: !0
}, {
    type: "points",
    color: 913663,
    uvShift: [.7, .34],
    position: [0, 0, -Ms * 0],
    random: .4,
    convertColor: !0
}, {
    type: "wireframe",
    color: 2236968,
    uvShift: [.2, 0],
    position: [0, 0, -Ms * 0],
    random: .8,
    convertColor: !0
}, {
    type: "points",
    color: 913663,
    uvShift: [.2, 0],
    position: [0, 0, -Ms * 0],
    random: .8,
    convertColor: !0
}, {
    type: "mesh",
    color: 1250067,
    uvShift: [1.2, .5],
    position: [0, 0, -Ms * 0],
    random: .5,
    convertColor: !1
}, {
    type: "points",
    color: 913663,
    uvShift: [1.2, .5],
    position: [0, 0, -Ms * 0],
    random: .5,
    convertColor: !0
}, {
    type: "mesh",
    color: 561,
    uvShift: [1.2, .5],
    position: [0, 0, -Ms * 0],
    random: 0,
    convertColor: !1
}, {
    type: "points",
    color: 913663,
    uvShift: [1.2, .5],
    position: [0, 0, -Ms * 0],
    random: 0,
    convertColor: !0
}];
class rH extends gr {
    constructor() {
        super(),
        this._blocks = [],
        this._init()
    }
    _init() {
        iH.forEach(e=>{
            const {type: t, uvShift: n, color: i, convertColor: s, position: o, random: a} = e
              , c = new nH({
                type: t,
                uvShift: n,
                random: a
            });
            c.material.uniforms.uColor.value.set(i),
            s && c.material.uniforms.uColor.value.convertLinearToSRGB(),
            c.position.z -= o[2],
            c.userData.position = o,
            c.updateMatrix(),
            this._blocks.push(c)
        }
        ),
        this.add(...this._blocks)
    }
    update(e) {
        this._blocks.forEach(t=>{
            t.update(e * .5)
        }
        )
    }
}
var sH = `attribute float aRandom;
attribute vec3 aTranslate;

uniform vec4 uCameraQuaterion;
uniform float uTime;

varying float vTime;
varying float vAlpha;
varying vec2 vUv;

float remap(float value, float min, float max, float newMin, float newMax) {
  return newMin + (newMax - newMin) * (value - min) / (max - min);
}
vec4 getMvPosition(vec3 _position, vec4 _cameraQuaternion, vec3 _translate){
  vec4 mvPosition = modelViewMatrix * instanceMatrix * vec4(_translate, 1.0);

  vec3 screenPos = _position;
  mvPosition.xyz += screenPos;

  return mvPosition;
}
vec3 getTranslate(vec3 _translate, float _time, float _random, float _bounds){
    vec3 translate = _translate;
    translate.x += sin(_time * 3.14 + cos(_time  * 0.6));
    translate.z += cos(_time * 4.34 + sin(_time  * 1.6));
    translate.z = remap(mod(_time, 1.0), 0.0, 1.0, _bounds, -_bounds);
    return translate;
}

mat2 rotate2d(float _angle){
    return mat2(cos(_angle),-sin(_angle),
                sin(_angle),cos(_angle));
}

void main(){
  float t = uTime * (0.5 + aRandom) + aRandom;
  float rt = uTime * (0.5 + aRandom * 2.0);
  vec3 translate = getTranslate(aTranslate, t, aRandom, BOUNDS);

  
  vec3 np = position;
  np.xy = rotate2d(rt) * np.xy;

  vec4 mvPosition = getMvPosition(np, uCameraQuaterion, translate);

  float alpha = smoothstep(0.0, BOUNDS * 0.8, length((translate.xz) * vec2(0.8, 0.8)));
  alpha = 1.0 - (alpha * alpha);

  gl_Position = projectionMatrix * mvPosition;
  vUv = uv;
  vAlpha = alpha * (1.0 + aRandom * smoothstep(0.0, 5.0, translate.y) * 0.3)  * clamp((-mvPosition.z * 1.0), 0.0, 1.0);
  vTime = t;
}`
  , oH = `precision highp float;
precision highp sampler2D;

uniform float uBaseAlpha;
uniform sampler2D uDiffuse;
uniform sampler2D uNoise;

varying float vTime;
varying float vAlpha;
varying vec2 vUv;

void main (){
  vec4 ra = texture2D(uDiffuse, vUv);
  ra.rgb *= 1.3;
  ra.a *= uBaseAlpha * vAlpha;

  gl_FragColor = ra;
}`
  , aH = `vec3 getTranslate(vec3 _translate, float _time, float _random, float _bounds){
    vec3 translate = _translate;
    translate.x += sin(_time * 3.14 + cos(_time  * 0.6));
    translate.z += cos(_time * 4.34 + sin(_time  * 1.6));
    translate.z = remap(mod(_time, 1.0), 0.0, 1.0, _bounds, -_bounds);
    return translate;
}`
  , lH = `vec4 getMvPosition(vec3 _position, vec4 _cameraQuaternion, vec3 _translate){
  vec4 mvPosition = modelViewMatrix * instanceMatrix * vec4(_translate, 1.0);

  vec3 screenPos = _position;
  mvPosition.xyz += screenPos;

  return mvPosition;
}`;
class cH extends F_ {
    constructor({depthPacking: e, time: t, cameraQuaternion: n, bounds: i}) {
        super({
            depthPacking: e
        }),
        this._time = t,
        this._cameraQuaternion = n,
        this._bounds = i
    }
    onBeforeCompile(e) {
        e.uniforms.uTime = this._time,
        e.uniforms.uCameraQuaternion = this._cameraQuaternion,
        e.defines.BOUNDS = this._bounds,
        e.vertexShader = e.vertexShader.replace("#include <common>", `
        #include <common>
        attribute float aRandom;
        attribute vec3 aTranslate;

        uniform vec4 uCameraQuaternion;
        uniform float uTime;

        ${aH}
        ${lH}
      `),
        e.vertexShader = e.vertexShader.replace("#include <project_vertex>", `
        vec3 translate = getTranslate(aTranslate, uTime, aRandom, BOUNDS);
        vec4 mvPosition = getMvPosition(position, uCameraQuaternion, translate);
        gl_Position = projectionMatrix * mvPosition;
      `)
    }
    update(e) {
        this._time.value += e
    }
}
const cm = new Yt;
class uH extends z_ {
    constructor({amount: e=200}={}) {
        super(!1, !1, e),
        this.amount = e,
        this._time = {
            value: 0
        },
        this._cameraQuaternion = {
            value: [0, 0, 0, 0]
        },
        this._init(),
        this._initEvents()
    }
    _init() {
        const e = dn("perlin-3")
          , t = dn("fog-smoke");
        t.wrapS = t.wrapT = ii,
        e.wrapS = e.wrapT = sl,
        this.geometry = new Tr(3.4,3.4,1,1),
        this.material = new Vt({
            vertexShader: sH,
            fragmentShader: oH,
            uniforms: {
                uDiffuse: {
                    value: t
                },
                uNoise: {
                    value: e
                },
                uCameraQuaternion: {
                    value: null
                },
                uBaseAlpha: {
                    value: .21
                },
                uTime: this._time
            },
            defines: {
                BOUNDS: An.environment.plane.size * .4
            },
            transparent: !0,
            depthWrite: !1,
            depthTest: !1,
            blending: Dc
        }),
        this.position.y += .1,
        this.instanceMatrix.setUsage(Dh),
        this.renderOrder = An.renderOrder.fog;
        const n = []
          , i = []
          , s = An.environment.plane.size * .4;
        for (let o = 0; o < this.amount; o++) {
            const a = Dn.randFloat(-s, s)
              , c = Math.random() > .5 ? Dn.randFloat(1, 6) : Dn.randFloat(0, 1.2)
              , h = Dn.randFloat(-s, s);
            n.push(a, c, h),
            i.push(Dn.randFloat(0, 1))
        }
        this.geometry.setAttribute("aTranslate", new cl(new Float32Array(n),3)),
        this.geometry.setAttribute("aRandom", new cl(new Float32Array(i),1));
        for (let o = 0; o < this.amount; o++)
            cm.position.set(0, 0, 0),
            cm.updateMatrix(),
            this.setMatrixAt(o, cm.matrix);
        this.instanceMatrix.needsUpdate = !0
    }
    _initDepth() {
        this.customDepthMaterial = new cH({
            depthPacking: R_,
            time: this._time,
            cameraQuaternion: this._cameraQuaternion,
            bounds: An.environment.plane.size * .4
        })
    }
    _initEvents() {
        yt.on(xt.RENDER_REFLECTOR, e=>{
            this.visible = !e
        }
        )
    }
    update(e) {
        this.material.uniforms.uCameraQuaternion.value = ce.camera.quaternion,
        this._time.value += e * .15
    }
}
var hH = `attribute float aRandom;
uniform float uTime;
uniform float uProgress;

varying float vProgress;
varying vec2 vUv;

float remap(float value, float min, float max, float newMin, float newMax) {
  return newMin + (newMax - newMin) * (value - min) / (max - min);
}
mat4 rotationMatrix(vec3 axis, float angle) {
    axis = normalize(axis);
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1.0 - c;

    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,
                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,
                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,
                0.0,                                0.0,                                0.0,                                1.0);
}

vec3 rotate(vec3 v, vec3 axis, float angle) {
  mat4 m = rotationMatrix(axis, angle);
  return (m * vec4(v, 1.0)).xyz;
}

void main(){
  float period = 5.0;
  float lightPeriod = 2.0;
  float time = uTime + (aRandom * period);
  float time2 = (uTime) * 0.3 + (aRandom * period);
  vec3 newPos = rotate(position, vec3(0.0, 1.0, 0.0), 0.1 * aRandom);
  newPos.z -= remap(mod(time * 0.15, 1.0), 0.0, 1.0, -BOUNDS, BOUNDS);

  vec4 mvPosition = modelViewMatrix * instanceMatrix * vec4(newPos, 1.0);
  gl_Position = projectionMatrix * mvPosition;

  float p = smoothstep(0.0, 0.32, mod(time2, lightPeriod));
  vProgress = p;
  vUv = uv - vec2(p * 0.4 + aRandom * 0.5, p * 0.2 + (aRandom - 0.5) * 0.1);
}`
  , fH = `uniform float uRenderType;
uniform sampler2D uMap;

varying float vProgress;
varying vec2 vUv;

void main(){
  vec4 map = texture2D(uMap, vUv);
  float s = map.r;
  float rp = vProgress;

  float shift = 0.4;
  float p = 1.0 - vProgress;
  float p2 = clamp(p+shift, 0.0, 1.0);

  s = smoothstep(p, p2, s- 0.1);
  s = clamp(0.0, 1.0, s);
  float t = s;
  float a = s;
  s *= 2.7;
  
  float alphaProgress = max(
    (sin(rp * 8.28 - 4.5) - cos(rp * 1.5)) * 1.8, 
    (sin(rp * 8.28) - sin(rp * 1.5)) * 0.65 
  );

  alphaProgress = clamp(alphaProgress, 0.0, 1.0) * a;

  vec3 color = mix(vec3(0.125, 0.7450, 0.7921), vec3(1.0, 0.678, 0.051), uRenderType);
  vec3 final = mix(color * 0.4, color, sin(t*3.14));
  final *= 5.0 + 12.0 * rp;

  gl_FragColor = vec4(final, alphaProgress);
}`;
const cc = new Yt
  , $x = 12;
class dH extends z_ {
    constructor() {
        super(null, null, $x),
        this._strikes = [],
        this._time = {
            value: ce.time.elapsed
        },
        this._init(),
        this._initEvents()
    }
    _init() {
        const e = dn("strike-model").scene.getObjectByName("strike")
          , t = dn("strike-map");
        t.wrapS = t.wrapT = ii,
        this.geometry = e.geometry,
        this.material = new Vt({
            vertexShader: hH,
            fragmentShader: fH,
            uniforms: {
                uMap: {
                    value: t
                },
                uProgress: {
                    value: 0
                },
                uTime: this._time,
                uRenderType: {
                    value: 0
                }
            },
            defines: {
                BOUNDS: An.environment.plane.size * .4
            },
            transparent: !0,
            depthTest: !1,
            side: 2
        });
        const n = [];
        for (let i = 0; i < $x; i++) {
            const s = Dn.randFloat(4, 15) * (Math.random() > .5 ? 1 : -1);
            cc.position.set(s, 0, 0),
            cc.scale.setScalar(Dn.randFloat(2.5, 3.5)),
            cc.rotation.y = Dn.randFloat(-.4, .4),
            cc.updateMatrix(),
            this.setMatrixAt(i, cc.matrix),
            n.push(Dn.randFloat(0, 1))
        }
        this.instanceMatrix.needsUpdate = !0,
        this.geometry.setAttribute("aRandom", new cl(new Float32Array(n),1)),
        this.renderOrder = An.renderOrder.strikes
    }
    _initEvents() {
        yt.on(xt.RENDER_REFLECTOR, e=>this._switchColors(e))
    }
    _switchColors(e) {
        this.material.uniforms.uRenderType.value = e ? 0 : 1
    }
    _addTheatre() {}
    update(e) {
        this._time.value += e
    }
}
var pH = `varying vec2 vUv;
varying vec4 vPos;

void main(){
  vec4 wPos = modelMatrix * vec4(position, 1.0);
  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);

  vPos = wPos;
  vUv = uv;
}`
  , mH = `varying vec2 vUv;
varying vec4 vPos;

uniform sampler2D uNoiseTxt;
uniform float uTime;
uniform float uBaseAlpha;
uniform float uGlowAlpha;
uniform float uTopFade;
uniform float uBottomFade;
uniform vec3 uRaysColor;
uniform vec3 uGlowColor;
uniform float uRaysStepMin;
uniform float uRaysStepMax;
uniform float uGlowStepMin;
uniform float uUvFactor;

void main() {
    vec2 raysUv = vUv;
    raysUv.x *= uUvFactor;
    raysUv.x += uTime * 0.03;
    raysUv.y = .0;

    vec4 t = texture2D(uNoiseTxt, raysUv);

    float raysFactor = smoothstep(uRaysStepMin, uRaysStepMax, t.g);
    float lengthFade = vUv.y - raysFactor * 0.1;
    float topFade = 1.0 - smoothstep(1.0 - uTopFade, 1.0, vUv.y);
    float bottomFade = smoothstep(uBottomFade, 1.0, vPos.y);
    float fade = min(bottomFade, topFade);
    float sourceGlow = smoothstep(uGlowStepMin, 1.0, vUv.y);

    vec3 composite = uRaysColor * raysFactor;
    composite = mix(composite, uGlowColor, sourceGlow);

    float alpha = uBaseAlpha * lengthFade * raysFactor;
    alpha = mix(alpha, uGlowAlpha, sourceGlow);
    alpha *= fade;

    gl_FragColor.rgba = vec4(composite, alpha);
}`;
const um = .41
  , hm = .49;
class _H extends en {
    constructor() {
        super(),
        this._init(),
        this._initEvents()
    }
    _init() {
        this.geometry = new G_(8,22,45,20,1,!0);
        const e = dn("rays-map");
        e.wrapS = e.wrapT = ii,
        this.material = new Vt({
            vertexShader: pH,
            fragmentShader: mH,
            uniforms: {
                uTime: {
                    value: 0
                },
                uBaseAlpha: {
                    value: um
                },
                uGlowAlpha: {
                    value: hm
                },
                uTopFade: {
                    value: .2
                },
                uBottomFade: {
                    value: 0
                },
                uRaysColor: {
                    value: new Ke("#0f0f0f")
                },
                uGlowColor: {
                    value: new Ke("#f0fbfc")
                },
                uRaysStepMin: {
                    value: .11
                },
                uRaysStepMax: {
                    value: .84
                },
                uGlowStepMin: {
                    value: .48
                },
                uNoiseTxt: {
                    value: e
                },
                uUvFactor: {
                    value: 3
                }
            },
            blending: Dc,
            side: 2,
            depthTest: !1,
            depthWrite: !1,
            transparent: !0
        }),
        this.renderOrder = An.renderOrder.rays,
        this.rotation.set(0, 0, .2),
        this.position.y += .2
    }
    _initEvents() {
        yt.on(xt.RENDER_REFLECTOR, e=>{
            this.material.uniforms.uBaseAlpha.value = e ? um * .7 : um,
            this.material.uniforms.uGlowAlpha.value = e ? hm * .1 : hm
        }
        )
    }
    update(e) {
        this.material.uniforms.uTime.value += e * 3,
        this.rotation.y += e * .1
    }
}
class gH extends gr {
    constructor() {
        super(),
        this._trees = [],
        this._particles = void 0,
        this._reflector = void 0,
        this._terrain = void 0,
        this._strikes = void 0,
        this._rays = void 0,
        this._init()
    }
    _init() {
        this._initReflector(),
        this._initParticles(),
        this._initTerrain(),
        this._initFog(),
        this._initStrikes(),
        this._initRays()
    }
    _initReflector() {
        const e = new Yz({
            camera: ce.camera,
            scene: ce.scene,
            gl: ce.gl
        });
        e.rotation.x = Math.PI * -.5,
        this.add(e),
        this._reflector = e
    }
    _initParticles() {
        const e = new Jz;
        this._particles = e,
        this.add(e)
    }
    _initTerrain() {
        const e = new rH;
        this._terrain = e,
        this.add(e)
    }
    _initFog() {
        const e = new uH;
        this._fog = e,
        this.add(e)
    }
    _initStrikes() {
        const e = new dH;
        this._strikes = e,
        this.add(e)
    }
    _initRays() {
        const e = new _H;
        this._rays = e,
        this.add(e)
    }
    update(e) {
        this._trees.forEach(t=>{
            t.position.z -= .03
        }
        ),
        this._particles.update(e),
        this._reflector.update(e),
        this._terrain.update(e),
        this._fog.update(e),
        this._strikes.update(e),
        this._rays.update(e)
    }
}
var vH = `uniform float uTime;

attribute float aLife;
attribute float aRandom;
attribute float aAngle;
attribute float aSpeed;
attribute vec3 aOrigin;
attribute vec3 aDirection;

varying float vAlpha;
varying float vRandom;

mat4 rotationMatrix(vec3 axis, float angle) {
    axis = normalize(axis);
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1.0 - c;

    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,
                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,
                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,
                0.0,                                0.0,                                0.0,                                1.0);
}

vec3 rotate(vec3 v, vec3 axis, float angle) {
  mat4 m = rotationMatrix(axis, angle);
  return (m * vec4(v, 1.0)).xyz;
}

void main(){
  float start = smoothstep(0.0, 0.1, aLife);
  float end = smoothstep(1.0, 0.8, aLife);
  float alpha = min(start, end);
  float time = uTime + aRandom;
  float nl = aLife;

  gl_PointSize = 9.0 + (aRandom * 9.0) * end;

  vec3 newDir = aDirection;
  newDir = rotate(newDir, vec3(0.0, 1.0, 0.0), aAngle); 
  newDir = rotate(newDir, vec3(1.0, 0.0, 0.0), (aRandom - 0.5) * 0.2 - 0.2); 

  
  float factor = 1.0;
  vec3 finalPos = aOrigin + newDir * (1.0 + aSpeed) * nl - vec3(0.0, aRandom * 0.1, 0.0) * factor * pow(nl, 1.0 + 5.0 * aRandom);
  
  
  finalPos.x += sin(15.0 * time + cos(16.0 * time)) * start * 0.01;
  finalPos.y += sin(19.0 * time - cos(13.0 * time)) * start * 0.01;

  vec4 mvPosition = modelViewMatrix * vec4(finalPos, 1.0);
  gl_PointSize *= ( 1.0 / - mvPosition.z );
  gl_Position = projectionMatrix * mvPosition;

  vAlpha = alpha;
  vRandom = aRandom;
}`
  , yH = `uniform float uRenderType;
varying float vAlpha;
varying float vRandom;

void main(){
  float a = smoothstep(0.7, 0.0, length(gl_PointCoord.xy - vec2(0.5)));
  a *= vAlpha * (0.2 + vRandom * 0.5);

  vec3 gold = mix( vec3(1.0, 0.3529, 0.0), vec3(1.0, 0.7137, 0.0235), vRandom); 
  vec3 ice = mix( vec3(0.050, 0.772, 1.0), vec3(0.050, 0.431, 1.0), vRandom); 

  vec3 color = mix(gold, ice, uRenderType);

  gl_FragColor = vec4(color, a);
}`;
const Eh = new k
  , Ah = new k
  , Zx = 100;
class xH extends gf {
    constructor({tracker: e, amount: t}) {
        super(),
        this._amount = t,
        this._tracker = e,
        this._spawnProg = 0,
        this._timeScale = {
            value: ce.time.scale
        },
        this._chunks = Zx,
        this._isActive = !1,
        this._init()
    }
    _init() {
        const e = new mn
          , t = []
          , n = []
          , i = []
          , s = []
          , o = []
          , a = []
          , c = [];
        for (let h = 0; h < this._amount; h++)
            t.push(0, 0, 0),
            n.push(0, 0, 0),
            i.push(0, 0, 0),
            s.push(Dn.randFloat(.1, .8) * 1.7),
            o.push(0),
            a.push(Dn.randFloat(-.2, .2)),
            c.push(Dn.randFloat(0, 1));
        e.setAttribute("position", new pt(new Float32Array(t),3)),
        e.setAttribute("aOrigin", new pt(new Float32Array(n),3).setUsage(Dh)),
        e.setAttribute("aDirection", new pt(new Float32Array(i),3).setUsage(Dh)),
        e.setAttribute("aSpeed", new pt(new Float32Array(s),1)),
        e.setAttribute("aLife", new pt(new Float32Array(o),1).setUsage(Dh)),
        e.setAttribute("aAngle", new pt(new Float32Array(a),1)),
        e.setAttribute("aRandom", new pt(new Float32Array(c),1)),
        this.geometry = e,
        this.material = new Vt({
            vertexShader: vH,
            fragmentShader: yH,
            uniforms: {
                uTime: {
                    value: 0
                },
                uRenderType: {
                    value: 0
                }
            },
            transparent: !0,
            depthTest: !1,
            blending: Dc
        }),
        this.renderOrder = An.renderOrder.flames,
        this._initEvents()
    }
    _initEvents() {
        yt.on(xt.ROAR, e=>{
            this._isActive = e
        }
        ),
        yt.on(xt.RENDER_REFLECTOR, e=>this._switchColors(e)),
        yt.on(xt.TIMESCALE_CHANGE, e=>{
            this._chunks = Math.floor(Zx * e)
        }
        )
    }
    _switchColors(e) {
        this.material.uniforms.uRenderType.value = e ? 1 : 0
    }
    update(e) {
        if (this._tracker.getWorldPosition(Eh),
        this._tracker.getWorldDirection(Ah),
        this.material.uniforms.uTime.value += e,
        this.geometry.attributes.aLife.array.forEach((t,n)=>{
            this.geometry.attributes.aLife.array[n] += .016 * ce.time.scale
        }
        ),
        this._isActive) {
            this._spawnProg >= this._amount && (this._spawnProg = 0);
            for (let t = this._spawnProg; t < this._spawnProg + this._chunks; t++)
                this.geometry.attributes.aLife.array[t] > 1 && (this.geometry.attributes.aLife.array[t] = 0,
                this.geometry.attributes.aOrigin.array[t * 3 + 0] = Eh.x,
                this.geometry.attributes.aOrigin.array[t * 3 + 1] = Eh.y,
                this.geometry.attributes.aOrigin.array[t * 3 + 2] = Eh.z,
                this.geometry.attributes.aDirection.array[t * 3 + 0] = Ah.x,
                this.geometry.attributes.aDirection.array[t * 3 + 1] = Ah.y,
                this.geometry.attributes.aDirection.array[t * 3 + 2] = Ah.z);
            this._spawnProg += this._chunks,
            this.geometry.attributes.aOrigin.needsUpdate = !0,
            this.geometry.attributes.aDirection.needsUpdate = !0
        }
        this.geometry.attributes.aLife.needsUpdate = !0
    }
}
/**
 * postprocessing v6.34.3 build Sat Feb 10 2024
 * https://github.com/pmndrs/postprocessing
 * Copyright 2015-2024 Raoul van Rschen
 * @license Zlib
 */
var _S = "varying vec2 vUv;void main(){vUv=position.xy*0.5+0.5;gl_Position=vec4(position.xy,1.0,1.0);}"
  , gt = {
    SKIP: 9,
    SET: 30,
    ADD: 0,
    ALPHA: 1,
    AVERAGE: 2,
    COLOR: 3,
    COLOR_BURN: 4,
    COLOR_DODGE: 5,
    DARKEN: 6,
    DIFFERENCE: 7,
    DIVIDE: 8,
    DST: 9,
    EXCLUSION: 10,
    HARD_LIGHT: 11,
    HARD_MIX: 12,
    HUE: 13,
    INVERT: 14,
    INVERT_RGB: 15,
    LIGHTEN: 16,
    LINEAR_BURN: 17,
    LINEAR_DODGE: 18,
    LINEAR_LIGHT: 19,
    LUMINOSITY: 20,
    MULTIPLY: 21,
    NEGATION: 22,
    NORMAL: 23,
    OVERLAY: 24,
    PIN_LIGHT: 25,
    REFLECT: 26,
    SATURATION: 27,
    SCREEN: 28,
    SOFT_LIGHT: 29,
    SRC: 30,
    SUBTRACT: 31,
    VIVID_LIGHT: 32
}
  , gS = ""
  , On = "srgb"
  , pl = "srgb-linear"
  , Co = {
    NONE: 0,
    DEPTH: 1,
    CONVOLUTION: 2
}
  , Mt = {
    FRAGMENT_HEAD: "FRAGMENT_HEAD",
    FRAGMENT_MAIN_UV: "FRAGMENT_MAIN_UV",
    FRAGMENT_MAIN_IMAGE: "FRAGMENT_MAIN_IMAGE",
    VERTEX_HEAD: "VERTEX_HEAD",
    VERTEX_MAIN_SUPPORT: "VERTEX_MAIN_SUPPORT"
}
  , tg = {
    VERY_SMALL: 0,
    SMALL: 1,
    MEDIUM: 2,
    LARGE: 3,
    VERY_LARGE: 4,
    HUGE: 5
}
  , TH = {
    SCALE_UP: "lut.scaleup"
}
  , vS = Number(gl.replace(/\D+/g, ""))
  , ng = vS >= 152
  , yS = new Map([[df, pl], [Dr, On]])
  , bH = new Map([[pl, df], [On, Dr]]);
function ml(r) {
    return r === null ? null : ng ? r.outputColorSpace : yS.get(r.outputEncoding)
}
function yr(r, e) {
    r !== null && (ng ? r.colorSpace = e : r.encoding = bH.get(e))
}
function fm(r, e) {
    r === null || e === null || (ng ? e.colorSpace = r.colorSpace : e.encoding = r.encoding)
}
function Vc(r) {
    return vS < 154 ? r.replace("colorspace_fragment", "encodings_fragment") : r
}
var SH = `#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec4 sum=texture2D(inputBuffer,vUv0);sum+=texture2D(inputBuffer,vUv1);sum+=texture2D(inputBuffer,vUv2);sum+=texture2D(inputBuffer,vUv3);gl_FragColor=sum*0.25;
#include <colorspace_fragment>
}`
  , MH = "uniform vec4 texelSize;uniform float kernel;uniform float scale;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec2 uv=position.xy*0.5+0.5;vec2 dUv=(texelSize.xy*vec2(kernel)+texelSize.zw)*scale;vUv0=vec2(uv.x-dUv.x,uv.y+dUv.y);vUv1=vec2(uv.x+dUv.x,uv.y+dUv.y);vUv2=vec2(uv.x+dUv.x,uv.y-dUv.y);vUv3=vec2(uv.x-dUv.x,uv.y-dUv.y);gl_Position=vec4(position.xy,1.0,1.0);}"
  , wH = [new Float32Array([0, 0]), new Float32Array([0, 1, 1]), new Float32Array([0, 1, 1, 2]), new Float32Array([0, 1, 2, 2, 3]), new Float32Array([0, 1, 2, 3, 4, 4, 5]), new Float32Array([0, 1, 2, 3, 4, 5, 7, 8, 9, 10])]
  , EH = class extends Vt {
    constructor(r=new Ct) {
        super({
            name: "KawaseBlurMaterial",
            uniforms: {
                inputBuffer: new bt(null),
                texelSize: new bt(new Ct),
                scale: new bt(1),
                kernel: new bt(0)
            },
            blending: Si,
            toneMapped: !1,
            depthWrite: !1,
            depthTest: !1,
            fragmentShader: SH,
            vertexShader: MH
        }),
        this.fragmentShader = Vc(this.fragmentShader),
        this.setTexelSize(r.x, r.y),
        this.kernelSize = tg.MEDIUM
    }
    set inputBuffer(r) {
        this.uniforms.inputBuffer.value = r
    }
    setInputBuffer(r) {
        this.inputBuffer = r
    }
    get kernelSequence() {
        return wH[this.kernelSize]
    }
    get scale() {
        return this.uniforms.scale.value
    }
    set scale(r) {
        this.uniforms.scale.value = r
    }
    getScale() {
        return this.uniforms.scale.value
    }
    setScale(r) {
        this.uniforms.scale.value = r
    }
    getKernel() {
        return null
    }
    get kernel() {
        return this.uniforms.kernel.value
    }
    set kernel(r) {
        this.uniforms.kernel.value = r
    }
    setKernel(r) {
        this.kernel = r
    }
    setTexelSize(r, e) {
        this.uniforms.texelSize.value.set(r, e, r * .5, e * .5)
    }
    setSize(r, e) {
        const t = 1 / r
          , n = 1 / e;
        this.uniforms.texelSize.value.set(t, n, t * .5, n * .5)
    }
}
  , AH = `#include <common>
#include <dithering_pars_fragment>
#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
uniform float opacity;varying vec2 vUv;void main(){vec4 texel=texture2D(inputBuffer,vUv);gl_FragColor=opacity*texel;
#include <colorspace_fragment>
#include <dithering_fragment>
}`
  , xS = class extends Vt {
    constructor() {
        super({
            name: "CopyMaterial",
            uniforms: {
                inputBuffer: new bt(null),
                opacity: new bt(1)
            },
            blending: Si,
            toneMapped: !1,
            depthWrite: !1,
            depthTest: !1,
            fragmentShader: AH,
            vertexShader: _S
        }),
        this.fragmentShader = Vc(this.fragmentShader)
    }
    set inputBuffer(r) {
        this.uniforms.inputBuffer.value = r
    }
    setInputBuffer(r) {
        this.uniforms.inputBuffer.value = r
    }
    getOpacity(r) {
        return this.uniforms.opacity.value
    }
    setOpacity(r) {
        this.uniforms.opacity.value = r
    }
}
  , PH = `#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
#define WEIGHT_INNER 0.125
#define WEIGHT_OUTER 0.0555555
varying vec2 vUv;varying vec2 vUv00;varying vec2 vUv01;varying vec2 vUv02;varying vec2 vUv03;varying vec2 vUv04;varying vec2 vUv05;varying vec2 vUv06;varying vec2 vUv07;varying vec2 vUv08;varying vec2 vUv09;varying vec2 vUv10;varying vec2 vUv11;float clampToBorder(const in vec2 uv){return float(uv.s>=0.0&&uv.s<=1.0&&uv.t>=0.0&&uv.t<=1.0);}void main(){vec4 c=vec4(0.0);vec4 w=WEIGHT_INNER*vec4(clampToBorder(vUv00),clampToBorder(vUv01),clampToBorder(vUv02),clampToBorder(vUv03));c+=w.x*texture2D(inputBuffer,vUv00);c+=w.y*texture2D(inputBuffer,vUv01);c+=w.z*texture2D(inputBuffer,vUv02);c+=w.w*texture2D(inputBuffer,vUv03);w=WEIGHT_OUTER*vec4(clampToBorder(vUv04),clampToBorder(vUv05),clampToBorder(vUv06),clampToBorder(vUv07));c+=w.x*texture2D(inputBuffer,vUv04);c+=w.y*texture2D(inputBuffer,vUv05);c+=w.z*texture2D(inputBuffer,vUv06);c+=w.w*texture2D(inputBuffer,vUv07);w=WEIGHT_OUTER*vec4(clampToBorder(vUv08),clampToBorder(vUv09),clampToBorder(vUv10),clampToBorder(vUv11));c+=w.x*texture2D(inputBuffer,vUv08);c+=w.y*texture2D(inputBuffer,vUv09);c+=w.z*texture2D(inputBuffer,vUv10);c+=w.w*texture2D(inputBuffer,vUv11);c+=WEIGHT_OUTER*texture2D(inputBuffer,vUv);gl_FragColor=c;
#include <colorspace_fragment>
}`
  , RH = "uniform vec2 texelSize;varying vec2 vUv;varying vec2 vUv00;varying vec2 vUv01;varying vec2 vUv02;varying vec2 vUv03;varying vec2 vUv04;varying vec2 vUv05;varying vec2 vUv06;varying vec2 vUv07;varying vec2 vUv08;varying vec2 vUv09;varying vec2 vUv10;varying vec2 vUv11;void main(){vUv=position.xy*0.5+0.5;vUv00=vUv+texelSize*vec2(-1.0,1.0);vUv01=vUv+texelSize*vec2(1.0,1.0);vUv02=vUv+texelSize*vec2(-1.0,-1.0);vUv03=vUv+texelSize*vec2(1.0,-1.0);vUv04=vUv+texelSize*vec2(-2.0,2.0);vUv05=vUv+texelSize*vec2(0.0,2.0);vUv06=vUv+texelSize*vec2(2.0,2.0);vUv07=vUv+texelSize*vec2(-2.0,0.0);vUv08=vUv+texelSize*vec2(2.0,0.0);vUv09=vUv+texelSize*vec2(-2.0,-2.0);vUv10=vUv+texelSize*vec2(0.0,-2.0);vUv11=vUv+texelSize*vec2(2.0,-2.0);gl_Position=vec4(position.xy,1.0,1.0);}"
  , CH = class extends Vt {
    constructor() {
        super({
            name: "DownsamplingMaterial",
            uniforms: {
                inputBuffer: new bt(null),
                texelSize: new bt(new Ce)
            },
            blending: Si,
            toneMapped: !1,
            depthWrite: !1,
            depthTest: !1,
            fragmentShader: PH,
            vertexShader: RH
        }),
        this.fragmentShader = Vc(this.fragmentShader)
    }
    set inputBuffer(r) {
        this.uniforms.inputBuffer.value = r
    }
    setSize(r, e) {
        this.uniforms.texelSize.value.set(1 / r, 1 / e)
    }
}
  , IH = `#include <common>
#include <packing>
#include <dithering_pars_fragment>
#define packFloatToRGBA(v) packDepthToRGBA(v)
#define unpackRGBAToFloat(v) unpackRGBAToDepth(v)
#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
#if DEPTH_PACKING == 3201
uniform lowp sampler2D depthBuffer;
#elif defined(GL_FRAGMENT_PRECISION_HIGH)
uniform highp sampler2D depthBuffer;
#else
uniform mediump sampler2D depthBuffer;
#endif
uniform vec2 resolution;uniform vec2 texelSize;uniform float cameraNear;uniform float cameraFar;uniform float aspect;uniform float time;varying vec2 vUv;
#if THREE_REVISION < 143
#define luminance(v) linearToRelativeLuminance(v)
#endif
#if THREE_REVISION >= 137
vec4 sRGBToLinear(const in vec4 value){return vec4(mix(pow(value.rgb*0.9478672986+vec3(0.0521327014),vec3(2.4)),value.rgb*0.0773993808,vec3(lessThanEqual(value.rgb,vec3(0.04045)))),value.a);}
#endif
float readDepth(const in vec2 uv){
#if DEPTH_PACKING == 3201
return unpackRGBAToDepth(texture2D(depthBuffer,uv));
#else
return texture2D(depthBuffer,uv).r;
#endif
}float getViewZ(const in float depth){
#ifdef PERSPECTIVE_CAMERA
return perspectiveDepthToViewZ(depth,cameraNear,cameraFar);
#else
return orthographicDepthToViewZ(depth,cameraNear,cameraFar);
#endif
}vec3 RGBToHCV(const in vec3 RGB){vec4 P=mix(vec4(RGB.bg,-1.0,2.0/3.0),vec4(RGB.gb,0.0,-1.0/3.0),step(RGB.b,RGB.g));vec4 Q=mix(vec4(P.xyw,RGB.r),vec4(RGB.r,P.yzx),step(P.x,RGB.r));float C=Q.x-min(Q.w,Q.y);float H=abs((Q.w-Q.y)/(6.0*C+EPSILON)+Q.z);return vec3(H,C,Q.x);}vec3 RGBToHSL(const in vec3 RGB){vec3 HCV=RGBToHCV(RGB);float L=HCV.z-HCV.y*0.5;float S=HCV.y/(1.0-abs(L*2.0-1.0)+EPSILON);return vec3(HCV.x,S,L);}vec3 HueToRGB(const in float H){float R=abs(H*6.0-3.0)-1.0;float G=2.0-abs(H*6.0-2.0);float B=2.0-abs(H*6.0-4.0);return clamp(vec3(R,G,B),0.0,1.0);}vec3 HSLToRGB(const in vec3 HSL){vec3 RGB=HueToRGB(HSL.x);float C=(1.0-abs(2.0*HSL.z-1.0))*HSL.y;return(RGB-0.5)*C+HSL.z;}FRAGMENT_HEAD void main(){FRAGMENT_MAIN_UV vec4 color0=texture2D(inputBuffer,UV);vec4 color1=vec4(0.0);FRAGMENT_MAIN_IMAGE color0.a=clamp(color0.a,0.0,1.0);gl_FragColor=color0;
#ifdef ENCODE_OUTPUT
#include <colorspace_fragment>
#endif
#include <dithering_fragment>
}`
  , LH = "uniform vec2 resolution;uniform vec2 texelSize;uniform float cameraNear;uniform float cameraFar;uniform float aspect;uniform float time;varying vec2 vUv;VERTEX_HEAD void main(){vUv=position.xy*0.5+0.5;VERTEX_MAIN_SUPPORT gl_Position=vec4(position.xy,1.0,1.0);}"
  , DH = class extends Vt {
    constructor(r, e, t, n, i=!1) {
        super({
            name: "EffectMaterial",
            defines: {
                THREE_REVISION: gl.replace(/\D+/g, ""),
                DEPTH_PACKING: "0",
                ENCODE_OUTPUT: "1"
            },
            uniforms: {
                inputBuffer: new bt(null),
                depthBuffer: new bt(null),
                resolution: new bt(new Ce),
                texelSize: new bt(new Ce),
                cameraNear: new bt(.3),
                cameraFar: new bt(1e3),
                aspect: new bt(1),
                time: new bt(0)
            },
            blending: Si,
            toneMapped: !1,
            depthWrite: !1,
            depthTest: !1,
            dithering: i
        }),
        r && this.setShaderParts(r),
        e && this.setDefines(e),
        t && this.setUniforms(t),
        this.copyCameraSettings(n)
    }
    set inputBuffer(r) {
        this.uniforms.inputBuffer.value = r
    }
    setInputBuffer(r) {
        this.uniforms.inputBuffer.value = r
    }
    get depthBuffer() {
        return this.uniforms.depthBuffer.value
    }
    set depthBuffer(r) {
        this.uniforms.depthBuffer.value = r
    }
    get depthPacking() {
        return Number(this.defines.DEPTH_PACKING)
    }
    set depthPacking(r) {
        this.defines.DEPTH_PACKING = r.toFixed(0),
        this.needsUpdate = !0
    }
    setDepthBuffer(r, e=Fc) {
        this.depthBuffer = r,
        this.depthPacking = e
    }
    setShaderData(r) {
        this.setShaderParts(r.shaderParts),
        this.setDefines(r.defines),
        this.setUniforms(r.uniforms),
        this.setExtensions(r.extensions)
    }
    setShaderParts(r) {
        return this.fragmentShader = IH.replace(Mt.FRAGMENT_HEAD, r.get(Mt.FRAGMENT_HEAD) || "").replace(Mt.FRAGMENT_MAIN_UV, r.get(Mt.FRAGMENT_MAIN_UV) || "").replace(Mt.FRAGMENT_MAIN_IMAGE, r.get(Mt.FRAGMENT_MAIN_IMAGE) || ""),
        this.vertexShader = LH.replace(Mt.VERTEX_HEAD, r.get(Mt.VERTEX_HEAD) || "").replace(Mt.VERTEX_MAIN_SUPPORT, r.get(Mt.VERTEX_MAIN_SUPPORT) || ""),
        this.fragmentShader = Vc(this.fragmentShader),
        this.needsUpdate = !0,
        this
    }
    setDefines(r) {
        for (const e of r.entries())
            this.defines[e[0]] = e[1];
        return this.needsUpdate = !0,
        this
    }
    setUniforms(r) {
        for (const e of r.entries())
            this.uniforms[e[0]] = e[1];
        return this
    }
    setExtensions(r) {
        this.extensions = {};
        for (const e of r)
            this.extensions[e] = !0;
        return this
    }
    get encodeOutput() {
        return this.defines.ENCODE_OUTPUT !== void 0
    }
    set encodeOutput(r) {
        this.encodeOutput !== r && (r ? this.defines.ENCODE_OUTPUT = "1" : delete this.defines.ENCODE_OUTPUT,
        this.needsUpdate = !0)
    }
    isOutputEncodingEnabled(r) {
        return this.encodeOutput
    }
    setOutputEncodingEnabled(r) {
        this.encodeOutput = r
    }
    get time() {
        return this.uniforms.time.value
    }
    set time(r) {
        this.uniforms.time.value = r
    }
    setDeltaTime(r) {
        this.uniforms.time.value += r
    }
    adoptCameraSettings(r) {
        this.copyCameraSettings(r)
    }
    copyCameraSettings(r) {
        r && (this.uniforms.cameraNear.value = r.near,
        this.uniforms.cameraFar.value = r.far,
        r instanceof qn ? this.defines.PERSPECTIVE_CAMERA = "1" : delete this.defines.PERSPECTIVE_CAMERA,
        this.needsUpdate = !0)
    }
    setSize(r, e) {
        const t = this.uniforms;
        t.resolution.value.set(r, e),
        t.texelSize.value.set(1 / r, 1 / e),
        t.aspect.value = r / e
    }
    static get Section() {
        return Mt
    }
}
  , OH = `#include <common>
#if THREE_REVISION < 143
#define luminance(v) linearToRelativeLuminance(v)
#endif
#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
#ifdef RANGE
uniform vec2 range;
#elif defined(THRESHOLD)
uniform float threshold;uniform float smoothing;
#endif
varying vec2 vUv;void main(){vec4 texel=texture2D(inputBuffer,vUv);float l=luminance(texel.rgb);
#ifdef RANGE
float low=step(range.x,l);float high=step(l,range.y);l*=low*high;
#elif defined(THRESHOLD)
l=smoothstep(threshold,threshold+smoothing,l)*l;
#endif
#ifdef COLOR
gl_FragColor=vec4(texel.rgb*clamp(l,0.0,1.0),l);
#else
gl_FragColor=vec4(l);
#endif
}`
  , UH = class extends Vt {
    constructor(r=!1, e=null) {
        super({
            name: "LuminanceMaterial",
            defines: {
                THREE_REVISION: gl.replace(/\D+/g, "")
            },
            uniforms: {
                inputBuffer: new bt(null),
                threshold: new bt(0),
                smoothing: new bt(1),
                range: new bt(null)
            },
            blending: Si,
            toneMapped: !1,
            depthWrite: !1,
            depthTest: !1,
            fragmentShader: OH,
            vertexShader: _S
        }),
        this.colorOutput = r,
        this.luminanceRange = e
    }
    set inputBuffer(r) {
        this.uniforms.inputBuffer.value = r
    }
    setInputBuffer(r) {
        this.uniforms.inputBuffer.value = r
    }
    get threshold() {
        return this.uniforms.threshold.value
    }
    set threshold(r) {
        this.smoothing > 0 || r > 0 ? this.defines.THRESHOLD = "1" : delete this.defines.THRESHOLD,
        this.uniforms.threshold.value = r
    }
    getThreshold() {
        return this.threshold
    }
    setThreshold(r) {
        this.threshold = r
    }
    get smoothing() {
        return this.uniforms.smoothing.value
    }
    set smoothing(r) {
        this.threshold > 0 || r > 0 ? this.defines.THRESHOLD = "1" : delete this.defines.THRESHOLD,
        this.uniforms.smoothing.value = r
    }
    getSmoothingFactor() {
        return this.smoothing
    }
    setSmoothingFactor(r) {
        this.smoothing = r
    }
    get useThreshold() {
        return this.threshold > 0 || this.smoothing > 0
    }
    set useThreshold(r) {}
    get colorOutput() {
        return this.defines.COLOR !== void 0
    }
    set colorOutput(r) {
        r ? this.defines.COLOR = "1" : delete this.defines.COLOR,
        this.needsUpdate = !0
    }
    isColorOutputEnabled(r) {
        return this.colorOutput
    }
    setColorOutputEnabled(r) {
        this.colorOutput = r
    }
    get useRange() {
        return this.luminanceRange !== null
    }
    set useRange(r) {
        this.luminanceRange = null
    }
    get luminanceRange() {
        return this.uniforms.range.value
    }
    set luminanceRange(r) {
        r !== null ? this.defines.RANGE = "1" : delete this.defines.RANGE,
        this.uniforms.range.value = r,
        this.needsUpdate = !0
    }
    getLuminanceRange() {
        return this.luminanceRange
    }
    setLuminanceRange(r) {
        this.luminanceRange = r
    }
}
  , NH = `#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;uniform mediump sampler2D supportBuffer;
#else
uniform lowp sampler2D inputBuffer;uniform lowp sampler2D supportBuffer;
#endif
uniform float radius;varying vec2 vUv;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;varying vec2 vUv4;varying vec2 vUv5;varying vec2 vUv6;varying vec2 vUv7;void main(){vec4 c=vec4(0.0);c+=texture2D(inputBuffer,vUv0)*0.0625;c+=texture2D(inputBuffer,vUv1)*0.125;c+=texture2D(inputBuffer,vUv2)*0.0625;c+=texture2D(inputBuffer,vUv3)*0.125;c+=texture2D(inputBuffer,vUv)*0.25;c+=texture2D(inputBuffer,vUv4)*0.125;c+=texture2D(inputBuffer,vUv5)*0.0625;c+=texture2D(inputBuffer,vUv6)*0.125;c+=texture2D(inputBuffer,vUv7)*0.0625;vec4 baseColor=texture2D(supportBuffer,vUv);gl_FragColor=mix(baseColor,c,radius);
#include <colorspace_fragment>
}`
  , FH = "uniform vec2 texelSize;varying vec2 vUv;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;varying vec2 vUv4;varying vec2 vUv5;varying vec2 vUv6;varying vec2 vUv7;void main(){vUv=position.xy*0.5+0.5;vUv0=vUv+texelSize*vec2(-1.0,1.0);vUv1=vUv+texelSize*vec2(0.0,1.0);vUv2=vUv+texelSize*vec2(1.0,1.0);vUv3=vUv+texelSize*vec2(-1.0,0.0);vUv4=vUv+texelSize*vec2(1.0,0.0);vUv5=vUv+texelSize*vec2(-1.0,-1.0);vUv6=vUv+texelSize*vec2(0.0,-1.0);vUv7=vUv+texelSize*vec2(1.0,-1.0);gl_Position=vec4(position.xy,1.0,1.0);}"
  , BH = class extends Vt {
    constructor() {
        super({
            name: "UpsamplingMaterial",
            uniforms: {
                inputBuffer: new bt(null),
                supportBuffer: new bt(null),
                texelSize: new bt(new Ce),
                radius: new bt(.85)
            },
            blending: Si,
            toneMapped: !1,
            depthWrite: !1,
            depthTest: !1,
            fragmentShader: NH,
            vertexShader: FH
        }),
        this.fragmentShader = Vc(this.fragmentShader)
    }
    set inputBuffer(r) {
        this.uniforms.inputBuffer.value = r
    }
    set supportBuffer(r) {
        this.uniforms.supportBuffer.value = r
    }
    get radius() {
        return this.uniforms.radius.value
    }
    set radius(r) {
        this.uniforms.radius.value = r
    }
    setSize(r, e) {
        this.uniforms.texelSize.value.set(1 / r, 1 / e)
    }
}
  , kH = new D_
  , ws = null;
function zH() {
    if (ws === null) {
        const r = new Float32Array([-1, -1, 0, 3, -1, 0, -1, 3, 0])
          , e = new Float32Array([0, 0, 2, 0, 0, 2]);
        ws = new mn,
        ws.setAttribute !== void 0 ? (ws.setAttribute("position", new pt(r,3)),
        ws.setAttribute("uv", new pt(e,2))) : (ws.addAttribute("position", new pt(r,3)),
        ws.addAttribute("uv", new pt(e,2)))
    }
    return ws
}
var Fr = class TS {
    constructor(e="Pass", t=new jm, n=kH) {
        this.name = e,
        this.renderer = null,
        this.scene = t,
        this.camera = n,
        this.screen = null,
        this.rtt = !0,
        this.needsSwap = !0,
        this.needsDepthTexture = !1,
        this.enabled = !0
    }
    get renderToScreen() {
        return !this.rtt
    }
    set renderToScreen(e) {
        if (this.rtt === e) {
            const t = this.fullscreenMaterial;
            t !== null && (t.needsUpdate = !0),
            this.rtt = !e
        }
    }
    set mainScene(e) {}
    set mainCamera(e) {}
    setRenderer(e) {
        this.renderer = e
    }
    isEnabled() {
        return this.enabled
    }
    setEnabled(e) {
        this.enabled = e
    }
    get fullscreenMaterial() {
        return this.screen !== null ? this.screen.material : null
    }
    set fullscreenMaterial(e) {
        let t = this.screen;
        t !== null ? t.material = e : (t = new en(zH(),e),
        t.frustumCulled = !1,
        this.scene === null && (this.scene = new jm),
        this.scene.add(t),
        this.screen = t)
    }
    getFullscreenMaterial() {
        return this.fullscreenMaterial
    }
    setFullscreenMaterial(e) {
        this.fullscreenMaterial = e
    }
    getDepthTexture() {
        return null
    }
    setDepthTexture(e, t=Fc) {}
    render(e, t, n, i, s) {
        throw new Error("Render method not implemented!")
    }
    setSize(e, t) {}
    initialize(e, t, n) {}
    dispose() {
        for (const e of Object.keys(this)) {
            const t = this[e];
            (t instanceof vn || t instanceof nr || t instanceof Pn || t instanceof TS) && this[e].dispose()
        }
    }
}
  , HH = class extends Fr {
    constructor(r, e=!0) {
        super("CopyPass"),
        this.fullscreenMaterial = new xS,
        this.needsSwap = !1,
        this.renderTarget = r,
        r === void 0 && (this.renderTarget = new vn(1,1,{
            minFilter: Ot,
            magFilter: Ot,
            stencilBuffer: !1,
            depthBuffer: !1
        }),
        this.renderTarget.texture.name = "CopyPass.Target"),
        this.autoResize = e
    }
    get resize() {
        return this.autoResize
    }
    set resize(r) {
        this.autoResize = r
    }
    get texture() {
        return this.renderTarget.texture
    }
    getTexture() {
        return this.renderTarget.texture
    }
    setAutoResizeEnabled(r) {
        this.autoResize = r
    }
    render(r, e, t, n, i) {
        this.fullscreenMaterial.inputBuffer = e.texture,
        r.setRenderTarget(this.renderToScreen ? null : this.renderTarget),
        r.render(this.scene, this.camera)
    }
    setSize(r, e) {
        this.autoResize && this.renderTarget.setSize(r, e)
    }
    initialize(r, e, t) {
        t !== void 0 && (this.renderTarget.texture.type = t,
        t !== Vn ? this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1" : ml(r) === On && yr(this.renderTarget.texture, On))
    }
}
  , VH = class extends Fr {
    constructor() {
        super("ClearMaskPass", null, null),
        this.needsSwap = !1
    }
    render(r, e, t, n, i) {
        const s = r.state.buffers.stencil;
        s.setLocked(!1),
        s.setTest(!1)
    }
}
  , Jx = new Ke
  , GH = class extends Fr {
    constructor(r=!0, e=!0, t=!1) {
        super("ClearPass", null, null),
        this.needsSwap = !1,
        this.color = r,
        this.depth = e,
        this.stencil = t,
        this.overrideClearColor = null,
        this.overrideClearAlpha = -1
    }
    setClearFlags(r, e, t) {
        this.color = r,
        this.depth = e,
        this.stencil = t
    }
    getOverrideClearColor() {
        return this.overrideClearColor
    }
    setOverrideClearColor(r) {
        this.overrideClearColor = r
    }
    getOverrideClearAlpha() {
        return this.overrideClearAlpha
    }
    setOverrideClearAlpha(r) {
        this.overrideClearAlpha = r
    }
    render(r, e, t, n, i) {
        const s = this.overrideClearColor
          , o = this.overrideClearAlpha
          , a = r.getClearAlpha()
          , c = s !== null
          , h = o >= 0;
        c ? (r.getClearColor(Jx),
        r.setClearColor(s, h ? o : a)) : h && r.setClearAlpha(o),
        r.setRenderTarget(this.renderToScreen ? null : e),
        r.clear(this.color, this.depth, this.stencil),
        c ? r.setClearColor(Jx, a) : h && r.setClearAlpha(a)
    }
}
;
function Qx(r, e, t) {
    for (const n of e) {
        const i = "$1" + r + n.charAt(0).toUpperCase() + n.slice(1)
          , s = new RegExp("([^\\.])(\\b" + n + "\\b)","g");
        for (const o of t.entries())
            o[1] !== null && t.set(o[0], o[1].replace(s, i))
    }
}
function WH(r, e, t) {
    let n = e.getFragmentShader()
      , i = e.getVertexShader();
    const s = n !== void 0 && /mainImage/.test(n)
      , o = n !== void 0 && /mainUv/.test(n);
    if (t.attributes |= e.getAttributes(),
    n === void 0)
        throw new Error(`Missing fragment shader (${e.name})`);
    if (o && t.attributes & Co.CONVOLUTION)
        throw new Error(`Effects that transform UVs are incompatible with convolution effects (${e.name})`);
    if (!s && !o)
        throw new Error(`Could not find mainImage or mainUv function (${e.name})`);
    {
        const a = /\w+\s+(\w+)\([\w\s,]*\)\s*{/g
          , c = t.shaderParts;
        let h = c.get(Mt.FRAGMENT_HEAD) || ""
          , d = c.get(Mt.FRAGMENT_MAIN_UV) || ""
          , l = c.get(Mt.FRAGMENT_MAIN_IMAGE) || ""
          , f = c.get(Mt.VERTEX_HEAD) || ""
          , p = c.get(Mt.VERTEX_MAIN_SUPPORT) || "";
        const g = new Set
          , y = new Set;
        if (o && (d += `	${r}MainUv(UV);
`,
        t.uvTransformation = !0),
        i !== null && /mainSupport/.test(i)) {
            const b = /mainSupport *\([\w\s]*?uv\s*?\)/.test(i);
            p += `	${r}MainSupport(`,
            p += b ? `vUv);
` : `);
`;
            for (const T of i.matchAll(/(?:varying\s+\w+\s+([\S\s]*?);)/g))
                for (const S of T[1].split(/\s*,\s*/))
                    t.varyings.add(S),
                    g.add(S),
                    y.add(S);
            for (const T of i.matchAll(a))
                y.add(T[1])
        }
        for (const b of n.matchAll(a))
            y.add(b[1]);
        for (const b of e.defines.keys())
            y.add(b.replace(/\([\w\s,]*\)/g, ""));
        for (const b of e.uniforms.keys())
            y.add(b);
        y.delete("while"),
        y.delete("for"),
        y.delete("if"),
        e.uniforms.forEach((b,T)=>t.uniforms.set(r + T.charAt(0).toUpperCase() + T.slice(1), b)),
        e.defines.forEach((b,T)=>t.defines.set(r + T.charAt(0).toUpperCase() + T.slice(1), b));
        const v = new Map([["fragment", n], ["vertex", i]]);
        Qx(r, y, t.defines),
        Qx(r, y, v),
        n = v.get("fragment"),
        i = v.get("vertex");
        const _ = e.blendMode;
        if (t.blendModes.set(_.blendFunction, _),
        s) {
            e.inputColorSpace !== null && e.inputColorSpace !== t.colorSpace && (l += e.inputColorSpace === On ? `color0 = LinearTosRGB(color0);
	` : `color0 = sRGBToLinear(color0);
	`),
            e.outputColorSpace !== gS ? t.colorSpace = e.outputColorSpace : e.inputColorSpace !== null && (t.colorSpace = e.inputColorSpace);
            const b = /MainImage *\([\w\s,]*?depth[\w\s,]*?\)/;
            l += `${r}MainImage(color0, UV, `,
            t.attributes & Co.DEPTH && b.test(n) && (l += "depth, ",
            t.readDepth = !0),
            l += `color1);
	`;
            const T = r + "BlendOpacity";
            t.uniforms.set(T, _.opacity),
            l += `color0 = blend${_.blendFunction}(color0, color1, ${T});

	`,
            h += `uniform float ${T};

`
        }
        if (h += n + `
`,
        i !== null && (f += i + `
`),
        c.set(Mt.FRAGMENT_HEAD, h),
        c.set(Mt.FRAGMENT_MAIN_UV, d),
        c.set(Mt.FRAGMENT_MAIN_IMAGE, l),
        c.set(Mt.VERTEX_HEAD, f),
        c.set(Mt.VERTEX_MAIN_SUPPORT, p),
        e.extensions !== null)
            for (const b of e.extensions)
                t.extensions.add(b)
    }
}
var jH = class extends Fr {
    constructor(r, ...e) {
        super("EffectPass"),
        this.fullscreenMaterial = new DH(null,null,null,r),
        this.listener = t=>this.handleEvent(t),
        this.effects = [],
        this.setEffects(e),
        this.skipRendering = !1,
        this.minTime = 1,
        this.maxTime = Number.POSITIVE_INFINITY,
        this.timeScale = 1
    }
    set mainScene(r) {
        for (const e of this.effects)
            e.mainScene = r
    }
    set mainCamera(r) {
        this.fullscreenMaterial.copyCameraSettings(r);
        for (const e of this.effects)
            e.mainCamera = r
    }
    get encodeOutput() {
        return this.fullscreenMaterial.encodeOutput
    }
    set encodeOutput(r) {
        this.fullscreenMaterial.encodeOutput = r
    }
    get dithering() {
        return this.fullscreenMaterial.dithering
    }
    set dithering(r) {
        const e = this.fullscreenMaterial;
        e.dithering = r,
        e.needsUpdate = !0
    }
    setEffects(r) {
        for (const e of this.effects)
            e.removeEventListener("change", this.listener);
        this.effects = r.sort((e,t)=>t.attributes - e.attributes);
        for (const e of this.effects)
            e.addEventListener("change", this.listener)
    }
    updateMaterial() {
        const r = new e4;
        let e = 0;
        for (const o of this.effects)
            if (o.blendMode.blendFunction === gt.DST)
                r.attributes |= o.getAttributes() & Co.DEPTH;
            else {
                if (r.attributes & o.getAttributes() & Co.CONVOLUTION)
                    throw new Error(`Convolution effects cannot be merged (${o.name})`);
                WH("e" + e++, o, r)
            }
        let t = r.shaderParts.get(Mt.FRAGMENT_HEAD)
          , n = r.shaderParts.get(Mt.FRAGMENT_MAIN_IMAGE)
          , i = r.shaderParts.get(Mt.FRAGMENT_MAIN_UV);
        const s = /\bblend\b/g;
        for (const o of r.blendModes.values())
            t += o.getShaderCode().replace(s, `blend${o.blendFunction}`) + `
`;
        r.attributes & Co.DEPTH ? (r.readDepth && (n = `float depth = readDepth(UV);

	` + n),
        this.needsDepthTexture = this.getDepthTexture() === null) : this.needsDepthTexture = !1,
        r.colorSpace === On && (n += `color0 = sRGBToLinear(color0);
	`),
        r.uvTransformation ? (i = `vec2 transformedUv = vUv;
` + i,
        r.defines.set("UV", "transformedUv")) : r.defines.set("UV", "vUv"),
        r.shaderParts.set(Mt.FRAGMENT_HEAD, t),
        r.shaderParts.set(Mt.FRAGMENT_MAIN_IMAGE, n),
        r.shaderParts.set(Mt.FRAGMENT_MAIN_UV, i);
        for (const [o,a] of r.shaderParts)
            a !== null && r.shaderParts.set(o, a.trim().replace(/^#/, `
#`));
        this.skipRendering = e === 0,
        this.needsSwap = !this.skipRendering,
        this.fullscreenMaterial.setShaderData(r)
    }
    recompile() {
        this.updateMaterial()
    }
    getDepthTexture() {
        return this.fullscreenMaterial.depthBuffer
    }
    setDepthTexture(r, e=Fc) {
        this.fullscreenMaterial.depthBuffer = r,
        this.fullscreenMaterial.depthPacking = e;
        for (const t of this.effects)
            t.setDepthTexture(r, e)
    }
    render(r, e, t, n, i) {
        for (const s of this.effects)
            s.update(r, e, n);
        if (!this.skipRendering || this.renderToScreen) {
            const s = this.fullscreenMaterial;
            s.inputBuffer = e.texture,
            s.time += n * this.timeScale,
            r.setRenderTarget(this.renderToScreen ? null : t),
            r.render(this.scene, this.camera)
        }
    }
    setSize(r, e) {
        this.fullscreenMaterial.setSize(r, e);
        for (const t of this.effects)
            t.setSize(r, e)
    }
    initialize(r, e, t) {
        this.renderer = r;
        for (const n of this.effects)
            n.initialize(r, e, t);
        this.updateMaterial(),
        t !== void 0 && t !== Vn && (this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1")
    }
    dispose() {
        super.dispose();
        for (const r of this.effects)
            r.removeEventListener("change", this.listener),
            r.dispose()
    }
    handleEvent(r) {
        switch (r.type) {
        case "change":
            this.recompile();
            break
        }
    }
}
  , XH = class extends Fr {
    constructor({kernelSize: r=tg.MEDIUM, resolutionScale: e=.5, width: t=Ir.AUTO_SIZE, height: n=Ir.AUTO_SIZE, resolutionX: i=t, resolutionY: s=n}={}) {
        super("KawaseBlurPass"),
        this.renderTargetA = new vn(1,1,{
            depthBuffer: !1
        }),
        this.renderTargetA.texture.name = "Blur.Target.A",
        this.renderTargetB = this.renderTargetA.clone(),
        this.renderTargetB.texture.name = "Blur.Target.B";
        const o = this.resolution = new Ir(this,i,s,e);
        o.addEventListener("change", a=>this.setSize(o.baseWidth, o.baseHeight)),
        this._blurMaterial = new EH,
        this._blurMaterial.kernelSize = r,
        this.copyMaterial = new xS
    }
    getResolution() {
        return this.resolution
    }
    get blurMaterial() {
        return this._blurMaterial
    }
    set blurMaterial(r) {
        this._blurMaterial = r
    }
    get dithering() {
        return this.copyMaterial.dithering
    }
    set dithering(r) {
        this.copyMaterial.dithering = r
    }
    get kernelSize() {
        return this.blurMaterial.kernelSize
    }
    set kernelSize(r) {
        this.blurMaterial.kernelSize = r
    }
    get width() {
        return this.resolution.width
    }
    set width(r) {
        this.resolution.preferredWidth = r
    }
    get height() {
        return this.resolution.height
    }
    set height(r) {
        this.resolution.preferredHeight = r
    }
    get scale() {
        return this.blurMaterial.scale
    }
    set scale(r) {
        this.blurMaterial.scale = r
    }
    getScale() {
        return this.blurMaterial.scale
    }
    setScale(r) {
        this.blurMaterial.scale = r
    }
    getKernelSize() {
        return this.kernelSize
    }
    setKernelSize(r) {
        this.kernelSize = r
    }
    getResolutionScale() {
        return this.resolution.scale
    }
    setResolutionScale(r) {
        this.resolution.scale = r
    }
    render(r, e, t, n, i) {
        const s = this.scene
          , o = this.camera
          , a = this.renderTargetA
          , c = this.renderTargetB
          , h = this.blurMaterial
          , d = h.kernelSequence;
        let l = e;
        this.fullscreenMaterial = h;
        for (let f = 0, p = d.length; f < p; ++f) {
            const g = f & 1 ? c : a;
            h.kernel = d[f],
            h.inputBuffer = l.texture,
            r.setRenderTarget(g),
            r.render(s, o),
            l = g
        }
        this.fullscreenMaterial = this.copyMaterial,
        this.copyMaterial.inputBuffer = l.texture,
        r.setRenderTarget(this.renderToScreen ? null : t),
        r.render(s, o)
    }
    setSize(r, e) {
        const t = this.resolution;
        t.setBaseSize(r, e);
        const n = t.width
          , i = t.height;
        this.renderTargetA.setSize(n, i),
        this.renderTargetB.setSize(n, i),
        this.blurMaterial.setSize(r, e)
    }
    initialize(r, e, t) {
        t !== void 0 && (this.renderTargetA.texture.type = t,
        this.renderTargetB.texture.type = t,
        t !== Vn ? (this.blurMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1",
        this.copyMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1") : ml(r) === On && (yr(this.renderTargetA.texture, On),
        yr(this.renderTargetB.texture, On)))
    }
    static get AUTO_SIZE() {
        return Ir.AUTO_SIZE
    }
}
  , qH = class extends Fr {
    constructor({renderTarget: r, luminanceRange: e, colorOutput: t, resolutionScale: n=1, width: i=Ir.AUTO_SIZE, height: s=Ir.AUTO_SIZE, resolutionX: o=i, resolutionY: a=s}={}) {
        super("LuminancePass"),
        this.fullscreenMaterial = new UH(t,e),
        this.needsSwap = !1,
        this.renderTarget = r,
        this.renderTarget === void 0 && (this.renderTarget = new vn(1,1,{
            depthBuffer: !1
        }),
        this.renderTarget.texture.name = "LuminancePass.Target");
        const c = this.resolution = new Ir(this,o,a,n);
        c.addEventListener("change", h=>this.setSize(c.baseWidth, c.baseHeight))
    }
    get texture() {
        return this.renderTarget.texture
    }
    getTexture() {
        return this.renderTarget.texture
    }
    getResolution() {
        return this.resolution
    }
    render(r, e, t, n, i) {
        const s = this.fullscreenMaterial;
        s.inputBuffer = e.texture,
        r.setRenderTarget(this.renderToScreen ? null : this.renderTarget),
        r.render(this.scene, this.camera)
    }
    setSize(r, e) {
        const t = this.resolution;
        t.setBaseSize(r, e),
        this.renderTarget.setSize(t.width, t.height)
    }
    initialize(r, e, t) {
        t !== void 0 && t !== Vn && (this.renderTarget.texture.type = t,
        this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1")
    }
}
  , KH = class extends Fr {
    constructor(r, e) {
        super("MaskPass", r, e),
        this.needsSwap = !1,
        this.clearPass = new GH(!1,!1,!0),
        this.inverse = !1
    }
    set mainScene(r) {
        this.scene = r
    }
    set mainCamera(r) {
        this.camera = r
    }
    get inverted() {
        return this.inverse
    }
    set inverted(r) {
        this.inverse = r
    }
    get clear() {
        return this.clearPass.enabled
    }
    set clear(r) {
        this.clearPass.enabled = r
    }
    getClearPass() {
        return this.clearPass
    }
    isInverted() {
        return this.inverted
    }
    setInverted(r) {
        this.inverted = r
    }
    render(r, e, t, n, i) {
        const s = r.getContext()
          , o = r.state.buffers
          , a = this.scene
          , c = this.camera
          , h = this.clearPass
          , d = this.inverted ? 0 : 1
          , l = 1 - d;
        o.color.setMask(!1),
        o.depth.setMask(!1),
        o.color.setLocked(!0),
        o.depth.setLocked(!0),
        o.stencil.setTest(!0),
        o.stencil.setOp(s.REPLACE, s.REPLACE, s.REPLACE),
        o.stencil.setFunc(s.ALWAYS, d, 4294967295),
        o.stencil.setClear(l),
        o.stencil.setLocked(!0),
        this.clearPass.enabled && (this.renderToScreen ? h.render(r, null) : (h.render(r, e),
        h.render(r, t))),
        this.renderToScreen ? (r.setRenderTarget(null),
        r.render(a, c)) : (r.setRenderTarget(e),
        r.render(a, c),
        r.setRenderTarget(t),
        r.render(a, c)),
        o.color.setLocked(!1),
        o.depth.setLocked(!1),
        o.stencil.setLocked(!1),
        o.stencil.setFunc(s.EQUAL, 1, 4294967295),
        o.stencil.setOp(s.KEEP, s.KEEP, s.KEEP),
        o.stencil.setLocked(!0)
    }
}
  , YH = class extends Fr {
    constructor() {
        super("MipmapBlurPass"),
        this.needsSwap = !1,
        this.renderTarget = new vn(1,1,{
            depthBuffer: !1
        }),
        this.renderTarget.texture.name = "Upsampling.Mipmap0",
        this.downsamplingMipmaps = [],
        this.upsamplingMipmaps = [],
        this.downsamplingMaterial = new CH,
        this.upsamplingMaterial = new BH,
        this.resolution = new Ce
    }
    get texture() {
        return this.renderTarget.texture
    }
    get levels() {
        return this.downsamplingMipmaps.length
    }
    set levels(r) {
        if (this.levels !== r) {
            const e = this.renderTarget;
            this.dispose(),
            this.downsamplingMipmaps = [],
            this.upsamplingMipmaps = [];
            for (let t = 0; t < r; ++t) {
                const n = e.clone();
                n.texture.name = "Downsampling.Mipmap" + t,
                this.downsamplingMipmaps.push(n)
            }
            this.upsamplingMipmaps.push(e);
            for (let t = 1, n = r - 1; t < n; ++t) {
                const i = e.clone();
                i.texture.name = "Upsampling.Mipmap" + t,
                this.upsamplingMipmaps.push(i)
            }
            this.setSize(this.resolution.x, this.resolution.y)
        }
    }
    get radius() {
        return this.upsamplingMaterial.radius
    }
    set radius(r) {
        this.upsamplingMaterial.radius = r
    }
    render(r, e, t, n, i) {
        const {scene: s, camera: o} = this
          , {downsamplingMaterial: a, upsamplingMaterial: c} = this
          , {downsamplingMipmaps: h, upsamplingMipmaps: d} = this;
        let l = e;
        this.fullscreenMaterial = a;
        for (let f = 0, p = h.length; f < p; ++f) {
            const g = h[f];
            a.setSize(l.width, l.height),
            a.inputBuffer = l.texture,
            r.setRenderTarget(g),
            r.render(s, o),
            l = g
        }
        this.fullscreenMaterial = c;
        for (let f = d.length - 1; f >= 0; --f) {
            const p = d[f];
            c.setSize(l.width, l.height),
            c.inputBuffer = l.texture,
            c.supportBuffer = h[f].texture,
            r.setRenderTarget(p),
            r.render(s, o),
            l = p
        }
    }
    setSize(r, e) {
        const t = this.resolution;
        t.set(r, e);
        let n = t.width
          , i = t.height;
        for (let s = 0, o = this.downsamplingMipmaps.length; s < o; ++s)
            n = Math.round(n * .5),
            i = Math.round(i * .5),
            this.downsamplingMipmaps[s].setSize(n, i),
            s < this.upsamplingMipmaps.length && this.upsamplingMipmaps[s].setSize(n, i)
    }
    initialize(r, e, t) {
        if (t !== void 0) {
            const n = this.downsamplingMipmaps.concat(this.upsamplingMipmaps);
            for (const i of n)
                i.texture.type = t;
            if (t !== Vn)
                this.downsamplingMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1",
                this.upsamplingMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1";
            else if (ml(r) === On)
                for (const i of n)
                    yr(i.texture, On)
        }
    }
    dispose() {
        super.dispose();
        for (const r of this.downsamplingMipmaps.concat(this.upsamplingMipmaps))
            r.dispose()
    }
}
  , $H = class extends Fr {
    constructor(r, e="inputBuffer") {
        super("ShaderPass"),
        this.fullscreenMaterial = r,
        this.input = e
    }
    setInput(r) {
        this.input = r
    }
    render(r, e, t, n, i) {
        const s = this.fullscreenMaterial.uniforms;
        e !== null && s !== void 0 && s[this.input] !== void 0 && (s[this.input].value = e.texture),
        r.setRenderTarget(this.renderToScreen ? null : t),
        r.render(this.scene, this.camera)
    }
    initialize(r, e, t) {
        t !== void 0 && t !== Vn && (this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1")
    }
}
  , dm = 1 / 1e3
  , ZH = 1e3
  , JH = class {
    constructor() {
        this.startTime = performance.now(),
        this.previousTime = 0,
        this.currentTime = 0,
        this._delta = 0,
        this._elapsed = 0,
        this._fixedDelta = 1e3 / 60,
        this.timescale = 1,
        this.useFixedDelta = !1,
        this._autoReset = !1
    }
    get autoReset() {
        return this._autoReset
    }
    set autoReset(r) {
        typeof document < "u" && document.hidden !== void 0 && (r ? document.addEventListener("visibilitychange", this) : document.removeEventListener("visibilitychange", this),
        this._autoReset = r)
    }
    get delta() {
        return this._delta * dm
    }
    get fixedDelta() {
        return this._fixedDelta * dm
    }
    set fixedDelta(r) {
        this._fixedDelta = r * ZH
    }
    get elapsed() {
        return this._elapsed * dm
    }
    update(r) {
        this.useFixedDelta ? this._delta = this.fixedDelta : (this.previousTime = this.currentTime,
        this.currentTime = (r !== void 0 ? r : performance.now()) - this.startTime,
        this._delta = this.currentTime - this.previousTime),
        this._delta *= this.timescale,
        this._elapsed += this._delta
    }
    reset() {
        this._delta = 0,
        this._elapsed = 0,
        this.currentTime = performance.now() - this.startTime
    }
    handleEvent(r) {
        document.hidden || (this.currentTime = performance.now() - this.startTime)
    }
    dispose() {
        this.autoReset = !1
    }
}
  , QH = class {
    constructor(r=null, {depthBuffer: e=!0, stencilBuffer: t=!1, multisampling: n=0, frameBufferType: i}={}) {
        this.renderer = null,
        this.inputBuffer = this.createBuffer(e, t, i, n),
        this.outputBuffer = this.inputBuffer.clone(),
        this.copyPass = new HH,
        this.depthTexture = null,
        this.passes = [],
        this.timer = new JH,
        this.autoRenderToScreen = !0,
        this.setRenderer(r)
    }
    get multisampling() {
        return this.inputBuffer.samples || 0
    }
    set multisampling(r) {
        const e = this.inputBuffer
          , t = this.multisampling;
        t > 0 && r > 0 ? (this.inputBuffer.samples = r,
        this.outputBuffer.samples = r,
        this.inputBuffer.dispose(),
        this.outputBuffer.dispose()) : t !== r && (this.inputBuffer.dispose(),
        this.outputBuffer.dispose(),
        this.inputBuffer = this.createBuffer(e.depthBuffer, e.stencilBuffer, e.texture.type, r),
        this.inputBuffer.depthTexture = this.depthTexture,
        this.outputBuffer = this.inputBuffer.clone())
    }
    getTimer() {
        return this.timer
    }
    getRenderer() {
        return this.renderer
    }
    setRenderer(r) {
        if (this.renderer = r,
        r !== null) {
            const e = r.getSize(new Ce)
              , t = r.getContext().getContextAttributes().alpha
              , n = this.inputBuffer.texture.type;
            n === Vn && ml(r) === On && (yr(this.inputBuffer.texture, On),
            yr(this.outputBuffer.texture, On),
            this.inputBuffer.dispose(),
            this.outputBuffer.dispose()),
            r.autoClear = !1,
            this.setSize(e.width, e.height);
            for (const i of this.passes)
                i.initialize(r, t, n)
        }
    }
    replaceRenderer(r, e=!0) {
        const t = this.renderer
          , n = t.domElement.parentNode;
        return this.setRenderer(r),
        e && n !== null && (n.removeChild(t.domElement),
        n.appendChild(r.domElement)),
        t
    }
    createDepthTexture() {
        const r = this.depthTexture = new N_;
        return this.inputBuffer.depthTexture = r,
        this.inputBuffer.dispose(),
        this.inputBuffer.stencilBuffer ? (r.format = Oo,
        r.type = Fs) : r.type = ns,
        r
    }
    deleteDepthTexture() {
        if (this.depthTexture !== null) {
            this.depthTexture.dispose(),
            this.depthTexture = null,
            this.inputBuffer.depthTexture = null,
            this.inputBuffer.dispose();
            for (const r of this.passes)
                r.setDepthTexture(null)
        }
    }
    createBuffer(r, e, t, n) {
        const i = this.renderer
          , s = i === null ? new Ce : i.getDrawingBufferSize(new Ce)
          , o = {
            minFilter: Ot,
            magFilter: Ot,
            stencilBuffer: e,
            depthBuffer: r,
            type: t
        }
          , a = new vn(s.width,s.height,o);
        return n > 0 && (a.ignoreDepthForMultisampleCopy = !1,
        a.samples = n),
        t === Vn && ml(i) === On && yr(a.texture, On),
        a.texture.name = "EffectComposer.Buffer",
        a.texture.generateMipmaps = !1,
        a
    }
    setMainScene(r) {
        for (const e of this.passes)
            e.mainScene = r
    }
    setMainCamera(r) {
        for (const e of this.passes)
            e.mainCamera = r
    }
    addPass(r, e) {
        const t = this.passes
          , n = this.renderer
          , i = n.getDrawingBufferSize(new Ce)
          , s = n.getContext().getContextAttributes().alpha
          , o = this.inputBuffer.texture.type;
        if (r.setRenderer(n),
        r.setSize(i.width, i.height),
        r.initialize(n, s, o),
        this.autoRenderToScreen && (t.length > 0 && (t[t.length - 1].renderToScreen = !1),
        r.renderToScreen && (this.autoRenderToScreen = !1)),
        e !== void 0 ? t.splice(e, 0, r) : t.push(r),
        this.autoRenderToScreen && (t[t.length - 1].renderToScreen = !0),
        r.needsDepthTexture || this.depthTexture !== null)
            if (this.depthTexture === null) {
                const a = this.createDepthTexture();
                for (r of t)
                    r.setDepthTexture(a)
            } else
                r.setDepthTexture(this.depthTexture)
    }
    removePass(r) {
        const e = this.passes
          , t = e.indexOf(r);
        if (t !== -1 && e.splice(t, 1).length > 0) {
            if (this.depthTexture !== null) {
                const s = (a,c)=>a || c.needsDepthTexture;
                e.reduce(s, !1) || (r.getDepthTexture() === this.depthTexture && r.setDepthTexture(null),
                this.deleteDepthTexture())
            }
            this.autoRenderToScreen && t === e.length && (r.renderToScreen = !1,
            e.length > 0 && (e[e.length - 1].renderToScreen = !0))
        }
    }
    removeAllPasses() {
        const r = this.passes;
        this.deleteDepthTexture(),
        r.length > 0 && (this.autoRenderToScreen && (r[r.length - 1].renderToScreen = !1),
        this.passes = [])
    }
    render(r) {
        const e = this.renderer
          , t = this.copyPass;
        let n = this.inputBuffer, i = this.outputBuffer, s = !1, o, a, c;
        r === void 0 && (this.timer.update(),
        r = this.timer.delta);
        for (const h of this.passes)
            h.enabled && (h.render(e, n, i, r, s),
            h.needsSwap && (s && (t.renderToScreen = h.renderToScreen,
            o = e.getContext(),
            a = e.state.buffers.stencil,
            a.setFunc(o.NOTEQUAL, 1, 4294967295),
            t.render(e, n, i, r, s),
            a.setFunc(o.EQUAL, 1, 4294967295)),
            c = n,
            n = i,
            i = c),
            h instanceof KH ? s = !0 : h instanceof VH && (s = !1))
    }
    setSize(r, e, t) {
        const n = this.renderer
          , i = n.getSize(new Ce);
        (r === void 0 || e === void 0) && (r = i.width,
        e = i.height),
        (i.width !== r || i.height !== e) && n.setSize(r, e, t);
        const s = n.getDrawingBufferSize(new Ce);
        this.inputBuffer.setSize(s.width, s.height),
        this.outputBuffer.setSize(s.width, s.height);
        for (const o of this.passes)
            o.setSize(s.width, s.height)
    }
    reset() {
        const r = this.timer.autoReset;
        this.dispose(),
        this.autoRenderToScreen = !0,
        this.timer.autoReset = r
    }
    dispose() {
        for (const r of this.passes)
            r.dispose();
        this.passes = [],
        this.inputBuffer !== null && this.inputBuffer.dispose(),
        this.outputBuffer !== null && this.outputBuffer.dispose(),
        this.deleteDepthTexture(),
        this.copyPass.dispose(),
        this.timer.dispose()
    }
}
  , e4 = class {
    constructor() {
        this.shaderParts = new Map([[Mt.FRAGMENT_HEAD, null], [Mt.FRAGMENT_MAIN_UV, null], [Mt.FRAGMENT_MAIN_IMAGE, null], [Mt.VERTEX_HEAD, null], [Mt.VERTEX_MAIN_SUPPORT, null]]),
        this.defines = new Map,
        this.uniforms = new Map,
        this.blendModes = new Map,
        this.extensions = new Set,
        this.attributes = Co.NONE,
        this.varyings = new Set,
        this.uvTransformation = !1,
        this.readDepth = !1,
        this.colorSpace = pl
    }
}
  , Es = -1
  , Ir = class extends Sr {
    constructor(r, e=Es, t=Es, n=1) {
        super(),
        this.resizable = r,
        this.baseSize = new Ce(1,1),
        this.preferredSize = new Ce(e,t),
        this.target = this.preferredSize,
        this.s = n,
        this.effectiveSize = new Ce,
        this.addEventListener("change", ()=>this.updateEffectiveSize()),
        this.updateEffectiveSize()
    }
    updateEffectiveSize() {
        const r = this.baseSize
          , e = this.preferredSize
          , t = this.effectiveSize
          , n = this.scale;
        e.width !== Es ? t.width = e.width : e.height !== Es ? t.width = Math.round(e.height * (r.width / Math.max(r.height, 1))) : t.width = Math.round(r.width * n),
        e.height !== Es ? t.height = e.height : e.width !== Es ? t.height = Math.round(e.width / Math.max(r.width / Math.max(r.height, 1), 1)) : t.height = Math.round(r.height * n)
    }
    get width() {
        return this.effectiveSize.width
    }
    set width(r) {
        this.preferredWidth = r
    }
    get height() {
        return this.effectiveSize.height
    }
    set height(r) {
        this.preferredHeight = r
    }
    getWidth() {
        return this.width
    }
    getHeight() {
        return this.height
    }
    get scale() {
        return this.s
    }
    set scale(r) {
        this.s !== r && (this.s = r,
        this.preferredSize.setScalar(Es),
        this.dispatchEvent({
            type: "change"
        }),
        this.resizable.setSize(this.baseSize.width, this.baseSize.height))
    }
    getScale() {
        return this.scale
    }
    setScale(r) {
        this.scale = r
    }
    get baseWidth() {
        return this.baseSize.width
    }
    set baseWidth(r) {
        this.baseSize.width !== r && (this.baseSize.width = r,
        this.dispatchEvent({
            type: "change"
        }),
        this.resizable.setSize(this.baseSize.width, this.baseSize.height))
    }
    getBaseWidth() {
        return this.baseWidth
    }
    setBaseWidth(r) {
        this.baseWidth = r
    }
    get baseHeight() {
        return this.baseSize.height
    }
    set baseHeight(r) {
        this.baseSize.height !== r && (this.baseSize.height = r,
        this.dispatchEvent({
            type: "change"
        }),
        this.resizable.setSize(this.baseSize.width, this.baseSize.height))
    }
    getBaseHeight() {
        return this.baseHeight
    }
    setBaseHeight(r) {
        this.baseHeight = r
    }
    setBaseSize(r, e) {
        (this.baseSize.width !== r || this.baseSize.height !== e) && (this.baseSize.set(r, e),
        this.dispatchEvent({
            type: "change"
        }),
        this.resizable.setSize(this.baseSize.width, this.baseSize.height))
    }
    get preferredWidth() {
        return this.preferredSize.width
    }
    set preferredWidth(r) {
        this.preferredSize.width !== r && (this.preferredSize.width = r,
        this.dispatchEvent({
            type: "change"
        }),
        this.resizable.setSize(this.baseSize.width, this.baseSize.height))
    }
    getPreferredWidth() {
        return this.preferredWidth
    }
    setPreferredWidth(r) {
        this.preferredWidth = r
    }
    get preferredHeight() {
        return this.preferredSize.height
    }
    set preferredHeight(r) {
        this.preferredSize.height !== r && (this.preferredSize.height = r,
        this.dispatchEvent({
            type: "change"
        }),
        this.resizable.setSize(this.baseSize.width, this.baseSize.height))
    }
    getPreferredHeight() {
        return this.preferredHeight
    }
    setPreferredHeight(r) {
        this.preferredHeight = r
    }
    setPreferredSize(r, e) {
        (this.preferredSize.width !== r || this.preferredSize.height !== e) && (this.preferredSize.set(r, e),
        this.dispatchEvent({
            type: "change"
        }),
        this.resizable.setSize(this.baseSize.width, this.baseSize.height))
    }
    copy(r) {
        this.s = r.scale,
        this.baseSize.set(r.baseWidth, r.baseHeight),
        this.preferredSize.set(r.preferredWidth, r.preferredHeight),
        this.dispatchEvent({
            type: "change"
        }),
        this.resizable.setSize(this.baseSize.width, this.baseSize.height)
    }
    static get AUTO_SIZE() {
        return Es
    }
}
  , t4 = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,x+y,opacity);}"
  , n4 = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,y,min(y.a,opacity));}"
  , i4 = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,(x+y)*0.5,opacity);}"
  , r4 = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(yHSL.rg,xHSL.b));return vec4(mix(x.rgb,z,opacity),y.a);}"
  , s4 = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=mix(step(0.0,y)*(1.0-min(vec4(1.0),(1.0-x)/y)),vec4(1.0),step(1.0,x));return mix(x,z,opacity);}"
  , o4 = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=step(0.0,x)*mix(min(vec4(1.0),x/max(1.0-y,1e-9)),vec4(1.0),step(1.0,y));return mix(x,z,opacity);}"
  , a4 = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,min(x,y),opacity);}"
  , l4 = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,abs(x-y),opacity);}"
  , c4 = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,x/max(y,1e-12),opacity);}"
  , u4 = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,(x+y-2.0*x*y),opacity);}"
  , h4 = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 a=min(x,1.0),b=min(y,1.0);vec4 z=mix(2.0*a*b,1.0-2.0*(1.0-a)*(1.0-b),step(0.5,y));return mix(x,z,opacity);}"
  , f4 = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,step(1.0,x+y),opacity);}"
  , d4 = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(yHSL.r,xHSL.gb));return vec4(mix(x.rgb,z,opacity),y.a);}"
  , p4 = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,1.0-y,opacity);}"
  , m4 = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,y*(1.0-x),opacity);}"
  , _4 = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,max(x,y),opacity);}"
  , g4 = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,clamp(y+x-1.0,0.0,1.0),opacity);}"
  , v4 = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,min(x+y,1.0),opacity);}"
  , y4 = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,clamp(2.0*y+x-1.0,0.0,1.0),opacity);}"
  , x4 = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(xHSL.rg,yHSL.b));return vec4(mix(x.rgb,z,opacity),y.a);}"
  , T4 = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,x*y,opacity);}"
  , b4 = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,1.0-abs(1.0-x-y),opacity);}"
  , S4 = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,y,opacity);}"
  , M4 = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=mix(2.0*y*x,1.0-2.0*(1.0-y)*(1.0-x),step(0.5,x));return mix(x,z,opacity);}"
  , w4 = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 y2=2.0*y;vec4 z=mix(mix(y2,x,step(0.5*x,y)),max(vec4(0.0),y2-1.0),step(x,(y2-1.0)));return mix(x,z,opacity);}"
  , E4 = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=mix(min(x*x/max(1.0-y,1e-12),1.0),y,step(1.0,y));return mix(x,z,opacity);}"
  , A4 = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(xHSL.r,yHSL.g,xHSL.b));return vec4(mix(x.rgb,z,opacity),y.a);}"
  , P4 = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,x+y-min(x*y,1.0),opacity);}"
  , R4 = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 y2=2.0*y;vec4 w=step(0.5,y);vec4 z=mix(x-(1.0-y2)*x*(1.0-x),mix(x+(y2-1.0)*(sqrt(x)-x),x+(y2-1.0)*x*((16.0*x-12.0)*x+3.0),w*(1.0-step(0.25,x))),w);return mix(x,z,opacity);}"
  , C4 = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return y;}"
  , I4 = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,max(x+y-1.0,0.0),opacity);}"
  , L4 = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=mix(max(1.0-min((1.0-x)/(2.0*y),1.0),0.0),min(x/(2.0*(1.0-y)),1.0),step(0.5,y));return mix(x,z,opacity);}"
  , D4 = new Map([[gt.ADD, t4], [gt.ALPHA, n4], [gt.AVERAGE, i4], [gt.COLOR, r4], [gt.COLOR_BURN, s4], [gt.COLOR_DODGE, o4], [gt.DARKEN, a4], [gt.DIFFERENCE, l4], [gt.DIVIDE, c4], [gt.DST, null], [gt.EXCLUSION, u4], [gt.HARD_LIGHT, h4], [gt.HARD_MIX, f4], [gt.HUE, d4], [gt.INVERT, p4], [gt.INVERT_RGB, m4], [gt.LIGHTEN, _4], [gt.LINEAR_BURN, g4], [gt.LINEAR_DODGE, v4], [gt.LINEAR_LIGHT, y4], [gt.LUMINOSITY, x4], [gt.MULTIPLY, T4], [gt.NEGATION, b4], [gt.NORMAL, S4], [gt.OVERLAY, M4], [gt.PIN_LIGHT, w4], [gt.REFLECT, E4], [gt.SATURATION, A4], [gt.SCREEN, P4], [gt.SOFT_LIGHT, R4], [gt.SRC, C4], [gt.SUBTRACT, I4], [gt.VIVID_LIGHT, L4]])
  , O4 = class extends Sr {
    constructor(r, e=1) {
        super(),
        this._blendFunction = r,
        this.opacity = new bt(e)
    }
    getOpacity() {
        return this.opacity.value
    }
    setOpacity(r) {
        this.opacity.value = r
    }
    get blendFunction() {
        return this._blendFunction
    }
    set blendFunction(r) {
        this._blendFunction = r,
        this.dispatchEvent({
            type: "change"
        })
    }
    getBlendFunction() {
        return this.blendFunction
    }
    setBlendFunction(r) {
        this.blendFunction = r
    }
    getShaderCode() {
        return D4.get(this.blendFunction)
    }
}
  , bS = class extends Sr {
    constructor(r, e, {attributes: t=Co.NONE, blendFunction: n=gt.NORMAL, defines: i=new Map, uniforms: s=new Map, extensions: o=null, vertexShader: a=null}={}) {
        super(),
        this.name = r,
        this.renderer = null,
        this.attributes = t,
        this.fragmentShader = e,
        this.vertexShader = a,
        this.defines = i,
        this.uniforms = s,
        this.extensions = o,
        this.blendMode = new O4(n),
        this.blendMode.addEventListener("change", c=>this.setChanged()),
        this._inputColorSpace = pl,
        this._outputColorSpace = gS
    }
    get inputColorSpace() {
        return this._inputColorSpace
    }
    set inputColorSpace(r) {
        this._inputColorSpace = r,
        this.setChanged()
    }
    get outputColorSpace() {
        return this._outputColorSpace
    }
    set outputColorSpace(r) {
        this._outputColorSpace = r,
        this.setChanged()
    }
    set mainScene(r) {}
    set mainCamera(r) {}
    getName() {
        return this.name
    }
    setRenderer(r) {
        this.renderer = r
    }
    getDefines() {
        return this.defines
    }
    getUniforms() {
        return this.uniforms
    }
    getExtensions() {
        return this.extensions
    }
    getBlendMode() {
        return this.blendMode
    }
    getAttributes() {
        return this.attributes
    }
    setAttributes(r) {
        this.attributes = r,
        this.setChanged()
    }
    getFragmentShader() {
        return this.fragmentShader
    }
    setFragmentShader(r) {
        this.fragmentShader = r,
        this.setChanged()
    }
    getVertexShader() {
        return this.vertexShader
    }
    setVertexShader(r) {
        this.vertexShader = r,
        this.setChanged()
    }
    setChanged() {
        this.dispatchEvent({
            type: "change"
        })
    }
    setDepthTexture(r, e=Fc) {}
    update(r, e, t) {}
    setSize(r, e) {}
    initialize(r, e, t) {}
    dispose() {
        for (const r of Object.keys(this)) {
            const e = this[r];
            (e instanceof vn || e instanceof nr || e instanceof Pn || e instanceof Fr) && this[r].dispose()
        }
    }
}
  , U4 = `#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D map;
#else
uniform lowp sampler2D map;
#endif
uniform float intensity;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec4 texel=texture2D(map,uv);outputColor=vec4(texel.rgb*intensity,texel.a);}`
  , N4 = class extends bS {
    constructor({blendFunction: r=gt.SCREEN, luminanceThreshold: e=.9, luminanceSmoothing: t=.025, mipmapBlur: n=!1, intensity: i=1, radius: s=.85, levels: o=8, kernelSize: a=tg.LARGE, resolutionScale: c=.5, width: h=Ir.AUTO_SIZE, height: d=Ir.AUTO_SIZE, resolutionX: l=h, resolutionY: f=d}={}) {
        super("BloomEffect", U4, {
            blendFunction: r,
            uniforms: new Map([["map", new bt(null)], ["intensity", new bt(i)]])
        }),
        this.renderTarget = new vn(1,1,{
            depthBuffer: !1
        }),
        this.renderTarget.texture.name = "Bloom.Target",
        this.blurPass = new XH({
            kernelSize: a
        }),
        this.luminancePass = new qH({
            colorOutput: !0
        }),
        this.luminanceMaterial.threshold = e,
        this.luminanceMaterial.smoothing = t,
        this.mipmapBlurPass = new YH,
        this.mipmapBlurPass.enabled = n,
        this.mipmapBlurPass.radius = s,
        this.mipmapBlurPass.levels = o,
        this.uniforms.get("map").value = n ? this.mipmapBlurPass.texture : this.renderTarget.texture;
        const p = this.resolution = new Ir(this,l,f,c);
        p.addEventListener("change", g=>this.setSize(p.baseWidth, p.baseHeight))
    }
    get texture() {
        return this.mipmapBlurPass.enabled ? this.mipmapBlurPass.texture : this.renderTarget.texture
    }
    getTexture() {
        return this.texture
    }
    getResolution() {
        return this.resolution
    }
    getBlurPass() {
        return this.blurPass
    }
    getLuminancePass() {
        return this.luminancePass
    }
    get luminanceMaterial() {
        return this.luminancePass.fullscreenMaterial
    }
    getLuminanceMaterial() {
        return this.luminancePass.fullscreenMaterial
    }
    get width() {
        return this.resolution.width
    }
    set width(r) {
        this.resolution.preferredWidth = r
    }
    get height() {
        return this.resolution.height
    }
    set height(r) {
        this.resolution.preferredHeight = r
    }
    get dithering() {
        return this.blurPass.dithering
    }
    set dithering(r) {
        this.blurPass.dithering = r
    }
    get kernelSize() {
        return this.blurPass.kernelSize
    }
    set kernelSize(r) {
        this.blurPass.kernelSize = r
    }
    get distinction() {
        return console.warn(this.name, "distinction was removed"),
        1
    }
    set distinction(r) {
        console.warn(this.name, "distinction was removed")
    }
    get intensity() {
        return this.uniforms.get("intensity").value
    }
    set intensity(r) {
        this.uniforms.get("intensity").value = r
    }
    getIntensity() {
        return this.intensity
    }
    setIntensity(r) {
        this.intensity = r
    }
    getResolutionScale() {
        return this.resolution.scale
    }
    setResolutionScale(r) {
        this.resolution.scale = r
    }
    update(r, e, t) {
        const n = this.renderTarget
          , i = this.luminancePass;
        i.enabled ? (i.render(r, e),
        this.mipmapBlurPass.enabled ? this.mipmapBlurPass.render(r, i.renderTarget) : this.blurPass.render(r, i.renderTarget, n)) : this.mipmapBlurPass.enabled ? this.mipmapBlurPass.render(r, e) : this.blurPass.render(r, e, n)
    }
    setSize(r, e) {
        const t = this.resolution;
        t.setBaseSize(r, e),
        this.renderTarget.setSize(t.width, t.height),
        this.blurPass.resolution.copy(t),
        this.luminancePass.setSize(r, e),
        this.mipmapBlurPass.setSize(r, e)
    }
    initialize(r, e, t) {
        this.blurPass.initialize(r, e, t),
        this.luminancePass.initialize(r, e, t),
        this.mipmapBlurPass.initialize(r, e, t),
        t !== void 0 && (this.renderTarget.texture.type = t,
        ml(r) === On && yr(this.renderTarget.texture, On))
    }
}
;
function eT(r, e, t) {
    const n = document.createElement("canvas")
      , i = n.getContext("2d");
    if (n.width = r,
    n.height = e,
    t instanceof Image)
        i.drawImage(t, 0, 0);
    else {
        const s = i.createImageData(r, e);
        s.data.set(t),
        i.putImageData(s, 0, 0)
    }
    return n
}
var F4 = class SS {
    constructor(e=0, t=0, n=null) {
        this.width = e,
        this.height = t,
        this.data = n
    }
    toCanvas() {
        return typeof document > "u" ? null : eT(this.width, this.height, this.data)
    }
    static from(e) {
        const {width: t, height: n} = e;
        let i;
        if (e instanceof Image) {
            const s = eT(t, n, e);
            s !== null && (i = s.getContext("2d").getImageData(0, 0, t, n).data)
        } else
            i = e.data;
        return new SS(t,n,i)
    }
}
  , B4 = `"use strict";(()=>{var O={SCALE_UP:"lut.scaleup"};var _=[new Float32Array(3),new Float32Array(3)],n=[new Float32Array(3),new Float32Array(3),new Float32Array(3),new Float32Array(3)],Z=[[new Float32Array([0,0,0]),new Float32Array([1,0,0]),new Float32Array([1,1,0]),new Float32Array([1,1,1])],[new Float32Array([0,0,0]),new Float32Array([1,0,0]),new Float32Array([1,0,1]),new Float32Array([1,1,1])],[new Float32Array([0,0,0]),new Float32Array([0,0,1]),new Float32Array([1,0,1]),new Float32Array([1,1,1])],[new Float32Array([0,0,0]),new Float32Array([0,1,0]),new Float32Array([1,1,0]),new Float32Array([1,1,1])],[new Float32Array([0,0,0]),new Float32Array([0,1,0]),new Float32Array([0,1,1]),new Float32Array([1,1,1])],[new Float32Array([0,0,0]),new Float32Array([0,0,1]),new Float32Array([0,1,1]),new Float32Array([1,1,1])]];function d(a,t,r,m){let i=r[0]-t[0],e=r[1]-t[1],y=r[2]-t[2],h=a[0]-t[0],A=a[1]-t[1],w=a[2]-t[2],c=e*w-y*A,l=y*h-i*w,x=i*A-e*h,u=Math.sqrt(c*c+l*l+x*x),b=u*.5,s=c/u,F=l/u,f=x/u,p=-(a[0]*s+a[1]*F+a[2]*f),M=m[0]*s+m[1]*F+m[2]*f;return Math.abs(M+p)*b/3}function V(a,t,r,m,i,e){let y=(r+m*t+i*t*t)*4;e[0]=a[y+0],e[1]=a[y+1],e[2]=a[y+2]}function k(a,t,r,m,i,e){let y=r*(t-1),h=m*(t-1),A=i*(t-1),w=Math.floor(y),c=Math.floor(h),l=Math.floor(A),x=Math.ceil(y),u=Math.ceil(h),b=Math.ceil(A),s=y-w,F=h-c,f=A-l;if(w===y&&c===h&&l===A)V(a,t,y,h,A,e);else{let p;s>=F&&F>=f?p=Z[0]:s>=f&&f>=F?p=Z[1]:f>=s&&s>=F?p=Z[2]:F>=s&&s>=f?p=Z[3]:F>=f&&f>=s?p=Z[4]:f>=F&&F>=s&&(p=Z[5]);let[M,g,X,Y]=p,P=_[0];P[0]=s,P[1]=F,P[2]=f;let o=_[1],L=x-w,S=u-c,U=b-l;o[0]=L*M[0]+w,o[1]=S*M[1]+c,o[2]=U*M[2]+l,V(a,t,o[0],o[1],o[2],n[0]),o[0]=L*g[0]+w,o[1]=S*g[1]+c,o[2]=U*g[2]+l,V(a,t,o[0],o[1],o[2],n[1]),o[0]=L*X[0]+w,o[1]=S*X[1]+c,o[2]=U*X[2]+l,V(a,t,o[0],o[1],o[2],n[2]),o[0]=L*Y[0]+w,o[1]=S*Y[1]+c,o[2]=U*Y[2]+l,V(a,t,o[0],o[1],o[2],n[3]);let T=d(g,X,Y,P)*6,q=d(M,X,Y,P)*6,C=d(M,g,Y,P)*6,E=d(M,g,X,P)*6;n[0][0]*=T,n[0][1]*=T,n[0][2]*=T,n[1][0]*=q,n[1][1]*=q,n[1][2]*=q,n[2][0]*=C,n[2][1]*=C,n[2][2]*=C,n[3][0]*=E,n[3][1]*=E,n[3][2]*=E,e[0]=n[0][0]+n[1][0]+n[2][0]+n[3][0],e[1]=n[0][1]+n[1][1]+n[2][1]+n[3][1],e[2]=n[0][2]+n[1][2]+n[2][2]+n[3][2]}}var v=class{static expand(t,r){let m=Math.cbrt(t.length/4),i=new Float32Array(3),e=new t.constructor(r**3*4),y=t instanceof Uint8Array?255:1,h=r**2,A=1/(r-1);for(let w=0;w<r;++w)for(let c=0;c<r;++c)for(let l=0;l<r;++l){let x=l*A,u=c*A,b=w*A,s=Math.round(l+c*r+w*h)*4;k(t,m,x,u,b,i),e[s+0]=i[0],e[s+1]=i[1],e[s+2]=i[2],e[s+3]=y}return e}};self.addEventListener("message",a=>{let t=a.data,r=t.data;switch(t.operation){case O.SCALE_UP:r=v.expand(r,t.size);break}postMessage(r,[r.buffer]),close()});})();
`
  , tT = new Ke
  , MS = class Fh extends Tc {
    constructor(e, t) {
        super(e, t, t, t),
        this.type = wn,
        this.format = Kn,
        this.minFilter = Ot,
        this.magFilter = Ot,
        this.wrapS = hi,
        this.wrapT = hi,
        this.wrapR = hi,
        this.unpackAlignment = 1,
        this.needsUpdate = !0,
        yr(this, pl),
        this.domainMin = new k(0,0,0),
        this.domainMax = new k(1,1,1)
    }
    get isLookupTexture3D() {
        return !0
    }
    scaleUp(e, t=!0) {
        const n = this.image;
        let i;
        return e <= n.width ? i = Promise.reject(new Error("The target size must be greater than the current size")) : i = new Promise((s,o)=>{
            const a = URL.createObjectURL(new Blob([B4],{
                type: "text/javascript"
            }))
              , c = new Worker(a);
            c.addEventListener("error", d=>o(d.error)),
            c.addEventListener("message", d=>{
                const l = new Fh(d.data,e);
                fm(this, l),
                l.type = this.type,
                l.name = this.name,
                URL.revokeObjectURL(a),
                s(l)
            }
            );
            const h = t ? [n.data.buffer] : [];
            c.postMessage({
                operation: TH.SCALE_UP,
                data: n.data,
                size: e
            }, h)
        }
        ),
        i
    }
    applyLUT(e) {
        const t = this.image
          , n = e.image
          , i = Math.min(t.width, t.height, t.depth)
          , s = Math.min(n.width, n.height, n.depth);
        if (i !== s)
            console.error("Size mismatch");
        else if (e.type !== wn || this.type !== wn)
            console.error("Both LUTs must be FloatType textures");
        else if (e.format !== Kn || this.format !== Kn)
            console.error("Both LUTs must be RGBA textures");
        else {
            const o = t.data
              , a = n.data
              , c = i
              , h = c ** 2
              , d = c - 1;
            for (let l = 0, f = c ** 3; l < f; ++l) {
                const p = l * 4
                  , g = o[p + 0] * d
                  , y = o[p + 1] * d
                  , v = o[p + 2] * d
                  , _ = Math.round(g + y * c + v * h) * 4;
                o[p + 0] = a[_ + 0],
                o[p + 1] = a[_ + 1],
                o[p + 2] = a[_ + 2]
            }
            this.needsUpdate = !0
        }
        return this
    }
    convertToUint8() {
        if (this.type === wn) {
            const e = this.image.data
              , t = new Uint8Array(e.length);
            for (let n = 0, i = e.length; n < i; ++n)
                t[n] = e[n] * 255 + .5;
            this.image.data = t,
            this.type = Vn,
            this.needsUpdate = !0
        }
        return this
    }
    convertToFloat() {
        if (this.type === Vn) {
            const e = this.image.data
              , t = new Float32Array(e.length);
            for (let n = 0, i = e.length; n < i; ++n)
                t[n] = e[n] / 255;
            this.image.data = t,
            this.type = wn,
            this.needsUpdate = !0
        }
        return this
    }
    convertToRGBA() {
        return console.warn("LookupTexture", "convertToRGBA() is deprecated, LUTs are now RGBA by default"),
        this
    }
    convertLinearToSRGB() {
        const e = this.image.data;
        if (this.type === wn) {
            for (let t = 0, n = e.length; t < n; t += 4)
                tT.fromArray(e, t).convertLinearToSRGB().toArray(e, t);
            yr(this, On),
            this.needsUpdate = !0
        } else
            console.error("Color space conversion requires FloatType data");
        return this
    }
    convertSRGBToLinear() {
        const e = this.image.data;
        if (this.type === wn) {
            for (let t = 0, n = e.length; t < n; t += 4)
                tT.fromArray(e, t).convertSRGBToLinear().toArray(e, t);
            yr(this, pl),
            this.needsUpdate = !0
        } else
            console.error("Color space conversion requires FloatType data");
        return this
    }
    toDataTexture() {
        const e = this.image.width
          , t = this.image.height * this.image.depth
          , n = new Xb(this.image.data,e,t);
        return n.name = this.name,
        n.type = this.type,
        n.format = this.format,
        n.minFilter = Ot,
        n.magFilter = Ot,
        n.wrapS = this.wrapS,
        n.wrapT = this.wrapT,
        n.generateMipmaps = !1,
        n.needsUpdate = !0,
        fm(this, n),
        n
    }
    static from(e) {
        const t = e.image
          , {width: n, height: i} = t
          , s = Math.min(n, i);
        let o;
        if (t instanceof Image) {
            const h = F4.from(t).data;
            if (n > i) {
                o = new Uint8Array(h.length);
                for (let d = 0; d < s; ++d)
                    for (let l = 0; l < s; ++l)
                        for (let f = 0; f < s; ++f) {
                            const p = (f + d * s + l * s * s) * 4
                              , g = (f + l * s + d * s * s) * 4;
                            o[g + 0] = h[p + 0],
                            o[g + 1] = h[p + 1],
                            o[g + 2] = h[p + 2],
                            o[g + 3] = h[p + 3]
                        }
            } else
                o = new Uint8Array(h.buffer)
        } else
            o = t.data.slice();
        const a = new Fh(o,s);
        return a.type = e.type,
        a.name = e.name,
        fm(e, a),
        a
    }
    static createNeutral(e) {
        const t = new Float32Array(e ** 3 * 4)
          , n = e ** 2
          , i = 1 / (e - 1);
        for (let o = 0; o < e; ++o)
            for (let a = 0; a < e; ++a)
                for (let c = 0; c < e; ++c) {
                    const h = (o + a * e + c * n) * 4;
                    t[h + 0] = o * i,
                    t[h + 1] = a * i,
                    t[h + 2] = c * i,
                    t[h + 3] = 1
                }
        const s = new Fh(t,e);
        return s.name = "neutral",
        s
    }
}
  , k4 = `uniform vec3 scale;uniform vec3 offset;
#ifdef CUSTOM_INPUT_DOMAIN
uniform vec3 domainMin;uniform vec3 domainMax;
#endif
#ifdef LUT_3D
#ifdef LUT_PRECISION_HIGH
#ifdef GL_FRAGMENT_PRECISION_HIGH
uniform highp sampler3D lut;
#else
uniform mediump sampler3D lut;
#endif
#else
uniform lowp sampler3D lut;
#endif
vec4 applyLUT(const in vec3 rgb){
#ifdef TETRAHEDRAL_INTERPOLATION
vec3 p=floor(rgb);vec3 f=rgb-p;vec3 v1=(p+0.5)*LUT_TEXEL_WIDTH;vec3 v4=(p+1.5)*LUT_TEXEL_WIDTH;vec3 v2,v3;vec3 frac;if(f.r>=f.g){if(f.g>f.b){frac=f.rgb;v2=vec3(v4.x,v1.y,v1.z);v3=vec3(v4.x,v4.y,v1.z);}else if(f.r>=f.b){frac=f.rbg;v2=vec3(v4.x,v1.y,v1.z);v3=vec3(v4.x,v1.y,v4.z);}else{frac=f.brg;v2=vec3(v1.x,v1.y,v4.z);v3=vec3(v4.x,v1.y,v4.z);}}else{if(f.b>f.g){frac=f.bgr;v2=vec3(v1.x,v1.y,v4.z);v3=vec3(v1.x,v4.y,v4.z);}else if(f.r>=f.b){frac=f.grb;v2=vec3(v1.x,v4.y,v1.z);v3=vec3(v4.x,v4.y,v1.z);}else{frac=f.gbr;v2=vec3(v1.x,v4.y,v1.z);v3=vec3(v1.x,v4.y,v4.z);}}vec4 n1=texture(lut,v1);vec4 n2=texture(lut,v2);vec4 n3=texture(lut,v3);vec4 n4=texture(lut,v4);vec4 weights=vec4(1.0-frac.x,frac.x-frac.y,frac.y-frac.z,frac.z);vec4 result=weights*mat4(vec4(n1.r,n2.r,n3.r,n4.r),vec4(n1.g,n2.g,n3.g,n4.g),vec4(n1.b,n2.b,n3.b,n4.b),vec4(1.0));return vec4(result.rgb,1.0);
#else
return texture(lut,rgb);
#endif
}
#else
#ifdef LUT_PRECISION_HIGH
#ifdef GL_FRAGMENT_PRECISION_HIGH
uniform highp sampler2D lut;
#else
uniform mediump sampler2D lut;
#endif
#else
uniform lowp sampler2D lut;
#endif
vec4 applyLUT(const in vec3 rgb){float slice=rgb.b*LUT_SIZE;float slice0=floor(slice);float interp=slice-slice0;float centeredInterp=interp-0.5;float slice1=slice0+sign(centeredInterp);
#ifdef LUT_STRIP_HORIZONTAL
float xOffset=clamp(rgb.r*LUT_TEXEL_HEIGHT,LUT_TEXEL_WIDTH*0.5,LUT_TEXEL_HEIGHT-LUT_TEXEL_WIDTH*0.5);vec2 uv0=vec2(slice0*LUT_TEXEL_HEIGHT+xOffset,rgb.g);vec2 uv1=vec2(slice1*LUT_TEXEL_HEIGHT+xOffset,rgb.g);
#else
float yOffset=clamp(rgb.g*LUT_TEXEL_WIDTH,LUT_TEXEL_HEIGHT*0.5,LUT_TEXEL_WIDTH-LUT_TEXEL_HEIGHT*0.5);vec2 uv0=vec2(rgb.r,slice0*LUT_TEXEL_WIDTH+yOffset);vec2 uv1=vec2(rgb.r,slice1*LUT_TEXEL_WIDTH+yOffset);
#endif
vec4 sample0=texture2D(lut,uv0);vec4 sample1=texture2D(lut,uv1);return mix(sample0,sample1,abs(centeredInterp));}
#endif
void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec3 c=inputColor.rgb;
#ifdef CUSTOM_INPUT_DOMAIN
if(c.r>=domainMin.r&&c.g>=domainMin.g&&c.b>=domainMin.b&&c.r<=domainMax.r&&c.g<=domainMax.g&&c.b<=domainMax.b){c=applyLUT(scale*c+offset).rgb;}else{c=inputColor.rgb;}
#else
#if !defined(LUT_3D) || defined(TETRAHEDRAL_INTERPOLATION)
c=clamp(c,0.0,1.0);
#endif
c=applyLUT(scale*c+offset).rgb;
#endif
outputColor=vec4(c,inputColor.a);}`
  , z4 = class extends bS {
    constructor(r, {blendFunction: e=gt.SRC, tetrahedralInterpolation: t=!1, inputEncoding: n=Dr, inputColorSpace: i}={}) {
        super("LUT3DEffect", k4, {
            blendFunction: e,
            uniforms: new Map([["lut", new bt(null)], ["scale", new bt(new k)], ["offset", new bt(new k)], ["domainMin", new bt(null)], ["domainMax", new bt(null)]])
        }),
        this.tetrahedralInterpolation = t,
        this.inputColorSpace = i || yS.get(n),
        this.lut = r
    }
    get inputEncoding() {
        return this.inputColorSpace
    }
    set inputEncoding(r) {
        this.inputColorSpace = r
    }
    getInputEncoding() {
        return this.inputColorSpace
    }
    setInputEncoding(r) {
        this.inputColorSpace = r
    }
    getOutputEncoding() {
        return this.outputColorSpace
    }
    get lut() {
        return this.uniforms.get("lut").value
    }
    set lut(r) {
        const e = this.defines
          , t = this.uniforms;
        if (this.lut !== r && (t.get("lut").value = r,
        r !== null)) {
            const n = r.image
              , i = this.tetrahedralInterpolation;
            if (e.clear(),
            e.set("LUT_SIZE", Math.min(n.width, n.height).toFixed(16)),
            e.set("LUT_TEXEL_WIDTH", (1 / n.width).toFixed(16)),
            e.set("LUT_TEXEL_HEIGHT", (1 / n.height).toFixed(16)),
            t.get("domainMin").value = null,
            t.get("domainMax").value = null,
            (r.type === wn || r.type === Ur) && e.set("LUT_PRECISION_HIGH", "1"),
            n.width > n.height ? e.set("LUT_STRIP_HORIZONTAL", "1") : r instanceof Tc && e.set("LUT_3D", "1"),
            r instanceof MS) {
                const s = r.domainMin
                  , o = r.domainMax;
                (s.x !== 0 || s.y !== 0 || s.z !== 0 || o.x !== 1 || o.y !== 1 || o.z !== 1) && (e.set("CUSTOM_INPUT_DOMAIN", "1"),
                t.get("domainMin").value = s.clone(),
                t.get("domainMax").value = o.clone())
            }
            this.tetrahedralInterpolation = i
        }
    }
    getLUT() {
        return this.lut
    }
    setLUT(r) {
        this.lut = r
    }
    updateScaleOffset() {
        const r = this.lut;
        if (r !== null) {
            const e = Math.min(r.image.width, r.image.height)
              , t = this.uniforms.get("scale").value
              , n = this.uniforms.get("offset").value;
            if (this.tetrahedralInterpolation && r instanceof Tc)
                if (this.defines.has("CUSTOM_INPUT_DOMAIN")) {
                    const i = r.domainMax.clone().sub(r.domainMin);
                    t.setScalar(e - 1).divide(i),
                    n.copy(r.domainMin).negate().multiply(t)
                } else
                    t.setScalar(e - 1),
                    n.setScalar(0);
            else if (this.defines.has("CUSTOM_INPUT_DOMAIN")) {
                const i = r.domainMax.clone().sub(r.domainMin).multiplyScalar(e);
                t.setScalar(e - 1).divide(i),
                n.copy(r.domainMin).negate().multiply(t).addScalar(1 / (2 * e))
            } else
                t.setScalar((e - 1) / e),
                n.setScalar(1 / (2 * e))
        }
    }
    configureTetrahedralInterpolation() {
        const r = this.lut;
        r !== null && (r.minFilter = Ot,
        r.magFilter = Ot,
        this.tetrahedralInterpolation && (r instanceof Tc ? (r.minFilter = Jt,
        r.magFilter = Jt) : console.warn("Tetrahedral interpolation requires a 3D texture")),
        r.source === void 0 && (r.needsUpdate = !0))
    }
    get tetrahedralInterpolation() {
        return this.defines.has("TETRAHEDRAL_INTERPOLATION")
    }
    set tetrahedralInterpolation(r) {
        r ? this.defines.set("TETRAHEDRAL_INTERPOLATION", "1") : this.defines.delete("TETRAHEDRAL_INTERPOLATION"),
        this.configureTetrahedralInterpolation(),
        this.updateScaleOffset(),
        this.setChanged()
    }
    setTetrahedralInterpolationEnabled(r) {
        this.tetrahedralInterpolation = r
    }
}
;
class H4 {
    constructor() {
        this._tl = new Map,
        this._init()
    }
    _init() {
        Object.keys(_l).forEach(e=>{
            this._create(_l[e], Qt.timeline({
                paused: !0
            }))
        }
        )
    }
    _create(e, t) {
        this._tl.set(e, t)
    }
    get(e) {
        return this._tl.get(e)
    }
}
const _l = {
    INTRO_ENTER: "INTRO:ENTER",
    INTRO_HOLD: "INTRO:HOLD"
}
  , af = new H4;
var V4 = Symbol.for("preact-signals");
function ig() {
    if (Za > 1)
        Za--;
    else {
        for (var r, e = !1; Mc !== void 0; ) {
            var t = Mc;
            for (Mc = void 0,
            l_++; t !== void 0; ) {
                var n = t.o;
                if (t.o = void 0,
                t.f &= -3,
                !(8 & t.f) && ES(t))
                    try {
                        t.c()
                    } catch (i) {
                        e || (r = i,
                        e = !0)
                    }
                t = n
            }
        }
        if (l_ = 0,
        Za--,
        e)
            throw r
    }
}
var Ht = void 0
  , Mc = void 0
  , Za = 0
  , l_ = 0
  , lf = 0;
function wS(r) {
    if (Ht !== void 0) {
        var e = r.n;
        if (e === void 0 || e.t !== Ht)
            return e = {
                i: 0,
                S: r,
                p: Ht.s,
                n: void 0,
                t: Ht,
                e: void 0,
                x: void 0,
                r: e
            },
            Ht.s !== void 0 && (Ht.s.n = e),
            Ht.s = e,
            r.n = e,
            32 & Ht.f && r.S(e),
            e;
        if (e.i === -1)
            return e.i = 0,
            e.n !== void 0 && (e.n.p = e.p,
            e.p !== void 0 && (e.p.n = e.n),
            e.p = Ht.s,
            e.n = void 0,
            Ht.s.n = e,
            Ht.s = e),
            e
    }
}
function mi(r) {
    this.v = r,
    this.i = 0,
    this.n = void 0,
    this.t = void 0
}
mi.prototype.brand = V4;
mi.prototype.h = function() {
    return !0
}
;
mi.prototype.S = function(r) {
    this.t !== r && r.e === void 0 && (r.x = this.t,
    this.t !== void 0 && (this.t.e = r),
    this.t = r)
}
;
mi.prototype.U = function(r) {
    if (this.t !== void 0) {
        var e = r.e
          , t = r.x;
        e !== void 0 && (e.x = t,
        r.e = void 0),
        t !== void 0 && (t.e = e,
        r.x = void 0),
        r === this.t && (this.t = t)
    }
}
;
mi.prototype.subscribe = function(r) {
    var e = this;
    return jc(function() {
        var t = e.value
          , n = Ht;
        Ht = void 0;
        try {
            r(t)
        } finally {
            Ht = n
        }
    })
}
;
mi.prototype.valueOf = function() {
    return this.value
}
;
mi.prototype.toString = function() {
    return this.value + ""
}
;
mi.prototype.toJSON = function() {
    return this.value
}
;
mi.prototype.peek = function() {
    var r = Ht;
    Ht = void 0;
    try {
        return this.value
    } finally {
        Ht = r
    }
}
;
Object.defineProperty(mi.prototype, "value", {
    get: function() {
        var r = wS(this);
        return r !== void 0 && (r.i = this.i),
        this.v
    },
    set: function(r) {
        if (r !== this.v) {
            if (l_ > 100)
                throw new Error("Cycle detected");
            this.v = r,
            this.i++,
            lf++,
            Za++;
            try {
                for (var e = this.t; e !== void 0; e = e.x)
                    e.t.N()
            } finally {
                ig()
            }
        }
    }
});
function nT(r) {
    return new mi(r)
}
function ES(r) {
    for (var e = r.s; e !== void 0; e = e.n)
        if (e.S.i !== e.i || !e.S.h() || e.S.i !== e.i)
            return !0;
    return !1
}
function AS(r) {
    for (var e = r.s; e !== void 0; e = e.n) {
        var t = e.S.n;
        if (t !== void 0 && (e.r = t),
        e.S.n = e,
        e.i = -1,
        e.n === void 0) {
            r.s = e;
            break
        }
    }
}
function PS(r) {
    for (var e = r.s, t = void 0; e !== void 0; ) {
        var n = e.p;
        e.i === -1 ? (e.S.U(e),
        n !== void 0 && (n.n = e.n),
        e.n !== void 0 && (e.n.p = n)) : t = e,
        e.S.n = e.r,
        e.r !== void 0 && (e.r = void 0),
        e = n
    }
    r.s = t
}
function Gc(r) {
    mi.call(this, void 0),
    this.x = r,
    this.s = void 0,
    this.g = lf - 1,
    this.f = 4
}
(Gc.prototype = new mi).h = function() {
    if (this.f &= -3,
    1 & this.f)
        return !1;
    if ((36 & this.f) == 32 || (this.f &= -5,
    this.g === lf))
        return !0;
    if (this.g = lf,
    this.f |= 1,
    this.i > 0 && !ES(this))
        return this.f &= -2,
        !0;
    var r = Ht;
    try {
        AS(this),
        Ht = this;
        var e = this.x();
        (16 & this.f || this.v !== e || this.i === 0) && (this.v = e,
        this.f &= -17,
        this.i++)
    } catch (t) {
        this.v = t,
        this.f |= 16,
        this.i++
    }
    return Ht = r,
    PS(this),
    this.f &= -2,
    !0
}
;
Gc.prototype.S = function(r) {
    if (this.t === void 0) {
        this.f |= 36;
        for (var e = this.s; e !== void 0; e = e.n)
            e.S.S(e)
    }
    mi.prototype.S.call(this, r)
}
;
Gc.prototype.U = function(r) {
    if (this.t !== void 0 && (mi.prototype.U.call(this, r),
    this.t === void 0)) {
        this.f &= -33;
        for (var e = this.s; e !== void 0; e = e.n)
            e.S.U(e)
    }
}
;
Gc.prototype.N = function() {
    if (!(2 & this.f)) {
        this.f |= 6;
        for (var r = this.t; r !== void 0; r = r.x)
            r.t.N()
    }
}
;
Object.defineProperty(Gc.prototype, "value", {
    get: function() {
        if (1 & this.f)
            throw new Error("Cycle detected");
        var r = wS(this);
        if (this.h(),
        r !== void 0 && (r.i = this.i),
        16 & this.f)
            throw this.v;
        return this.v
    }
});
function RS(r) {
    var e = r.u;
    if (r.u = void 0,
    typeof e == "function") {
        Za++;
        var t = Ht;
        Ht = void 0;
        try {
            e()
        } catch (n) {
            throw r.f &= -2,
            r.f |= 8,
            rg(r),
            n
        } finally {
            Ht = t,
            ig()
        }
    }
}
function rg(r) {
    for (var e = r.s; e !== void 0; e = e.n)
        e.S.U(e);
    r.x = void 0,
    r.s = void 0,
    RS(r)
}
function G4(r) {
    if (Ht !== this)
        throw new Error("Out-of-order effect");
    PS(this),
    Ht = r,
    this.f &= -2,
    8 & this.f && rg(this),
    ig()
}
function Wc(r) {
    this.x = r,
    this.u = void 0,
    this.s = void 0,
    this.o = void 0,
    this.f = 32
}
Wc.prototype.c = function() {
    var r = this.S();
    try {
        if (8 & this.f || this.x === void 0)
            return;
        var e = this.x();
        typeof e == "function" && (this.u = e)
    } finally {
        r()
    }
}
;
Wc.prototype.S = function() {
    if (1 & this.f)
        throw new Error("Cycle detected");
    this.f |= 1,
    this.f &= -9,
    RS(this),
    AS(this),
    Za++;
    var r = Ht;
    return Ht = this,
    G4.bind(this, r)
}
;
Wc.prototype.N = function() {
    2 & this.f || (this.f |= 2,
    this.o = Mc,
    Mc = this)
}
;
Wc.prototype.d = function() {
    this.f |= 8,
    1 & this.f || rg(this)
}
;
function jc(r) {
    var e = new Wc(r);
    try {
        e.c()
    } catch (t) {
        throw e.d(),
        t
    }
    return e.d.bind(e)
}
const ls = {
    isSidebarActive: nT(!1),
    isIntroDone: nT(!1)
};
var W4 = `varying vec2 vUv;

void main() {
    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    vUv= uv;
}`
  , j4 = `uniform sampler2D inputBuffer;
uniform sampler2D uInput;
uniform sampler2D uIceNormalTxt;
uniform sampler2D uIceTxt;
uniform sampler2D uIceDensityTxt;
uniform sampler2D uMouseTxt;
uniform sampler2D uNoiseTxt;
uniform sampler2D uLogoNormals;
uniform sampler2D uLogoMask;
uniform sampler2D uRadial;
uniform vec3 uLogoSpecs;
uniform vec3 uBlendColor;
uniform vec2 uResolution;
uniform vec2 uMousePosition;
uniform float uLogoDisplacement;
uniform float uLogoBrightness;
uniform float uTime;
uniform float uKonProg;
uniform float uSlowMoProgress;
uniform float uBarrelStrength;
uniform float uSceneProgress;
uniform float uMaskProgress;
uniform float uMaskProgress2;
uniform float uSidebarProgress;
uniform bool uIsMobile;

varying vec2 vUv;

float blendScreen(float base, float blend) {
	return 1.0-((1.0-base)*(1.0-blend));
}

vec3 blendScreen(vec3 base, vec3 blend) {
	return vec3(blendScreen(base.r,blend.r),blendScreen(base.g,blend.g),blendScreen(base.b,blend.b));
}

vec3 blendScreen(vec3 base, vec3 blend, float opacity) {
	return (blendScreen(base, blend) * opacity + base * (1.0 - opacity));
}

float sineInOut(float t) {
  return -0.5 * (cos(3.14 * t) - 1.0);
}

float sineOut(float t) {
  return sin(t * 3.14 * 0.5);
}

vec2 barrelDistortion(vec2 coord, float amt) {
	vec2 cc = coord - 0.5;
	float dist = dot(cc, cc);
	return coord + cc * dist * amt;
}

float sat( float t )
{
	return clamp( t, 0.0, 1.0 );
}

float linterp( float t ) {
	return sat( 1.0 - abs( 2.0*t - 1.0 ) );
}

float remap( float t, float a, float b ) {
	return sat( (t - a) / (b - a) );
}

float invLerp(float from, float to, float value){
  return (value - from) / (to - from);
}

float map(float value, float min1, float max1, float min2, float max2) {
  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);
}

vec4 spectrum_offset( float t ) {
	vec4 ret;
	float lo = step(t,0.5);
	float hi = 1.0-lo;
	float w = linterp( remap( t, 1.0/6.0, 5.0/6.0 ) );
	ret = vec4(lo,1.0,hi, 1.) * vec4(1.0-w, w, 1.0-w, 1.);

	return pow( ret, vec4(1.0/2.2) );
}

const float max_distort = 2.2;
const int num_iter = 6;
const float reci_num_iter_f = 1.0 / float(num_iter);

void main(){
  
  vec2 uv = vUv;
  vec4 final = vec4(0.0);

  
  bool isKonami = uKonProg > 0.0 && uKonProg < 1.0;

  
  float ratioxy = uResolution.x / uResolution.y;
  float ratioyx = uResolution.y / uResolution.x;
  float ratio = uIsMobile ? (ratioxy) * 1.2 : 1.1;

  
  vec2 suv = vUv;
  suv -= 0.5;
  suv *= vec2(1.0, ratioyx);
  suv += 0.5;

  
  float dist = distance(suv, vec2(0.5));
  dist = clamp(dist, 0.0, 1.0) * ratio;
  float dist2 = dist;

  float origDist = dist;
  float konamiDist = dist;
  float sProg = sineOut(uSlowMoProgress * 1.25);
  dist = 1.0 - (smoothstep(0.0 + sProg, 0.2 + sProg, dist + 0.2));
  dist2 = 1.0 - (smoothstep(0.2 + sProg - 0.05, 0.6 + sProg - 0.05, dist2 + 0.6));
  

  
  vec4 sumcol1 = vec4(0.0);
  vec4 sumcol2 = vec4(0.0);
  vec4 sumw = vec4(0.0);

  
  float kDist = konamiDist;
  float konDist = 0.0;
  vec2 radDist = vec2(0.0);

  if( isKonami ){
    float konProg = (uKonProg * 1.25);
    float kDist2 = konamiDist;

    kDist = 1.0 - (smoothstep(0.0 + konProg, 0.2 + konProg, kDist + 0.2));
    kDist2 = 1.0 - (smoothstep(0.2 + konProg - 0.05, 0.6 + konProg - 0.05, kDist2 + 0.6));

    konDist = (kDist - kDist2) * konProg * konamiDist;
    radDist = texture2D(uRadial, vUv).rg;
  }

  
  float finalDist = (dist - dist2) * sProg * origDist;
  vec2 dir = normalize(vUv - vec2(0.5));
  vec2 swf = (-(finalDist) * 1.05) * dir;

  if(isKonami){
    swf = (-(finalDist) * 1.05 -(konDist) * 1.5) * dir;
  }
  swf *= 1.5;
  

  vec2 newUv = vUv;
  newUv -= vec2(0.5);
  newUv *= 1.0 - 0.4 * uSlowMoProgress;
  newUv += vec2(0.5);
  vec2 basicUv = newUv; 
  newUv += swf;

  if( isKonami ){
    basicUv += radDist * konDist * 4.0;
    newUv += radDist * konDist * 4.0;
  }

  for ( int i = 0; i < num_iter; ++i ) {
    float t = float(i) * reci_num_iter_f;
    vec4 w = spectrum_offset( t );
    sumw += w;
    sumcol1 += w * texture2D( uInput, barrelDistortion(newUv, -.6 * max_distort * t * uBarrelStrength *  uSlowMoProgress ) );
    sumcol2 += w * texture2D( uInput, barrelDistortion(basicUv, -.2 * max_distort * t * uBarrelStrength *  0.2 ) );
  }

  vec4 final1 = sumcol1 / sumw;
  vec4 final2 = sumcol2 / sumw;

  float slowMoInt = sat(smoothstep(0.0, 0.01, uSlowMoProgress));
  final = mix(final2, final1, slowMoInt);
  

  
  if(!(uMaskProgress2 >= 1.0 && uMaskProgress >= 1.0)) {
    float logoWidth = uLogoSpecs.z;
    float logoRatio = 0.4384;
    vec2 screenRatio = vec2(1.0, 1.0 / (ratioxy));
    vec2 lUv = (((vUv - 0.5) * vec2(logoWidth, logoWidth / logoRatio) * screenRatio) + 0.5) + uLogoSpecs.xy;

    vec4 logotTxt = texture2D(uLogoNormals, lUv);
    float logoMask = texture2D(uLogoMask, lUv).r;

    vec2 logoNorm = logotTxt.rg;
    vec2 logoNormCorr = (logotTxt.rg * 2.0) - 1.0;

    
    vec4 finalExperience = final;
    finalExperience.rgb = mix(vec3(0.0), finalExperience.rgb, uSceneProgress);

    
    vec2 ratioUv = vUv;
    ratioUv -= 0.5;
    ratioUv *= vec2(1.0, ratioyx);
    ratioUv = (ratioUv * 3.0) + 0.5;

    vec2 duv = vUv;
    duv -= 0.5;
    duv *= uIsMobile ? vec2(1.0, ratioyx) * 0.55 : vec2(1.0);
    duv += 0.5;

    float distFromCenter = distance(duv - 0.5, vec2(0.0));

    
    float borderMix = smoothstep(0.35, 0.75, 1.0 - distFromCenter);

    
    vec4 ice = texture2D(uIceTxt, ratioUv);
    float iceDensity = texture2D(uIceDensityTxt, ratioUv).r;
    vec4 iceN = texture2D(uIceNormalTxt, ratioUv);
    vec2 iceNorm = (iceN.rg * 2.0) - 1.0;
    vec4 mouse = texture2D(uMouseTxt, vUv);

    
    float mouseMask = smoothstep(0.0, 1.0, mouse.r) * 2.5 - (1.0 + iceDensity);
    mouseMask = clamp(smoothstep(0.0, 0.6, mouseMask) - 0.12, 0.0 , 1.0);

    
    vec4 finalIntro1 = texture2D(uInput, vUv + (iceNorm) * 0.15 * iceDensity * (1.0 - logoMask) + (logoNormCorr * 0.06 * iceNorm * 0.2 + logoNormCorr * uLogoDisplacement * (1.0 + iceNorm * 0.2)) * smoothstep(0.0, 0.2, logoMask));
    finalIntro1.rgb = mix(vec3(0.0), finalIntro1.rgb, uSceneProgress);

    
    vec3 icedColor = mix(
      ice.rgb * 0.2 + ice.rgb * 0.4 * (1.0 + finalIntro1.rgb * 30.0),
      ice.rgb * 0.6 + ice.rgb * 0.4 * (1.0 + finalIntro1.rgb * 1.0),
      borderMix
    );

    vec3 finalIntro1Center = finalIntro1.rgb * (1.0 + ice.rgb * 2.0 * ice.b * 6.0 ) * 0.4 * (1.0 - logoMask);
    finalIntro1Center = clamp(finalIntro1Center, 0.0, 1.0);
    finalIntro1Center -= 0.19;

    
    finalIntro1.rgb = mix(
      icedColor,
      finalIntro1Center,
      mix(0.0, 1.0 - (iceDensity * 0.1), borderMix * 0.7 - 0.1 * logoMask)
    );

    
    finalIntro1.rgb += smoothstep(0.0, 0.99, logoMask) * (0.05 + uLogoBrightness * pow(max(0.0, dot(normalize(logotTxt.rgb * 2.0 - 1.0), normalize(vec3(uMousePosition.x, 1.0, 0.3)))), 3.0) * 2.0);
    final = finalIntro1;

    
    final.rgb = blendScreen(final.rgb, uBlendColor, 0.64);
    final.rgb = clamp(final.rgb - 0.05  * (1.0 - borderMix), vec3(0.0), vec3(1.0));

    
    vec3 darkFinal = final.rgb;
    darkFinal.rgb -= 0.12 * smoothstep(0.35,0.45, 1.0 - distFromCenter);
    darkFinal.rgb = clamp(darkFinal.rgb, vec3(0.0), vec3(1.0));

    
    float brightnessTest = dot(final.rgb, vec3(0.299, 0.587, 0.114));
    final.rgb -= 0.2 * smoothstep(0.35,0.45, 1.0 - distFromCenter);
    final.r = final.r < 0.0 ? 5.0 + smoothstep(-0.9, 0.0, final.r) : final.r;
    final.g = final.g < 0.0 ? 0.7 : final.g;
    final.b = final.b < 0.0 ? 0.7 : final.b;

    
    float brigh2 = smoothstep(0.15, 0.35, brightnessTest);
    float brigh3 = smoothstep(0.2, 0.45, brightnessTest);
    float brigh4 = smoothstep(0.65, 0.80, brightnessTest);
    float brigh = clamp(brigh2 - brigh4 - brigh3, 0.0 ,1.0);
    brigh = smoothstep(0.4, 0.45, brigh);

    vec3 rr = vec3(1.0, 0.0, 0.0) * 4.7;
    vec3 gg = vec3(0.0, 0.7, 0.0) * 1.0;
    vec3 finalFlamesScene = rr * brigh2 + gg * brigh3 + final.b * brigh4;

    finalFlamesScene = (final.rgb * 0.8) + finalFlamesScene;
    final.rgb = mix(darkFinal, final.rgb, mouseMask);

    
    float threshold = 0.06;
    float maskShiftFactor = iceDensity * 0.1 + brigh * 0.1;

    
    float flamesMask = texture2D(uNoiseTxt, ratioUv * 0.12 + vec2(0.0, uTime * 0.01)).r * 1.3 - (maskShiftFactor);
    flamesMask = smoothstep(0.0, 0.6, flamesMask);

    float r1 = uMaskProgress * ( 1.0 + threshold * 2.0 ) - threshold;
		float mixf2 = 1.0 - clamp( ( flamesMask - r1 ) * ( 1.0 / threshold ), 0.0, 1.0 );
    final.rgb = mix(final.rgb, finalFlamesScene, mixf2);

    
    float sceneMask = texture2D(uNoiseTxt, ratioUv * 0.12 + vec2(0.0, uTime * 0.01 + 0.1)).r * 1.3 - (maskShiftFactor);
    sceneMask = smoothstep(0.0, 0.6, sceneMask);

    float r2 = uMaskProgress2 * ( 1.0 + threshold * 2.0 ) - threshold;
		float mixf = 1.0 - clamp( ( sceneMask - r2 ) * ( 1.0 / threshold ), 0.0, 1.0 );
    final.rgb = mix(final.rgb, finalExperience.rgb, mixf);
  }

  if(uSidebarProgress > 0.0) {
    vec2 ratioUv = vUv;
    ratioUv -= 0.5;
    ratioUv *= vec2(1.0, ratioyx);
    ratioUv = (ratioUv * (uIsMobile ? 3.0 : 5.0)) + 0.5;

    vec4 ice = texture2D(uIceTxt, ratioUv);
    float iceDensity = texture2D(uIceDensityTxt, ratioUv).r;
    vec4 iceN = texture2D(uIceNormalTxt, ratioUv);
    vec2 iceNorm = (iceN.rg * 2.0) - 1.0;
    vec4 icedSidebar = texture2D(uInput, vUv + (iceNorm) * 0.25 * iceDensity);

    vec2 circleUv = vUv;
    circleUv -= vec2(0.0, 1.0);
    circleUv.x *= ratioxy;
    float circle = 1.0 - clamp(dot(circleUv, circleUv) * 1.1, 0.0, 1.0);
    float ic = 1.0 - smoothstep(0.0, 0.4, circle);

    float lights = pow(max(0.0, dot(normalize(iceN.rgb * 2.0 - 1.0), normalize(vec3(uMousePosition.x, 1.0, 0.3)))), 1.8);
    lights = smoothstep(0.2, 0.5, lights) ;

    float noiseMask = texture2D(uNoiseTxt, ratioUv * 0.12 + vec2(uTime * 0.006, uTime * 0.01)).r * 1.3 ;
    noiseMask = smoothstep(0.2, 0.4, noiseMask);

    circle = clamp(((circle + 0.4) - (iceDensity * 0.3) - (noiseMask * 0.2) - (1.0 - uSidebarProgress)), 0.0, 1.0);
    circle = smoothstep(0.4, 0.55, circle);

    icedSidebar.rgb = icedSidebar.rgb * (1.0 + ice.rgb * 2.0 * ice.b * 8.0 ) * (0.18 + ic * 0.2);
    icedSidebar.rgb *= 1.0 + ((lights * 2.4));

    
    vec4 mouse = texture2D(uMouseTxt, vUv);
    float mouseMask = smoothstep(0.0, 1.0, mouse.r) * 2.5 - (1.0 + iceDensity);
    mouseMask = clamp(smoothstep(0.0, 0.6, mouseMask) - 0.12, 0.0 , 1.0);
    float mixFactor = clamp((1.0 - circle) - (mouseMask * uSidebarProgress) * 0.33, 0.0, 1.0);

    final.rgb = mix(icedSidebar.rgb, final.rgb, mixFactor);
  }

  
  final.rgb = blendScreen(final.rgb, uBlendColor, 0.64);

  
  float hf = map(clamp(uSlowMoProgress, 0.0, 0.4), 0.0, 0.4, 80.0, 25.0);
  final.rgb *= 1.0 + ((finalDist * hf * 0.8) * vec3(1.0, 1.0, 0.85)); 

  if(isKonami) {
    float hf2 = map(clamp(uKonProg, 0.0, 0.4), 0.0, 0.4, 80.0, 25.0);
    final.rgb *= 1.0 + ((konDist * hf2 * 0.45) * vec3(1.0, 1.0, 0.85)); 
  }

  
  gl_FragColor = final;

  #include <colorspace_fragment>
}`
  , X4 = `varying vec2 vUv;

void main() {
  gl_Position = vec4(position.xy, 1.0, 1.0);
  vUv = uv;
}`
  , q4 = `uniform sampler2D uPrev;
uniform sampler2D uNoiseTxt;
uniform vec2 uMouse;
uniform vec2 uResolution;
uniform float uProgress;
uniform float uTime;

varying vec2 vUv;

float circle(vec2 uv, vec2 pos, vec2 res, float radius, float scale, float s1, float s2) {
    uv -= pos;
    uv.x *= res.x / res.y;
    return 1. - smoothstep(s1, s2, dot(uv, uv) * radius / scale);
}
void main(){
  float n = texture2D(uNoiseTxt, (vUv * 1.0) + vec2(0.0, uTime)).r;
  vec4 p = texture2D(uPrev, vUv + vec2(0.0, n * 0.01));
  n = smoothstep(0.0, 0.3, n);

  float radius = 50.0;
  float scale = 17.0 * uProgress;
  float circ = circle(vUv, (uMouse + 1.0) * 0.5, uResolution, radius , scale, 0.0, 0.4);
  circ = pow(circ, 1.2);

  float factor = 1.0 - step(0.9, p.r) * 0.01;
  float final = (p.r * 1.0) - 0.0045;
  final += clamp(circ * 0.10 - 0.092 * n * smoothstep(0.4, 1.0, final), 0.0, 1.0);
  final = clamp(final, 0.0, 0.96);

  gl_FragColor = vec4(final, 0.0, 0.0, 1.0);
}`;
const K4 = new Ke;
class Y4 {
    constructor() {
        this._scene = ce.scene,
        this._shaderMaterial = void 0,
        this._interpolators = new Map,
        this._mouseRtt = void 0,
        this._mouseMesh = void 0,
        this._isMouseMoving = !1,
        this._sceneProgress = {
            value: 0
        },
        this._maskProgress = {
            value: 0
        },
        this._maskProgress2 = {
            value: 1
        },
        this._sidebarProgress = {
            value: 0
        },
        this._logoSizeInterpolant = new Jh(new Float32Array([500, 1400, 2e3]),new Float32Array([.93, 1.2, 1.6]),1),
        this._init(),
        this._initEvents(),
        this._addTheatre()
    }
    get renderPass() {
        return this._renderPass
    }
    get depthPass() {
        return this._depthPass
    }
    get outputTexture() {
        return this._finalCopyPass.texture
    }
    _init() {
        this._initMouseTrail();
        const e = new QH(ce.gl,{
            depthBuffer: !0,
            stencilBuffer: !1,
            multisampling: 0,
            frameBufferType: Ur
        });
        e.autoRenderToScreen = !0;
        const t = new vn(1,1,{
            type: Ur
        });
        this._mainFbo = t;
        const n = dn("lut");
        n.colorSpace = Ni,
        n.needsUpdate = !0;
        const i = new z4(MS.from(n))
          , s = dn("radial")
          , o = dn("ice-normal-4");
        o.colorSpace = gn;
        const a = dn("ice-diffuse-3");
        a.colorSpace = gn;
        const c = dn("ice-density-4")
          , h = dn("fog-noise");
        o.wrapS = o.wrapT = ii,
        a.wrapS = a.wrapT = ii,
        c.wrapS = c.wrapT = ii,
        h.wrapS = h.wrapT = ii;
        const d = dn("logo");
        d.colorSpace = gn;
        const l = dn("logo2")
          , f = new Vt({
            vertexShader: W4,
            fragmentShader: j4,
            uniforms: {
                inputBuffer: {
                    value: null
                },
                uInput: {
                    value: t.texture
                },
                uTime: {
                    value: 0
                },
                uIsMobile: {
                    value: ce.size.isMobile
                },
                uSlowMoProgress: {
                    value: 0
                },
                uBarrelStrength: {
                    value: -3.5
                },
                uResolution: {
                    value: [ce.size.width, ce.size.height]
                },
                uBlendColor: {
                    value: K4.clone().set("#0c1024").convertLinearToSRGB()
                },
                uIceNormalTxt: {
                    value: o
                },
                uIceTxt: {
                    value: a
                },
                uIceDensityTxt: {
                    value: c
                },
                uMouseTxt: {
                    value: this._mouseRtt.read.texture
                },
                uNoiseTxt: {
                    value: h
                },
                uSceneProgress: this._sceneProgress,
                uMaskProgress: this._maskProgress,
                uMaskProgress2: this._maskProgress2,
                uMousePosition: {
                    value: ce.mouse.smooth
                },
                uLogoSpecs: {
                    value: [0, -.15, 1.2]
                },
                uLogoNormals: {
                    value: d
                },
                uLogoMask: {
                    value: l
                },
                uLogoDisplacement: {
                    value: .34
                },
                uLogoBrightness: {
                    value: .63
                },
                uSidebarProgress: this._sidebarProgress,
                uRadial: {
                    value: s
                },
                uKonProg: {
                    value: 0
                }
            }
        });
        this._shaderMaterial = f;
        const p = new $H(f)
          , g = new N4({
            mipmapBlur: !0,
            radius: .3,
            intensity: 3,
            levels: 6,
            luminanceSmoothing: .9,
            luminanceThreshold: 1.1
        })
          , y = new jH(ce.camera,g,i);
        y.fullscreenMaterial.encodeOutput = !1,
        this._bp = g,
        this._composer = e,
        this._shaderMaterial = f,
        e.addPass(p),
        e.addPass(y),
        this._initInterpolators(),
        this.resize()
    }
    _initEvents() {
        yt.on(xt.MOUSE_MOVE, ()=>{
            this._isMouseMoving = !0
        }
        ),
        yt.on(xt.INTRO_ENTERING, ()=>this._onIntroEntering(), 0),
        yt.on(xt.INTRO_ENTERED, ()=>this._onIntroEntered(), 0),
        yt.on(xt.KONAMI, ()=>this._onKonami()),
        jc(()=>{
            this._animateSidebar(ls.isSidebarActive.value)
        }
        )
    }
    _onIntroEntering() {
        const e = Qt.timeline()
          , {uniforms: t} = this._shaderMaterial;
        e.fromTo(t.uMaskProgress2, {
            value: 1
        }, {
            duration: 2.8,
            value: 0,
            ease: "power1.inOut"
        }, 0).fromTo(t.uSceneProgress, {
            value: 0
        }, {
            duration: 2.5,
            value: 1,
            ease: "power1.in"
        }, 1.2),
        e.timeScale(.8),
        af.get(_l.INTRO_ENTER).add(e, 0)
    }
    _onIntroEntered() {
        const e = Qt.timeline()
          , {uniforms: t} = this._shaderMaterial;
        e.to(t.uSceneProgress, {
            duration: 1.5,
            value: 1,
            ease: "power2.in"
        }, 0).to(t.uMaskProgress, {
            duration: 3,
            value: 1,
            ease: "power1.in"
        }, 0).to(t.uMaskProgress2, {
            duration: 3,
            value: 1,
            ease: "power2.in"
        }, .15),
        e.timeScale(1.6),
        af.get(_l.INTRO_HOLD).add(e, 0)
    }
    _onKonami() {
        const {uniforms: e} = this._shaderMaterial;
        Qt.to(e.uKonProg, {
            value: 1,
            duration: 2.3,
            ease: "power2.inOut"
        })
    }
    _animateSidebar(e) {
        const t = e ? "power1.out" : "power1.inOut";
        Qt.to(this._sidebarProgress, {
            duration: 2,
            value: e ? 1 : 0,
            ease: t
        })
    }
    _initMouseTrail() {
        const e = new vn(1,1,{
            depth: !1,
            stencil: !1
        });
        this._mouseRtt = {
            read: e,
            write: e.clone()
        };
        const t = new mn
          , n = new Float32Array([-1, -1, 3, -1, -1, 3])
          , i = new Float32Array([0, 0, 2, 0, 0, 2]);
        t.setAttribute("uv", new pt(i,2)),
        t.setAttribute("position", new pt(n,2));
        const s = new Vt({
            vertexShader: X4,
            fragmentShader: q4,
            uniforms: {
                uMouse: {
                    value: ce.mouse.smooth
                },
                uPrev: {
                    value: this._mouseRtt.read
                },
                uNoiseTxt: {
                    value: dn("fog-noise")
                },
                uResolution: {
                    value: [1, 1]
                },
                uProgress: {
                    value: 0
                },
                uTime: {
                    value: 0
                }
            }
        })
          , o = new en(t,s);
        this._mouseMesh = o
    }
    _initInterpolators() {
        const e = An.composer.responsive
          , t = e.map(i=>i.size);
        Object.keys(e[0]).filter(i=>!["size"].includes(i)).forEach(i=>{
            const s = e.map(a=>a[i])
              , o = new Jh(new Float32Array(t),new Float32Array(s),1);
            this._interpolators.set(i, o)
        }
        )
    }
    _addTheatre() {
        const t = Xi.getProject(sf.projectName, {
            state: hS
        }).sheet(sf.sheets.config)
          , n = this._bp;
        t.object("Composer", {
            radius: Xi.types.number(n.mipmapBlurPass.radius, {
                range: [0, 1],
                nudgeMultiplier: .01
            }),
            intensity: Xi.types.number(n.intensity, {
                range: [0, 10],
                nudgeMultiplier: .1
            }),
            levels: Xi.types.number(n.mipmapBlurPass.levels, {
                range: [0, 10],
                nudgeMultiplier: 1
            }),
            threshold: Xi.types.number(n.luminancePass.fullscreenMaterial.threshold, {
                range: [0, 4],
                nudgeMultiplier: .01
            }),
            smoothing: Xi.types.number(n.luminancePass.fullscreenMaterial.smoothing, {
                range: [0, 1],
                nudgeMultiplier: .01
            }),
            sceneProgress: Xi.types.number(this._shaderMaterial.uniforms.uSceneProgress.value, {
                range: [0, 1]
            }),
            maskProgress: Xi.types.number(this._shaderMaterial.uniforms.uMaskProgress.value, {
                range: [0, 1]
            }),
            maskProgress2: Xi.types.number(this._shaderMaterial.uniforms.uMaskProgress2.value, {
                range: [0, 1]
            }),
            logoDisplacement: Xi.types.number(this._shaderMaterial.uniforms.uLogoDisplacement.value, {
                range: [0, 5]
            }),
            logoBrightness: Xi.types.number(this._shaderMaterial.uniforms.uLogoBrightness.value, {
                range: [-5, 5]
            })
        }).onValuesChange(s=>{
            n.mipmapBlurPass.radius = s.radius,
            n.intensity = s.intensity,
            n.mipmapBlurPass.levels = s.levels,
            n.luminancePass.fullscreenMaterial.threshold = s.threshold,
            n.luminancePass.fullscreenMaterial.smoothing = s.smoothing,
            this._shaderMaterial.uniforms.uSceneProgress.value = s.sceneProgress,
            this._shaderMaterial.uniforms.uMaskProgress.value = s.maskProgress,
            this._shaderMaterial.uniforms.uMaskProgress2.value = s.maskProgress2,
            this._shaderMaterial.uniforms.uLogoDisplacement.value = s.logoDisplacement,
            this._shaderMaterial.uniforms.uLogoBrightness.value = s.logoBrightness
        }
        )
    }
    render() {
        const e = this._mouseRtt.write;
        this._mouseRtt.write = this._mouseRtt.read,
        this._mouseRtt.read = e,
        ce.gl.setRenderTarget(this._mouseRtt.read),
        ce.gl.render(this._mouseMesh, ce.camera),
        ce.gl.setRenderTarget(null),
        No(this._mouseMesh.material.uniforms.uProgress, "value", this._isMouseMoving ? 1 : 0, .35, ce.clock.delta, 1 / 0, tf),
        this._isMouseMoving = !1,
        this._shaderMaterial.uniforms.uTime.value = ce.time.elapsed,
        this._mouseMesh.material.uniforms.uTime.value = ce.time.elapsed,
        this._shaderMaterial.uniforms.uMouseTxt.value = this._mouseRtt.read.texture,
        this._mouseMesh.material.uniforms.uPrev.value = this._mouseRtt.read.texture,
        ce.gl.setRenderTarget(this._mainFbo),
        ce.gl.clear(),
        ce.gl.render(ce.scene, ce.camera),
        ce.gl.setRenderTarget(null),
        No(this._shaderMaterial.uniforms.uSlowMoProgress, "value", 1 - ce.time.scale, .35, ce.clock.delta, 1 / 0, tf),
        this._composer.render()
    }
    resize() {
        const {width: e, height: t} = ce.size
          , n = this._logoSizeInterpolant.evaluate(e)[0];
        this._shaderMaterial.uniforms.uIsMobile.value = ce.size.isMobile,
        this._shaderMaterial.uniforms.uResolution.value = [ce.size.width, ce.size.height],
        this._shaderMaterial.uniforms.uLogoSpecs.value[2] = n,
        this._mouseMesh.material.uniforms.uResolution.value = [ce.size.width, ce.size.height],
        this._mouseRtt.read.setSize(e * .1, t * .1),
        this._mouseRtt.write.setSize(e * .1, t * .1),
        this._bp.mipmapBlurPass.radius = this._interpolators.get("radius").evaluate(e)[0],
        this._bp.intensity = this._interpolators.get("intensity").evaluate(e)[0],
        this._bp.mipmapBlurPass.levels = Math.round(this._interpolators.get("levels").evaluate(e)[0]),
        this._bp.luminancePass.fullscreenMaterial.threshold = this._interpolators.get("luminanceThreshold").evaluate(e)[0],
        this._bp.luminancePass.fullscreenMaterial.smoothing = this._interpolators.get("luminanceSmoothing").evaluate(e)[0],
        this._composer.setSize(e, t),
        this._mainFbo.setSize(e, t)
    }
}
var $4 = `varying vec2 vUv;

void main() {
    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);

    vUv = uv;
}`
  , Z4 = `uniform sampler2D uOriginalPosition;
uniform sampler2D uCurrent;
uniform sampler2D uVelocity;
uniform float uTime;
uniform float uTimeScale;
uniform float uThreshold;
uniform bool uIsFirstRender;

varying vec2 vUv;

const float MAX_LIFE = 1.0;

float random (vec2 st) {
    return fract(sin(dot(st.xy,vec2(12.9898,78.233)))*43758.5453123);
}

float hash12(vec2 p) {
    vec3 p3 = fract(vec3(p.xyx) * .1031);
    p3 += dot(p3, p3.yzx + 33.33);
    return fract((p3.x + p3.y) * p3.z);
}

float calcRespawnLife(float threshold, vec2 uv) {
  return random(uv) <= uThreshold ? hash12(uv * (90.0 + 10.0 * HASH)) * MAX_LIFE : MAX_LIFE + hash12(uv * (90.0 + 10.0 * HASH));
}

void main() {
    vec4 origin = texture2D(uOriginalPosition, vUv);
    vec4 current = texture2D(uCurrent, vUv);
    vec4 velocity = texture2D(uVelocity, vUv);
    vec4 final = current;
    float life = current.a;
    float time = uTime + hash12(vUv);

  if(!uIsFirstRender){
    

    float speed = life < MAX_LIFE ? 1.0 : 0.0;
    final.rgb = current.rgb + velocity.rgb * speed;
    
    
    

    
    
    life = life - 0.01 * uTimeScale;

    if(life < 0.0){
      
      life = calcRespawnLife(0.2, vUv);
      final.rgb = origin.rgb;

    }else if(life > MAX_LIFE) {
      
      final.rgb = current.rgb;
      
      
      
      final.rgb += velocity.rgb * 1.0;
      
      
        
      
    }
  }

  
  
  

  if(uIsFirstRender){
    final.rgb = origin.rgb;
    life = calcRespawnLife(0.2, vUv);
  }

  
  
  

  gl_FragColor = vec4(final.rgb, life);
}`
  , J4 = `varying vec2 vUv;

void main() {
    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);

    vUv = uv;
}`
  , Q4 = `uniform mat4 uProjectionMatrix;
uniform mat4 uModelViewMatrix;
uniform sampler2D uOriginalPosition;
uniform sampler2D uPosition;
uniform sampler2D uCurrent;
uniform vec3 uMouse;
uniform float uTimeScale;
uniform float uFactor;
uniform bool uIsFirstRender;

varying vec2 vUv;

float random (vec2 st) {
    return fract(sin(dot(st.xy,vec2(12.9898,78.233)))*43758.5453123);
}

float hash12(vec2 p) {
    vec3 p3 = fract(vec3(p.xyx) * .1031);
    p3 += dot(p3, p3.yzx + 33.33);
    return fract((p3.x + p3.y) * p3.z);
}

const float MAX_LIFE = 1.0;

void main() {
  vec4 current = texture2D(uCurrent, vUv);
  vec4 position_t = texture2D(uPosition, vUv);
  vec3 position = texture2D(uPosition, vUv).rgb;
  vec3 originalPosition = texture2D(uOriginalPosition, vUv).rgb;

  if(position_t.a > 1.0){
    current.xyz *= 0.97;
  }

  vec3 direction = normalize(originalPosition - position);
  float dist = length(originalPosition - position);
  float d = distance(originalPosition, position);
  float a = current.a;
  a *= 0.99;
  a = clamp(a, 0.0, 10.0);
  float sa = smoothstep(0.0, 2.0, a);

  vec3 o = uMouse;
  float dm = distance(position, o);
  float maxdis = 1.5;

  if(dm < maxdis) {
      a = 10.0;
      vec3 dir = normalize(position - o);
      current.xyz += dir * (1.0 - dm / maxdis) * 0.038;
  }

  if(dist > 0.01){
    current.xyz += direction * 0.0015;
  }

  current.xyz = mix((1.0 - sa) * (originalPosition - position), current.xyz, sa);

  if(position_t.a <= 1.0){ 
    current.xyz = vec3(0.0, 0.0, -0.045)  * uTimeScale;
  }

  gl_FragColor = vec4(current.xyz, a);
}`;
const Ph = r=>{
    const e = new vn(r,r,{
        format: Kn,
        type: wn
    });
    return e.texture.minFilter = Jt,
    e.texture.magFilter = Jt,
    e
}
  , eV = new k;
class iT {
    constructor({gl: e, size: t, originTexture: n, customUvBuffer: i, threshold: s}) {
        this._size = t,
        this._gl = e,
        this._originPosition = n,
        this._isFirstRender = !0,
        this._mouseIntersection = eV.clone().set(-100, -200),
        this._time = {
            value: 0
        },
        this._timeScale = {
            value: ce.time.scale
        },
        this._customUvs = i,
        this._threshold = s,
        this._positionRtt = {
            write: void 0,
            read: void 0
        },
        this._velocityRtt = {
            write: void 0,
            read: void 0
        },
        this._camera = void 0,
        this._positionMaterial = void 0,
        this._positionMesh = void 0,
        this._init(),
        this._initEvents()
    }
    get texture() {
        return this._positionRtt.read.texture
    }
    _init() {
        this._initCam(),
        this._initVelocity(),
        this._initPosition()
    }
    _initEvents() {
        yt.on(xt.TIMESCALE_CHANGE, e=>{
            this._timeScale.value = ce.time.scale
        }
        )
    }
    _initCam() {
        const n = new vl(-.5,.5,.5,-.5,1,10);
        n.position.z = 5,
        this._camera = n
    }
    _initVelocity() {
        this._velocityRtt.read = Ph(this._size),
        this._velocityRtt.write = Ph(this._size);
        const e = new Tr(1,1,1,1)
          , t = new Vt({
            name: "velocity_gpgpu",
            vertexShader: J4,
            fragmentShader: Q4,
            uniforms: {
                uProjectionMatrix: {
                    value: null
                },
                uModelViewMatrix: {
                    value: null
                },
                uPosition: {
                    value: null
                },
                uOriginalPosition: {
                    value: this._originPosition
                },
                uCurrent: {
                    value: this._velocityRtt.read.texture
                },
                uMouse: {
                    value: this._mouseIntersection
                },
                uFactor: {
                    value: .2
                },
                uIsFirstRender: {
                    value: !1
                },
                uTimeScale: this._timeScale
            }
        })
          , n = new en(e,t);
        this._velocityMaterial = t,
        this._velocityMesh = n,
        window.dc = t
    }
    _initPosition() {
        this._positionRtt.read = Ph(this._size),
        this._positionRtt.write = Ph(this._size);
        const e = new Tr(1,1,1,1)
          , t = new Vt({
            name: "position_gpgpu",
            vertexShader: $4,
            fragmentShader: Z4,
            uniforms: {
                uOriginalPosition: {
                    value: this._originPosition
                },
                uCurrent: {
                    value: this._positionRtt.read.texture
                },
                uVelocity: {
                    value: this._velocityRtt.read.texture
                },
                uIsFirstRender: {
                    value: !0
                },
                uTime: this._time,
                uThreshold: {
                    value: this._threshold
                },
                uTimeScale: this._timeScale
            },
            defines: {
                HASH: .1
            }
        })
          , n = new en(e,t);
        this._positionMaterial = t,
        this._positionMesh = n
    }
    _swap() {
        const e = this._positionRtt.write;
        this._positionRtt.write = this._positionRtt.read,
        this._positionRtt.read = e;
        const t = this._velocityRtt.write;
        this._velocityRtt.write = this._velocityRtt.read,
        this._velocityRtt.read = t
    }
    update3DMouse(e) {
        this._mouseIntersection.copy(e)
    }
    update(e) {
        this._swap(),
        this._velocityMaterial.uniforms.uCurrent.value = this._velocityRtt.read.texture,
        this._velocityMaterial.uniforms.uPosition.value = this._positionRtt.read.texture,
        this._positionMaterial.uniforms.uCurrent.value = this._positionRtt.read.texture,
        this._positionMaterial.uniforms.uVelocity.value = this._velocityRtt.write.texture,
        this._time.value = e,
        this._gl.autoClear = !1,
        this._gl.setRenderTarget(this._velocityRtt.write),
        this._gl.render(this._velocityMesh, this._camera),
        this._gl.setRenderTarget(this._positionRtt.write),
        this._gl.render(this._positionMesh, this._camera),
        this._gl.setRenderTarget(null),
        this._gl.autoClear = !0,
        this._isFirstRender && (this._isFirstRender = !1,
        this._positionMaterial.uniforms.uIsFirstRender.value = !1)
    }
}
var tV = `uniform bool uScaleParticles;
uniform float uBaseSize;
uniform sampler2D uSim;
uniform sampler2D uOrigin;

varying vec2 vUv;
varying float vNormalised;

attribute vec2 aUv;

float random (vec2 st) {
    return fract(sin(dot(st.xy,vec2(12.9898,78.233)))*43758.5453123);
}

float hash12(vec2 p) {
    vec3 p3 = fract(vec3(p.xyx) * .1031);
    p3 += dot(p3, p3.yzx + 33.33);
    return fract((p3.x + p3.y) * p3.z);
}

float map(float value, float min1, float max1, float min2, float max2) {
  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);
}

void main(){
  vec4 simTxt = texture2D(uSim, aUv);
  vec4 oriTxt = texture2D(uOrigin, aUv);

  float scaleFactor = uBaseSize;
  float d = 1.0;

  if(uScaleParticles == true && simTxt.a >= 1.0){
    d = distance(simTxt.rgb, oriTxt.rgb);
    d = clamp(d - 1.0, 0.0, 100.0);
    d = 1.0 + (smoothstep(0.0, 0.6, simTxt.a) * d) * 2.4;
    d = clamp(d, 0.0, 2.0);
  }

  vec3 newPos = simTxt.rgb;
  newPos.x += (random(aUv * 0.45) - 0.5) * 0.05;
  newPos.y += (random(aUv * 0.67) - 0.5) * 0.05;
  newPos.z += (random(aUv * 0.53) - 0.5) * 0.05;

  float r = hash12(aUv * 1.0);
  float size = r * 14.0 * smoothstep(0.05, 1.0, simTxt.a);
  float factor = step(0.9, r);
  size *= scaleFactor;
  if(simTxt.a <= 1.0){
    size +=  factor * 10.0;
  }

  vec4 mvPosition = modelViewMatrix * vec4(simTxt.rgb, 1.0);

  gl_PointSize = size * (d);
  gl_PointSize *= ( 1.0 / - mvPosition.z );

  gl_Position = projectionMatrix * mvPosition;
  vUv = aUv;
  vNormalised = 1.0 - smoothstep(0.0, 9.0, size);
}`
  , nV = `uniform float uAlpha;
uniform float uRenderType;
uniform vec3 uMainColor;
uniform vec3 uWaterColor;
uniform sampler2D uSim;

varying vec2 vUv;
varying float vNormalised;

float hash12(vec2 p) {
    vec3 p3 = fract(vec3(p.xyx) * .1031);
    p3 += dot(p3, p3.yzx + 33.33);
    return fract((p3.x + p3.y) * p3.z);
}

void main(){
  vec4 t = texture2D(uSim, vUv);
  float m = clamp(t.a, 0.0, 1.0);
  float c = smoothstep(1.0, 0.8, t.a);
  float a = smoothstep(0.5, 0.15, length(gl_PointCoord.xy - vec2(0.5)));
  float r = hash12(mod(vUv * 30.0, 1.0));

  vec3 trail = mix(uMainColor, uWaterColor, uRenderType);
  trail *= 3.2;
  vec3 main = mix(vec3(0.85), vec3(0.95), r) * 1.4;
  vec3 final = mix(main, trail, c);
  float alpha = (m * a) * uAlpha;

  gl_FragColor = vec4(final, alpha);
}`;
const rT = new Ke;
class sT extends gf {
    constructor({count: e, textureSize: t, gpgpuTexture: n, originTexture: i, isAdditiveBlending: s=!1, scaleParticles: o=!1, baseSize: a=1, mainColor: c="#20BECA", waterColor: h="#FFAD0D", convertColor: d=!0}) {
        super(),
        this._count = e,
        this._textureSize = t,
        this._gpgpuTexture = n,
        this._isAdditiveBlending = s,
        this._originTexture = i,
        this._scaleParticles = o,
        this._baseSize = a,
        this._convertColor = d,
        this._mainColor = rT.clone().set(c),
        this._waterColor = rT.clone().set(h),
        this._init(),
        this._initEvents()
    }
    _init() {
        this._convertColor && (this._mainColor.convertLinearToSRGB(),
        this._waterColor.convertLinearToSRGB());
        const e = [];
        let t = [];
        for (let o = 0; o < this._count; o++)
            e.push(Math.random(), Math.random(), Math.random());
        const n = this._textureSize;
        for (let o = 0; o < n; o++)
            for (let a = 0; a < n; a++) {
                const c = a / n + 1 / n * .5
                  , h = o / n + 1 / n * .5;
                t.push(c, h)
            }
        t = t.slice(0, this._count * 2);
        const i = new mn;
        i.setAttribute("position", new pt(new Float32Array(e),3)),
        i.setAttribute("aUv", new pt(new Float32Array(t),2));
        const s = new Vt({
            vertexShader: tV,
            fragmentShader: nV,
            uniforms: {
                uSim: {
                    value: this._gpgpuTexture
                },
                uOrigin: {
                    value: this._originTexture
                },
                uRenderType: {
                    value: 0
                },
                uBaseSize: {
                    value: this._baseSize
                },
                uScaleParticles: {
                    value: this._scaleParticles
                },
                uMainColor: {
                    value: this._mainColor
                },
                uWaterColor: {
                    value: this._waterColor
                },
                uAlpha: {
                    value: 1
                }
            },
            depthWrite: !1,
            transparent: !0
        });
        this.geometry = i,
        this.material = s,
        this.renderOrder = An.renderOrder.particleMesh,
        this.frustumCulled = !1
    }
    _initEvents() {
        yt.on(xt.RENDER_REFLECTOR, e=>this._switchColors(e))
    }
    _switchColors(e) {
        this.material.uniforms.uRenderType.value = e ? 1 : 0
    }
}
var iV = `attribute vec2 aCustomUv;

varying vec3 vPosition;
varying vec2 vCustomUvs;

#include <common>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

void main(){
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>

  vec2 np = (aCustomUv * 2.0) -1.0;
  vec4 dc = modelMatrix * vec4(transformed, 1.0);

  gl_PointSize = 1.0;
  gl_Position = vec4(np, 0.0, 1.0);
  

  vCustomUvs = np;
  vPosition = dc.rgb;
}`
  , rV = `varying vec3 vPosition;
varying vec2 vCustomUvs;

float random (vec2 st) {
    return fract(sin(dot(st.xy,vec2(12.9898,78.233)))*43758.5453123);
}

void main(){
    gl_FragColor = vec4(vPosition, random(vCustomUvs));
}`;
const As = An.vat.texture.size;
class pm extends gr {
    constructor({asset: e, meshTrackerKey: t, mainColor: n="#20BECA", waterColor: i="#FFAD0D", initAlpha: s=1, convertColor: o=!0}) {
        super(),
        this._asset = e,
        this._meshTrackerKey = t,
        this._mainColor = n,
        this._waterColor = i,
        this._initAlpha = s,
        this._convertColor = o,
        this.hitMeshes = [],
        this._mainMesh = void 0,
        this._trailMesh = void 0,
        this._enterTl = Qt.timeline(),
        this._init()
    }
    get tracker() {
        return this._trackerEntireScene
    }
    _init() {
        this._initFBO(),
        this._prepareMesh(),
        this._initGpgpu(),
        this._initScene()
    }
    _initFBO() {
        const n = new vl(-.5,.5,.5,-.5,1,10);
        n.position.z = 5;
        const i = new vn(As,As,{
            format: Kn,
            type: wn
        });
        i.texture.minFilter = Jt,
        i.texture.magFilter = Jt,
        i.texture.needsUpdate = !0,
        this._fboCam = n,
        this._originRtt = i.clone()
    }
    _prepareMesh() {
        const {scene: e} = this._asset
          , t = e.getObjectByName(this._meshTrackerKey)
          , n = t.geometry
          , i = new Vt({
            name: `SavePosMat-${this._meshTrackerKey}`,
            vertexShader: iV,
            fragmentShader: rV
        });
        t.material = i,
        this._trackerMesh = t,
        this._trackerMesh.isPoints = !0,
        this._trackerMesh.isMesh = !1,
        e.traverse(d=>{
            d.name.includes("hit") && (this.hitMeshes.push(d),
            d.visible = !1)
        }
        ),
        e.traverse(d=>{
            d.isObject3D && (d.frustumCulled = !1)
        }
        ),
        this._trackerEntireScene = e;
        const s = As
          , o = As;
        let a = 0
          , c = 0;
        const h = [];
        for (let d = 0; d < this._trackerMesh.geometry.attributes.position.count; d++) {
            const l = c / s + 1 / s * .5
              , f = a / o + 1 / o * .5;
            c = (c + 1) % s,
            h.push(l, f),
            c === s - 1 && (a += 1)
        }
        n.setAttribute("aCustomUv", new pt(new Float32Array(h),2))
    }
    _initGpgpu() {
        this._gpgpuMesh = new iT({
            gl: ce.gl,
            size: As,
            originTexture: this._originRtt.texture,
            customUvBuffer: this._trackerMesh.geometry.attributes.aCustomUv,
            threshold: 1
        }),
        this._gpgpuTrail = new iT({
            gl: ce.gl,
            size: As,
            originTexture: this._originRtt.texture,
            customUvBuffer: this._trackerMesh.geometry.attributes.aCustomUv,
            threshold: 0
        })
    }
    _initScene() {
        const {count: e} = this._trackerMesh.geometry.attributes.position
          , t = new sT({
            count: e,
            textureSize: As,
            gpgpuTexture: this._gpgpuMesh.texture,
            originTexture: this._originRtt.texture,
            isAdditiveBlending: !0,
            baseSize: .4,
            scaleParticles: !1,
            mainColor: this._mainColor,
            waterColor: this._waterColor,
            convertColor: this._convertColor
        });
        this.add(t);
        const n = new sT({
            count: e,
            textureSize: As,
            gpgpuTexture: this._gpgpuTrail.texture,
            originTexture: this._originRtt.texture,
            isAdditiveBlending: !1,
            baseSize: 1.5,
            scaleParticles: !0,
            mainColor: this._mainColor,
            waterColor: this._waterColor,
            convertColor: this._convertColor
        });
        n.renderOrder += 1,
        this.add(n),
        this._mainMesh = t,
        this._trailMesh = n,
        t.material.uniforms.uAlpha.value = this._initAlpha,
        n.material.uniforms.uAlpha.value = this._initAlpha
    }
    enter({scale: e}) {
        const t = Qt.timeline()
          , n = this._mainMesh
          , i = this._trailMesh;
        t.to([n.material.uniforms.uAlpha, i.material.uniforms.uAlpha], {
            duration: 1,
            value: 1,
            ease: "power3.in"
        }, 0).fromTo(this._trackerEntireScene.scale, {
            x: 0,
            y: 0,
            z: 0
        }, {
            duration: 1,
            x: e,
            y: e,
            z: e,
            ease: "power3.out"
        }, 0),
        this._enterTl = t
    }
    detectIntersection() {
        const e = ce.raycaster.intersectObjects(this.hitMeshes);
        e.length > 0 ? (ce.mouse.world.copy(e[0].point),
        this._gpgpuMesh.update3DMouse(ce.mouse.world),
        this._gpgpuTrail.update3DMouse(ce.mouse.world)) : (ce.mouse.world.set(-100, -100, -100),
        this._gpgpuMesh.update3DMouse(ce.mouse.world),
        this._gpgpuTrail.update3DMouse(ce.mouse.world))
    }
    update() {
        ce.gl.setRenderTarget(this._originRtt),
        ce.gl.render(this._trackerEntireScene, this._fboCam),
        ce.gl.setRenderTarget(null),
        this._gpgpuMesh.update(ce.time.elapsed),
        this._gpgpuTrail.update(ce.time.elapsed)
    }
}
var sg = {};
/*!
 *  howler.js v2.2.4
 *  howlerjs.com
 *
 *  (c) 2013-2020, James Simpson of GoldFire Studios
 *  goldfirestudios.com
 *
 *  MIT License
 */
(function(r) {
    (function() {
        var e = function() {
            this.init()
        };
        e.prototype = {
            init: function() {
                var l = this || t;
                return l._counter = 1e3,
                l._html5AudioPool = [],
                l.html5PoolSize = 10,
                l._codecs = {},
                l._howls = [],
                l._muted = !1,
                l._volume = 1,
                l._canPlayEvent = "canplaythrough",
                l._navigator = typeof window < "u" && window.navigator ? window.navigator : null,
                l.masterGain = null,
                l.noAudio = !1,
                l.usingWebAudio = !0,
                l.autoSuspend = !0,
                l.ctx = null,
                l.autoUnlock = !0,
                l._setup(),
                l
            },
            volume: function(l) {
                var f = this || t;
                if (l = parseFloat(l),
                f.ctx || d(),
                typeof l < "u" && l >= 0 && l <= 1) {
                    if (f._volume = l,
                    f._muted)
                        return f;
                    f.usingWebAudio && f.masterGain.gain.setValueAtTime(l, t.ctx.currentTime);
                    for (var p = 0; p < f._howls.length; p++)
                        if (!f._howls[p]._webAudio)
                            for (var g = f._howls[p]._getSoundIds(), y = 0; y < g.length; y++) {
                                var v = f._howls[p]._soundById(g[y]);
                                v && v._node && (v._node.volume = v._volume * l)
                            }
                    return f
                }
                return f._volume
            },
            mute: function(l) {
                var f = this || t;
                f.ctx || d(),
                f._muted = l,
                f.usingWebAudio && f.masterGain.gain.setValueAtTime(l ? 0 : f._volume, t.ctx.currentTime);
                for (var p = 0; p < f._howls.length; p++)
                    if (!f._howls[p]._webAudio)
                        for (var g = f._howls[p]._getSoundIds(), y = 0; y < g.length; y++) {
                            var v = f._howls[p]._soundById(g[y]);
                            v && v._node && (v._node.muted = l ? !0 : v._muted)
                        }
                return f
            },
            stop: function() {
                for (var l = this || t, f = 0; f < l._howls.length; f++)
                    l._howls[f].stop();
                return l
            },
            unload: function() {
                for (var l = this || t, f = l._howls.length - 1; f >= 0; f--)
                    l._howls[f].unload();
                return l.usingWebAudio && l.ctx && typeof l.ctx.close < "u" && (l.ctx.close(),
                l.ctx = null,
                d()),
                l
            },
            codecs: function(l) {
                return (this || t)._codecs[l.replace(/^x-/, "")]
            },
            _setup: function() {
                var l = this || t;
                if (l.state = l.ctx && l.ctx.state || "suspended",
                l._autoSuspend(),
                !l.usingWebAudio)
                    if (typeof Audio < "u")
                        try {
                            var f = new Audio;
                            typeof f.oncanplaythrough > "u" && (l._canPlayEvent = "canplay")
                        } catch {
                            l.noAudio = !0
                        }
                    else
                        l.noAudio = !0;
                try {
                    var f = new Audio;
                    f.muted && (l.noAudio = !0)
                } catch {}
                return l.noAudio || l._setupCodecs(),
                l
            },
            _setupCodecs: function() {
                var l = this || t
                  , f = null;
                try {
                    f = typeof Audio < "u" ? new Audio : null
                } catch {
                    return l
                }
                if (!f || typeof f.canPlayType != "function")
                    return l;
                var p = f.canPlayType("audio/mpeg;").replace(/^no$/, "")
                  , g = l._navigator ? l._navigator.userAgent : ""
                  , y = g.match(/OPR\/(\d+)/g)
                  , v = y && parseInt(y[0].split("/")[1], 10) < 33
                  , _ = g.indexOf("Safari") !== -1 && g.indexOf("Chrome") === -1
                  , b = g.match(/Version\/(.*?) /)
                  , T = _ && b && parseInt(b[1], 10) < 15;
                return l._codecs = {
                    mp3: !!(!v && (p || f.canPlayType("audio/mp3;").replace(/^no$/, ""))),
                    mpeg: !!p,
                    opus: !!f.canPlayType('audio/ogg; codecs="opus"').replace(/^no$/, ""),
                    ogg: !!f.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ""),
                    oga: !!f.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ""),
                    wav: !!(f.canPlayType('audio/wav; codecs="1"') || f.canPlayType("audio/wav")).replace(/^no$/, ""),
                    aac: !!f.canPlayType("audio/aac;").replace(/^no$/, ""),
                    caf: !!f.canPlayType("audio/x-caf;").replace(/^no$/, ""),
                    m4a: !!(f.canPlayType("audio/x-m4a;") || f.canPlayType("audio/m4a;") || f.canPlayType("audio/aac;")).replace(/^no$/, ""),
                    m4b: !!(f.canPlayType("audio/x-m4b;") || f.canPlayType("audio/m4b;") || f.canPlayType("audio/aac;")).replace(/^no$/, ""),
                    mp4: !!(f.canPlayType("audio/x-mp4;") || f.canPlayType("audio/mp4;") || f.canPlayType("audio/aac;")).replace(/^no$/, ""),
                    weba: !!(!T && f.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, "")),
                    webm: !!(!T && f.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, "")),
                    dolby: !!f.canPlayType('audio/mp4; codecs="ec-3"').replace(/^no$/, ""),
                    flac: !!(f.canPlayType("audio/x-flac;") || f.canPlayType("audio/flac;")).replace(/^no$/, "")
                },
                l
            },
            _unlockAudio: function() {
                var l = this || t;
                if (!(l._audioUnlocked || !l.ctx)) {
                    l._audioUnlocked = !1,
                    l.autoUnlock = !1,
                    !l._mobileUnloaded && l.ctx.sampleRate !== 44100 && (l._mobileUnloaded = !0,
                    l.unload()),
                    l._scratchBuffer = l.ctx.createBuffer(1, 1, 22050);
                    var f = function(p) {
                        for (; l._html5AudioPool.length < l.html5PoolSize; )
                            try {
                                var g = new Audio;
                                g._unlocked = !0,
                                l._releaseHtml5Audio(g)
                            } catch {
                                l.noAudio = !0;
                                break
                            }
                        for (var y = 0; y < l._howls.length; y++)
                            if (!l._howls[y]._webAudio)
                                for (var v = l._howls[y]._getSoundIds(), _ = 0; _ < v.length; _++) {
                                    var b = l._howls[y]._soundById(v[_]);
                                    b && b._node && !b._node._unlocked && (b._node._unlocked = !0,
                                    b._node.load())
                                }
                        l._autoResume();
                        var T = l.ctx.createBufferSource();
                        T.buffer = l._scratchBuffer,
                        T.connect(l.ctx.destination),
                        typeof T.start > "u" ? T.noteOn(0) : T.start(0),
                        typeof l.ctx.resume == "function" && l.ctx.resume(),
                        T.onended = function() {
                            T.disconnect(0),
                            l._audioUnlocked = !0,
                            document.removeEventListener("touchstart", f, !0),
                            document.removeEventListener("touchend", f, !0),
                            document.removeEventListener("click", f, !0),
                            document.removeEventListener("keydown", f, !0);
                            for (var S = 0; S < l._howls.length; S++)
                                l._howls[S]._emit("unlock")
                        }
                    };
                    return document.addEventListener("touchstart", f, !0),
                    document.addEventListener("touchend", f, !0),
                    document.addEventListener("click", f, !0),
                    document.addEventListener("keydown", f, !0),
                    l
                }
            },
            _obtainHtml5Audio: function() {
                var l = this || t;
                if (l._html5AudioPool.length)
                    return l._html5AudioPool.pop();
                var f = new Audio().play();
                return f && typeof Promise < "u" && (f instanceof Promise || typeof f.then == "function") && f.catch(function() {
                    console.warn("HTML5 Audio pool exhausted, returning potentially locked audio object.")
                }),
                new Audio
            },
            _releaseHtml5Audio: function(l) {
                var f = this || t;
                return l._unlocked && f._html5AudioPool.push(l),
                f
            },
            _autoSuspend: function() {
                var l = this;
                if (!(!l.autoSuspend || !l.ctx || typeof l.ctx.suspend > "u" || !t.usingWebAudio)) {
                    for (var f = 0; f < l._howls.length; f++)
                        if (l._howls[f]._webAudio) {
                            for (var p = 0; p < l._howls[f]._sounds.length; p++)
                                if (!l._howls[f]._sounds[p]._paused)
                                    return l
                        }
                    return l._suspendTimer && clearTimeout(l._suspendTimer),
                    l._suspendTimer = setTimeout(function() {
                        if (l.autoSuspend) {
                            l._suspendTimer = null,
                            l.state = "suspending";
                            var g = function() {
                                l.state = "suspended",
                                l._resumeAfterSuspend && (delete l._resumeAfterSuspend,
                                l._autoResume())
                            };
                            l.ctx.suspend().then(g, g)
                        }
                    }, 3e4),
                    l
                }
            },
            _autoResume: function() {
                var l = this;
                if (!(!l.ctx || typeof l.ctx.resume > "u" || !t.usingWebAudio))
                    return l.state === "running" && l.ctx.state !== "interrupted" && l._suspendTimer ? (clearTimeout(l._suspendTimer),
                    l._suspendTimer = null) : l.state === "suspended" || l.state === "running" && l.ctx.state === "interrupted" ? (l.ctx.resume().then(function() {
                        l.state = "running";
                        for (var f = 0; f < l._howls.length; f++)
                            l._howls[f]._emit("resume")
                    }),
                    l._suspendTimer && (clearTimeout(l._suspendTimer),
                    l._suspendTimer = null)) : l.state === "suspending" && (l._resumeAfterSuspend = !0),
                    l
            }
        };
        var t = new e
          , n = function(l) {
            var f = this;
            if (!l.src || l.src.length === 0) {
                console.error("An array of source files must be passed with any new Howl.");
                return
            }
            f.init(l)
        };
        n.prototype = {
            init: function(l) {
                var f = this;
                return t.ctx || d(),
                f._autoplay = l.autoplay || !1,
                f._format = typeof l.format != "string" ? l.format : [l.format],
                f._html5 = l.html5 || !1,
                f._muted = l.mute || !1,
                f._loop = l.loop || !1,
                f._pool = l.pool || 5,
                f._preload = typeof l.preload == "boolean" || l.preload === "metadata" ? l.preload : !0,
                f._rate = l.rate || 1,
                f._sprite = l.sprite || {},
                f._src = typeof l.src != "string" ? l.src : [l.src],
                f._volume = l.volume !== void 0 ? l.volume : 1,
                f._xhr = {
                    method: l.xhr && l.xhr.method ? l.xhr.method : "GET",
                    headers: l.xhr && l.xhr.headers ? l.xhr.headers : null,
                    withCredentials: l.xhr && l.xhr.withCredentials ? l.xhr.withCredentials : !1
                },
                f._duration = 0,
                f._state = "unloaded",
                f._sounds = [],
                f._endTimers = {},
                f._queue = [],
                f._playLock = !1,
                f._onend = l.onend ? [{
                    fn: l.onend
                }] : [],
                f._onfade = l.onfade ? [{
                    fn: l.onfade
                }] : [],
                f._onload = l.onload ? [{
                    fn: l.onload
                }] : [],
                f._onloaderror = l.onloaderror ? [{
                    fn: l.onloaderror
                }] : [],
                f._onplayerror = l.onplayerror ? [{
                    fn: l.onplayerror
                }] : [],
                f._onpause = l.onpause ? [{
                    fn: l.onpause
                }] : [],
                f._onplay = l.onplay ? [{
                    fn: l.onplay
                }] : [],
                f._onstop = l.onstop ? [{
                    fn: l.onstop
                }] : [],
                f._onmute = l.onmute ? [{
                    fn: l.onmute
                }] : [],
                f._onvolume = l.onvolume ? [{
                    fn: l.onvolume
                }] : [],
                f._onrate = l.onrate ? [{
                    fn: l.onrate
                }] : [],
                f._onseek = l.onseek ? [{
                    fn: l.onseek
                }] : [],
                f._onunlock = l.onunlock ? [{
                    fn: l.onunlock
                }] : [],
                f._onresume = [],
                f._webAudio = t.usingWebAudio && !f._html5,
                typeof t.ctx < "u" && t.ctx && t.autoUnlock && t._unlockAudio(),
                t._howls.push(f),
                f._autoplay && f._queue.push({
                    event: "play",
                    action: function() {
                        f.play()
                    }
                }),
                f._preload && f._preload !== "none" && f.load(),
                f
            },
            load: function() {
                var l = this
                  , f = null;
                if (t.noAudio) {
                    l._emit("loaderror", null, "No audio support.");
                    return
                }
                typeof l._src == "string" && (l._src = [l._src]);
                for (var p = 0; p < l._src.length; p++) {
                    var g, y;
                    if (l._format && l._format[p])
                        g = l._format[p];
                    else {
                        if (y = l._src[p],
                        typeof y != "string") {
                            l._emit("loaderror", null, "Non-string found in selected audio sources - ignoring.");
                            continue
                        }
                        g = /^data:audio\/([^;,]+);/i.exec(y),
                        g || (g = /\.([^.]+)$/.exec(y.split("?", 1)[0])),
                        g && (g = g[1].toLowerCase())
                    }
                    if (g || console.warn('No file extension was found. Consider using the "format" property or specify an extension.'),
                    g && t.codecs(g)) {
                        f = l._src[p];
                        break
                    }
                }
                if (!f) {
                    l._emit("loaderror", null, "No codec support for selected audio sources.");
                    return
                }
                return l._src = f,
                l._state = "loading",
                window.location.protocol === "https:" && f.slice(0, 5) === "http:" && (l._html5 = !0,
                l._webAudio = !1),
                new i(l),
                l._webAudio && o(l),
                l
            },
            play: function(l, f) {
                var p = this
                  , g = null;
                if (typeof l == "number")
                    g = l,
                    l = null;
                else {
                    if (typeof l == "string" && p._state === "loaded" && !p._sprite[l])
                        return null;
                    if (typeof l > "u" && (l = "__default",
                    !p._playLock)) {
                        for (var y = 0, v = 0; v < p._sounds.length; v++)
                            p._sounds[v]._paused && !p._sounds[v]._ended && (y++,
                            g = p._sounds[v]._id);
                        y === 1 ? l = null : g = null
                    }
                }
                var _ = g ? p._soundById(g) : p._inactiveSound();
                if (!_)
                    return null;
                if (g && !l && (l = _._sprite || "__default"),
                p._state !== "loaded") {
                    _._sprite = l,
                    _._ended = !1;
                    var b = _._id;
                    return p._queue.push({
                        event: "play",
                        action: function() {
                            p.play(b)
                        }
                    }),
                    b
                }
                if (g && !_._paused)
                    return f || p._loadQueue("play"),
                    _._id;
                p._webAudio && t._autoResume();
                var T = Math.max(0, _._seek > 0 ? _._seek : p._sprite[l][0] / 1e3)
                  , S = Math.max(0, (p._sprite[l][0] + p._sprite[l][1]) / 1e3 - T)
                  , E = S * 1e3 / Math.abs(_._rate)
                  , P = p._sprite[l][0] / 1e3
                  , R = (p._sprite[l][0] + p._sprite[l][1]) / 1e3;
                _._sprite = l,
                _._ended = !1;
                var O = function() {
                    _._paused = !1,
                    _._seek = T,
                    _._start = P,
                    _._stop = R,
                    _._loop = !!(_._loop || p._sprite[l][2])
                };
                if (T >= R) {
                    p._ended(_);
                    return
                }
                var w = _._node;
                if (p._webAudio) {
                    var I = function() {
                        p._playLock = !1,
                        O(),
                        p._refreshBuffer(_);
                        var F = _._muted || p._muted ? 0 : _._volume;
                        w.gain.setValueAtTime(F, t.ctx.currentTime),
                        _._playStart = t.ctx.currentTime,
                        typeof w.bufferSource.start > "u" ? _._loop ? w.bufferSource.noteGrainOn(0, T, 86400) : w.bufferSource.noteGrainOn(0, T, S) : _._loop ? w.bufferSource.start(0, T, 86400) : w.bufferSource.start(0, T, S),
                        E !== 1 / 0 && (p._endTimers[_._id] = setTimeout(p._ended.bind(p, _), E)),
                        f || setTimeout(function() {
                            p._emit("play", _._id),
                            p._loadQueue()
                        }, 0)
                    };
                    t.state === "running" && t.ctx.state !== "interrupted" ? I() : (p._playLock = !0,
                    p.once("resume", I),
                    p._clearTimer(_._id))
                } else {
                    var V = function() {
                        w.currentTime = T,
                        w.muted = _._muted || p._muted || t._muted || w.muted,
                        w.volume = _._volume * t.volume(),
                        w.playbackRate = _._rate;
                        try {
                            var F = w.play();
                            if (F && typeof Promise < "u" && (F instanceof Promise || typeof F.then == "function") ? (p._playLock = !0,
                            O(),
                            F.then(function() {
                                p._playLock = !1,
                                w._unlocked = !0,
                                f ? p._loadQueue() : p._emit("play", _._id)
                            }).catch(function() {
                                p._playLock = !1,
                                p._emit("playerror", _._id, "Playback was unable to start. This is most commonly an issue on mobile devices and Chrome where playback was not within a user interaction."),
                                _._ended = !0,
                                _._paused = !0
                            })) : f || (p._playLock = !1,
                            O(),
                            p._emit("play", _._id)),
                            w.playbackRate = _._rate,
                            w.paused) {
                                p._emit("playerror", _._id, "Playback was unable to start. This is most commonly an issue on mobile devices and Chrome where playback was not within a user interaction.");
                                return
                            }
                            l !== "__default" || _._loop ? p._endTimers[_._id] = setTimeout(p._ended.bind(p, _), E) : (p._endTimers[_._id] = function() {
                                p._ended(_),
                                w.removeEventListener("ended", p._endTimers[_._id], !1)
                            }
                            ,
                            w.addEventListener("ended", p._endTimers[_._id], !1))
                        } catch (j) {
                            p._emit("playerror", _._id, j)
                        }
                    };
                    w.src === "data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA" && (w.src = p._src,
                    w.load());
                    var z = window && window.ejecta || !w.readyState && t._navigator.isCocoonJS;
                    if (w.readyState >= 3 || z)
                        V();
                    else {
                        p._playLock = !0,
                        p._state = "loading";
                        var q = function() {
                            p._state = "loaded",
                            V(),
                            w.removeEventListener(t._canPlayEvent, q, !1)
                        };
                        w.addEventListener(t._canPlayEvent, q, !1),
                        p._clearTimer(_._id)
                    }
                }
                return _._id
            },
            pause: function(l) {
                var f = this;
                if (f._state !== "loaded" || f._playLock)
                    return f._queue.push({
                        event: "pause",
                        action: function() {
                            f.pause(l)
                        }
                    }),
                    f;
                for (var p = f._getSoundIds(l), g = 0; g < p.length; g++) {
                    f._clearTimer(p[g]);
                    var y = f._soundById(p[g]);
                    if (y && !y._paused && (y._seek = f.seek(p[g]),
                    y._rateSeek = 0,
                    y._paused = !0,
                    f._stopFade(p[g]),
                    y._node))
                        if (f._webAudio) {
                            if (!y._node.bufferSource)
                                continue;
                            typeof y._node.bufferSource.stop > "u" ? y._node.bufferSource.noteOff(0) : y._node.bufferSource.stop(0),
                            f._cleanBuffer(y._node)
                        } else
                            (!isNaN(y._node.duration) || y._node.duration === 1 / 0) && y._node.pause();
                    arguments[1] || f._emit("pause", y ? y._id : null)
                }
                return f
            },
            stop: function(l, f) {
                var p = this;
                if (p._state !== "loaded" || p._playLock)
                    return p._queue.push({
                        event: "stop",
                        action: function() {
                            p.stop(l)
                        }
                    }),
                    p;
                for (var g = p._getSoundIds(l), y = 0; y < g.length; y++) {
                    p._clearTimer(g[y]);
                    var v = p._soundById(g[y]);
                    v && (v._seek = v._start || 0,
                    v._rateSeek = 0,
                    v._paused = !0,
                    v._ended = !0,
                    p._stopFade(g[y]),
                    v._node && (p._webAudio ? v._node.bufferSource && (typeof v._node.bufferSource.stop > "u" ? v._node.bufferSource.noteOff(0) : v._node.bufferSource.stop(0),
                    p._cleanBuffer(v._node)) : (!isNaN(v._node.duration) || v._node.duration === 1 / 0) && (v._node.currentTime = v._start || 0,
                    v._node.pause(),
                    v._node.duration === 1 / 0 && p._clearSound(v._node))),
                    f || p._emit("stop", v._id))
                }
                return p
            },
            mute: function(l, f) {
                var p = this;
                if (p._state !== "loaded" || p._playLock)
                    return p._queue.push({
                        event: "mute",
                        action: function() {
                            p.mute(l, f)
                        }
                    }),
                    p;
                if (typeof f > "u")
                    if (typeof l == "boolean")
                        p._muted = l;
                    else
                        return p._muted;
                for (var g = p._getSoundIds(f), y = 0; y < g.length; y++) {
                    var v = p._soundById(g[y]);
                    v && (v._muted = l,
                    v._interval && p._stopFade(v._id),
                    p._webAudio && v._node ? v._node.gain.setValueAtTime(l ? 0 : v._volume, t.ctx.currentTime) : v._node && (v._node.muted = t._muted ? !0 : l),
                    p._emit("mute", v._id))
                }
                return p
            },
            volume: function() {
                var l = this, f = arguments, p, g;
                if (f.length === 0)
                    return l._volume;
                if (f.length === 1 || f.length === 2 && typeof f[1] > "u") {
                    var y = l._getSoundIds()
                      , v = y.indexOf(f[0]);
                    v >= 0 ? g = parseInt(f[0], 10) : p = parseFloat(f[0])
                } else
                    f.length >= 2 && (p = parseFloat(f[0]),
                    g = parseInt(f[1], 10));
                var _;
                if (typeof p < "u" && p >= 0 && p <= 1) {
                    if (l._state !== "loaded" || l._playLock)
                        return l._queue.push({
                            event: "volume",
                            action: function() {
                                l.volume.apply(l, f)
                            }
                        }),
                        l;
                    typeof g > "u" && (l._volume = p),
                    g = l._getSoundIds(g);
                    for (var b = 0; b < g.length; b++)
                        _ = l._soundById(g[b]),
                        _ && (_._volume = p,
                        f[2] || l._stopFade(g[b]),
                        l._webAudio && _._node && !_._muted ? _._node.gain.setValueAtTime(p, t.ctx.currentTime) : _._node && !_._muted && (_._node.volume = p * t.volume()),
                        l._emit("volume", _._id))
                } else
                    return _ = g ? l._soundById(g) : l._sounds[0],
                    _ ? _._volume : 0;
                return l
            },
            fade: function(l, f, p, g) {
                var y = this;
                if (y._state !== "loaded" || y._playLock)
                    return y._queue.push({
                        event: "fade",
                        action: function() {
                            y.fade(l, f, p, g)
                        }
                    }),
                    y;
                l = Math.min(Math.max(0, parseFloat(l)), 1),
                f = Math.min(Math.max(0, parseFloat(f)), 1),
                p = parseFloat(p),
                y.volume(l, g);
                for (var v = y._getSoundIds(g), _ = 0; _ < v.length; _++) {
                    var b = y._soundById(v[_]);
                    if (b) {
                        if (g || y._stopFade(v[_]),
                        y._webAudio && !b._muted) {
                            var T = t.ctx.currentTime
                              , S = T + p / 1e3;
                            b._volume = l,
                            b._node.gain.setValueAtTime(l, T),
                            b._node.gain.linearRampToValueAtTime(f, S)
                        }
                        y._startFadeInterval(b, l, f, p, v[_], typeof g > "u")
                    }
                }
                return y
            },
            _startFadeInterval: function(l, f, p, g, y, v) {
                var _ = this
                  , b = f
                  , T = p - f
                  , S = Math.abs(T / .01)
                  , E = Math.max(4, S > 0 ? g / S : g)
                  , P = Date.now();
                l._fadeTo = p,
                l._interval = setInterval(function() {
                    var R = (Date.now() - P) / g;
                    P = Date.now(),
                    b += T * R,
                    b = Math.round(b * 100) / 100,
                    T < 0 ? b = Math.max(p, b) : b = Math.min(p, b),
                    _._webAudio ? l._volume = b : _.volume(b, l._id, !0),
                    v && (_._volume = b),
                    (p < f && b <= p || p > f && b >= p) && (clearInterval(l._interval),
                    l._interval = null,
                    l._fadeTo = null,
                    _.volume(p, l._id),
                    _._emit("fade", l._id))
                }, E)
            },
            _stopFade: function(l) {
                var f = this
                  , p = f._soundById(l);
                return p && p._interval && (f._webAudio && p._node.gain.cancelScheduledValues(t.ctx.currentTime),
                clearInterval(p._interval),
                p._interval = null,
                f.volume(p._fadeTo, l),
                p._fadeTo = null,
                f._emit("fade", l)),
                f
            },
            loop: function() {
                var l = this, f = arguments, p, g, y;
                if (f.length === 0)
                    return l._loop;
                if (f.length === 1)
                    if (typeof f[0] == "boolean")
                        p = f[0],
                        l._loop = p;
                    else
                        return y = l._soundById(parseInt(f[0], 10)),
                        y ? y._loop : !1;
                else
                    f.length === 2 && (p = f[0],
                    g = parseInt(f[1], 10));
                for (var v = l._getSoundIds(g), _ = 0; _ < v.length; _++)
                    y = l._soundById(v[_]),
                    y && (y._loop = p,
                    l._webAudio && y._node && y._node.bufferSource && (y._node.bufferSource.loop = p,
                    p && (y._node.bufferSource.loopStart = y._start || 0,
                    y._node.bufferSource.loopEnd = y._stop,
                    l.playing(v[_]) && (l.pause(v[_], !0),
                    l.play(v[_], !0)))));
                return l
            },
            rate: function() {
                var l = this, f = arguments, p, g;
                if (f.length === 0)
                    g = l._sounds[0]._id;
                else if (f.length === 1) {
                    var y = l._getSoundIds()
                      , v = y.indexOf(f[0]);
                    v >= 0 ? g = parseInt(f[0], 10) : p = parseFloat(f[0])
                } else
                    f.length === 2 && (p = parseFloat(f[0]),
                    g = parseInt(f[1], 10));
                var _;
                if (typeof p == "number") {
                    if (l._state !== "loaded" || l._playLock)
                        return l._queue.push({
                            event: "rate",
                            action: function() {
                                l.rate.apply(l, f)
                            }
                        }),
                        l;
                    typeof g > "u" && (l._rate = p),
                    g = l._getSoundIds(g);
                    for (var b = 0; b < g.length; b++)
                        if (_ = l._soundById(g[b]),
                        _) {
                            l.playing(g[b]) && (_._rateSeek = l.seek(g[b]),
                            _._playStart = l._webAudio ? t.ctx.currentTime : _._playStart),
                            _._rate = p,
                            l._webAudio && _._node && _._node.bufferSource ? _._node.bufferSource.playbackRate.setValueAtTime(p, t.ctx.currentTime) : _._node && (_._node.playbackRate = p);
                            var T = l.seek(g[b])
                              , S = (l._sprite[_._sprite][0] + l._sprite[_._sprite][1]) / 1e3 - T
                              , E = S * 1e3 / Math.abs(_._rate);
                            (l._endTimers[g[b]] || !_._paused) && (l._clearTimer(g[b]),
                            l._endTimers[g[b]] = setTimeout(l._ended.bind(l, _), E)),
                            l._emit("rate", _._id)
                        }
                } else
                    return _ = l._soundById(g),
                    _ ? _._rate : l._rate;
                return l
            },
            seek: function() {
                var l = this, f = arguments, p, g;
                if (f.length === 0)
                    l._sounds.length && (g = l._sounds[0]._id);
                else if (f.length === 1) {
                    var y = l._getSoundIds()
                      , v = y.indexOf(f[0]);
                    v >= 0 ? g = parseInt(f[0], 10) : l._sounds.length && (g = l._sounds[0]._id,
                    p = parseFloat(f[0]))
                } else
                    f.length === 2 && (p = parseFloat(f[0]),
                    g = parseInt(f[1], 10));
                if (typeof g > "u")
                    return 0;
                if (typeof p == "number" && (l._state !== "loaded" || l._playLock))
                    return l._queue.push({
                        event: "seek",
                        action: function() {
                            l.seek.apply(l, f)
                        }
                    }),
                    l;
                var _ = l._soundById(g);
                if (_)
                    if (typeof p == "number" && p >= 0) {
                        var b = l.playing(g);
                        b && l.pause(g, !0),
                        _._seek = p,
                        _._ended = !1,
                        l._clearTimer(g),
                        !l._webAudio && _._node && !isNaN(_._node.duration) && (_._node.currentTime = p);
                        var T = function() {
                            b && l.play(g, !0),
                            l._emit("seek", g)
                        };
                        if (b && !l._webAudio) {
                            var S = function() {
                                l._playLock ? setTimeout(S, 0) : T()
                            };
                            setTimeout(S, 0)
                        } else
                            T()
                    } else if (l._webAudio) {
                        var E = l.playing(g) ? t.ctx.currentTime - _._playStart : 0
                          , P = _._rateSeek ? _._rateSeek - _._seek : 0;
                        return _._seek + (P + E * Math.abs(_._rate))
                    } else
                        return _._node.currentTime;
                return l
            },
            playing: function(l) {
                var f = this;
                if (typeof l == "number") {
                    var p = f._soundById(l);
                    return p ? !p._paused : !1
                }
                for (var g = 0; g < f._sounds.length; g++)
                    if (!f._sounds[g]._paused)
                        return !0;
                return !1
            },
            duration: function(l) {
                var f = this
                  , p = f._duration
                  , g = f._soundById(l);
                return g && (p = f._sprite[g._sprite][1] / 1e3),
                p
            },
            state: function() {
                return this._state
            },
            unload: function() {
                for (var l = this, f = l._sounds, p = 0; p < f.length; p++)
                    f[p]._paused || l.stop(f[p]._id),
                    l._webAudio || (l._clearSound(f[p]._node),
                    f[p]._node.removeEventListener("error", f[p]._errorFn, !1),
                    f[p]._node.removeEventListener(t._canPlayEvent, f[p]._loadFn, !1),
                    f[p]._node.removeEventListener("ended", f[p]._endFn, !1),
                    t._releaseHtml5Audio(f[p]._node)),
                    delete f[p]._node,
                    l._clearTimer(f[p]._id);
                var g = t._howls.indexOf(l);
                g >= 0 && t._howls.splice(g, 1);
                var y = !0;
                for (p = 0; p < t._howls.length; p++)
                    if (t._howls[p]._src === l._src || l._src.indexOf(t._howls[p]._src) >= 0) {
                        y = !1;
                        break
                    }
                return s && y && delete s[l._src],
                t.noAudio = !1,
                l._state = "unloaded",
                l._sounds = [],
                l = null,
                null
            },
            on: function(l, f, p, g) {
                var y = this
                  , v = y["_on" + l];
                return typeof f == "function" && v.push(g ? {
                    id: p,
                    fn: f,
                    once: g
                } : {
                    id: p,
                    fn: f
                }),
                y
            },
            off: function(l, f, p) {
                var g = this
                  , y = g["_on" + l]
                  , v = 0;
                if (typeof f == "number" && (p = f,
                f = null),
                f || p)
                    for (v = 0; v < y.length; v++) {
                        var _ = p === y[v].id;
                        if (f === y[v].fn && _ || !f && _) {
                            y.splice(v, 1);
                            break
                        }
                    }
                else if (l)
                    g["_on" + l] = [];
                else {
                    var b = Object.keys(g);
                    for (v = 0; v < b.length; v++)
                        b[v].indexOf("_on") === 0 && Array.isArray(g[b[v]]) && (g[b[v]] = [])
                }
                return g
            },
            once: function(l, f, p) {
                var g = this;
                return g.on(l, f, p, 1),
                g
            },
            _emit: function(l, f, p) {
                for (var g = this, y = g["_on" + l], v = y.length - 1; v >= 0; v--)
                    (!y[v].id || y[v].id === f || l === "load") && (setTimeout(function(_) {
                        _.call(this, f, p)
                    }
                    .bind(g, y[v].fn), 0),
                    y[v].once && g.off(l, y[v].fn, y[v].id));
                return g._loadQueue(l),
                g
            },
            _loadQueue: function(l) {
                var f = this;
                if (f._queue.length > 0) {
                    var p = f._queue[0];
                    p.event === l && (f._queue.shift(),
                    f._loadQueue()),
                    l || p.action()
                }
                return f
            },
            _ended: function(l) {
                var f = this
                  , p = l._sprite;
                if (!f._webAudio && l._node && !l._node.paused && !l._node.ended && l._node.currentTime < l._stop)
                    return setTimeout(f._ended.bind(f, l), 100),
                    f;
                var g = !!(l._loop || f._sprite[p][2]);
                if (f._emit("end", l._id),
                !f._webAudio && g && f.stop(l._id, !0).play(l._id),
                f._webAudio && g) {
                    f._emit("play", l._id),
                    l._seek = l._start || 0,
                    l._rateSeek = 0,
                    l._playStart = t.ctx.currentTime;
                    var y = (l._stop - l._start) * 1e3 / Math.abs(l._rate);
                    f._endTimers[l._id] = setTimeout(f._ended.bind(f, l), y)
                }
                return f._webAudio && !g && (l._paused = !0,
                l._ended = !0,
                l._seek = l._start || 0,
                l._rateSeek = 0,
                f._clearTimer(l._id),
                f._cleanBuffer(l._node),
                t._autoSuspend()),
                !f._webAudio && !g && f.stop(l._id, !0),
                f
            },
            _clearTimer: function(l) {
                var f = this;
                if (f._endTimers[l]) {
                    if (typeof f._endTimers[l] != "function")
                        clearTimeout(f._endTimers[l]);
                    else {
                        var p = f._soundById(l);
                        p && p._node && p._node.removeEventListener("ended", f._endTimers[l], !1)
                    }
                    delete f._endTimers[l]
                }
                return f
            },
            _soundById: function(l) {
                for (var f = this, p = 0; p < f._sounds.length; p++)
                    if (l === f._sounds[p]._id)
                        return f._sounds[p];
                return null
            },
            _inactiveSound: function() {
                var l = this;
                l._drain();
                for (var f = 0; f < l._sounds.length; f++)
                    if (l._sounds[f]._ended)
                        return l._sounds[f].reset();
                return new i(l)
            },
            _drain: function() {
                var l = this
                  , f = l._pool
                  , p = 0
                  , g = 0;
                if (!(l._sounds.length < f)) {
                    for (g = 0; g < l._sounds.length; g++)
                        l._sounds[g]._ended && p++;
                    for (g = l._sounds.length - 1; g >= 0; g--) {
                        if (p <= f)
                            return;
                        l._sounds[g]._ended && (l._webAudio && l._sounds[g]._node && l._sounds[g]._node.disconnect(0),
                        l._sounds.splice(g, 1),
                        p--)
                    }
                }
            },
            _getSoundIds: function(l) {
                var f = this;
                if (typeof l > "u") {
                    for (var p = [], g = 0; g < f._sounds.length; g++)
                        p.push(f._sounds[g]._id);
                    return p
                } else
                    return [l]
            },
            _refreshBuffer: function(l) {
                var f = this;
                return l._node.bufferSource = t.ctx.createBufferSource(),
                l._node.bufferSource.buffer = s[f._src],
                l._panner ? l._node.bufferSource.connect(l._panner) : l._node.bufferSource.connect(l._node),
                l._node.bufferSource.loop = l._loop,
                l._loop && (l._node.bufferSource.loopStart = l._start || 0,
                l._node.bufferSource.loopEnd = l._stop || 0),
                l._node.bufferSource.playbackRate.setValueAtTime(l._rate, t.ctx.currentTime),
                f
            },
            _cleanBuffer: function(l) {
                var f = this
                  , p = t._navigator && t._navigator.vendor.indexOf("Apple") >= 0;
                if (!l.bufferSource)
                    return f;
                if (t._scratchBuffer && l.bufferSource && (l.bufferSource.onended = null,
                l.bufferSource.disconnect(0),
                p))
                    try {
                        l.bufferSource.buffer = t._scratchBuffer
                    } catch {}
                return l.bufferSource = null,
                f
            },
            _clearSound: function(l) {
                var f = /MSIE |Trident\//.test(t._navigator && t._navigator.userAgent);
                f || (l.src = "data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA")
            }
        };
        var i = function(l) {
            this._parent = l,
            this.init()
        };
        i.prototype = {
            init: function() {
                var l = this
                  , f = l._parent;
                return l._muted = f._muted,
                l._loop = f._loop,
                l._volume = f._volume,
                l._rate = f._rate,
                l._seek = 0,
                l._paused = !0,
                l._ended = !0,
                l._sprite = "__default",
                l._id = ++t._counter,
                f._sounds.push(l),
                l.create(),
                l
            },
            create: function() {
                var l = this
                  , f = l._parent
                  , p = t._muted || l._muted || l._parent._muted ? 0 : l._volume;
                return f._webAudio ? (l._node = typeof t.ctx.createGain > "u" ? t.ctx.createGainNode() : t.ctx.createGain(),
                l._node.gain.setValueAtTime(p, t.ctx.currentTime),
                l._node.paused = !0,
                l._node.connect(t.masterGain)) : t.noAudio || (l._node = t._obtainHtml5Audio(),
                l._errorFn = l._errorListener.bind(l),
                l._node.addEventListener("error", l._errorFn, !1),
                l._loadFn = l._loadListener.bind(l),
                l._node.addEventListener(t._canPlayEvent, l._loadFn, !1),
                l._endFn = l._endListener.bind(l),
                l._node.addEventListener("ended", l._endFn, !1),
                l._node.src = f._src,
                l._node.preload = f._preload === !0 ? "auto" : f._preload,
                l._node.volume = p * t.volume(),
                l._node.load()),
                l
            },
            reset: function() {
                var l = this
                  , f = l._parent;
                return l._muted = f._muted,
                l._loop = f._loop,
                l._volume = f._volume,
                l._rate = f._rate,
                l._seek = 0,
                l._rateSeek = 0,
                l._paused = !0,
                l._ended = !0,
                l._sprite = "__default",
                l._id = ++t._counter,
                l
            },
            _errorListener: function() {
                var l = this;
                l._parent._emit("loaderror", l._id, l._node.error ? l._node.error.code : 0),
                l._node.removeEventListener("error", l._errorFn, !1)
            },
            _loadListener: function() {
                var l = this
                  , f = l._parent;
                f._duration = Math.ceil(l._node.duration * 10) / 10,
                Object.keys(f._sprite).length === 0 && (f._sprite = {
                    __default: [0, f._duration * 1e3]
                }),
                f._state !== "loaded" && (f._state = "loaded",
                f._emit("load"),
                f._loadQueue()),
                l._node.removeEventListener(t._canPlayEvent, l._loadFn, !1)
            },
            _endListener: function() {
                var l = this
                  , f = l._parent;
                f._duration === 1 / 0 && (f._duration = Math.ceil(l._node.duration * 10) / 10,
                f._sprite.__default[1] === 1 / 0 && (f._sprite.__default[1] = f._duration * 1e3),
                f._ended(l)),
                l._node.removeEventListener("ended", l._endFn, !1)
            }
        };
        var s = {}
          , o = function(l) {
            var f = l._src;
            if (s[f]) {
                l._duration = s[f].duration,
                h(l);
                return
            }
            if (/^data:[^;]+;base64,/.test(f)) {
                for (var p = atob(f.split(",")[1]), g = new Uint8Array(p.length), y = 0; y < p.length; ++y)
                    g[y] = p.charCodeAt(y);
                c(g.buffer, l)
            } else {
                var v = new XMLHttpRequest;
                v.open(l._xhr.method, f, !0),
                v.withCredentials = l._xhr.withCredentials,
                v.responseType = "arraybuffer",
                l._xhr.headers && Object.keys(l._xhr.headers).forEach(function(_) {
                    v.setRequestHeader(_, l._xhr.headers[_])
                }),
                v.onload = function() {
                    var _ = (v.status + "")[0];
                    if (_ !== "0" && _ !== "2" && _ !== "3") {
                        l._emit("loaderror", null, "Failed loading audio file with status: " + v.status + ".");
                        return
                    }
                    c(v.response, l)
                }
                ,
                v.onerror = function() {
                    l._webAudio && (l._html5 = !0,
                    l._webAudio = !1,
                    l._sounds = [],
                    delete s[f],
                    l.load())
                }
                ,
                a(v)
            }
        }
          , a = function(l) {
            try {
                l.send()
            } catch {
                l.onerror()
            }
        }
          , c = function(l, f) {
            var p = function() {
                f._emit("loaderror", null, "Decoding audio data failed.")
            }
              , g = function(y) {
                y && f._sounds.length > 0 ? (s[f._src] = y,
                h(f, y)) : p()
            };
            typeof Promise < "u" && t.ctx.decodeAudioData.length === 1 ? t.ctx.decodeAudioData(l).then(g).catch(p) : t.ctx.decodeAudioData(l, g, p)
        }
          , h = function(l, f) {
            f && !l._duration && (l._duration = f.duration),
            Object.keys(l._sprite).length === 0 && (l._sprite = {
                __default: [0, l._duration * 1e3]
            }),
            l._state !== "loaded" && (l._state = "loaded",
            l._emit("load"),
            l._loadQueue())
        }
          , d = function() {
            if (t.usingWebAudio) {
                try {
                    typeof AudioContext < "u" ? t.ctx = new AudioContext : typeof webkitAudioContext < "u" ? t.ctx = new webkitAudioContext : t.usingWebAudio = !1
                } catch {
                    t.usingWebAudio = !1
                }
                t.ctx || (t.usingWebAudio = !1);
                var l = /iP(hone|od|ad)/.test(t._navigator && t._navigator.platform)
                  , f = t._navigator && t._navigator.appVersion.match(/OS (\d+)_(\d+)_?(\d+)?/)
                  , p = f ? parseInt(f[1], 10) : null;
                if (l && p && p < 9) {
                    var g = /safari/.test(t._navigator && t._navigator.userAgent.toLowerCase());
                    t._navigator && !g && (t.usingWebAudio = !1)
                }
                t.usingWebAudio && (t.masterGain = typeof t.ctx.createGain > "u" ? t.ctx.createGainNode() : t.ctx.createGain(),
                t.masterGain.gain.setValueAtTime(t._muted ? 0 : t._volume, t.ctx.currentTime),
                t.masterGain.connect(t.ctx.destination)),
                t._setup()
            }
        };
        r.Howler = t,
        r.Howl = n,
        typeof ci < "u" ? (ci.HowlerGlobal = e,
        ci.Howler = t,
        ci.Howl = n,
        ci.Sound = i) : typeof window < "u" && (window.HowlerGlobal = e,
        window.Howler = t,
        window.Howl = n,
        window.Sound = i)
    }
    )();
    /*!
 *  Spatial Plugin - Adds support for stereo and 3D audio where Web Audio is supported.
 *  
 *  howler.js v2.2.4
 *  howlerjs.com
 *
 *  (c) 2013-2020, James Simpson of GoldFire Studios
 *  goldfirestudios.com
 *
 *  MIT License
 */
    (function() {
        HowlerGlobal.prototype._pos = [0, 0, 0],
        HowlerGlobal.prototype._orientation = [0, 0, -1, 0, 1, 0],
        HowlerGlobal.prototype.stereo = function(t) {
            var n = this;
            if (!n.ctx || !n.ctx.listener)
                return n;
            for (var i = n._howls.length - 1; i >= 0; i--)
                n._howls[i].stereo(t);
            return n
        }
        ,
        HowlerGlobal.prototype.pos = function(t, n, i) {
            var s = this;
            if (!s.ctx || !s.ctx.listener)
                return s;
            if (n = typeof n != "number" ? s._pos[1] : n,
            i = typeof i != "number" ? s._pos[2] : i,
            typeof t == "number")
                s._pos = [t, n, i],
                typeof s.ctx.listener.positionX < "u" ? (s.ctx.listener.positionX.setTargetAtTime(s._pos[0], Howler.ctx.currentTime, .1),
                s.ctx.listener.positionY.setTargetAtTime(s._pos[1], Howler.ctx.currentTime, .1),
                s.ctx.listener.positionZ.setTargetAtTime(s._pos[2], Howler.ctx.currentTime, .1)) : s.ctx.listener.setPosition(s._pos[0], s._pos[1], s._pos[2]);
            else
                return s._pos;
            return s
        }
        ,
        HowlerGlobal.prototype.orientation = function(t, n, i, s, o, a) {
            var c = this;
            if (!c.ctx || !c.ctx.listener)
                return c;
            var h = c._orientation;
            if (n = typeof n != "number" ? h[1] : n,
            i = typeof i != "number" ? h[2] : i,
            s = typeof s != "number" ? h[3] : s,
            o = typeof o != "number" ? h[4] : o,
            a = typeof a != "number" ? h[5] : a,
            typeof t == "number")
                c._orientation = [t, n, i, s, o, a],
                typeof c.ctx.listener.forwardX < "u" ? (c.ctx.listener.forwardX.setTargetAtTime(t, Howler.ctx.currentTime, .1),
                c.ctx.listener.forwardY.setTargetAtTime(n, Howler.ctx.currentTime, .1),
                c.ctx.listener.forwardZ.setTargetAtTime(i, Howler.ctx.currentTime, .1),
                c.ctx.listener.upX.setTargetAtTime(s, Howler.ctx.currentTime, .1),
                c.ctx.listener.upY.setTargetAtTime(o, Howler.ctx.currentTime, .1),
                c.ctx.listener.upZ.setTargetAtTime(a, Howler.ctx.currentTime, .1)) : c.ctx.listener.setOrientation(t, n, i, s, o, a);
            else
                return h;
            return c
        }
        ,
        Howl.prototype.init = function(t) {
            return function(n) {
                var i = this;
                return i._orientation = n.orientation || [1, 0, 0],
                i._stereo = n.stereo || null,
                i._pos = n.pos || null,
                i._pannerAttr = {
                    coneInnerAngle: typeof n.coneInnerAngle < "u" ? n.coneInnerAngle : 360,
                    coneOuterAngle: typeof n.coneOuterAngle < "u" ? n.coneOuterAngle : 360,
                    coneOuterGain: typeof n.coneOuterGain < "u" ? n.coneOuterGain : 0,
                    distanceModel: typeof n.distanceModel < "u" ? n.distanceModel : "inverse",
                    maxDistance: typeof n.maxDistance < "u" ? n.maxDistance : 1e4,
                    panningModel: typeof n.panningModel < "u" ? n.panningModel : "HRTF",
                    refDistance: typeof n.refDistance < "u" ? n.refDistance : 1,
                    rolloffFactor: typeof n.rolloffFactor < "u" ? n.rolloffFactor : 1
                },
                i._onstereo = n.onstereo ? [{
                    fn: n.onstereo
                }] : [],
                i._onpos = n.onpos ? [{
                    fn: n.onpos
                }] : [],
                i._onorientation = n.onorientation ? [{
                    fn: n.onorientation
                }] : [],
                t.call(this, n)
            }
        }(Howl.prototype.init),
        Howl.prototype.stereo = function(t, n) {
            var i = this;
            if (!i._webAudio)
                return i;
            if (i._state !== "loaded")
                return i._queue.push({
                    event: "stereo",
                    action: function() {
                        i.stereo(t, n)
                    }
                }),
                i;
            var s = typeof Howler.ctx.createStereoPanner > "u" ? "spatial" : "stereo";
            if (typeof n > "u")
                if (typeof t == "number")
                    i._stereo = t,
                    i._pos = [t, 0, 0];
                else
                    return i._stereo;
            for (var o = i._getSoundIds(n), a = 0; a < o.length; a++) {
                var c = i._soundById(o[a]);
                if (c)
                    if (typeof t == "number")
                        c._stereo = t,
                        c._pos = [t, 0, 0],
                        c._node && (c._pannerAttr.panningModel = "equalpower",
                        (!c._panner || !c._panner.pan) && e(c, s),
                        s === "spatial" ? typeof c._panner.positionX < "u" ? (c._panner.positionX.setValueAtTime(t, Howler.ctx.currentTime),
                        c._panner.positionY.setValueAtTime(0, Howler.ctx.currentTime),
                        c._panner.positionZ.setValueAtTime(0, Howler.ctx.currentTime)) : c._panner.setPosition(t, 0, 0) : c._panner.pan.setValueAtTime(t, Howler.ctx.currentTime)),
                        i._emit("stereo", c._id);
                    else
                        return c._stereo
            }
            return i
        }
        ,
        Howl.prototype.pos = function(t, n, i, s) {
            var o = this;
            if (!o._webAudio)
                return o;
            if (o._state !== "loaded")
                return o._queue.push({
                    event: "pos",
                    action: function() {
                        o.pos(t, n, i, s)
                    }
                }),
                o;
            if (n = typeof n != "number" ? 0 : n,
            i = typeof i != "number" ? -.5 : i,
            typeof s > "u")
                if (typeof t == "number")
                    o._pos = [t, n, i];
                else
                    return o._pos;
            for (var a = o._getSoundIds(s), c = 0; c < a.length; c++) {
                var h = o._soundById(a[c]);
                if (h)
                    if (typeof t == "number")
                        h._pos = [t, n, i],
                        h._node && ((!h._panner || h._panner.pan) && e(h, "spatial"),
                        typeof h._panner.positionX < "u" ? (h._panner.positionX.setValueAtTime(t, Howler.ctx.currentTime),
                        h._panner.positionY.setValueAtTime(n, Howler.ctx.currentTime),
                        h._panner.positionZ.setValueAtTime(i, Howler.ctx.currentTime)) : h._panner.setPosition(t, n, i)),
                        o._emit("pos", h._id);
                    else
                        return h._pos
            }
            return o
        }
        ,
        Howl.prototype.orientation = function(t, n, i, s) {
            var o = this;
            if (!o._webAudio)
                return o;
            if (o._state !== "loaded")
                return o._queue.push({
                    event: "orientation",
                    action: function() {
                        o.orientation(t, n, i, s)
                    }
                }),
                o;
            if (n = typeof n != "number" ? o._orientation[1] : n,
            i = typeof i != "number" ? o._orientation[2] : i,
            typeof s > "u")
                if (typeof t == "number")
                    o._orientation = [t, n, i];
                else
                    return o._orientation;
            for (var a = o._getSoundIds(s), c = 0; c < a.length; c++) {
                var h = o._soundById(a[c]);
                if (h)
                    if (typeof t == "number")
                        h._orientation = [t, n, i],
                        h._node && (h._panner || (h._pos || (h._pos = o._pos || [0, 0, -.5]),
                        e(h, "spatial")),
                        typeof h._panner.orientationX < "u" ? (h._panner.orientationX.setValueAtTime(t, Howler.ctx.currentTime),
                        h._panner.orientationY.setValueAtTime(n, Howler.ctx.currentTime),
                        h._panner.orientationZ.setValueAtTime(i, Howler.ctx.currentTime)) : h._panner.setOrientation(t, n, i)),
                        o._emit("orientation", h._id);
                    else
                        return h._orientation
            }
            return o
        }
        ,
        Howl.prototype.pannerAttr = function() {
            var t = this, n = arguments, i, s, o;
            if (!t._webAudio)
                return t;
            if (n.length === 0)
                return t._pannerAttr;
            if (n.length === 1)
                if (typeof n[0] == "object")
                    i = n[0],
                    typeof s > "u" && (i.pannerAttr || (i.pannerAttr = {
                        coneInnerAngle: i.coneInnerAngle,
                        coneOuterAngle: i.coneOuterAngle,
                        coneOuterGain: i.coneOuterGain,
                        distanceModel: i.distanceModel,
                        maxDistance: i.maxDistance,
                        refDistance: i.refDistance,
                        rolloffFactor: i.rolloffFactor,
                        panningModel: i.panningModel
                    }),
                    t._pannerAttr = {
                        coneInnerAngle: typeof i.pannerAttr.coneInnerAngle < "u" ? i.pannerAttr.coneInnerAngle : t._coneInnerAngle,
                        coneOuterAngle: typeof i.pannerAttr.coneOuterAngle < "u" ? i.pannerAttr.coneOuterAngle : t._coneOuterAngle,
                        coneOuterGain: typeof i.pannerAttr.coneOuterGain < "u" ? i.pannerAttr.coneOuterGain : t._coneOuterGain,
                        distanceModel: typeof i.pannerAttr.distanceModel < "u" ? i.pannerAttr.distanceModel : t._distanceModel,
                        maxDistance: typeof i.pannerAttr.maxDistance < "u" ? i.pannerAttr.maxDistance : t._maxDistance,
                        refDistance: typeof i.pannerAttr.refDistance < "u" ? i.pannerAttr.refDistance : t._refDistance,
                        rolloffFactor: typeof i.pannerAttr.rolloffFactor < "u" ? i.pannerAttr.rolloffFactor : t._rolloffFactor,
                        panningModel: typeof i.pannerAttr.panningModel < "u" ? i.pannerAttr.panningModel : t._panningModel
                    });
                else
                    return o = t._soundById(parseInt(n[0], 10)),
                    o ? o._pannerAttr : t._pannerAttr;
            else
                n.length === 2 && (i = n[0],
                s = parseInt(n[1], 10));
            for (var a = t._getSoundIds(s), c = 0; c < a.length; c++)
                if (o = t._soundById(a[c]),
                o) {
                    var h = o._pannerAttr;
                    h = {
                        coneInnerAngle: typeof i.coneInnerAngle < "u" ? i.coneInnerAngle : h.coneInnerAngle,
                        coneOuterAngle: typeof i.coneOuterAngle < "u" ? i.coneOuterAngle : h.coneOuterAngle,
                        coneOuterGain: typeof i.coneOuterGain < "u" ? i.coneOuterGain : h.coneOuterGain,
                        distanceModel: typeof i.distanceModel < "u" ? i.distanceModel : h.distanceModel,
                        maxDistance: typeof i.maxDistance < "u" ? i.maxDistance : h.maxDistance,
                        refDistance: typeof i.refDistance < "u" ? i.refDistance : h.refDistance,
                        rolloffFactor: typeof i.rolloffFactor < "u" ? i.rolloffFactor : h.rolloffFactor,
                        panningModel: typeof i.panningModel < "u" ? i.panningModel : h.panningModel
                    };
                    var d = o._panner;
                    d || (o._pos || (o._pos = t._pos || [0, 0, -.5]),
                    e(o, "spatial"),
                    d = o._panner),
                    d.coneInnerAngle = h.coneInnerAngle,
                    d.coneOuterAngle = h.coneOuterAngle,
                    d.coneOuterGain = h.coneOuterGain,
                    d.distanceModel = h.distanceModel,
                    d.maxDistance = h.maxDistance,
                    d.refDistance = h.refDistance,
                    d.rolloffFactor = h.rolloffFactor,
                    d.panningModel = h.panningModel
                }
            return t
        }
        ,
        Sound.prototype.init = function(t) {
            return function() {
                var n = this
                  , i = n._parent;
                n._orientation = i._orientation,
                n._stereo = i._stereo,
                n._pos = i._pos,
                n._pannerAttr = i._pannerAttr,
                t.call(this),
                n._stereo ? i.stereo(n._stereo) : n._pos && i.pos(n._pos[0], n._pos[1], n._pos[2], n._id)
            }
        }(Sound.prototype.init),
        Sound.prototype.reset = function(t) {
            return function() {
                var n = this
                  , i = n._parent;
                return n._orientation = i._orientation,
                n._stereo = i._stereo,
                n._pos = i._pos,
                n._pannerAttr = i._pannerAttr,
                n._stereo ? i.stereo(n._stereo) : n._pos ? i.pos(n._pos[0], n._pos[1], n._pos[2], n._id) : n._panner && (n._panner.disconnect(0),
                n._panner = void 0,
                i._refreshBuffer(n)),
                t.call(this)
            }
        }(Sound.prototype.reset);
        var e = function(t, n) {
            n = n || "spatial",
            n === "spatial" ? (t._panner = Howler.ctx.createPanner(),
            t._panner.coneInnerAngle = t._pannerAttr.coneInnerAngle,
            t._panner.coneOuterAngle = t._pannerAttr.coneOuterAngle,
            t._panner.coneOuterGain = t._pannerAttr.coneOuterGain,
            t._panner.distanceModel = t._pannerAttr.distanceModel,
            t._panner.maxDistance = t._pannerAttr.maxDistance,
            t._panner.refDistance = t._pannerAttr.refDistance,
            t._panner.rolloffFactor = t._pannerAttr.rolloffFactor,
            t._panner.panningModel = t._pannerAttr.panningModel,
            typeof t._panner.positionX < "u" ? (t._panner.positionX.setValueAtTime(t._pos[0], Howler.ctx.currentTime),
            t._panner.positionY.setValueAtTime(t._pos[1], Howler.ctx.currentTime),
            t._panner.positionZ.setValueAtTime(t._pos[2], Howler.ctx.currentTime)) : t._panner.setPosition(t._pos[0], t._pos[1], t._pos[2]),
            typeof t._panner.orientationX < "u" ? (t._panner.orientationX.setValueAtTime(t._orientation[0], Howler.ctx.currentTime),
            t._panner.orientationY.setValueAtTime(t._orientation[1], Howler.ctx.currentTime),
            t._panner.orientationZ.setValueAtTime(t._orientation[2], Howler.ctx.currentTime)) : t._panner.setOrientation(t._orientation[0], t._orientation[1], t._orientation[2])) : (t._panner = Howler.ctx.createStereoPanner(),
            t._panner.pan.setValueAtTime(t._stereo, Howler.ctx.currentTime)),
            t._panner.connect(t._node),
            t._paused || t._parent.pause(t._id, !0).play(t._id, !0)
        }
    }
    )()
}
)(sg);
const sV = [{
    key: "ambient",
    path: "/audio/loop.mp3",
    loop: !0,
    volume: 1
}, {
    key: "konami",
    path: "/audio/stars.mp3",
    loop: !0,
    volume: .65
}, {
    key: "ice",
    path: "/audio/ice.mp3",
    loop: !0,
    volume: 1
}, {
    key: "fire",
    path: "/audio/flames.mp3",
    loop: !0,
    volume: .01
}, {
    key: "roar",
    path: "/audio/roar.mp3",
    volume: .35
}, {
    key: "hint",
    path: "/audio/hint.mp3",
    loop: !1,
    volume: .54
}];
sg.Howler.autoSuspend = !1;
class oV {
    constructor() {
        this._resources = new Map,
        this._onLoadCb = ()=>{}
    }
    get(e) {
        return this._resources.get(e)
    }
    play(e) {
        this._resources.has(e) && this._resources.get(e).play()
    }
    pause(e) {
        this._resources.has(e) && this._resources.get(e).pause()
    }
    stop(e) {
        this._resources.has(e) && this._resources.get(e).stop()
    }
    killTween(e) {
        this._resources.has(e) && this._resources.get(e).gsapTween?.kill()
    }
    restart(e) {
        if (!this._resources.has(e))
            return;
        this.killTween(e);
        const t = this._resources.get(e);
        t.volume(t?.userData.volume),
        t.pause(),
        t.seek(0),
        t.play()
    }
    seek(e, t=0) {
        this._resources.has(e) && this._resources.get(e).seek(t)
    }
    fadeIn(e, t=.2, n="none") {
        if (!this._resources.has(e))
            return;
        this.restart(e);
        const i = this._resources.get(e)
          , s = {
            volume: i.volume()
        }
          , o = i?.userData?.volume || 1
          , a = ()=>{
            i.volume(s.volume)
        }
        ;
        i.gsapTween = Qt.fromTo(s, {
            volume: 0
        }, {
            duration: t,
            volume: o,
            onUpdate: a,
            ease: n
        })
    }
    fadeOut(e, t=.2, n=0) {
        if (!this._resources.has(e))
            return;
        this.killTween(e);
        const i = this._resources.get(e)
          , s = {
            volume: i.volume()
        }
          , o = ()=>i.pause()
          , a = ()=>{
            i.volume(s.volume)
        }
        ;
        i.gsapTween = Qt.to(s, {
            duration: t,
            volume: 0,
            onComplete: o,
            onUpdate: a,
            delay: n
        })
    }
    startLoad(e=()=>{}
    ) {
        const t = [];
        return this._onLoadCb = e,
        sV.forEach(n=>{
            if (this._resources.has(n.key))
                return;
            const i = n.path
              , s = new sg.Howl({
                src: [i],
                preload: !0,
                loop: n?.loop || !1,
                volume: n?.volume || 1
            });
            s.gsapTween = void 0,
            s.userData = n;
            const o = new Promise((a,c)=>{
                s.on("load", ()=>{
                    a(),
                    console.log("--- LOADED:AUDIO:", n.key)
                }
                )
            }
            );
            t.push(o),
            this._resources.set(n.key, s)
        }
        ),
        Promise.all(t).then(()=>this.onLoadComplete())
    }
    onLoadComplete() {
        this._onLoadCb()
    }
}
const kn = new oV;
new k;
en.prototype.raycast = tS;
Wb.prototype.raycast = tS;
mn.prototype.computeBoundsTree = lB;
mn.prototype.disposeBoundsTree = cB;
class aV {
    constructor() {
        this._renderer = void 0,
        this._camera = void 0,
        this._scene = void 0,
        this._raycaster = void 0,
        this._mixer = void 0,
        this._mixerTimeline = void 0,
        this._mesh = void 0,
        this._water = void 0,
        this._clock = new V3,
        this._clock.start(),
        this._raf = void 0,
        this._gpgpuMesh = void 0,
        this._gpgpuTrail = void 0,
        this._reflector = void 0,
        this._flames = void 0,
        this._env = void 0,
        this._fwaLogo = void 0,
        this._awwwLogo = void 0,
        this._dragon = void 0,
        this._timeScaleTarget = ce.time.scale,
        this._controlsDragCb = void 0,
        ce.isDebug = !!new URLSearchParams(window.location.search).get("debug"),
        this._init(),
        this._load()
    }
    _load() {
        a_.startLoad(()=>{}
        , void 0, ce.gl);
        const e = a_.getLoadPromise()
          , t = kn.startLoad();
        Promise.all([e, t]).then(()=>{
            this._onLoaded()
        }
        )
    }
    _onLoaded() {
        this._initScene(),
        this._initDragonMixer(),
        this._initEnvironment(),
        this._initComposer(),
        this._onResize(),
        ce.isDebug && this._initDebug(),
        this._initEvents(),
        this._initKonami(),
        this._start(),
        yt.emit(xt.LOADED)
    }
    _init() {
        this._renderer = new Gb({
            canvas: document.querySelector("#canvas"),
            depth: !0,
            stencil: !1
        }),
        this._renderer.outputColorSpace = Ft,
        this._renderer.shadowMap.enabled = !1,
        this._renderer.setPixelRatio(1);
        const e = window.innerWidth
          , t = window.innerHeight
          , n = e / t;
        this._renderer.setSize(e, t),
        this._camera = new qn(70,n,.1,100),
        this._camera.position.x = 2,
        this._camera.position.y = 2,
        this._camera.position.z = 11,
        this._scene = new jm,
        this._raycaster = new nF,
        this._raycaster.firstHitOnly = !0,
        ce.gl = this._renderer,
        ce.camera = this._camera,
        ce.scene = this._scene,
        ce.raycaster = this._raycaster,
        ce.clock = this._clock,
        ce.size.width = e,
        ce.size.height = t,
        ce.size.isMobile = e < t,
        this._controls = new rF(ce.camera,this._renderer.domElement),
        this._controls.maxDistance = 14,
        this._controls.minDistance = 4,
        this._controls.maxPolarAngle = Math.PI * .5,
        this._controls.dampingFactor = .02,
        this._controls.enableDamping = !0,
        this._controls.enablePan = ce.isDebug
    }
    _initScene() {
        this._initDragon(),
        this._initLogos()
    }
    _initDragonMixer() {
        const e = new tF(this._dragon.tracker)
          , t = dn("dragon").animations
          , n = a=>{
            yt.emit(xt.ROAR, a)
        }
          , i = e.clipAction(t[0]);
        i.play();
        const s = {
            time: 0
        }
          , o = Qt.timeline({
            repeat: -1,
            onUpdate: ()=>{
                this._mixer.setTime(s.time)
            }
        });
        o.to(s, {
            time: i._clip.duration,
            duration: i._clip.duration,
            ease: "none"
        }, 0).call(()=>kn.restart("roar"), !1, 3.16).call(n, [!0], 5.98).call(n, [!1], 6.93),
        this._mixer = e,
        this._mixerTimeline = o
    }
    _initEnvironment() {
        const e = new gH;
        e.position.y = -2,
        this._env = e,
        this._scene.add(e)
    }
    _initComposer() {
        this._composer = new Y4,
        ce.composer = this._composer
    }
    _initDragon() {
        const e = new pm({
            asset: dn("dragon"),
            meshTrackerKey: "Object_233",
            mainColor: 2145994,
            waterColor: 16755981
        });
        ce.scene.add(e),
        e.tracker.position.y -= 3,
        this._dragon = e,
        this._initFlames()
    }
    _initLogos() {
        const e = new pm({
            asset: dn("fwa"),
            meshTrackerKey: "Curve009",
            mainColor: 15836687,
            waterColor: 5325863,
            initAlpha: 0,
            convertColor: !1
        });
        ce.scene.add(e),
        e.tracker.rotation.order = "YXZ",
        e.tracker.scale.setScalar(0),
        this._fwaLogo = e;
        const t = new pm({
            asset: dn("awww"),
            meshTrackerKey: "Curve008",
            mainColor: 16274722,
            waterColor: 48818,
            initAlpha: 0,
            convertColor: !1
        });
        ce.scene.add(t),
        t.tracker.rotation.order = "YXZ",
        t.tracker.scale.setScalar(0),
        this._awwwLogo = t
    }
    _initFlames() {
        const e = this._dragon.tracker.getObjectByName("flames");
        e.visible = !1;
        const t = new xH({
            tracker: e,
            amount: 9e3
        });
        this._flames = t,
        this._scene.add(t)
    }
    async _initDebug() {
        (await _0(()=>import("./index.k0spFkxn.js").then(h=>h.i), __vite__mapDeps([]))).default.initialize(),
        Xi.getProject(sf.projectName, {
            state: hS
        }).sheet(sf.sheets.config);
        const {ThreePerf: n} = await _0(()=>import("./index.D7eBjQrN.js"), __vite__mapDeps([]));
        this._stats = new n({
            anchorX: "right",
            anchorY: "bottom",
            domElement: document.body,
            renderer: ce.gl
        });
        const i = new Tr(2,2)
          , s = new _r({
            map: this._gpgpuMesh.texture
        })
          , o = new en(i,s);
        o.position.y += 3,
        o.visible = !0,
        this._scene.add(o);
        const a = new Q_(this._meshHelper,5);
        this._bvhHelper = a,
        this._scene.add(a);
        const c = new en(new W_(.1,5,5),new _r);
        this._mouseMesh = c,
        this._mouseMesh.position.copy(ce.mouse.world),
        this._scene.add(c)
    }
    _initEvents() {
        window.addEventListener("resize", this._onResize.bind(this)),
        new wk(window,{
            onMove: e=>{
                this._onMouseMove(e.values[0], e.values[1])
            }
            ,
            onDrag: e=>{
                this._onMouseMove(e.values[0], e.values[1])
            }
        },{
            eventOptions: {
                passive: !0
            },
            pointer: {
                touch: !1
            },
            filterTaps: !0
        }),
        yt.on(xt.TICK, this._onRaf.bind(this)),
        yt.on(xt.TIMESCALE_CHANGE, this._onTimeScaleChange.bind(this)),
        this._controls.addEventListener("start", ()=>this._onControlsToggle(!0)),
        this._controls.addEventListener("end", ()=>this._onControlsToggle(!1))
    }
    _initKonami() {
        const e = ()=>{
            yt.emit(xt.KONAMI),
            Qt.delayedCall(.8, ()=>this._fwaLogo.enter({
                scale: .2
            })),
            Qt.delayedCall(1.4, ()=>this._awwwLogo.enter({
                scale: .2
            })),
            kn.fadeIn("konami", 2),
            kn.fadeOut("ambient", 2),
            ce.isKonami = !0
        }
        ;
        Ck.add(e)
    }
    _onMouseMove(e, t) {
        ce.mouse.static.x = e / window.innerWidth * 2 - 1,
        ce.mouse.static.y = -(t / window.innerHeight) * 2 + 1,
        yt.emit(xt.MOUSE_MOVE, ce.mouse),
        this._raycaster.setFromCamera(ce.mouse.static, ce.camera),
        this._dragon.detectIntersection(),
        this._fwaLogo.detectIntersection(),
        this._awwwLogo.detectIntersection(),
        ce.isDebug && this._mouseMesh.position.copy(ce.mouse.world)
    }
    _toggleTimeScale(e=!0) {
        this._timeScaleTarget = e ? An.timeScale.max : An.timeScale.min
    }
    _updateTimeScale() {
        No(ce.time, "scale", this._timeScaleTarget, .35, ce.clock.delta, 1 / 0, tf),
        yt.emit(xt.TIMESCALE_CHANGE, ce.time.scale)
    }
    _onTimeScaleChange(e) {
        this._mixerTimeline.timeScale(e)
    }
    _onControlsToggle(e) {
        this._controlsDragCb?.kill(),
        e && (ce.mouse.isDragging = !0,
        this._toggleTimeScale(!1)),
        e || (this._toggleTimeScale(!0),
        this._controlsDragCb = Qt.delayedCall(2, ()=>{
            ce.mouse.isDragging = !1
        }
        ))
    }
    _onResize(e) {
        const t = window.innerWidth
          , n = window.innerHeight
          , i = t / n;
        ce.size.width = t,
        ce.size.height = n,
        ce.size.isMobile = t < n,
        ce.camera.aspect = i,
        ce.camera.updateProjectionMatrix(),
        this._composer.resize(),
        yt.emit(xt.RESIZE, e)
    }
    _start() {
        this._raf = window.requestAnimationFrame(this._animate.bind(this)),
        window.store = ce
    }
    _pause() {
        window.cancelAnimationFrame(this._raf)
    }
    _animate() {
        this._raf = window.requestAnimationFrame(this._animate.bind(this)),
        yt.emit(xt.TICK, ce.time)
    }
    _onRaf() {
        ce.mouse.smooth.lerp(ce.mouse.static, .1),
        this._stats?.begin(),
        this._clock.delta = this._clock.getDelta(),
        this._clock.getElapsedTime(),
        ce.time.delta = this._clock.delta * ce.time.scale,
        ce.time.elapsed += ce.time.delta,
        ce.frames += 1,
        this._updateTimeScale(),
        this._controls.update(),
        this._env.update(ce.time.delta),
        this._flames.update(ce.time.delta),
        this._dragon.update();
        const e = ce.time.elapsed + .5
          , t = wh(this._awwwLogo.tracker.position.x, this._awwwLogo.tracker.position.y, e)
          , n = wh(this._awwwLogo.tracker.position.y, this._awwwLogo.tracker.position.x, e + 100);
        this._awwwLogo.tracker.position.x = 2.3 + (t - .5) * 1.5,
        this._awwwLogo.tracker.position.y = 1.6 + (n - .5) * 1.5,
        this._awwwLogo.tracker.rotation.x = Math.sin(e) * .3,
        this._awwwLogo.tracker.rotation.y = Math.sin(e + 3) * .75,
        this._awwwLogo.update();
        const i = ce.time.elapsed + 1.9
          , s = wh(this._fwaLogo.tracker.position.x, this._fwaLogo.tracker.position.y, i)
          , o = wh(this._fwaLogo.tracker.position.y, this._fwaLogo.tracker.position.x, i + 100);
        this._fwaLogo.tracker.position.y = 1.6 + (s - .5) * 1.5,
        this._fwaLogo.tracker.position.x = -2.6 + (o - .5) * 1.5,
        this._fwaLogo.tracker.rotation.x = Math.sin(i) * .3,
        this._fwaLogo.tracker.rotation.y = Math.sin(i + 2) * .75,
        this._fwaLogo.update(),
        kn.get("ambient").rate(ce.time.scale),
        ce.isKonami && kn.get("konami").rate(ce.time.scale),
        kn.get("roar").rate(ce.time.scale),
        this._composer.render(),
        this._stats?.end()
    }
}
new aV;
window.dataLayer = window.dataLayer || [];
function CS() {
    dataLayer.push(arguments)
}
CS("js", new Date);
CS("config", "G-FKGXZJC2N8");
const og = document.querySelector(".opening")
  , IS = document.querySelector(".opening__content")
  , lV = document.querySelector(".opening__bar")
  , dc = af.get(_l.INTRO_HOLD)
  , oT = {
    value: 0
};
let ag = !1
  , LS = !1;
og.addEventListener("pointerdown", ()=>{
    LS && (ag = !0)
}
);
og.addEventListener("pointerup", r=>{
    ag = !1
}
);
const cV = ()=>{
    kn.get("ambient").volume(.35),
    kn.play("ambient");
    const r = af.get(_l.INTRO_ENTER)
      , e = Qt.timeline();
    e.to(IS, {
        duration: 2,
        opacity: 1,
        ease: "power1.in"
    });
    const t = ()=>{
        LS = !0,
        yt.emit(xt.INTRO_ENTERED)
    }
    ;
    r.call(t, null, "+=0.1").add(e, "-=2"),
    r.play(0)
}
  , uV = ()=>{
    kn.play("fire");
    const r = {
        fire: 0,
        ambient: kn.get("ambient").volume()
    }
      , e = ()=>{
        kn.get("fire").volume(r.fire),
        kn.get("ambient").volume(r.ambient)
    }
      , t = ()=>{
        yt.off(xt.TICK, DS),
        dc.play()
    }
    ;
    dc.eventCallback("onComplete", ()=>{
        ls.isIntroDone.value = !0,
        kn.get("fire").pause()
    }
    );
    const n = Qt.timeline();
    n.to(lV, {
        duration: 1,
        scaleX: 1
    }, 0).fromTo(r, {
        fire: 0
    }, {
        duration: .4,
        fire: 1,
        onUpdate: e
    }, 0),
    n.duration(dc.duration()),
    dc.add(n, 0).call(t, null, "-=0.42").addLabel("leave").to(IS, {
        duration: 1,
        opacity: 0
    }, "leave-=0.5").to(r, {
        duration: 1,
        fire: 0,
        ambient: kn.get("ambient").userData.volume,
        onUpdate: e,
        ease: "power1.in"
    }, "leave-=0.5").set(og, {
        display: "none"
    })
}
  , DS = ()=>{
    No(oT, "value", ag ? 1 : 0, 1, ce.time.delta, .3),
    dc.progress(oT.value)
}
;
yt.on(xt.INTRO_ENTERING, cV, 10);
yt.on(xt.INTRO_ENTERED, uV, 10);
yt.on(xt.TICK, DS, 10);
const hV = document.querySelector(".scene__root")
  , OS = Qt.quickSetter("html", "--blur", "px");
jc(()=>{
    if (ls.isIntroDone.value) {
        const r = Qt.timeline({
            onUpdate: ()=>{
                OS((1 - r.progress()) * 8)
            }
        });
        r.to(hV, {
            opacity: 1,
            duration: 1.1,
            ease: "power1.in"
        })
    }
}
);
const aT = {
    blur: 0
}
  , fV = An.timeScale.max
  , dV = An.timeScale.min
  , pV = ()=>{
    No(aT, "blur", (1 - ce.time.scale) * 8, .2),
    ce.time.scale < fV && ce.time.scale > dV && OS(aT.blur)
}
;
yt.on(xt.TICK, pV);
const lT = ["DRAG TO ROTATE", "HOVER THE DRAGON", "PLAY WITH THE WATER", "TRY KONAMI CODE", "SCROLL TO ZOOM", "OPEN THE MENU"];
let mm = 0
  , cT = 0;
const uT = document.querySelector(".scene__bottom");
document.querySelector(".scene__bottom-right");
const mV = document.querySelector(".scene__bottom-m")
  , _V = document.querySelector(".scene__bottom-s")
  , gV = document.querySelector(".scene__bottom-ms")
  , _m = document.querySelector(".scene__bottom-hint-text")
  , c_ = document.querySelector(".scene__bottom-hint-cube")
  , vV = Qt.quickSetter(c_, "rotate", "deg")
  , wc = {
    static: 0,
    smooth: 0
}
  , gm = Qt.getProperty("html", "--color-yellow")
  , vm = Qt.getProperty("html", "--color-white")
  , yV = r=>{
    r && kn.restart("hint");
    const e = ()=>{
        _m.innerHTML = lT[mm],
        mm = (mm + 1) % lT.length
    }
    ;
    Qt.timeline().to(_m, {
        duration: .3,
        "--contentBlur": 4,
        opacity: 0,
        ease: "power1.in",
        color: gm
    }).to(uT, {
        duration: .3,
        "--contentBlur": 4,
        ease: "power1.in",
        color: gm
    }, "<").to(c_, {
        duration: .3,
        background: gm
    }, "<").call(e).addLabel("enter", "+=0.1").to(_m, {
        duration: .3,
        "--contentBlur": 0,
        opacity: 1,
        ease: "power1.in",
        color: vm
    }, "enter").to(uT, {
        duration: .3,
        "--contentBlur": 0,
        ease: "power1.in",
        color: vm
    }, "enter").to(c_, {
        duration: .3,
        background: vm
    }, "enter"),
    wc.static += 180
}
  , xV = r=>{
    if (ce.frames % 4 === 0) {
        let e = parseFloat(r.elapsed)
          , t = e / 60 | 0
          , n = e % 60 | 0
          , i = (e - (e | 0)) * 1e3 | 0
          , s = t < 10 ? "0" + t : t
          , o = n < 10 ? "0" + n : n
          , a = i.toString().padStart(3, "0");
        mV.innerHTML = s,
        _V.innerHTML = o,
        gV.innerHTML = a,
        o % 10 === 0 && cT !== o && (yV(ls.isIntroDone.value),
        cT = o)
    }
}
  , TV = r=>{
    vV(wc.smooth)
}
  , bV = r=>{
    wc.static += r.delta * 100,
    No(wc, "smooth", wc.static, .2),
    xV(r),
    TV()
}
;
yt.on(xt.TICK, bV);
const Na = document.querySelector(".scene__info-content")
  , SV = document.querySelector(".scene__info-close")
  , hT = document.querySelector(".scene__info-overlay");
let fT = !1
  , dT = !0;
SV.addEventListener("click", ()=>ls.isSidebarActive.value = !1);
const pc = {
    value: 0
}
  , US = ()=>{
    kn.get("ice").volume(pc.value)
}
  , Fa = Qt.timeline({
    onUpdate: US
});
US();
const MV = r=>{
    if (dT) {
        dT = !1;
        return
    }
    kn.play("ice"),
    Fa?.kill(),
    Fa?.clear(),
    fT = r,
    fT ? (Fa.to(pc, {
        duration: .5,
        value: 1
    }, 0).to(pc, {
        duration: .5,
        value: 0
    }, .7).to(Na, {
        duration: 1.7,
        "--size": 100,
        ease: "power2.out"
    }, 0).to(Na, {
        duration: .7,
        "--contentBlur": 0
    }, .4).to(hT, {
        duration: 1,
        opacity: .6
    }, 0).restart(),
    Fa.timeScale(.6),
    Na.classList.add("--isActive")) : (Fa.to(Na, {
        duration: 1.7,
        "--contentBlur": 5
    }, 0).to(Na, {
        duration: 1.7,
        "--size": 0,
        ease: "power1.out"
    }, 0).to(hT, {
        duration: 1,
        opacity: 0
    }, 0).to(pc, {
        duration: .5,
        value: 1
    }, 0).to(pc, {
        duration: .5,
        value: 0
    }, .7).restart(),
    Fa.timeScale(.65),
    Na.classList.remove("--isActive"))
}
;
jc(()=>{
    MV(ls.isSidebarActive.value)
}
);
const wV = document.querySelector(".scene__bottom-cta-content")
  , pT = document.querySelector(".scene__bottom-cta-content");
wV.addEventListener("click", ()=>{
    ls.isSidebarActive.value = !ls.isSidebarActive.value
}
);
const EV = r=>{
    r ? pT.classList.add("--isActive") : pT.classList.remove("--isActive")
}
;
jc(()=>{
    EV(ls.isSidebarActive.value)
}
);
export {yn as B, Ke as C, mr as D, xr as F, AV as I, Ot as L, F_ as M, vl as O, Tr as P, R_ as R, ft as S, Pn as T, ID as U, Ce as V, Gb as W, r3 as a, en as b, ci as c, bn as d, Mr as e, fi as f, PV as g, cl as h, Ct as i, _t as j, _r as k, it as l, k as m, mn as n, di as o, jm as p, pt as q, Dh as r, V_ as s, H_ as t, Dn as u, Yt as v};
function __vite__mapDeps(indexes) {
    if (!__vite__mapDeps.viteFileDeps) {
        __vite__mapDeps.viteFileDeps = []
    }
    return indexes.map((i)=>__vite__mapDeps.viteFileDeps[i])
}
